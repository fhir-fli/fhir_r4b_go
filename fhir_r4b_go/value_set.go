// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// ValueSet
// A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [CodeSystem](codesystem.html) definitions and their use in [coded elements](terminologies.html).
type ValueSet struct {
	extends CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Immutable *FhirBoolean `json:"immutable,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	Compose *ValueSetCompose `json:"compose,omitempty"`
	Expansion *ValueSetExpansion `json:"expansion,omitempty"`
}

// NewValueSet creates a new ValueSet instance.
func NewValueSet() *ValueSet {
	return &ValueSet{}
}

// UnmarshalJSON populates ValueSet from JSON data.
func (m *ValueSet) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url *FhirUri `json:"url,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Title *FhirString `json:"title,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Experimental *FhirBoolean `json:"experimental,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		Publisher *FhirString `json:"publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Immutable *FhirBoolean `json:"immutable,omitempty"`
		Purpose *FhirMarkdown `json:"purpose,omitempty"`
		Copyright *FhirMarkdown `json:"copyright,omitempty"`
		Compose *ValueSetCompose `json:"compose,omitempty"`
		Expansion *ValueSetExpansion `json:"expansion,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Url = temp.Url
	m.Identifier = temp.Identifier
	m.Version = temp.Version
	m.Name = temp.Name
	m.Title = temp.Title
	m.Status = temp.Status
	m.Experimental = temp.Experimental
	m.Date = temp.Date
	m.Publisher = temp.Publisher
	m.Contact = temp.Contact
	m.Description = temp.Description
	m.UseContext = temp.UseContext
	m.Jurisdiction = temp.Jurisdiction
	m.Immutable = temp.Immutable
	m.Purpose = temp.Purpose
	m.Copyright = temp.Copyright
	m.Compose = temp.Compose
	m.Expansion = temp.Expansion
	return nil
}

// MarshalJSON converts ValueSet to JSON data.
func (m *ValueSet) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Title interface{} `json:"title,omitempty"`
		TitleElement map[string]interface{} `json:"_title,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Experimental interface{} `json:"experimental,omitempty"`
		ExperimentalElement map[string]interface{} `json:"_experimental,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Publisher interface{} `json:"publisher,omitempty"`
		PublisherElement map[string]interface{} `json:"_publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Immutable interface{} `json:"immutable,omitempty"`
		ImmutableElement map[string]interface{} `json:"_immutable,omitempty"`
		Purpose interface{} `json:"purpose,omitempty"`
		PurposeElement map[string]interface{} `json:"_purpose,omitempty"`
		Copyright interface{} `json:"copyright,omitempty"`
		CopyrightElement map[string]interface{} `json:"_copyright,omitempty"`
		Compose *ValueSetCompose `json:"compose,omitempty"`
		Expansion *ValueSetExpansion `json:"expansion,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	output.Identifier = m.Identifier
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.Title != nil && m.Title.Value != nil {
		output.Title = m.Title.Value
		if m.Title.Element != nil {
			output.TitleElement = toMapOrNil(m.Title.Element.MarshalJSON())
		}
	}
	output.Status = m.Status
	if m.Experimental != nil && m.Experimental.Value != nil {
		output.Experimental = m.Experimental.Value
		if m.Experimental.Element != nil {
			output.ExperimentalElement = toMapOrNil(m.Experimental.Element.MarshalJSON())
		}
	}
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.MarshalJSON())
		}
	}
	if m.Publisher != nil && m.Publisher.Value != nil {
		output.Publisher = m.Publisher.Value
		if m.Publisher.Element != nil {
			output.PublisherElement = toMapOrNil(m.Publisher.Element.MarshalJSON())
		}
	}
	output.Contact = m.Contact
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.UseContext = m.UseContext
	output.Jurisdiction = m.Jurisdiction
	if m.Immutable != nil && m.Immutable.Value != nil {
		output.Immutable = m.Immutable.Value
		if m.Immutable.Element != nil {
			output.ImmutableElement = toMapOrNil(m.Immutable.Element.MarshalJSON())
		}
	}
	if m.Purpose != nil && m.Purpose.Value != nil {
		output.Purpose = m.Purpose.Value
		if m.Purpose.Element != nil {
			output.PurposeElement = toMapOrNil(m.Purpose.Element.MarshalJSON())
		}
	}
	if m.Copyright != nil && m.Copyright.Value != nil {
		output.Copyright = m.Copyright.Value
		if m.Copyright.Element != nil {
			output.CopyrightElement = toMapOrNil(m.Copyright.Element.MarshalJSON())
		}
	}
	output.Compose = m.Compose
	output.Expansion = m.Expansion
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSet.
func (m *ValueSet) Clone() *ValueSet {
	if m == nil { return nil }
	return &ValueSet{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Immutable: m.Immutable.Clone(),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		Compose: m.Compose.Clone(),
		Expansion: m.Expansion.Clone(),
	}
}

// Equals checks equality between two ValueSet instances.
func (m *ValueSet) Equals(other *ValueSet) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Immutable.Equals(other.Immutable) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.Compose.Equals(other.Compose) { return false }
	if !m.Expansion.Equals(other.Expansion) { return false }
	return true
}

// ValueSetCompose
// A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
type ValueSetCompose struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	LockedDate *FhirDate `json:"lockeddate,omitempty"`
	Inactive *FhirBoolean `json:"inactive,omitempty"`
	Include []*ValueSetInclude `json:"include,omitempty"`
	Exclude []*ValueSetInclude `json:"exclude,omitempty"`
}

// NewValueSetCompose creates a new ValueSetCompose instance.
func NewValueSetCompose() *ValueSetCompose {
	return &ValueSetCompose{}
}

// UnmarshalJSON populates ValueSetCompose from JSON data.
func (m *ValueSetCompose) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		LockedDate *FhirDate `json:"lockeddate,omitempty"`
		Inactive *FhirBoolean `json:"inactive,omitempty"`
		Include []*ValueSetInclude `json:"include,omitempty"`
		Exclude []*ValueSetInclude `json:"exclude,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.LockedDate = temp.LockedDate
	m.Inactive = temp.Inactive
	m.Include = temp.Include
	m.Exclude = temp.Exclude
	return nil
}

// MarshalJSON converts ValueSetCompose to JSON data.
func (m *ValueSetCompose) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		LockedDate interface{} `json:"lockeddate,omitempty"`
		LockedDateElement map[string]interface{} `json:"_lockeddate,omitempty"`
		Inactive interface{} `json:"inactive,omitempty"`
		InactiveElement map[string]interface{} `json:"_inactive,omitempty"`
		Include []*ValueSetInclude `json:"include,omitempty"`
		Exclude []*ValueSetInclude `json:"exclude,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.LockedDate != nil && m.LockedDate.Value != nil {
		output.LockedDate = m.LockedDate.Value
		if m.LockedDate.Element != nil {
			output.LockedDateElement = toMapOrNil(m.LockedDate.Element.MarshalJSON())
		}
	}
	if m.Inactive != nil && m.Inactive.Value != nil {
		output.Inactive = m.Inactive.Value
		if m.Inactive.Element != nil {
			output.InactiveElement = toMapOrNil(m.Inactive.Element.MarshalJSON())
		}
	}
	output.Include = m.Include
	output.Exclude = m.Exclude
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetCompose.
func (m *ValueSetCompose) Clone() *ValueSetCompose {
	if m == nil { return nil }
	return &ValueSetCompose{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		LockedDate: m.LockedDate.Clone(),
		Inactive: m.Inactive.Clone(),
		Include: cloneSlices(m.Include),
		Exclude: cloneSlices(m.Exclude),
	}
}

// Equals checks equality between two ValueSetCompose instances.
func (m *ValueSetCompose) Equals(other *ValueSetCompose) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.LockedDate.Equals(other.LockedDate) { return false }
	if !m.Inactive.Equals(other.Inactive) { return false }
	if !compareSlices(m.Include, other.Include) { return false }
	if !compareSlices(m.Exclude, other.Exclude) { return false }
	return true
}

// ValueSetInclude
// Include one or more codes from a code system or other value set(s).
type ValueSetInclude struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	System *FhirUri `json:"system,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Concept []*ValueSetConcept `json:"concept,omitempty"`
	Filter []*ValueSetFilter `json:"filter,omitempty"`
	ValueSet []*FhirCanonical `json:"valueset,omitempty"`
}

// NewValueSetInclude creates a new ValueSetInclude instance.
func NewValueSetInclude() *ValueSetInclude {
	return &ValueSetInclude{}
}

// UnmarshalJSON populates ValueSetInclude from JSON data.
func (m *ValueSetInclude) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		System *FhirUri `json:"system,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Concept []*ValueSetConcept `json:"concept,omitempty"`
		Filter []*ValueSetFilter `json:"filter,omitempty"`
		ValueSet []interface{} `json:"valueset,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.System = temp.System
	m.Version = temp.Version
	m.Concept = temp.Concept
	m.Filter = temp.Filter
	if len(temp.ValueSet) > 0 {
		m.ValueSet = make([]*FhirCanonical, len(temp.ValueSet))
		for i := range temp.ValueSet {
			itemMap, ok := temp.ValueSet[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for ValueSet[%d]: expected map", i) }
			primitive, err := NewFhirCanonicalFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse ValueSet[%d]: %v", i, err) }
			m.ValueSet[i] = primitive
		}
	}
	return nil
}

// MarshalJSON converts ValueSetInclude to JSON data.
func (m *ValueSetInclude) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		System interface{} `json:"system,omitempty"`
		SystemElement map[string]interface{} `json:"_system,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Concept []*ValueSetConcept `json:"concept,omitempty"`
		Filter []*ValueSetFilter `json:"filter,omitempty"`
		ValueSet []interface{} `json:"valueset,omitempty"`
		ValueSetElement []map[string]interface{} `json:"_valueset,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.System != nil && m.System.Value != nil {
		output.System = m.System.Value
		if m.System.Element != nil {
			output.SystemElement = toMapOrNil(m.System.Element.MarshalJSON())
		}
	}
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	output.Concept = m.Concept
	output.Filter = m.Filter
	if len(m.ValueSet) > 0 {
		output.ValueSet = make([]interface{}, len(m.ValueSet))
		output.ValueSetElement = make([]map[string]interface{}, len(m.ValueSet))
		for i, item := range m.ValueSet {
			if item != nil && item.Value != nil {
				output.ValueSet[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.ValueSetElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetInclude.
func (m *ValueSetInclude) Clone() *ValueSetInclude {
	if m == nil { return nil }
	return &ValueSetInclude{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		System: m.System.Clone(),
		Version: m.Version.Clone(),
		Concept: cloneSlices(m.Concept),
		Filter: cloneSlices(m.Filter),
		ValueSet: cloneSlices(m.ValueSet),
	}
}

// Equals checks equality between two ValueSetInclude instances.
func (m *ValueSetInclude) Equals(other *ValueSetInclude) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.System.Equals(other.System) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !compareSlices(m.Concept, other.Concept) { return false }
	if !compareSlices(m.Filter, other.Filter) { return false }
	if !compareSlices(m.ValueSet, other.ValueSet) { return false }
	return true
}

// ValueSetConcept
// Specifies a concept to be included or excluded.
type ValueSetConcept struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Display *FhirString `json:"display,omitempty"`
	Designation []*ValueSetDesignation `json:"designation,omitempty"`
}

// NewValueSetConcept creates a new ValueSetConcept instance.
func NewValueSetConcept() *ValueSetConcept {
	return &ValueSetConcept{}
}

// UnmarshalJSON populates ValueSetConcept from JSON data.
func (m *ValueSetConcept) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *FhirCode `json:"code,omitempty"`
		Display *FhirString `json:"display,omitempty"`
		Designation []*ValueSetDesignation `json:"designation,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Display = temp.Display
	m.Designation = temp.Designation
	return nil
}

// MarshalJSON converts ValueSetConcept to JSON data.
func (m *ValueSetConcept) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code interface{} `json:"code,omitempty"`
		CodeElement map[string]interface{} `json:"_code,omitempty"`
		Display interface{} `json:"display,omitempty"`
		DisplayElement map[string]interface{} `json:"_display,omitempty"`
		Designation []*ValueSetDesignation `json:"designation,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Code != nil && m.Code.Value != nil {
		output.Code = m.Code.Value
		if m.Code.Element != nil {
			output.CodeElement = toMapOrNil(m.Code.Element.MarshalJSON())
		}
	}
	if m.Display != nil && m.Display.Value != nil {
		output.Display = m.Display.Value
		if m.Display.Element != nil {
			output.DisplayElement = toMapOrNil(m.Display.Element.MarshalJSON())
		}
	}
	output.Designation = m.Designation
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetConcept.
func (m *ValueSetConcept) Clone() *ValueSetConcept {
	if m == nil { return nil }
	return &ValueSetConcept{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Display: m.Display.Clone(),
		Designation: cloneSlices(m.Designation),
	}
}

// Equals checks equality between two ValueSetConcept instances.
func (m *ValueSetConcept) Equals(other *ValueSetConcept) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Display.Equals(other.Display) { return false }
	if !compareSlices(m.Designation, other.Designation) { return false }
	return true
}

// ValueSetDesignation
// Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
type ValueSetDesignation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Use *Coding `json:"use,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewValueSetDesignation creates a new ValueSetDesignation instance.
func NewValueSetDesignation() *ValueSetDesignation {
	return &ValueSetDesignation{}
}

// UnmarshalJSON populates ValueSetDesignation from JSON data.
func (m *ValueSetDesignation) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Use *Coding `json:"use,omitempty"`
		Value *FhirString `json:"value,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Language = temp.Language
	m.Use = temp.Use
	m.Value = temp.Value
	return nil
}

// MarshalJSON converts ValueSetDesignation to JSON data.
func (m *ValueSetDesignation) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Use *Coding `json:"use,omitempty"`
		Value interface{} `json:"value,omitempty"`
		ValueElement map[string]interface{} `json:"_value,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Language = m.Language
	output.Use = m.Use
	if m.Value != nil && m.Value.Value != nil {
		output.Value = m.Value.Value
		if m.Value.Element != nil {
			output.ValueElement = toMapOrNil(m.Value.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetDesignation.
func (m *ValueSetDesignation) Clone() *ValueSetDesignation {
	if m == nil { return nil }
	return &ValueSetDesignation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Language: m.Language.Clone(),
		Use: m.Use.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks equality between two ValueSetDesignation instances.
func (m *ValueSetDesignation) Equals(other *ValueSetDesignation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// ValueSetFilter
// Select concepts by specify a matching criterion based on the properties (including relationships) defined by the system, or on filters defined by the system. If multiple filters are specified, they SHALL all be true.
type ValueSetFilter struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Property *FhirCode `json:"property,omitempty"`
	Op *FilterOperator `json:"op,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewValueSetFilter creates a new ValueSetFilter instance.
func NewValueSetFilter() *ValueSetFilter {
	return &ValueSetFilter{}
}

// UnmarshalJSON populates ValueSetFilter from JSON data.
func (m *ValueSetFilter) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Property *FhirCode `json:"property,omitempty"`
		Op *FilterOperator `json:"op,omitempty"`
		Value *FhirString `json:"value,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Property = temp.Property
	m.Op = temp.Op
	m.Value = temp.Value
	return nil
}

// MarshalJSON converts ValueSetFilter to JSON data.
func (m *ValueSetFilter) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Property interface{} `json:"property,omitempty"`
		PropertyElement map[string]interface{} `json:"_property,omitempty"`
		Op *FilterOperator `json:"op,omitempty"`
		Value interface{} `json:"value,omitempty"`
		ValueElement map[string]interface{} `json:"_value,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Property != nil && m.Property.Value != nil {
		output.Property = m.Property.Value
		if m.Property.Element != nil {
			output.PropertyElement = toMapOrNil(m.Property.Element.MarshalJSON())
		}
	}
	output.Op = m.Op
	if m.Value != nil && m.Value.Value != nil {
		output.Value = m.Value.Value
		if m.Value.Element != nil {
			output.ValueElement = toMapOrNil(m.Value.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetFilter.
func (m *ValueSetFilter) Clone() *ValueSetFilter {
	if m == nil { return nil }
	return &ValueSetFilter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Property: m.Property.Clone(),
		Op: m.Op.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks equality between two ValueSetFilter instances.
func (m *ValueSetFilter) Equals(other *ValueSetFilter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Property.Equals(other.Property) { return false }
	if !m.Op.Equals(other.Op) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// ValueSetExpansion
// A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
type ValueSetExpansion struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *FhirUri `json:"identifier,omitempty"`
	Timestamp *FhirDateTime `json:"timestamp,omitempty"`
	Total *FhirInteger `json:"total,omitempty"`
	Offset *FhirInteger `json:"offset,omitempty"`
	Parameter []*ValueSetParameter `json:"parameter,omitempty"`
	Contains []*ValueSetContains `json:"contains,omitempty"`
}

// NewValueSetExpansion creates a new ValueSetExpansion instance.
func NewValueSetExpansion() *ValueSetExpansion {
	return &ValueSetExpansion{}
}

// UnmarshalJSON populates ValueSetExpansion from JSON data.
func (m *ValueSetExpansion) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier *FhirUri `json:"identifier,omitempty"`
		Timestamp *FhirDateTime `json:"timestamp,omitempty"`
		Total *FhirInteger `json:"total,omitempty"`
		Offset *FhirInteger `json:"offset,omitempty"`
		Parameter []*ValueSetParameter `json:"parameter,omitempty"`
		Contains []*ValueSetContains `json:"contains,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Timestamp = temp.Timestamp
	m.Total = temp.Total
	m.Offset = temp.Offset
	m.Parameter = temp.Parameter
	m.Contains = temp.Contains
	return nil
}

// MarshalJSON converts ValueSetExpansion to JSON data.
func (m *ValueSetExpansion) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier interface{} `json:"identifier,omitempty"`
		IdentifierElement map[string]interface{} `json:"_identifier,omitempty"`
		Timestamp interface{} `json:"timestamp,omitempty"`
		TimestampElement map[string]interface{} `json:"_timestamp,omitempty"`
		Total interface{} `json:"total,omitempty"`
		TotalElement map[string]interface{} `json:"_total,omitempty"`
		Offset interface{} `json:"offset,omitempty"`
		OffsetElement map[string]interface{} `json:"_offset,omitempty"`
		Parameter []*ValueSetParameter `json:"parameter,omitempty"`
		Contains []*ValueSetContains `json:"contains,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Identifier != nil && m.Identifier.Value != nil {
		output.Identifier = m.Identifier.Value
		if m.Identifier.Element != nil {
			output.IdentifierElement = toMapOrNil(m.Identifier.Element.MarshalJSON())
		}
	}
	if m.Timestamp != nil && m.Timestamp.Value != nil {
		output.Timestamp = m.Timestamp.Value
		if m.Timestamp.Element != nil {
			output.TimestampElement = toMapOrNil(m.Timestamp.Element.MarshalJSON())
		}
	}
	if m.Total != nil && m.Total.Value != nil {
		output.Total = m.Total.Value
		if m.Total.Element != nil {
			output.TotalElement = toMapOrNil(m.Total.Element.MarshalJSON())
		}
	}
	if m.Offset != nil && m.Offset.Value != nil {
		output.Offset = m.Offset.Value
		if m.Offset.Element != nil {
			output.OffsetElement = toMapOrNil(m.Offset.Element.MarshalJSON())
		}
	}
	output.Parameter = m.Parameter
	output.Contains = m.Contains
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetExpansion.
func (m *ValueSetExpansion) Clone() *ValueSetExpansion {
	if m == nil { return nil }
	return &ValueSetExpansion{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Timestamp: m.Timestamp.Clone(),
		Total: m.Total.Clone(),
		Offset: m.Offset.Clone(),
		Parameter: cloneSlices(m.Parameter),
		Contains: cloneSlices(m.Contains),
	}
}

// Equals checks equality between two ValueSetExpansion instances.
func (m *ValueSetExpansion) Equals(other *ValueSetExpansion) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Timestamp.Equals(other.Timestamp) { return false }
	if !m.Total.Equals(other.Total) { return false }
	if !m.Offset.Equals(other.Offset) { return false }
	if !compareSlices(m.Parameter, other.Parameter) { return false }
	if !compareSlices(m.Contains, other.Contains) { return false }
	return true
}

// ValueSetParameter
// A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
type ValueSetParameter struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueCode *FhirCode `json:"valuecode,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
}

// NewValueSetParameter creates a new ValueSetParameter instance.
func NewValueSetParameter() *ValueSetParameter {
	return &ValueSetParameter{}
}

// UnmarshalJSON populates ValueSetParameter from JSON data.
func (m *ValueSetParameter) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		ValueString *FhirString `json:"valuestring,omitempty"`
		ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
		ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
		ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
		ValueUri *FhirUri `json:"valueuri,omitempty"`
		ValueCode *FhirCode `json:"valuecode,omitempty"`
		ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.ValueString = temp.ValueString
	m.ValueBoolean = temp.ValueBoolean
	m.ValueInteger = temp.ValueInteger
	m.ValueDecimal = temp.ValueDecimal
	m.ValueUri = temp.ValueUri
	m.ValueCode = temp.ValueCode
	m.ValueDateTime = temp.ValueDateTime
	return nil
}

// MarshalJSON converts ValueSetParameter to JSON data.
func (m *ValueSetParameter) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		ValueString interface{} `json:"valuestring,omitempty"`
		ValueStringElement map[string]interface{} `json:"_valuestring,omitempty"`
		ValueBoolean interface{} `json:"valueboolean,omitempty"`
		ValueBooleanElement map[string]interface{} `json:"_valueboolean,omitempty"`
		ValueInteger interface{} `json:"valueinteger,omitempty"`
		ValueIntegerElement map[string]interface{} `json:"_valueinteger,omitempty"`
		ValueDecimal interface{} `json:"valuedecimal,omitempty"`
		ValueDecimalElement map[string]interface{} `json:"_valuedecimal,omitempty"`
		ValueUri interface{} `json:"valueuri,omitempty"`
		ValueUriElement map[string]interface{} `json:"_valueuri,omitempty"`
		ValueCode interface{} `json:"valuecode,omitempty"`
		ValueCodeElement map[string]interface{} `json:"_valuecode,omitempty"`
		ValueDateTime interface{} `json:"valuedatetime,omitempty"`
		ValueDateTimeElement map[string]interface{} `json:"_valuedatetime,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.ValueString != nil && m.ValueString.Value != nil {
		output.ValueString = m.ValueString.Value
		if m.ValueString.Element != nil {
			output.ValueStringElement = toMapOrNil(m.ValueString.Element.MarshalJSON())
		}
	}
	if m.ValueBoolean != nil && m.ValueBoolean.Value != nil {
		output.ValueBoolean = m.ValueBoolean.Value
		if m.ValueBoolean.Element != nil {
			output.ValueBooleanElement = toMapOrNil(m.ValueBoolean.Element.MarshalJSON())
		}
	}
	if m.ValueInteger != nil && m.ValueInteger.Value != nil {
		output.ValueInteger = m.ValueInteger.Value
		if m.ValueInteger.Element != nil {
			output.ValueIntegerElement = toMapOrNil(m.ValueInteger.Element.MarshalJSON())
		}
	}
	if m.ValueDecimal != nil && m.ValueDecimal.Value != nil {
		output.ValueDecimal = m.ValueDecimal.Value
		if m.ValueDecimal.Element != nil {
			output.ValueDecimalElement = toMapOrNil(m.ValueDecimal.Element.MarshalJSON())
		}
	}
	if m.ValueUri != nil && m.ValueUri.Value != nil {
		output.ValueUri = m.ValueUri.Value
		if m.ValueUri.Element != nil {
			output.ValueUriElement = toMapOrNil(m.ValueUri.Element.MarshalJSON())
		}
	}
	if m.ValueCode != nil && m.ValueCode.Value != nil {
		output.ValueCode = m.ValueCode.Value
		if m.ValueCode.Element != nil {
			output.ValueCodeElement = toMapOrNil(m.ValueCode.Element.MarshalJSON())
		}
	}
	if m.ValueDateTime != nil && m.ValueDateTime.Value != nil {
		output.ValueDateTime = m.ValueDateTime.Value
		if m.ValueDateTime.Element != nil {
			output.ValueDateTimeElement = toMapOrNil(m.ValueDateTime.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetParameter.
func (m *ValueSetParameter) Clone() *ValueSetParameter {
	if m == nil { return nil }
	return &ValueSetParameter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueCode: m.ValueCode.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
	}
}

// Equals checks equality between two ValueSetParameter instances.
func (m *ValueSetParameter) Equals(other *ValueSetParameter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueCode.Equals(other.ValueCode) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	return true
}

// ValueSetContains
// The codes that are contained in the value set expansion.
type ValueSetContains struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	System *FhirUri `json:"system,omitempty"`
	Abstract_ *FhirBoolean `json:"abstract,omitempty"`
	Inactive *FhirBoolean `json:"inactive,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Display *FhirString `json:"display,omitempty"`
	Designation []*ValueSetDesignation `json:"designation,omitempty"`
	Contains []*ValueSetContains `json:"contains,omitempty"`
}

// NewValueSetContains creates a new ValueSetContains instance.
func NewValueSetContains() *ValueSetContains {
	return &ValueSetContains{}
}

// UnmarshalJSON populates ValueSetContains from JSON data.
func (m *ValueSetContains) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		System *FhirUri `json:"system,omitempty"`
		Abstract_ *FhirBoolean `json:"abstract,omitempty"`
		Inactive *FhirBoolean `json:"inactive,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Code *FhirCode `json:"code,omitempty"`
		Display *FhirString `json:"display,omitempty"`
		Designation []*ValueSetDesignation `json:"designation,omitempty"`
		Contains []*ValueSetContains `json:"contains,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.System = temp.System
	m.Abstract_ = temp.Abstract_
	m.Inactive = temp.Inactive
	m.Version = temp.Version
	m.Code = temp.Code
	m.Display = temp.Display
	m.Designation = temp.Designation
	m.Contains = temp.Contains
	return nil
}

// MarshalJSON converts ValueSetContains to JSON data.
func (m *ValueSetContains) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		System interface{} `json:"system,omitempty"`
		SystemElement map[string]interface{} `json:"_system,omitempty"`
		Abstract_ interface{} `json:"abstract,omitempty"`
		Abstract_Element map[string]interface{} `json:"_abstract,omitempty"`
		Inactive interface{} `json:"inactive,omitempty"`
		InactiveElement map[string]interface{} `json:"_inactive,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Code interface{} `json:"code,omitempty"`
		CodeElement map[string]interface{} `json:"_code,omitempty"`
		Display interface{} `json:"display,omitempty"`
		DisplayElement map[string]interface{} `json:"_display,omitempty"`
		Designation []*ValueSetDesignation `json:"designation,omitempty"`
		Contains []*ValueSetContains `json:"contains,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.System != nil && m.System.Value != nil {
		output.System = m.System.Value
		if m.System.Element != nil {
			output.SystemElement = toMapOrNil(m.System.Element.MarshalJSON())
		}
	}
	if m.Abstract_ != nil && m.Abstract_.Value != nil {
		output.Abstract_ = m.Abstract_.Value
		if m.Abstract_.Element != nil {
			output.Abstract_Element = toMapOrNil(m.Abstract_.Element.MarshalJSON())
		}
	}
	if m.Inactive != nil && m.Inactive.Value != nil {
		output.Inactive = m.Inactive.Value
		if m.Inactive.Element != nil {
			output.InactiveElement = toMapOrNil(m.Inactive.Element.MarshalJSON())
		}
	}
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	if m.Code != nil && m.Code.Value != nil {
		output.Code = m.Code.Value
		if m.Code.Element != nil {
			output.CodeElement = toMapOrNil(m.Code.Element.MarshalJSON())
		}
	}
	if m.Display != nil && m.Display.Value != nil {
		output.Display = m.Display.Value
		if m.Display.Element != nil {
			output.DisplayElement = toMapOrNil(m.Display.Element.MarshalJSON())
		}
	}
	output.Designation = m.Designation
	output.Contains = m.Contains
	return json.Marshal(output)
}

// Clone creates a deep copy of ValueSetContains.
func (m *ValueSetContains) Clone() *ValueSetContains {
	if m == nil { return nil }
	return &ValueSetContains{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		System: m.System.Clone(),
		Abstract_: m.Abstract_.Clone(),
		Inactive: m.Inactive.Clone(),
		Version: m.Version.Clone(),
		Code: m.Code.Clone(),
		Display: m.Display.Clone(),
		Designation: cloneSlices(m.Designation),
		Contains: cloneSlices(m.Contains),
	}
}

// Equals checks equality between two ValueSetContains instances.
func (m *ValueSetContains) Equals(other *ValueSetContains) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.System.Equals(other.System) { return false }
	if !m.Abstract_.Equals(other.Abstract_) { return false }
	if !m.Inactive.Equals(other.Inactive) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Display.Equals(other.Display) { return false }
	if !compareSlices(m.Designation, other.Designation) { return false }
	if !compareSlices(m.Contains, other.Contains) { return false }
	return true
}

