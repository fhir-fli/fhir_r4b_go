// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ValueSet
// A ValueSet resource instance specifies a set of codes drawn from one or more code systems, intended for use in a particular context. Value sets link between [CodeSystem](codesystem.html) definitions and their use in [coded elements](terminologies.html).
type ValueSet struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Immutable *FhirBoolean `json:"immutable,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	Compose *ValueSetCompose `json:"compose,omitempty"`
	Expansion *ValueSetExpansion `json:"expansion,omitempty"`
}

// NewValueSet creates a new ValueSet instance
func NewValueSet() *ValueSet {
	return &ValueSet{}
}

// FromJSON populates ValueSet from JSON data
func (m *ValueSet) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSet to JSON data
func (m *ValueSet) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSet
func (m *ValueSet) Clone() *ValueSet {
	if m == nil { return nil }
	return &ValueSet{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Immutable: m.Immutable.Clone(),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		Compose: m.Compose.Clone(),
		Expansion: m.Expansion.Clone(),
	}
}

// Equals checks for equality with another ValueSet instance
func (m *ValueSet) Equals(other *ValueSet) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Immutable.Equals(other.Immutable) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.Compose.Equals(other.Compose) { return false }
	if !m.Expansion.Equals(other.Expansion) { return false }
	return true
}

// ValueSetCompose
// A set of criteria that define the contents of the value set by including or excluding codes selected from the specified code system(s) that the value set draws from. This is also known as the Content Logical Definition (CLD).
type ValueSetCompose struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	LockedDate *FhirDate `json:"lockeddate,omitempty"`
	Inactive *FhirBoolean `json:"inactive,omitempty"`
	Include []*ValueSetInclude `json:"include,omitempty"`
	Exclude []*ValueSetInclude `json:"exclude,omitempty"`
}

// NewValueSetCompose creates a new ValueSetCompose instance
func NewValueSetCompose() *ValueSetCompose {
	return &ValueSetCompose{}
}

// FromJSON populates ValueSetCompose from JSON data
func (m *ValueSetCompose) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetCompose to JSON data
func (m *ValueSetCompose) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetCompose
func (m *ValueSetCompose) Clone() *ValueSetCompose {
	if m == nil { return nil }
	return &ValueSetCompose{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		LockedDate: m.LockedDate.Clone(),
		Inactive: m.Inactive.Clone(),
		Include: cloneSlices(m.Include),
		Exclude: cloneSlices(m.Exclude),
	}
}

// Equals checks for equality with another ValueSetCompose instance
func (m *ValueSetCompose) Equals(other *ValueSetCompose) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.LockedDate.Equals(other.LockedDate) { return false }
	if !m.Inactive.Equals(other.Inactive) { return false }
	if !compareSlices(m.Include, other.Include) { return false }
	if !compareSlices(m.Exclude, other.Exclude) { return false }
	return true
}

// ValueSetInclude
// Include one or more codes from a code system or other value set(s).
type ValueSetInclude struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	System *FhirUri `json:"system,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Concept []*ValueSetConcept `json:"concept,omitempty"`
	Filter []*ValueSetFilter `json:"filter,omitempty"`
	ValueSet []*FhirCanonical `json:"valueset,omitempty"`
}

// NewValueSetInclude creates a new ValueSetInclude instance
func NewValueSetInclude() *ValueSetInclude {
	return &ValueSetInclude{}
}

// FromJSON populates ValueSetInclude from JSON data
func (m *ValueSetInclude) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetInclude to JSON data
func (m *ValueSetInclude) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetInclude
func (m *ValueSetInclude) Clone() *ValueSetInclude {
	if m == nil { return nil }
	return &ValueSetInclude{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		System: m.System.Clone(),
		Version: m.Version.Clone(),
		Concept: cloneSlices(m.Concept),
		Filter: cloneSlices(m.Filter),
		ValueSet: cloneSlices(m.ValueSet),
	}
}

// Equals checks for equality with another ValueSetInclude instance
func (m *ValueSetInclude) Equals(other *ValueSetInclude) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.System.Equals(other.System) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !compareSlices(m.Concept, other.Concept) { return false }
	if !compareSlices(m.Filter, other.Filter) { return false }
	if !compareSlices(m.ValueSet, other.ValueSet) { return false }
	return true
}

// ValueSetConcept
// Specifies a concept to be included or excluded.
type ValueSetConcept struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Display *FhirString `json:"display,omitempty"`
	Designation []*ValueSetDesignation `json:"designation,omitempty"`
}

// NewValueSetConcept creates a new ValueSetConcept instance
func NewValueSetConcept() *ValueSetConcept {
	return &ValueSetConcept{}
}

// FromJSON populates ValueSetConcept from JSON data
func (m *ValueSetConcept) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetConcept to JSON data
func (m *ValueSetConcept) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetConcept
func (m *ValueSetConcept) Clone() *ValueSetConcept {
	if m == nil { return nil }
	return &ValueSetConcept{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Display: m.Display.Clone(),
		Designation: cloneSlices(m.Designation),
	}
}

// Equals checks for equality with another ValueSetConcept instance
func (m *ValueSetConcept) Equals(other *ValueSetConcept) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Display.Equals(other.Display) { return false }
	if !compareSlices(m.Designation, other.Designation) { return false }
	return true
}

// ValueSetDesignation
// Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
type ValueSetDesignation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Use *Coding `json:"use,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewValueSetDesignation creates a new ValueSetDesignation instance
func NewValueSetDesignation() *ValueSetDesignation {
	return &ValueSetDesignation{}
}

// FromJSON populates ValueSetDesignation from JSON data
func (m *ValueSetDesignation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetDesignation to JSON data
func (m *ValueSetDesignation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetDesignation
func (m *ValueSetDesignation) Clone() *ValueSetDesignation {
	if m == nil { return nil }
	return &ValueSetDesignation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Language: m.Language.Clone(),
		Use: m.Use.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another ValueSetDesignation instance
func (m *ValueSetDesignation) Equals(other *ValueSetDesignation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// ValueSetFilter
// Select concepts by specify a matching criterion based on the properties (including relationships) defined by the system, or on filters defined by the system. If multiple filters are specified, they SHALL all be true.
type ValueSetFilter struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Property *FhirCode `json:"property,omitempty"`
	Op *FilterOperator `json:"op,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewValueSetFilter creates a new ValueSetFilter instance
func NewValueSetFilter() *ValueSetFilter {
	return &ValueSetFilter{}
}

// FromJSON populates ValueSetFilter from JSON data
func (m *ValueSetFilter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetFilter to JSON data
func (m *ValueSetFilter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetFilter
func (m *ValueSetFilter) Clone() *ValueSetFilter {
	if m == nil { return nil }
	return &ValueSetFilter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Property: m.Property.Clone(),
		Op: m.Op.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another ValueSetFilter instance
func (m *ValueSetFilter) Equals(other *ValueSetFilter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Property.Equals(other.Property) { return false }
	if !m.Op.Equals(other.Op) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// ValueSetExpansion
// A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
type ValueSetExpansion struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *FhirUri `json:"identifier,omitempty"`
	Timestamp *FhirDateTime `json:"timestamp,omitempty"`
	Total *FhirInteger `json:"total,omitempty"`
	Offset *FhirInteger `json:"offset,omitempty"`
	Parameter []*ValueSetParameter `json:"parameter,omitempty"`
	Contains []*ValueSetContains `json:"contains,omitempty"`
}

// NewValueSetExpansion creates a new ValueSetExpansion instance
func NewValueSetExpansion() *ValueSetExpansion {
	return &ValueSetExpansion{}
}

// FromJSON populates ValueSetExpansion from JSON data
func (m *ValueSetExpansion) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetExpansion to JSON data
func (m *ValueSetExpansion) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetExpansion
func (m *ValueSetExpansion) Clone() *ValueSetExpansion {
	if m == nil { return nil }
	return &ValueSetExpansion{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Timestamp: m.Timestamp.Clone(),
		Total: m.Total.Clone(),
		Offset: m.Offset.Clone(),
		Parameter: cloneSlices(m.Parameter),
		Contains: cloneSlices(m.Contains),
	}
}

// Equals checks for equality with another ValueSetExpansion instance
func (m *ValueSetExpansion) Equals(other *ValueSetExpansion) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Timestamp.Equals(other.Timestamp) { return false }
	if !m.Total.Equals(other.Total) { return false }
	if !m.Offset.Equals(other.Offset) { return false }
	if !compareSlices(m.Parameter, other.Parameter) { return false }
	if !compareSlices(m.Contains, other.Contains) { return false }
	return true
}

// ValueSetParameter
// A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
type ValueSetParameter struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueCode *FhirCode `json:"valuecode,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
}

// NewValueSetParameter creates a new ValueSetParameter instance
func NewValueSetParameter() *ValueSetParameter {
	return &ValueSetParameter{}
}

// FromJSON populates ValueSetParameter from JSON data
func (m *ValueSetParameter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetParameter to JSON data
func (m *ValueSetParameter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetParameter
func (m *ValueSetParameter) Clone() *ValueSetParameter {
	if m == nil { return nil }
	return &ValueSetParameter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueCode: m.ValueCode.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
	}
}

// Equals checks for equality with another ValueSetParameter instance
func (m *ValueSetParameter) Equals(other *ValueSetParameter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueCode.Equals(other.ValueCode) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	return true
}

// ValueSetContains
// The codes that are contained in the value set expansion.
type ValueSetContains struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	System *FhirUri `json:"system,omitempty"`
	Abstract_ *FhirBoolean `json:"abstract,omitempty"`
	Inactive *FhirBoolean `json:"inactive,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Display *FhirString `json:"display,omitempty"`
	Designation []*ValueSetDesignation `json:"designation,omitempty"`
	Contains []*ValueSetContains `json:"contains,omitempty"`
}

// NewValueSetContains creates a new ValueSetContains instance
func NewValueSetContains() *ValueSetContains {
	return &ValueSetContains{}
}

// FromJSON populates ValueSetContains from JSON data
func (m *ValueSetContains) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ValueSetContains to JSON data
func (m *ValueSetContains) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ValueSetContains
func (m *ValueSetContains) Clone() *ValueSetContains {
	if m == nil { return nil }
	return &ValueSetContains{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		System: m.System.Clone(),
		Abstract_: m.Abstract_.Clone(),
		Inactive: m.Inactive.Clone(),
		Version: m.Version.Clone(),
		Code: m.Code.Clone(),
		Display: m.Display.Clone(),
		Designation: cloneSlices(m.Designation),
		Contains: cloneSlices(m.Contains),
	}
}

// Equals checks for equality with another ValueSetContains instance
func (m *ValueSetContains) Equals(other *ValueSetContains) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.System.Equals(other.System) { return false }
	if !m.Abstract_.Equals(other.Abstract_) { return false }
	if !m.Inactive.Equals(other.Inactive) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Display.Equals(other.Display) { return false }
	if !compareSlices(m.Designation, other.Designation) { return false }
	if !compareSlices(m.Contains, other.Contains) { return false }
	return true
}

