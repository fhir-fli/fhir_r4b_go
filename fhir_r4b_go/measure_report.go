// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// MeasureReport
// The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation.
type MeasureReport struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *MeasureReportStatus `json:"status,omitempty"`
	Type *MeasureReportType `json:"type,omitempty"`
	Measure *FhirCanonical `json:"measure,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Reporter *Reference `json:"reporter,omitempty"`
	Period *Period `json:"period,omitempty"`
	ImprovementNotation *CodeableConcept `json:"improvementnotation,omitempty"`
	Group []*MeasureReportGroup `json:"group,omitempty"`
	EvaluatedResource []*Reference `json:"evaluatedresource,omitempty"`
}

// NewMeasureReport creates a new MeasureReport instance.
func NewMeasureReport() *MeasureReport {
	return &MeasureReport{}
}

// FromJSON populates MeasureReport from JSON data.
func (m *MeasureReport) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *MeasureReportStatus `json:"status,omitempty"`
		Type *MeasureReportType `json:"type,omitempty"`
		Measure *FhirCanonical `json:"measure,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		Reporter *Reference `json:"reporter,omitempty"`
		Period *Period `json:"period,omitempty"`
		ImprovementNotation *CodeableConcept `json:"improvementnotation,omitempty"`
		Group []*MeasureReportGroup `json:"group,omitempty"`
		EvaluatedResource []*Reference `json:"evaluatedresource,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Status = temp.Status
	m.Type = temp.Type
	m.Measure = temp.Measure
	m.Subject = temp.Subject
	m.Date = temp.Date
	m.Reporter = temp.Reporter
	m.Period = temp.Period
	m.ImprovementNotation = temp.ImprovementNotation
	m.Group = temp.Group
	m.EvaluatedResource = temp.EvaluatedResource
	return nil
}

// ToJSON converts MeasureReport to JSON data.
func (m *MeasureReport) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *MeasureReportStatus `json:"status,omitempty"`
		Type *MeasureReportType `json:"type,omitempty"`
		Measure interface{} `json:"measure,omitempty"`
		MeasureElement map[string]interface{} `json:"_measure,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Reporter *Reference `json:"reporter,omitempty"`
		Period *Period `json:"period,omitempty"`
		ImprovementNotation *CodeableConcept `json:"improvementnotation,omitempty"`
		Group []*MeasureReportGroup `json:"group,omitempty"`
		EvaluatedResource []*Reference `json:"evaluatedresource,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.ToJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Status = m.Status
	output.Type = m.Type
	if m.Measure != nil && m.Measure.Value != nil {
		output.Measure = m.Measure.Value
		if m.Measure.Element != nil {
			output.MeasureElement = toMapOrNil(m.Measure.Element.ToJSON())
		}
	}
	output.Subject = m.Subject
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.ToJSON())
		}
	}
	output.Reporter = m.Reporter
	output.Period = m.Period
	output.ImprovementNotation = m.ImprovementNotation
	output.Group = m.Group
	output.EvaluatedResource = m.EvaluatedResource
	return json.Marshal(output)
}

// Clone creates a deep copy of MeasureReport.
func (m *MeasureReport) Clone() *MeasureReport {
	if m == nil { return nil }
	return &MeasureReport{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		Measure: m.Measure.Clone(),
		Subject: m.Subject.Clone(),
		Date: m.Date.Clone(),
		Reporter: m.Reporter.Clone(),
		Period: m.Period.Clone(),
		ImprovementNotation: m.ImprovementNotation.Clone(),
		Group: cloneSlices(m.Group),
		EvaluatedResource: cloneSlices(m.EvaluatedResource),
	}
}

// Equals checks equality between two MeasureReport instances.
func (m *MeasureReport) Equals(other *MeasureReport) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Measure.Equals(other.Measure) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Reporter.Equals(other.Reporter) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.ImprovementNotation.Equals(other.ImprovementNotation) { return false }
	if !compareSlices(m.Group, other.Group) { return false }
	if !compareSlices(m.EvaluatedResource, other.EvaluatedResource) { return false }
	return true
}

// MeasureReportGroup
// The results of the calculation, one for each population group in the measure.
type MeasureReportGroup struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Population []*MeasureReportPopulation `json:"population,omitempty"`
	MeasureScore *Quantity `json:"measurescore,omitempty"`
	Stratifier []*MeasureReportStratifier `json:"stratifier,omitempty"`
}

// NewMeasureReportGroup creates a new MeasureReportGroup instance.
func NewMeasureReportGroup() *MeasureReportGroup {
	return &MeasureReportGroup{}
}

// FromJSON populates MeasureReportGroup from JSON data.
func (m *MeasureReportGroup) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Population []*MeasureReportPopulation `json:"population,omitempty"`
		MeasureScore *Quantity `json:"measurescore,omitempty"`
		Stratifier []*MeasureReportStratifier `json:"stratifier,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Population = temp.Population
	m.MeasureScore = temp.MeasureScore
	m.Stratifier = temp.Stratifier
	return nil
}

// ToJSON converts MeasureReportGroup to JSON data.
func (m *MeasureReportGroup) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Population []*MeasureReportPopulation `json:"population,omitempty"`
		MeasureScore *Quantity `json:"measurescore,omitempty"`
		Stratifier []*MeasureReportStratifier `json:"stratifier,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	output.Population = m.Population
	output.MeasureScore = m.MeasureScore
	output.Stratifier = m.Stratifier
	return json.Marshal(output)
}

// Clone creates a deep copy of MeasureReportGroup.
func (m *MeasureReportGroup) Clone() *MeasureReportGroup {
	if m == nil { return nil }
	return &MeasureReportGroup{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Population: cloneSlices(m.Population),
		MeasureScore: m.MeasureScore.Clone(),
		Stratifier: cloneSlices(m.Stratifier),
	}
}

// Equals checks equality between two MeasureReportGroup instances.
func (m *MeasureReportGroup) Equals(other *MeasureReportGroup) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.Population, other.Population) { return false }
	if !m.MeasureScore.Equals(other.MeasureScore) { return false }
	if !compareSlices(m.Stratifier, other.Stratifier) { return false }
	return true
}

// MeasureReportPopulation
// The populations that make up the population group, one for each type of population appropriate for the measure.
type MeasureReportPopulation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Count *FhirInteger `json:"count,omitempty"`
	SubjectResults *Reference `json:"subjectresults,omitempty"`
}

// NewMeasureReportPopulation creates a new MeasureReportPopulation instance.
func NewMeasureReportPopulation() *MeasureReportPopulation {
	return &MeasureReportPopulation{}
}

// FromJSON populates MeasureReportPopulation from JSON data.
func (m *MeasureReportPopulation) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Count *FhirInteger `json:"count,omitempty"`
		SubjectResults *Reference `json:"subjectresults,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Count = temp.Count
	m.SubjectResults = temp.SubjectResults
	return nil
}

// ToJSON converts MeasureReportPopulation to JSON data.
func (m *MeasureReportPopulation) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Count interface{} `json:"count,omitempty"`
		CountElement map[string]interface{} `json:"_count,omitempty"`
		SubjectResults *Reference `json:"subjectresults,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	if m.Count != nil && m.Count.Value != nil {
		output.Count = m.Count.Value
		if m.Count.Element != nil {
			output.CountElement = toMapOrNil(m.Count.Element.ToJSON())
		}
	}
	output.SubjectResults = m.SubjectResults
	return json.Marshal(output)
}

// Clone creates a deep copy of MeasureReportPopulation.
func (m *MeasureReportPopulation) Clone() *MeasureReportPopulation {
	if m == nil { return nil }
	return &MeasureReportPopulation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Count: m.Count.Clone(),
		SubjectResults: m.SubjectResults.Clone(),
	}
}

// Equals checks equality between two MeasureReportPopulation instances.
func (m *MeasureReportPopulation) Equals(other *MeasureReportPopulation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Count.Equals(other.Count) { return false }
	if !m.SubjectResults.Equals(other.SubjectResults) { return false }
	return true
}

// MeasureReportStratifier
// When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
type MeasureReportStratifier struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code []*CodeableConcept `json:"code,omitempty"`
	Stratum []*MeasureReportStratum `json:"stratum,omitempty"`
}

// NewMeasureReportStratifier creates a new MeasureReportStratifier instance.
func NewMeasureReportStratifier() *MeasureReportStratifier {
	return &MeasureReportStratifier{}
}

// FromJSON populates MeasureReportStratifier from JSON data.
func (m *MeasureReportStratifier) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code []*CodeableConcept `json:"code,omitempty"`
		Stratum []*MeasureReportStratum `json:"stratum,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Stratum = temp.Stratum
	return nil
}

// ToJSON converts MeasureReportStratifier to JSON data.
func (m *MeasureReportStratifier) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code []*CodeableConcept `json:"code,omitempty"`
		Stratum []*MeasureReportStratum `json:"stratum,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	output.Stratum = m.Stratum
	return json.Marshal(output)
}

// Clone creates a deep copy of MeasureReportStratifier.
func (m *MeasureReportStratifier) Clone() *MeasureReportStratifier {
	if m == nil { return nil }
	return &MeasureReportStratifier{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: cloneSlices(m.Code),
		Stratum: cloneSlices(m.Stratum),
	}
}

// Equals checks equality between two MeasureReportStratifier instances.
func (m *MeasureReportStratifier) Equals(other *MeasureReportStratifier) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Stratum, other.Stratum) { return false }
	return true
}

// MeasureReportStratum
// This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
type MeasureReportStratum struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Value *CodeableConcept `json:"value,omitempty"`
	Component []*MeasureReportComponent `json:"component,omitempty"`
	Population []*MeasureReportPopulation `json:"population,omitempty"`
	MeasureScore *Quantity `json:"measurescore,omitempty"`
}

// NewMeasureReportStratum creates a new MeasureReportStratum instance.
func NewMeasureReportStratum() *MeasureReportStratum {
	return &MeasureReportStratum{}
}

// FromJSON populates MeasureReportStratum from JSON data.
func (m *MeasureReportStratum) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Value *CodeableConcept `json:"value,omitempty"`
		Component []*MeasureReportComponent `json:"component,omitempty"`
		Population []*MeasureReportPopulation `json:"population,omitempty"`
		MeasureScore *Quantity `json:"measurescore,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Value = temp.Value
	m.Component = temp.Component
	m.Population = temp.Population
	m.MeasureScore = temp.MeasureScore
	return nil
}

// ToJSON converts MeasureReportStratum to JSON data.
func (m *MeasureReportStratum) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Value *CodeableConcept `json:"value,omitempty"`
		Component []*MeasureReportComponent `json:"component,omitempty"`
		Population []*MeasureReportPopulation `json:"population,omitempty"`
		MeasureScore *Quantity `json:"measurescore,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Value = m.Value
	output.Component = m.Component
	output.Population = m.Population
	output.MeasureScore = m.MeasureScore
	return json.Marshal(output)
}

// Clone creates a deep copy of MeasureReportStratum.
func (m *MeasureReportStratum) Clone() *MeasureReportStratum {
	if m == nil { return nil }
	return &MeasureReportStratum{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Value: m.Value.Clone(),
		Component: cloneSlices(m.Component),
		Population: cloneSlices(m.Population),
		MeasureScore: m.MeasureScore.Clone(),
	}
}

// Equals checks equality between two MeasureReportStratum instances.
func (m *MeasureReportStratum) Equals(other *MeasureReportStratum) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !compareSlices(m.Component, other.Component) { return false }
	if !compareSlices(m.Population, other.Population) { return false }
	if !m.MeasureScore.Equals(other.MeasureScore) { return false }
	return true
}

// MeasureReportComponent
// A stratifier component value.
type MeasureReportComponent struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Value *CodeableConcept `json:"value,omitempty"`
}

// NewMeasureReportComponent creates a new MeasureReportComponent instance.
func NewMeasureReportComponent() *MeasureReportComponent {
	return &MeasureReportComponent{}
}

// FromJSON populates MeasureReportComponent from JSON data.
func (m *MeasureReportComponent) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Value *CodeableConcept `json:"value,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Value = temp.Value
	return nil
}

// ToJSON converts MeasureReportComponent to JSON data.
func (m *MeasureReportComponent) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Value *CodeableConcept `json:"value,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	output.Value = m.Value
	return json.Marshal(output)
}

// Clone creates a deep copy of MeasureReportComponent.
func (m *MeasureReportComponent) Clone() *MeasureReportComponent {
	if m == nil { return nil }
	return &MeasureReportComponent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks equality between two MeasureReportComponent instances.
func (m *MeasureReportComponent) Equals(other *MeasureReportComponent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// MeasureReportPopulation1
// The populations that make up the stratum, one for each type of population appropriate to the measure.
type MeasureReportPopulation1 struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Count *FhirInteger `json:"count,omitempty"`
	SubjectResults *Reference `json:"subjectresults,omitempty"`
}

// NewMeasureReportPopulation1 creates a new MeasureReportPopulation1 instance.
func NewMeasureReportPopulation1() *MeasureReportPopulation1 {
	return &MeasureReportPopulation1{}
}

// FromJSON populates MeasureReportPopulation1 from JSON data.
func (m *MeasureReportPopulation1) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Count *FhirInteger `json:"count,omitempty"`
		SubjectResults *Reference `json:"subjectresults,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Count = temp.Count
	m.SubjectResults = temp.SubjectResults
	return nil
}

// ToJSON converts MeasureReportPopulation1 to JSON data.
func (m *MeasureReportPopulation1) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Count interface{} `json:"count,omitempty"`
		CountElement map[string]interface{} `json:"_count,omitempty"`
		SubjectResults *Reference `json:"subjectresults,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	if m.Count != nil && m.Count.Value != nil {
		output.Count = m.Count.Value
		if m.Count.Element != nil {
			output.CountElement = toMapOrNil(m.Count.Element.ToJSON())
		}
	}
	output.SubjectResults = m.SubjectResults
	return json.Marshal(output)
}

// Clone creates a deep copy of MeasureReportPopulation1.
func (m *MeasureReportPopulation1) Clone() *MeasureReportPopulation1 {
	if m == nil { return nil }
	return &MeasureReportPopulation1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Count: m.Count.Clone(),
		SubjectResults: m.SubjectResults.Clone(),
	}
}

// Equals checks equality between two MeasureReportPopulation1 instances.
func (m *MeasureReportPopulation1) Equals(other *MeasureReportPopulation1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Count.Equals(other.Count) { return false }
	if !m.SubjectResults.Equals(other.SubjectResults) { return false }
	return true
}

