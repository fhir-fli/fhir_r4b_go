// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// TestScript
// A structured set of tests against a FHIR server or client implementation to determine compliance against the FHIR specification.
type TestScript struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	Origin []*TestScriptOrigin `json:"origin,omitempty"`
	Destination []*TestScriptDestination `json:"destination,omitempty"`
	Metadata *TestScriptMetadata `json:"metadata,omitempty"`
	Fixture []*TestScriptFixture `json:"fixture,omitempty"`
	Profile []*Reference `json:"profile,omitempty"`
	Variable []*TestScriptVariable `json:"variable,omitempty"`
	Setup *TestScriptSetup `json:"setup,omitempty"`
	Test []*TestScriptTest `json:"test,omitempty"`
	Teardown *TestScriptTeardown `json:"teardown,omitempty"`
}

// NewTestScript creates a new TestScript instance.
func NewTestScript() *TestScript {
	return &TestScript{}
}

// UnmarshalJSON populates TestScript from JSON data.
func (m *TestScript) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url *FhirUri `json:"url,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Title *FhirString `json:"title,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Experimental *FhirBoolean `json:"experimental,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		Publisher *FhirString `json:"publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Purpose *FhirMarkdown `json:"purpose,omitempty"`
		Copyright *FhirMarkdown `json:"copyright,omitempty"`
		Origin []*TestScriptOrigin `json:"origin,omitempty"`
		Destination []*TestScriptDestination `json:"destination,omitempty"`
		Metadata *TestScriptMetadata `json:"metadata,omitempty"`
		Fixture []*TestScriptFixture `json:"fixture,omitempty"`
		Profile []*Reference `json:"profile,omitempty"`
		Variable []*TestScriptVariable `json:"variable,omitempty"`
		Setup *TestScriptSetup `json:"setup,omitempty"`
		Test []*TestScriptTest `json:"test,omitempty"`
		Teardown *TestScriptTeardown `json:"teardown,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Url = temp.Url
	m.Identifier = temp.Identifier
	m.Version = temp.Version
	m.Name = temp.Name
	m.Title = temp.Title
	m.Status = temp.Status
	m.Experimental = temp.Experimental
	m.Date = temp.Date
	m.Publisher = temp.Publisher
	m.Contact = temp.Contact
	m.Description = temp.Description
	m.UseContext = temp.UseContext
	m.Jurisdiction = temp.Jurisdiction
	m.Purpose = temp.Purpose
	m.Copyright = temp.Copyright
	m.Origin = temp.Origin
	m.Destination = temp.Destination
	m.Metadata = temp.Metadata
	m.Fixture = temp.Fixture
	m.Profile = temp.Profile
	m.Variable = temp.Variable
	m.Setup = temp.Setup
	m.Test = temp.Test
	m.Teardown = temp.Teardown
	return nil
}

// MarshalJSON converts TestScript to JSON data.
func (m *TestScript) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Title interface{} `json:"title,omitempty"`
		TitleElement map[string]interface{} `json:"_title,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Experimental interface{} `json:"experimental,omitempty"`
		ExperimentalElement map[string]interface{} `json:"_experimental,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Publisher interface{} `json:"publisher,omitempty"`
		PublisherElement map[string]interface{} `json:"_publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Purpose interface{} `json:"purpose,omitempty"`
		PurposeElement map[string]interface{} `json:"_purpose,omitempty"`
		Copyright interface{} `json:"copyright,omitempty"`
		CopyrightElement map[string]interface{} `json:"_copyright,omitempty"`
		Origin []*TestScriptOrigin `json:"origin,omitempty"`
		Destination []*TestScriptDestination `json:"destination,omitempty"`
		Metadata *TestScriptMetadata `json:"metadata,omitempty"`
		Fixture []*TestScriptFixture `json:"fixture,omitempty"`
		Profile []*Reference `json:"profile,omitempty"`
		Variable []*TestScriptVariable `json:"variable,omitempty"`
		Setup *TestScriptSetup `json:"setup,omitempty"`
		Test []*TestScriptTest `json:"test,omitempty"`
		Teardown *TestScriptTeardown `json:"teardown,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	output.Identifier = m.Identifier
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.Title != nil && m.Title.Value != nil {
		output.Title = m.Title.Value
		if m.Title.Element != nil {
			output.TitleElement = toMapOrNil(m.Title.Element.MarshalJSON())
		}
	}
	output.Status = m.Status
	if m.Experimental != nil && m.Experimental.Value != nil {
		output.Experimental = m.Experimental.Value
		if m.Experimental.Element != nil {
			output.ExperimentalElement = toMapOrNil(m.Experimental.Element.MarshalJSON())
		}
	}
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.MarshalJSON())
		}
	}
	if m.Publisher != nil && m.Publisher.Value != nil {
		output.Publisher = m.Publisher.Value
		if m.Publisher.Element != nil {
			output.PublisherElement = toMapOrNil(m.Publisher.Element.MarshalJSON())
		}
	}
	output.Contact = m.Contact
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.UseContext = m.UseContext
	output.Jurisdiction = m.Jurisdiction
	if m.Purpose != nil && m.Purpose.Value != nil {
		output.Purpose = m.Purpose.Value
		if m.Purpose.Element != nil {
			output.PurposeElement = toMapOrNil(m.Purpose.Element.MarshalJSON())
		}
	}
	if m.Copyright != nil && m.Copyright.Value != nil {
		output.Copyright = m.Copyright.Value
		if m.Copyright.Element != nil {
			output.CopyrightElement = toMapOrNil(m.Copyright.Element.MarshalJSON())
		}
	}
	output.Origin = m.Origin
	output.Destination = m.Destination
	output.Metadata = m.Metadata
	output.Fixture = m.Fixture
	output.Profile = m.Profile
	output.Variable = m.Variable
	output.Setup = m.Setup
	output.Test = m.Test
	output.Teardown = m.Teardown
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScript.
func (m *TestScript) Clone() *TestScript {
	if m == nil { return nil }
	return &TestScript{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: m.Identifier.Clone(),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		Origin: cloneSlices(m.Origin),
		Destination: cloneSlices(m.Destination),
		Metadata: m.Metadata.Clone(),
		Fixture: cloneSlices(m.Fixture),
		Profile: cloneSlices(m.Profile),
		Variable: cloneSlices(m.Variable),
		Setup: m.Setup.Clone(),
		Test: cloneSlices(m.Test),
		Teardown: m.Teardown.Clone(),
	}
}

// Equals checks equality between two TestScript instances.
func (m *TestScript) Equals(other *TestScript) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !compareSlices(m.Origin, other.Origin) { return false }
	if !compareSlices(m.Destination, other.Destination) { return false }
	if !m.Metadata.Equals(other.Metadata) { return false }
	if !compareSlices(m.Fixture, other.Fixture) { return false }
	if !compareSlices(m.Profile, other.Profile) { return false }
	if !compareSlices(m.Variable, other.Variable) { return false }
	if !m.Setup.Equals(other.Setup) { return false }
	if !compareSlices(m.Test, other.Test) { return false }
	if !m.Teardown.Equals(other.Teardown) { return false }
	return true
}

// TestScriptOrigin
// An abstract server used in operations within this test script in the origin element.
type TestScriptOrigin struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Index *FhirInteger `json:"index,omitempty"`
	Profile *Coding `json:"profile,omitempty"`
}

// NewTestScriptOrigin creates a new TestScriptOrigin instance.
func NewTestScriptOrigin() *TestScriptOrigin {
	return &TestScriptOrigin{}
}

// UnmarshalJSON populates TestScriptOrigin from JSON data.
func (m *TestScriptOrigin) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Index *FhirInteger `json:"index,omitempty"`
		Profile *Coding `json:"profile,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Index = temp.Index
	m.Profile = temp.Profile
	return nil
}

// MarshalJSON converts TestScriptOrigin to JSON data.
func (m *TestScriptOrigin) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Index interface{} `json:"index,omitempty"`
		IndexElement map[string]interface{} `json:"_index,omitempty"`
		Profile *Coding `json:"profile,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Index != nil && m.Index.Value != nil {
		output.Index = m.Index.Value
		if m.Index.Element != nil {
			output.IndexElement = toMapOrNil(m.Index.Element.MarshalJSON())
		}
	}
	output.Profile = m.Profile
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptOrigin.
func (m *TestScriptOrigin) Clone() *TestScriptOrigin {
	if m == nil { return nil }
	return &TestScriptOrigin{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Index: m.Index.Clone(),
		Profile: m.Profile.Clone(),
	}
}

// Equals checks equality between two TestScriptOrigin instances.
func (m *TestScriptOrigin) Equals(other *TestScriptOrigin) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Index.Equals(other.Index) { return false }
	if !m.Profile.Equals(other.Profile) { return false }
	return true
}

// TestScriptDestination
// An abstract server used in operations within this test script in the destination element.
type TestScriptDestination struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Index *FhirInteger `json:"index,omitempty"`
	Profile *Coding `json:"profile,omitempty"`
}

// NewTestScriptDestination creates a new TestScriptDestination instance.
func NewTestScriptDestination() *TestScriptDestination {
	return &TestScriptDestination{}
}

// UnmarshalJSON populates TestScriptDestination from JSON data.
func (m *TestScriptDestination) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Index *FhirInteger `json:"index,omitempty"`
		Profile *Coding `json:"profile,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Index = temp.Index
	m.Profile = temp.Profile
	return nil
}

// MarshalJSON converts TestScriptDestination to JSON data.
func (m *TestScriptDestination) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Index interface{} `json:"index,omitempty"`
		IndexElement map[string]interface{} `json:"_index,omitempty"`
		Profile *Coding `json:"profile,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Index != nil && m.Index.Value != nil {
		output.Index = m.Index.Value
		if m.Index.Element != nil {
			output.IndexElement = toMapOrNil(m.Index.Element.MarshalJSON())
		}
	}
	output.Profile = m.Profile
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptDestination.
func (m *TestScriptDestination) Clone() *TestScriptDestination {
	if m == nil { return nil }
	return &TestScriptDestination{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Index: m.Index.Clone(),
		Profile: m.Profile.Clone(),
	}
}

// Equals checks equality between two TestScriptDestination instances.
func (m *TestScriptDestination) Equals(other *TestScriptDestination) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Index.Equals(other.Index) { return false }
	if !m.Profile.Equals(other.Profile) { return false }
	return true
}

// TestScriptMetadata
// The required capability must exist and are assumed to function correctly on the FHIR server being tested.
type TestScriptMetadata struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Link []*TestScriptLink `json:"link,omitempty"`
	Capability []*TestScriptCapability `json:"capability,omitempty"`
}

// NewTestScriptMetadata creates a new TestScriptMetadata instance.
func NewTestScriptMetadata() *TestScriptMetadata {
	return &TestScriptMetadata{}
}

// UnmarshalJSON populates TestScriptMetadata from JSON data.
func (m *TestScriptMetadata) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Link []*TestScriptLink `json:"link,omitempty"`
		Capability []*TestScriptCapability `json:"capability,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Link = temp.Link
	m.Capability = temp.Capability
	return nil
}

// MarshalJSON converts TestScriptMetadata to JSON data.
func (m *TestScriptMetadata) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Link []*TestScriptLink `json:"link,omitempty"`
		Capability []*TestScriptCapability `json:"capability,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Link = m.Link
	output.Capability = m.Capability
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptMetadata.
func (m *TestScriptMetadata) Clone() *TestScriptMetadata {
	if m == nil { return nil }
	return &TestScriptMetadata{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Link: cloneSlices(m.Link),
		Capability: cloneSlices(m.Capability),
	}
}

// Equals checks equality between two TestScriptMetadata instances.
func (m *TestScriptMetadata) Equals(other *TestScriptMetadata) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	if !compareSlices(m.Capability, other.Capability) { return false }
	return true
}

// TestScriptLink
// A link to the FHIR specification that this test is covering.
type TestScriptLink struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Description *FhirString `json:"description,omitempty"`
}

// NewTestScriptLink creates a new TestScriptLink instance.
func NewTestScriptLink() *TestScriptLink {
	return &TestScriptLink{}
}

// UnmarshalJSON populates TestScriptLink from JSON data.
func (m *TestScriptLink) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url *FhirUri `json:"url,omitempty"`
		Description *FhirString `json:"description,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Url = temp.Url
	m.Description = temp.Description
	return nil
}

// MarshalJSON converts TestScriptLink to JSON data.
func (m *TestScriptLink) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptLink.
func (m *TestScriptLink) Clone() *TestScriptLink {
	if m == nil { return nil }
	return &TestScriptLink{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Description: m.Description.Clone(),
	}
}

// Equals checks equality between two TestScriptLink instances.
func (m *TestScriptLink) Equals(other *TestScriptLink) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Description.Equals(other.Description) { return false }
	return true
}

// TestScriptCapability
// Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
type TestScriptCapability struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Required_ *FhirBoolean `json:"required,omitempty"`
	Validated *FhirBoolean `json:"validated,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Origin []*FhirInteger `json:"origin,omitempty"`
	Destination *FhirInteger `json:"destination,omitempty"`
	Link []*FhirUri `json:"link,omitempty"`
	Capabilities *FhirCanonical `json:"capabilities,omitempty"`
}

// NewTestScriptCapability creates a new TestScriptCapability instance.
func NewTestScriptCapability() *TestScriptCapability {
	return &TestScriptCapability{}
}

// UnmarshalJSON populates TestScriptCapability from JSON data.
func (m *TestScriptCapability) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Required_ *FhirBoolean `json:"required,omitempty"`
		Validated *FhirBoolean `json:"validated,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Origin []interface{} `json:"origin,omitempty"`
		Destination *FhirInteger `json:"destination,omitempty"`
		Link []interface{} `json:"link,omitempty"`
		Capabilities *FhirCanonical `json:"capabilities,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Required_ = temp.Required_
	m.Validated = temp.Validated
	m.Description = temp.Description
	if len(temp.Origin) > 0 {
		m.Origin = make([]*FhirInteger, len(temp.Origin))
		for i := range temp.Origin {
			itemMap, ok := temp.Origin[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Origin[%d]: expected map", i) }
			primitive, err := NewFhirIntegerFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Origin[%d]: %v", i, err) }
			m.Origin[i] = primitive
		}
	}
	m.Destination = temp.Destination
	if len(temp.Link) > 0 {
		m.Link = make([]*FhirUri, len(temp.Link))
		for i := range temp.Link {
			itemMap, ok := temp.Link[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Link[%d]: expected map", i) }
			primitive, err := NewFhirUriFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Link[%d]: %v", i, err) }
			m.Link[i] = primitive
		}
	}
	m.Capabilities = temp.Capabilities
	return nil
}

// MarshalJSON converts TestScriptCapability to JSON data.
func (m *TestScriptCapability) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Required_ interface{} `json:"required,omitempty"`
		Required_Element map[string]interface{} `json:"_required,omitempty"`
		Validated interface{} `json:"validated,omitempty"`
		ValidatedElement map[string]interface{} `json:"_validated,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Origin []interface{} `json:"origin,omitempty"`
		OriginElement []map[string]interface{} `json:"_origin,omitempty"`
		Destination interface{} `json:"destination,omitempty"`
		DestinationElement map[string]interface{} `json:"_destination,omitempty"`
		Link []interface{} `json:"link,omitempty"`
		LinkElement []map[string]interface{} `json:"_link,omitempty"`
		Capabilities interface{} `json:"capabilities,omitempty"`
		CapabilitiesElement map[string]interface{} `json:"_capabilities,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Required_ != nil && m.Required_.Value != nil {
		output.Required_ = m.Required_.Value
		if m.Required_.Element != nil {
			output.Required_Element = toMapOrNil(m.Required_.Element.MarshalJSON())
		}
	}
	if m.Validated != nil && m.Validated.Value != nil {
		output.Validated = m.Validated.Value
		if m.Validated.Element != nil {
			output.ValidatedElement = toMapOrNil(m.Validated.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	if len(m.Origin) > 0 {
		output.Origin = make([]interface{}, len(m.Origin))
		output.OriginElement = make([]map[string]interface{}, len(m.Origin))
		for i, item := range m.Origin {
			if item != nil && item.Value != nil {
				output.Origin[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.OriginElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	if m.Destination != nil && m.Destination.Value != nil {
		output.Destination = m.Destination.Value
		if m.Destination.Element != nil {
			output.DestinationElement = toMapOrNil(m.Destination.Element.MarshalJSON())
		}
	}
	if len(m.Link) > 0 {
		output.Link = make([]interface{}, len(m.Link))
		output.LinkElement = make([]map[string]interface{}, len(m.Link))
		for i, item := range m.Link {
			if item != nil && item.Value != nil {
				output.Link[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.LinkElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	if m.Capabilities != nil && m.Capabilities.Value != nil {
		output.Capabilities = m.Capabilities.Value
		if m.Capabilities.Element != nil {
			output.CapabilitiesElement = toMapOrNil(m.Capabilities.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptCapability.
func (m *TestScriptCapability) Clone() *TestScriptCapability {
	if m == nil { return nil }
	return &TestScriptCapability{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Required_: m.Required_.Clone(),
		Validated: m.Validated.Clone(),
		Description: m.Description.Clone(),
		Origin: cloneSlices(m.Origin),
		Destination: m.Destination.Clone(),
		Link: cloneSlices(m.Link),
		Capabilities: m.Capabilities.Clone(),
	}
}

// Equals checks equality between two TestScriptCapability instances.
func (m *TestScriptCapability) Equals(other *TestScriptCapability) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Required_.Equals(other.Required_) { return false }
	if !m.Validated.Equals(other.Validated) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Origin, other.Origin) { return false }
	if !m.Destination.Equals(other.Destination) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	if !m.Capabilities.Equals(other.Capabilities) { return false }
	return true
}

// TestScriptFixture
// Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
type TestScriptFixture struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Autocreate *FhirBoolean `json:"autocreate,omitempty"`
	Autodelete *FhirBoolean `json:"autodelete,omitempty"`
	Resource *Reference `json:"resource,omitempty"`
}

// NewTestScriptFixture creates a new TestScriptFixture instance.
func NewTestScriptFixture() *TestScriptFixture {
	return &TestScriptFixture{}
}

// UnmarshalJSON populates TestScriptFixture from JSON data.
func (m *TestScriptFixture) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Autocreate *FhirBoolean `json:"autocreate,omitempty"`
		Autodelete *FhirBoolean `json:"autodelete,omitempty"`
		Resource *Reference `json:"resource,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Autocreate = temp.Autocreate
	m.Autodelete = temp.Autodelete
	m.Resource = temp.Resource
	return nil
}

// MarshalJSON converts TestScriptFixture to JSON data.
func (m *TestScriptFixture) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Autocreate interface{} `json:"autocreate,omitempty"`
		AutocreateElement map[string]interface{} `json:"_autocreate,omitempty"`
		Autodelete interface{} `json:"autodelete,omitempty"`
		AutodeleteElement map[string]interface{} `json:"_autodelete,omitempty"`
		Resource *Reference `json:"resource,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Autocreate != nil && m.Autocreate.Value != nil {
		output.Autocreate = m.Autocreate.Value
		if m.Autocreate.Element != nil {
			output.AutocreateElement = toMapOrNil(m.Autocreate.Element.MarshalJSON())
		}
	}
	if m.Autodelete != nil && m.Autodelete.Value != nil {
		output.Autodelete = m.Autodelete.Value
		if m.Autodelete.Element != nil {
			output.AutodeleteElement = toMapOrNil(m.Autodelete.Element.MarshalJSON())
		}
	}
	output.Resource = m.Resource
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptFixture.
func (m *TestScriptFixture) Clone() *TestScriptFixture {
	if m == nil { return nil }
	return &TestScriptFixture{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Autocreate: m.Autocreate.Clone(),
		Autodelete: m.Autodelete.Clone(),
		Resource: m.Resource.Clone(),
	}
}

// Equals checks equality between two TestScriptFixture instances.
func (m *TestScriptFixture) Equals(other *TestScriptFixture) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Autocreate.Equals(other.Autocreate) { return false }
	if !m.Autodelete.Equals(other.Autodelete) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	return true
}

// TestScriptVariable
// Variable is set based either on element value in response body or on header field value in the response headers.
type TestScriptVariable struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	DefaultValue *FhirString `json:"defaultvalue,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Expression *FhirString `json:"expression,omitempty"`
	HeaderField *FhirString `json:"headerfield,omitempty"`
	Hint *FhirString `json:"hint,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	SourceId *FhirId `json:"sourceid,omitempty"`
}

// NewTestScriptVariable creates a new TestScriptVariable instance.
func NewTestScriptVariable() *TestScriptVariable {
	return &TestScriptVariable{}
}

// UnmarshalJSON populates TestScriptVariable from JSON data.
func (m *TestScriptVariable) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		DefaultValue *FhirString `json:"defaultvalue,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Expression *FhirString `json:"expression,omitempty"`
		HeaderField *FhirString `json:"headerfield,omitempty"`
		Hint *FhirString `json:"hint,omitempty"`
		Path *FhirString `json:"path,omitempty"`
		SourceId *FhirId `json:"sourceid,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.DefaultValue = temp.DefaultValue
	m.Description = temp.Description
	m.Expression = temp.Expression
	m.HeaderField = temp.HeaderField
	m.Hint = temp.Hint
	m.Path = temp.Path
	m.SourceId = temp.SourceId
	return nil
}

// MarshalJSON converts TestScriptVariable to JSON data.
func (m *TestScriptVariable) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		DefaultValue interface{} `json:"defaultvalue,omitempty"`
		DefaultValueElement map[string]interface{} `json:"_defaultvalue,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Expression interface{} `json:"expression,omitempty"`
		ExpressionElement map[string]interface{} `json:"_expression,omitempty"`
		HeaderField interface{} `json:"headerfield,omitempty"`
		HeaderFieldElement map[string]interface{} `json:"_headerfield,omitempty"`
		Hint interface{} `json:"hint,omitempty"`
		HintElement map[string]interface{} `json:"_hint,omitempty"`
		Path interface{} `json:"path,omitempty"`
		PathElement map[string]interface{} `json:"_path,omitempty"`
		SourceId interface{} `json:"sourceid,omitempty"`
		SourceIdElement map[string]interface{} `json:"_sourceid,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.DefaultValue != nil && m.DefaultValue.Value != nil {
		output.DefaultValue = m.DefaultValue.Value
		if m.DefaultValue.Element != nil {
			output.DefaultValueElement = toMapOrNil(m.DefaultValue.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	if m.Expression != nil && m.Expression.Value != nil {
		output.Expression = m.Expression.Value
		if m.Expression.Element != nil {
			output.ExpressionElement = toMapOrNil(m.Expression.Element.MarshalJSON())
		}
	}
	if m.HeaderField != nil && m.HeaderField.Value != nil {
		output.HeaderField = m.HeaderField.Value
		if m.HeaderField.Element != nil {
			output.HeaderFieldElement = toMapOrNil(m.HeaderField.Element.MarshalJSON())
		}
	}
	if m.Hint != nil && m.Hint.Value != nil {
		output.Hint = m.Hint.Value
		if m.Hint.Element != nil {
			output.HintElement = toMapOrNil(m.Hint.Element.MarshalJSON())
		}
	}
	if m.Path != nil && m.Path.Value != nil {
		output.Path = m.Path.Value
		if m.Path.Element != nil {
			output.PathElement = toMapOrNil(m.Path.Element.MarshalJSON())
		}
	}
	if m.SourceId != nil && m.SourceId.Value != nil {
		output.SourceId = m.SourceId.Value
		if m.SourceId.Element != nil {
			output.SourceIdElement = toMapOrNil(m.SourceId.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptVariable.
func (m *TestScriptVariable) Clone() *TestScriptVariable {
	if m == nil { return nil }
	return &TestScriptVariable{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		DefaultValue: m.DefaultValue.Clone(),
		Description: m.Description.Clone(),
		Expression: m.Expression.Clone(),
		HeaderField: m.HeaderField.Clone(),
		Hint: m.Hint.Clone(),
		Path: m.Path.Clone(),
		SourceId: m.SourceId.Clone(),
	}
}

// Equals checks equality between two TestScriptVariable instances.
func (m *TestScriptVariable) Equals(other *TestScriptVariable) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.DefaultValue.Equals(other.DefaultValue) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Expression.Equals(other.Expression) { return false }
	if !m.HeaderField.Equals(other.HeaderField) { return false }
	if !m.Hint.Equals(other.Hint) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !m.SourceId.Equals(other.SourceId) { return false }
	return true
}

// TestScriptSetup
// A series of required setup operations before tests are executed.
type TestScriptSetup struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Action []*TestScriptAction `json:"action,omitempty"`
}

// NewTestScriptSetup creates a new TestScriptSetup instance.
func NewTestScriptSetup() *TestScriptSetup {
	return &TestScriptSetup{}
}

// UnmarshalJSON populates TestScriptSetup from JSON data.
func (m *TestScriptSetup) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestScriptAction `json:"action,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Action = temp.Action
	return nil
}

// MarshalJSON converts TestScriptSetup to JSON data.
func (m *TestScriptSetup) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestScriptAction `json:"action,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Action = m.Action
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptSetup.
func (m *TestScriptSetup) Clone() *TestScriptSetup {
	if m == nil { return nil }
	return &TestScriptSetup{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks equality between two TestScriptSetup instances.
func (m *TestScriptSetup) Equals(other *TestScriptSetup) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// TestScriptAction
// Action would contain either an operation or an assertion.
type TestScriptAction struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Operation *TestScriptOperation `json:"operation,omitempty"`
	Assert_ *TestScriptAssert `json:"assert,omitempty"`
}

// NewTestScriptAction creates a new TestScriptAction instance.
func NewTestScriptAction() *TestScriptAction {
	return &TestScriptAction{}
}

// UnmarshalJSON populates TestScriptAction from JSON data.
func (m *TestScriptAction) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestScriptOperation `json:"operation,omitempty"`
		Assert_ *TestScriptAssert `json:"assert,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Operation = temp.Operation
	m.Assert_ = temp.Assert_
	return nil
}

// MarshalJSON converts TestScriptAction to JSON data.
func (m *TestScriptAction) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestScriptOperation `json:"operation,omitempty"`
		Assert_ *TestScriptAssert `json:"assert,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Operation = m.Operation
	output.Assert_ = m.Assert_
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptAction.
func (m *TestScriptAction) Clone() *TestScriptAction {
	if m == nil { return nil }
	return &TestScriptAction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Operation: m.Operation.Clone(),
		Assert_: m.Assert_.Clone(),
	}
}

// Equals checks equality between two TestScriptAction instances.
func (m *TestScriptAction) Equals(other *TestScriptAction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Operation.Equals(other.Operation) { return false }
	if !m.Assert_.Equals(other.Assert_) { return false }
	return true
}

// TestScriptOperation
// The operation to perform.
type TestScriptOperation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *Coding `json:"type,omitempty"`
	Resource *FhirCode `json:"resource,omitempty"`
	Label *FhirString `json:"label,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Accept *FhirCode `json:"accept,omitempty"`
	ContentType *FhirCode `json:"contenttype,omitempty"`
	Destination *FhirInteger `json:"destination,omitempty"`
	EncodeRequestUrl *FhirBoolean `json:"encoderequesturl,omitempty"`
	Method *TestScriptRequestMethodCode `json:"method,omitempty"`
	Origin *FhirInteger `json:"origin,omitempty"`
	Params *FhirString `json:"params,omitempty"`
	RequestHeader []*TestScriptRequestHeader `json:"requestheader,omitempty"`
	RequestId *FhirId `json:"requestid,omitempty"`
	ResponseId *FhirId `json:"responseid,omitempty"`
	SourceId *FhirId `json:"sourceid,omitempty"`
	TargetId *FhirId `json:"targetid,omitempty"`
	Url *FhirString `json:"url,omitempty"`
}

// NewTestScriptOperation creates a new TestScriptOperation instance.
func NewTestScriptOperation() *TestScriptOperation {
	return &TestScriptOperation{}
}

// UnmarshalJSON populates TestScriptOperation from JSON data.
func (m *TestScriptOperation) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *Coding `json:"type,omitempty"`
		Resource *FhirCode `json:"resource,omitempty"`
		Label *FhirString `json:"label,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Accept *FhirCode `json:"accept,omitempty"`
		ContentType *FhirCode `json:"contenttype,omitempty"`
		Destination *FhirInteger `json:"destination,omitempty"`
		EncodeRequestUrl *FhirBoolean `json:"encoderequesturl,omitempty"`
		Method *TestScriptRequestMethodCode `json:"method,omitempty"`
		Origin *FhirInteger `json:"origin,omitempty"`
		Params *FhirString `json:"params,omitempty"`
		RequestHeader []*TestScriptRequestHeader `json:"requestheader,omitempty"`
		RequestId *FhirId `json:"requestid,omitempty"`
		ResponseId *FhirId `json:"responseid,omitempty"`
		SourceId *FhirId `json:"sourceid,omitempty"`
		TargetId *FhirId `json:"targetid,omitempty"`
		Url *FhirString `json:"url,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Resource = temp.Resource
	m.Label = temp.Label
	m.Description = temp.Description
	m.Accept = temp.Accept
	m.ContentType = temp.ContentType
	m.Destination = temp.Destination
	m.EncodeRequestUrl = temp.EncodeRequestUrl
	m.Method = temp.Method
	m.Origin = temp.Origin
	m.Params = temp.Params
	m.RequestHeader = temp.RequestHeader
	m.RequestId = temp.RequestId
	m.ResponseId = temp.ResponseId
	m.SourceId = temp.SourceId
	m.TargetId = temp.TargetId
	m.Url = temp.Url
	return nil
}

// MarshalJSON converts TestScriptOperation to JSON data.
func (m *TestScriptOperation) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *Coding `json:"type,omitempty"`
		Resource interface{} `json:"resource,omitempty"`
		ResourceElement map[string]interface{} `json:"_resource,omitempty"`
		Label interface{} `json:"label,omitempty"`
		LabelElement map[string]interface{} `json:"_label,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Accept interface{} `json:"accept,omitempty"`
		AcceptElement map[string]interface{} `json:"_accept,omitempty"`
		ContentType interface{} `json:"contenttype,omitempty"`
		ContentTypeElement map[string]interface{} `json:"_contenttype,omitempty"`
		Destination interface{} `json:"destination,omitempty"`
		DestinationElement map[string]interface{} `json:"_destination,omitempty"`
		EncodeRequestUrl interface{} `json:"encoderequesturl,omitempty"`
		EncodeRequestUrlElement map[string]interface{} `json:"_encoderequesturl,omitempty"`
		Method *TestScriptRequestMethodCode `json:"method,omitempty"`
		Origin interface{} `json:"origin,omitempty"`
		OriginElement map[string]interface{} `json:"_origin,omitempty"`
		Params interface{} `json:"params,omitempty"`
		ParamsElement map[string]interface{} `json:"_params,omitempty"`
		RequestHeader []*TestScriptRequestHeader `json:"requestheader,omitempty"`
		RequestId interface{} `json:"requestid,omitempty"`
		RequestIdElement map[string]interface{} `json:"_requestid,omitempty"`
		ResponseId interface{} `json:"responseid,omitempty"`
		ResponseIdElement map[string]interface{} `json:"_responseid,omitempty"`
		SourceId interface{} `json:"sourceid,omitempty"`
		SourceIdElement map[string]interface{} `json:"_sourceid,omitempty"`
		TargetId interface{} `json:"targetid,omitempty"`
		TargetIdElement map[string]interface{} `json:"_targetid,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.Resource != nil && m.Resource.Value != nil {
		output.Resource = m.Resource.Value
		if m.Resource.Element != nil {
			output.ResourceElement = toMapOrNil(m.Resource.Element.MarshalJSON())
		}
	}
	if m.Label != nil && m.Label.Value != nil {
		output.Label = m.Label.Value
		if m.Label.Element != nil {
			output.LabelElement = toMapOrNil(m.Label.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	if m.Accept != nil && m.Accept.Value != nil {
		output.Accept = m.Accept.Value
		if m.Accept.Element != nil {
			output.AcceptElement = toMapOrNil(m.Accept.Element.MarshalJSON())
		}
	}
	if m.ContentType != nil && m.ContentType.Value != nil {
		output.ContentType = m.ContentType.Value
		if m.ContentType.Element != nil {
			output.ContentTypeElement = toMapOrNil(m.ContentType.Element.MarshalJSON())
		}
	}
	if m.Destination != nil && m.Destination.Value != nil {
		output.Destination = m.Destination.Value
		if m.Destination.Element != nil {
			output.DestinationElement = toMapOrNil(m.Destination.Element.MarshalJSON())
		}
	}
	if m.EncodeRequestUrl != nil && m.EncodeRequestUrl.Value != nil {
		output.EncodeRequestUrl = m.EncodeRequestUrl.Value
		if m.EncodeRequestUrl.Element != nil {
			output.EncodeRequestUrlElement = toMapOrNil(m.EncodeRequestUrl.Element.MarshalJSON())
		}
	}
	output.Method = m.Method
	if m.Origin != nil && m.Origin.Value != nil {
		output.Origin = m.Origin.Value
		if m.Origin.Element != nil {
			output.OriginElement = toMapOrNil(m.Origin.Element.MarshalJSON())
		}
	}
	if m.Params != nil && m.Params.Value != nil {
		output.Params = m.Params.Value
		if m.Params.Element != nil {
			output.ParamsElement = toMapOrNil(m.Params.Element.MarshalJSON())
		}
	}
	output.RequestHeader = m.RequestHeader
	if m.RequestId != nil && m.RequestId.Value != nil {
		output.RequestId = m.RequestId.Value
		if m.RequestId.Element != nil {
			output.RequestIdElement = toMapOrNil(m.RequestId.Element.MarshalJSON())
		}
	}
	if m.ResponseId != nil && m.ResponseId.Value != nil {
		output.ResponseId = m.ResponseId.Value
		if m.ResponseId.Element != nil {
			output.ResponseIdElement = toMapOrNil(m.ResponseId.Element.MarshalJSON())
		}
	}
	if m.SourceId != nil && m.SourceId.Value != nil {
		output.SourceId = m.SourceId.Value
		if m.SourceId.Element != nil {
			output.SourceIdElement = toMapOrNil(m.SourceId.Element.MarshalJSON())
		}
	}
	if m.TargetId != nil && m.TargetId.Value != nil {
		output.TargetId = m.TargetId.Value
		if m.TargetId.Element != nil {
			output.TargetIdElement = toMapOrNil(m.TargetId.Element.MarshalJSON())
		}
	}
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptOperation.
func (m *TestScriptOperation) Clone() *TestScriptOperation {
	if m == nil { return nil }
	return &TestScriptOperation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Resource: m.Resource.Clone(),
		Label: m.Label.Clone(),
		Description: m.Description.Clone(),
		Accept: m.Accept.Clone(),
		ContentType: m.ContentType.Clone(),
		Destination: m.Destination.Clone(),
		EncodeRequestUrl: m.EncodeRequestUrl.Clone(),
		Method: m.Method.Clone(),
		Origin: m.Origin.Clone(),
		Params: m.Params.Clone(),
		RequestHeader: cloneSlices(m.RequestHeader),
		RequestId: m.RequestId.Clone(),
		ResponseId: m.ResponseId.Clone(),
		SourceId: m.SourceId.Clone(),
		TargetId: m.TargetId.Clone(),
		Url: m.Url.Clone(),
	}
}

// Equals checks equality between two TestScriptOperation instances.
func (m *TestScriptOperation) Equals(other *TestScriptOperation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !m.Label.Equals(other.Label) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Accept.Equals(other.Accept) { return false }
	if !m.ContentType.Equals(other.ContentType) { return false }
	if !m.Destination.Equals(other.Destination) { return false }
	if !m.EncodeRequestUrl.Equals(other.EncodeRequestUrl) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Origin.Equals(other.Origin) { return false }
	if !m.Params.Equals(other.Params) { return false }
	if !compareSlices(m.RequestHeader, other.RequestHeader) { return false }
	if !m.RequestId.Equals(other.RequestId) { return false }
	if !m.ResponseId.Equals(other.ResponseId) { return false }
	if !m.SourceId.Equals(other.SourceId) { return false }
	if !m.TargetId.Equals(other.TargetId) { return false }
	if !m.Url.Equals(other.Url) { return false }
	return true
}

// TestScriptRequestHeader
// Header elements would be used to set HTTP headers.
type TestScriptRequestHeader struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Field *FhirString `json:"field,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewTestScriptRequestHeader creates a new TestScriptRequestHeader instance.
func NewTestScriptRequestHeader() *TestScriptRequestHeader {
	return &TestScriptRequestHeader{}
}

// UnmarshalJSON populates TestScriptRequestHeader from JSON data.
func (m *TestScriptRequestHeader) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Field *FhirString `json:"field,omitempty"`
		Value *FhirString `json:"value,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Field = temp.Field
	m.Value = temp.Value
	return nil
}

// MarshalJSON converts TestScriptRequestHeader to JSON data.
func (m *TestScriptRequestHeader) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Field interface{} `json:"field,omitempty"`
		FieldElement map[string]interface{} `json:"_field,omitempty"`
		Value interface{} `json:"value,omitempty"`
		ValueElement map[string]interface{} `json:"_value,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Field != nil && m.Field.Value != nil {
		output.Field = m.Field.Value
		if m.Field.Element != nil {
			output.FieldElement = toMapOrNil(m.Field.Element.MarshalJSON())
		}
	}
	if m.Value != nil && m.Value.Value != nil {
		output.Value = m.Value.Value
		if m.Value.Element != nil {
			output.ValueElement = toMapOrNil(m.Value.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptRequestHeader.
func (m *TestScriptRequestHeader) Clone() *TestScriptRequestHeader {
	if m == nil { return nil }
	return &TestScriptRequestHeader{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Field: m.Field.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks equality between two TestScriptRequestHeader instances.
func (m *TestScriptRequestHeader) Equals(other *TestScriptRequestHeader) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Field.Equals(other.Field) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// TestScriptAssert
// Evaluates the results of previous operations to determine if the server under test behaves appropriately.
type TestScriptAssert struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Label *FhirString `json:"label,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Direction *AssertionDirectionType `json:"direction,omitempty"`
	CompareToSourceId *FhirString `json:"comparetosourceid,omitempty"`
	CompareToSourceExpression *FhirString `json:"comparetosourceexpression,omitempty"`
	CompareToSourcePath *FhirString `json:"comparetosourcepath,omitempty"`
	ContentType *FhirCode `json:"contenttype,omitempty"`
	Expression *FhirString `json:"expression,omitempty"`
	HeaderField *FhirString `json:"headerfield,omitempty"`
	MinimumId *FhirString `json:"minimumid,omitempty"`
	NavigationLinks *FhirBoolean `json:"navigationlinks,omitempty"`
	Operator_ *AssertionOperatorType `json:"operator,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	RequestMethod *TestScriptRequestMethodCode `json:"requestmethod,omitempty"`
	RequestURL *FhirString `json:"requesturl,omitempty"`
	Resource *FhirCode `json:"resource,omitempty"`
	Response *AssertionResponseTypes `json:"response,omitempty"`
	ResponseCode *FhirString `json:"responsecode,omitempty"`
	SourceId *FhirId `json:"sourceid,omitempty"`
	ValidateProfileId *FhirId `json:"validateprofileid,omitempty"`
	Value *FhirString `json:"value,omitempty"`
	WarningOnly *FhirBoolean `json:"warningonly,omitempty"`
}

// NewTestScriptAssert creates a new TestScriptAssert instance.
func NewTestScriptAssert() *TestScriptAssert {
	return &TestScriptAssert{}
}

// UnmarshalJSON populates TestScriptAssert from JSON data.
func (m *TestScriptAssert) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Label *FhirString `json:"label,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Direction *AssertionDirectionType `json:"direction,omitempty"`
		CompareToSourceId *FhirString `json:"comparetosourceid,omitempty"`
		CompareToSourceExpression *FhirString `json:"comparetosourceexpression,omitempty"`
		CompareToSourcePath *FhirString `json:"comparetosourcepath,omitempty"`
		ContentType *FhirCode `json:"contenttype,omitempty"`
		Expression *FhirString `json:"expression,omitempty"`
		HeaderField *FhirString `json:"headerfield,omitempty"`
		MinimumId *FhirString `json:"minimumid,omitempty"`
		NavigationLinks *FhirBoolean `json:"navigationlinks,omitempty"`
		Operator_ *AssertionOperatorType `json:"operator,omitempty"`
		Path *FhirString `json:"path,omitempty"`
		RequestMethod *TestScriptRequestMethodCode `json:"requestmethod,omitempty"`
		RequestURL *FhirString `json:"requesturl,omitempty"`
		Resource *FhirCode `json:"resource,omitempty"`
		Response *AssertionResponseTypes `json:"response,omitempty"`
		ResponseCode *FhirString `json:"responsecode,omitempty"`
		SourceId *FhirId `json:"sourceid,omitempty"`
		ValidateProfileId *FhirId `json:"validateprofileid,omitempty"`
		Value *FhirString `json:"value,omitempty"`
		WarningOnly *FhirBoolean `json:"warningonly,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Label = temp.Label
	m.Description = temp.Description
	m.Direction = temp.Direction
	m.CompareToSourceId = temp.CompareToSourceId
	m.CompareToSourceExpression = temp.CompareToSourceExpression
	m.CompareToSourcePath = temp.CompareToSourcePath
	m.ContentType = temp.ContentType
	m.Expression = temp.Expression
	m.HeaderField = temp.HeaderField
	m.MinimumId = temp.MinimumId
	m.NavigationLinks = temp.NavigationLinks
	m.Operator_ = temp.Operator_
	m.Path = temp.Path
	m.RequestMethod = temp.RequestMethod
	m.RequestURL = temp.RequestURL
	m.Resource = temp.Resource
	m.Response = temp.Response
	m.ResponseCode = temp.ResponseCode
	m.SourceId = temp.SourceId
	m.ValidateProfileId = temp.ValidateProfileId
	m.Value = temp.Value
	m.WarningOnly = temp.WarningOnly
	return nil
}

// MarshalJSON converts TestScriptAssert to JSON data.
func (m *TestScriptAssert) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Label interface{} `json:"label,omitempty"`
		LabelElement map[string]interface{} `json:"_label,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Direction *AssertionDirectionType `json:"direction,omitempty"`
		CompareToSourceId interface{} `json:"comparetosourceid,omitempty"`
		CompareToSourceIdElement map[string]interface{} `json:"_comparetosourceid,omitempty"`
		CompareToSourceExpression interface{} `json:"comparetosourceexpression,omitempty"`
		CompareToSourceExpressionElement map[string]interface{} `json:"_comparetosourceexpression,omitempty"`
		CompareToSourcePath interface{} `json:"comparetosourcepath,omitempty"`
		CompareToSourcePathElement map[string]interface{} `json:"_comparetosourcepath,omitempty"`
		ContentType interface{} `json:"contenttype,omitempty"`
		ContentTypeElement map[string]interface{} `json:"_contenttype,omitempty"`
		Expression interface{} `json:"expression,omitempty"`
		ExpressionElement map[string]interface{} `json:"_expression,omitempty"`
		HeaderField interface{} `json:"headerfield,omitempty"`
		HeaderFieldElement map[string]interface{} `json:"_headerfield,omitempty"`
		MinimumId interface{} `json:"minimumid,omitempty"`
		MinimumIdElement map[string]interface{} `json:"_minimumid,omitempty"`
		NavigationLinks interface{} `json:"navigationlinks,omitempty"`
		NavigationLinksElement map[string]interface{} `json:"_navigationlinks,omitempty"`
		Operator_ *AssertionOperatorType `json:"operator,omitempty"`
		Path interface{} `json:"path,omitempty"`
		PathElement map[string]interface{} `json:"_path,omitempty"`
		RequestMethod *TestScriptRequestMethodCode `json:"requestmethod,omitempty"`
		RequestURL interface{} `json:"requesturl,omitempty"`
		RequestURLElement map[string]interface{} `json:"_requesturl,omitempty"`
		Resource interface{} `json:"resource,omitempty"`
		ResourceElement map[string]interface{} `json:"_resource,omitempty"`
		Response *AssertionResponseTypes `json:"response,omitempty"`
		ResponseCode interface{} `json:"responsecode,omitempty"`
		ResponseCodeElement map[string]interface{} `json:"_responsecode,omitempty"`
		SourceId interface{} `json:"sourceid,omitempty"`
		SourceIdElement map[string]interface{} `json:"_sourceid,omitempty"`
		ValidateProfileId interface{} `json:"validateprofileid,omitempty"`
		ValidateProfileIdElement map[string]interface{} `json:"_validateprofileid,omitempty"`
		Value interface{} `json:"value,omitempty"`
		ValueElement map[string]interface{} `json:"_value,omitempty"`
		WarningOnly interface{} `json:"warningonly,omitempty"`
		WarningOnlyElement map[string]interface{} `json:"_warningonly,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Label != nil && m.Label.Value != nil {
		output.Label = m.Label.Value
		if m.Label.Element != nil {
			output.LabelElement = toMapOrNil(m.Label.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Direction = m.Direction
	if m.CompareToSourceId != nil && m.CompareToSourceId.Value != nil {
		output.CompareToSourceId = m.CompareToSourceId.Value
		if m.CompareToSourceId.Element != nil {
			output.CompareToSourceIdElement = toMapOrNil(m.CompareToSourceId.Element.MarshalJSON())
		}
	}
	if m.CompareToSourceExpression != nil && m.CompareToSourceExpression.Value != nil {
		output.CompareToSourceExpression = m.CompareToSourceExpression.Value
		if m.CompareToSourceExpression.Element != nil {
			output.CompareToSourceExpressionElement = toMapOrNil(m.CompareToSourceExpression.Element.MarshalJSON())
		}
	}
	if m.CompareToSourcePath != nil && m.CompareToSourcePath.Value != nil {
		output.CompareToSourcePath = m.CompareToSourcePath.Value
		if m.CompareToSourcePath.Element != nil {
			output.CompareToSourcePathElement = toMapOrNil(m.CompareToSourcePath.Element.MarshalJSON())
		}
	}
	if m.ContentType != nil && m.ContentType.Value != nil {
		output.ContentType = m.ContentType.Value
		if m.ContentType.Element != nil {
			output.ContentTypeElement = toMapOrNil(m.ContentType.Element.MarshalJSON())
		}
	}
	if m.Expression != nil && m.Expression.Value != nil {
		output.Expression = m.Expression.Value
		if m.Expression.Element != nil {
			output.ExpressionElement = toMapOrNil(m.Expression.Element.MarshalJSON())
		}
	}
	if m.HeaderField != nil && m.HeaderField.Value != nil {
		output.HeaderField = m.HeaderField.Value
		if m.HeaderField.Element != nil {
			output.HeaderFieldElement = toMapOrNil(m.HeaderField.Element.MarshalJSON())
		}
	}
	if m.MinimumId != nil && m.MinimumId.Value != nil {
		output.MinimumId = m.MinimumId.Value
		if m.MinimumId.Element != nil {
			output.MinimumIdElement = toMapOrNil(m.MinimumId.Element.MarshalJSON())
		}
	}
	if m.NavigationLinks != nil && m.NavigationLinks.Value != nil {
		output.NavigationLinks = m.NavigationLinks.Value
		if m.NavigationLinks.Element != nil {
			output.NavigationLinksElement = toMapOrNil(m.NavigationLinks.Element.MarshalJSON())
		}
	}
	output.Operator_ = m.Operator_
	if m.Path != nil && m.Path.Value != nil {
		output.Path = m.Path.Value
		if m.Path.Element != nil {
			output.PathElement = toMapOrNil(m.Path.Element.MarshalJSON())
		}
	}
	output.RequestMethod = m.RequestMethod
	if m.RequestURL != nil && m.RequestURL.Value != nil {
		output.RequestURL = m.RequestURL.Value
		if m.RequestURL.Element != nil {
			output.RequestURLElement = toMapOrNil(m.RequestURL.Element.MarshalJSON())
		}
	}
	if m.Resource != nil && m.Resource.Value != nil {
		output.Resource = m.Resource.Value
		if m.Resource.Element != nil {
			output.ResourceElement = toMapOrNil(m.Resource.Element.MarshalJSON())
		}
	}
	output.Response = m.Response
	if m.ResponseCode != nil && m.ResponseCode.Value != nil {
		output.ResponseCode = m.ResponseCode.Value
		if m.ResponseCode.Element != nil {
			output.ResponseCodeElement = toMapOrNil(m.ResponseCode.Element.MarshalJSON())
		}
	}
	if m.SourceId != nil && m.SourceId.Value != nil {
		output.SourceId = m.SourceId.Value
		if m.SourceId.Element != nil {
			output.SourceIdElement = toMapOrNil(m.SourceId.Element.MarshalJSON())
		}
	}
	if m.ValidateProfileId != nil && m.ValidateProfileId.Value != nil {
		output.ValidateProfileId = m.ValidateProfileId.Value
		if m.ValidateProfileId.Element != nil {
			output.ValidateProfileIdElement = toMapOrNil(m.ValidateProfileId.Element.MarshalJSON())
		}
	}
	if m.Value != nil && m.Value.Value != nil {
		output.Value = m.Value.Value
		if m.Value.Element != nil {
			output.ValueElement = toMapOrNil(m.Value.Element.MarshalJSON())
		}
	}
	if m.WarningOnly != nil && m.WarningOnly.Value != nil {
		output.WarningOnly = m.WarningOnly.Value
		if m.WarningOnly.Element != nil {
			output.WarningOnlyElement = toMapOrNil(m.WarningOnly.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptAssert.
func (m *TestScriptAssert) Clone() *TestScriptAssert {
	if m == nil { return nil }
	return &TestScriptAssert{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Label: m.Label.Clone(),
		Description: m.Description.Clone(),
		Direction: m.Direction.Clone(),
		CompareToSourceId: m.CompareToSourceId.Clone(),
		CompareToSourceExpression: m.CompareToSourceExpression.Clone(),
		CompareToSourcePath: m.CompareToSourcePath.Clone(),
		ContentType: m.ContentType.Clone(),
		Expression: m.Expression.Clone(),
		HeaderField: m.HeaderField.Clone(),
		MinimumId: m.MinimumId.Clone(),
		NavigationLinks: m.NavigationLinks.Clone(),
		Operator_: m.Operator_.Clone(),
		Path: m.Path.Clone(),
		RequestMethod: m.RequestMethod.Clone(),
		RequestURL: m.RequestURL.Clone(),
		Resource: m.Resource.Clone(),
		Response: m.Response.Clone(),
		ResponseCode: m.ResponseCode.Clone(),
		SourceId: m.SourceId.Clone(),
		ValidateProfileId: m.ValidateProfileId.Clone(),
		Value: m.Value.Clone(),
		WarningOnly: m.WarningOnly.Clone(),
	}
}

// Equals checks equality between two TestScriptAssert instances.
func (m *TestScriptAssert) Equals(other *TestScriptAssert) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Label.Equals(other.Label) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Direction.Equals(other.Direction) { return false }
	if !m.CompareToSourceId.Equals(other.CompareToSourceId) { return false }
	if !m.CompareToSourceExpression.Equals(other.CompareToSourceExpression) { return false }
	if !m.CompareToSourcePath.Equals(other.CompareToSourcePath) { return false }
	if !m.ContentType.Equals(other.ContentType) { return false }
	if !m.Expression.Equals(other.Expression) { return false }
	if !m.HeaderField.Equals(other.HeaderField) { return false }
	if !m.MinimumId.Equals(other.MinimumId) { return false }
	if !m.NavigationLinks.Equals(other.NavigationLinks) { return false }
	if !m.Operator_.Equals(other.Operator_) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !m.RequestMethod.Equals(other.RequestMethod) { return false }
	if !m.RequestURL.Equals(other.RequestURL) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !m.Response.Equals(other.Response) { return false }
	if !m.ResponseCode.Equals(other.ResponseCode) { return false }
	if !m.SourceId.Equals(other.SourceId) { return false }
	if !m.ValidateProfileId.Equals(other.ValidateProfileId) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !m.WarningOnly.Equals(other.WarningOnly) { return false }
	return true
}

// TestScriptTest
// A test in this script.
type TestScriptTest struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Action []*TestScriptAction `json:"action,omitempty"`
}

// NewTestScriptTest creates a new TestScriptTest instance.
func NewTestScriptTest() *TestScriptTest {
	return &TestScriptTest{}
}

// UnmarshalJSON populates TestScriptTest from JSON data.
func (m *TestScriptTest) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Action []*TestScriptAction `json:"action,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.Description = temp.Description
	m.Action = temp.Action
	return nil
}

// MarshalJSON converts TestScriptTest to JSON data.
func (m *TestScriptTest) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Action []*TestScriptAction `json:"action,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Action = m.Action
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptTest.
func (m *TestScriptTest) Clone() *TestScriptTest {
	if m == nil { return nil }
	return &TestScriptTest{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Description: m.Description.Clone(),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks equality between two TestScriptTest instances.
func (m *TestScriptTest) Equals(other *TestScriptTest) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// TestScriptAction1
// Action would contain either an operation or an assertion.
type TestScriptAction1 struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Operation *TestScriptOperation `json:"operation,omitempty"`
	Assert_ *TestScriptAssert `json:"assert,omitempty"`
}

// NewTestScriptAction1 creates a new TestScriptAction1 instance.
func NewTestScriptAction1() *TestScriptAction1 {
	return &TestScriptAction1{}
}

// UnmarshalJSON populates TestScriptAction1 from JSON data.
func (m *TestScriptAction1) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestScriptOperation `json:"operation,omitempty"`
		Assert_ *TestScriptAssert `json:"assert,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Operation = temp.Operation
	m.Assert_ = temp.Assert_
	return nil
}

// MarshalJSON converts TestScriptAction1 to JSON data.
func (m *TestScriptAction1) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestScriptOperation `json:"operation,omitempty"`
		Assert_ *TestScriptAssert `json:"assert,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Operation = m.Operation
	output.Assert_ = m.Assert_
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptAction1.
func (m *TestScriptAction1) Clone() *TestScriptAction1 {
	if m == nil { return nil }
	return &TestScriptAction1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Operation: m.Operation.Clone(),
		Assert_: m.Assert_.Clone(),
	}
}

// Equals checks equality between two TestScriptAction1 instances.
func (m *TestScriptAction1) Equals(other *TestScriptAction1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Operation.Equals(other.Operation) { return false }
	if !m.Assert_.Equals(other.Assert_) { return false }
	return true
}

// TestScriptTeardown
// A series of operations required to clean up after all the tests are executed (successfully or otherwise).
type TestScriptTeardown struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Action []*TestScriptAction `json:"action,omitempty"`
}

// NewTestScriptTeardown creates a new TestScriptTeardown instance.
func NewTestScriptTeardown() *TestScriptTeardown {
	return &TestScriptTeardown{}
}

// UnmarshalJSON populates TestScriptTeardown from JSON data.
func (m *TestScriptTeardown) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestScriptAction `json:"action,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Action = temp.Action
	return nil
}

// MarshalJSON converts TestScriptTeardown to JSON data.
func (m *TestScriptTeardown) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestScriptAction `json:"action,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Action = m.Action
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptTeardown.
func (m *TestScriptTeardown) Clone() *TestScriptTeardown {
	if m == nil { return nil }
	return &TestScriptTeardown{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks equality between two TestScriptTeardown instances.
func (m *TestScriptTeardown) Equals(other *TestScriptTeardown) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// TestScriptAction2
// The teardown action will only contain an operation.
type TestScriptAction2 struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Operation *TestScriptOperation `json:"operation,omitempty"`
}

// NewTestScriptAction2 creates a new TestScriptAction2 instance.
func NewTestScriptAction2() *TestScriptAction2 {
	return &TestScriptAction2{}
}

// UnmarshalJSON populates TestScriptAction2 from JSON data.
func (m *TestScriptAction2) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestScriptOperation `json:"operation,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Operation = temp.Operation
	return nil
}

// MarshalJSON converts TestScriptAction2 to JSON data.
func (m *TestScriptAction2) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestScriptOperation `json:"operation,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Operation = m.Operation
	return json.Marshal(output)
}

// Clone creates a deep copy of TestScriptAction2.
func (m *TestScriptAction2) Clone() *TestScriptAction2 {
	if m == nil { return nil }
	return &TestScriptAction2{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Operation: m.Operation.Clone(),
	}
}

// Equals checks equality between two TestScriptAction2 instances.
func (m *TestScriptAction2) Equals(other *TestScriptAction2) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Operation.Equals(other.Operation) { return false }
	return true
}

