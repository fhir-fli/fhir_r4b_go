// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// AuditEvent
// A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
type AuditEvent struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *Coding `json:"type,omitempty"`
	Subtype []*Coding `json:"subtype,omitempty"`
	Action *AuditEventAction `json:"action,omitempty"`
	Period *Period `json:"period,omitempty"`
	Recorded *FhirInstant `json:"recorded,omitempty"`
	Outcome *AuditEventOutcome `json:"outcome,omitempty"`
	OutcomeDesc *FhirString `json:"outcomedesc,omitempty"`
	PurposeOfEvent []*CodeableConcept `json:"purposeofevent,omitempty"`
	Agent []*AuditEventAgent `json:"agent,omitempty"`
	Source *AuditEventSource `json:"source,omitempty"`
	Entity []*AuditEventEntity `json:"entity,omitempty"`
}

// NewAuditEvent creates a new AuditEvent instance.
func NewAuditEvent() *AuditEvent {
	return &AuditEvent{}
}

// UnmarshalJSON populates AuditEvent from JSON data.
func (m *AuditEvent) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *Coding `json:"type,omitempty"`
		Subtype []*Coding `json:"subtype,omitempty"`
		Action *AuditEventAction `json:"action,omitempty"`
		Period *Period `json:"period,omitempty"`
		Recorded *FhirInstant `json:"recorded,omitempty"`
		Outcome *AuditEventOutcome `json:"outcome,omitempty"`
		OutcomeDesc *FhirString `json:"outcomedesc,omitempty"`
		PurposeOfEvent []*CodeableConcept `json:"purposeofevent,omitempty"`
		Agent []*AuditEventAgent `json:"agent,omitempty"`
		Source *AuditEventSource `json:"source,omitempty"`
		Entity []*AuditEventEntity `json:"entity,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Subtype = temp.Subtype
	m.Action = temp.Action
	m.Period = temp.Period
	m.Recorded = temp.Recorded
	m.Outcome = temp.Outcome
	m.OutcomeDesc = temp.OutcomeDesc
	m.PurposeOfEvent = temp.PurposeOfEvent
	m.Agent = temp.Agent
	m.Source = temp.Source
	m.Entity = temp.Entity
	return nil
}

// MarshalJSON converts AuditEvent to JSON data.
func (m *AuditEvent) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *Coding `json:"type,omitempty"`
		Subtype []*Coding `json:"subtype,omitempty"`
		Action *AuditEventAction `json:"action,omitempty"`
		Period *Period `json:"period,omitempty"`
		Recorded interface{} `json:"recorded,omitempty"`
		RecordedElement map[string]interface{} `json:"_recorded,omitempty"`
		Outcome *AuditEventOutcome `json:"outcome,omitempty"`
		OutcomeDesc interface{} `json:"outcomedesc,omitempty"`
		OutcomeDescElement map[string]interface{} `json:"_outcomedesc,omitempty"`
		PurposeOfEvent []*CodeableConcept `json:"purposeofevent,omitempty"`
		Agent []*AuditEventAgent `json:"agent,omitempty"`
		Source *AuditEventSource `json:"source,omitempty"`
		Entity []*AuditEventEntity `json:"entity,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Subtype = m.Subtype
	output.Action = m.Action
	output.Period = m.Period
	if m.Recorded != nil && m.Recorded.Value != nil {
		output.Recorded = m.Recorded.Value
		if m.Recorded.Element != nil {
			output.RecordedElement = toMapOrNil(m.Recorded.Element.MarshalJSON())
		}
	}
	output.Outcome = m.Outcome
	if m.OutcomeDesc != nil && m.OutcomeDesc.Value != nil {
		output.OutcomeDesc = m.OutcomeDesc.Value
		if m.OutcomeDesc.Element != nil {
			output.OutcomeDescElement = toMapOrNil(m.OutcomeDesc.Element.MarshalJSON())
		}
	}
	output.PurposeOfEvent = m.PurposeOfEvent
	output.Agent = m.Agent
	output.Source = m.Source
	output.Entity = m.Entity
	return json.Marshal(output)
}

// Clone creates a deep copy of AuditEvent.
func (m *AuditEvent) Clone() *AuditEvent {
	if m == nil { return nil }
	return &AuditEvent{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Subtype: cloneSlices(m.Subtype),
		Action: m.Action.Clone(),
		Period: m.Period.Clone(),
		Recorded: m.Recorded.Clone(),
		Outcome: m.Outcome.Clone(),
		OutcomeDesc: m.OutcomeDesc.Clone(),
		PurposeOfEvent: cloneSlices(m.PurposeOfEvent),
		Agent: cloneSlices(m.Agent),
		Source: m.Source.Clone(),
		Entity: cloneSlices(m.Entity),
	}
}

// Equals checks equality between two AuditEvent instances.
func (m *AuditEvent) Equals(other *AuditEvent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Subtype, other.Subtype) { return false }
	if !m.Action.Equals(other.Action) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.Recorded.Equals(other.Recorded) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	if !m.OutcomeDesc.Equals(other.OutcomeDesc) { return false }
	if !compareSlices(m.PurposeOfEvent, other.PurposeOfEvent) { return false }
	if !compareSlices(m.Agent, other.Agent) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !compareSlices(m.Entity, other.Entity) { return false }
	return true
}

// AuditEventAgent
// An actor taking an active role in the event or activity that is logged.
type AuditEventAgent struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Role []*CodeableConcept `json:"role,omitempty"`
	Who *Reference `json:"who,omitempty"`
	AltId *FhirString `json:"altid,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Requestor *FhirBoolean `json:"requestor,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Policy []*FhirUri `json:"policy,omitempty"`
	Media *Coding `json:"media,omitempty"`
	Network *AuditEventNetwork `json:"network,omitempty"`
	PurposeOfUse []*CodeableConcept `json:"purposeofuse,omitempty"`
}

// NewAuditEventAgent creates a new AuditEventAgent instance.
func NewAuditEventAgent() *AuditEventAgent {
	return &AuditEventAgent{}
}

// UnmarshalJSON populates AuditEventAgent from JSON data.
func (m *AuditEventAgent) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Role []*CodeableConcept `json:"role,omitempty"`
		Who *Reference `json:"who,omitempty"`
		AltId *FhirString `json:"altid,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Requestor *FhirBoolean `json:"requestor,omitempty"`
		Location *Reference `json:"location,omitempty"`
		Policy []interface{} `json:"policy,omitempty"`
		Media *Coding `json:"media,omitempty"`
		Network *AuditEventNetwork `json:"network,omitempty"`
		PurposeOfUse []*CodeableConcept `json:"purposeofuse,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Role = temp.Role
	m.Who = temp.Who
	m.AltId = temp.AltId
	m.Name = temp.Name
	m.Requestor = temp.Requestor
	m.Location = temp.Location
	if len(temp.Policy) > 0 {
		m.Policy = make([]*FhirUri, len(temp.Policy))
		for i := range temp.Policy {
			itemMap, ok := temp.Policy[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Policy[%d]: expected map", i) }
			primitive, err := NewFhirUriFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Policy[%d]: %v", i, err) }
			m.Policy[i] = primitive
		}
	}
	m.Media = temp.Media
	m.Network = temp.Network
	m.PurposeOfUse = temp.PurposeOfUse
	return nil
}

// MarshalJSON converts AuditEventAgent to JSON data.
func (m *AuditEventAgent) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Role []*CodeableConcept `json:"role,omitempty"`
		Who *Reference `json:"who,omitempty"`
		AltId interface{} `json:"altid,omitempty"`
		AltIdElement map[string]interface{} `json:"_altid,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Requestor interface{} `json:"requestor,omitempty"`
		RequestorElement map[string]interface{} `json:"_requestor,omitempty"`
		Location *Reference `json:"location,omitempty"`
		Policy []interface{} `json:"policy,omitempty"`
		PolicyElement []map[string]interface{} `json:"_policy,omitempty"`
		Media *Coding `json:"media,omitempty"`
		Network *AuditEventNetwork `json:"network,omitempty"`
		PurposeOfUse []*CodeableConcept `json:"purposeofuse,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Role = m.Role
	output.Who = m.Who
	if m.AltId != nil && m.AltId.Value != nil {
		output.AltId = m.AltId.Value
		if m.AltId.Element != nil {
			output.AltIdElement = toMapOrNil(m.AltId.Element.MarshalJSON())
		}
	}
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.Requestor != nil && m.Requestor.Value != nil {
		output.Requestor = m.Requestor.Value
		if m.Requestor.Element != nil {
			output.RequestorElement = toMapOrNil(m.Requestor.Element.MarshalJSON())
		}
	}
	output.Location = m.Location
	if len(m.Policy) > 0 {
		output.Policy = make([]interface{}, len(m.Policy))
		output.PolicyElement = make([]map[string]interface{}, len(m.Policy))
		for i, item := range m.Policy {
			if item != nil && item.Value != nil {
				output.Policy[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.PolicyElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	output.Media = m.Media
	output.Network = m.Network
	output.PurposeOfUse = m.PurposeOfUse
	return json.Marshal(output)
}

// Clone creates a deep copy of AuditEventAgent.
func (m *AuditEventAgent) Clone() *AuditEventAgent {
	if m == nil { return nil }
	return &AuditEventAgent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Role: cloneSlices(m.Role),
		Who: m.Who.Clone(),
		AltId: m.AltId.Clone(),
		Name: m.Name.Clone(),
		Requestor: m.Requestor.Clone(),
		Location: m.Location.Clone(),
		Policy: cloneSlices(m.Policy),
		Media: m.Media.Clone(),
		Network: m.Network.Clone(),
		PurposeOfUse: cloneSlices(m.PurposeOfUse),
	}
}

// Equals checks equality between two AuditEventAgent instances.
func (m *AuditEventAgent) Equals(other *AuditEventAgent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Role, other.Role) { return false }
	if !m.Who.Equals(other.Who) { return false }
	if !m.AltId.Equals(other.AltId) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Requestor.Equals(other.Requestor) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !compareSlices(m.Policy, other.Policy) { return false }
	if !m.Media.Equals(other.Media) { return false }
	if !m.Network.Equals(other.Network) { return false }
	if !compareSlices(m.PurposeOfUse, other.PurposeOfUse) { return false }
	return true
}

// AuditEventNetwork
// Logical network location for application activity, if the activity has a network location.
type AuditEventNetwork struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Address *FhirString `json:"address,omitempty"`
	Type *AuditEventAgentNetworkType `json:"type,omitempty"`
}

// NewAuditEventNetwork creates a new AuditEventNetwork instance.
func NewAuditEventNetwork() *AuditEventNetwork {
	return &AuditEventNetwork{}
}

// UnmarshalJSON populates AuditEventNetwork from JSON data.
func (m *AuditEventNetwork) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Address *FhirString `json:"address,omitempty"`
		Type *AuditEventAgentNetworkType `json:"type,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Address = temp.Address
	m.Type = temp.Type
	return nil
}

// MarshalJSON converts AuditEventNetwork to JSON data.
func (m *AuditEventNetwork) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Address interface{} `json:"address,omitempty"`
		AddressElement map[string]interface{} `json:"_address,omitempty"`
		Type *AuditEventAgentNetworkType `json:"type,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Address != nil && m.Address.Value != nil {
		output.Address = m.Address.Value
		if m.Address.Element != nil {
			output.AddressElement = toMapOrNil(m.Address.Element.MarshalJSON())
		}
	}
	output.Type = m.Type
	return json.Marshal(output)
}

// Clone creates a deep copy of AuditEventNetwork.
func (m *AuditEventNetwork) Clone() *AuditEventNetwork {
	if m == nil { return nil }
	return &AuditEventNetwork{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Address: m.Address.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks equality between two AuditEventNetwork instances.
func (m *AuditEventNetwork) Equals(other *AuditEventNetwork) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Address.Equals(other.Address) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// AuditEventSource
// The system that is reporting the event.
type AuditEventSource struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Site *FhirString `json:"site,omitempty"`
	Observer *Reference `json:"observer,omitempty"`
	Type []*Coding `json:"type,omitempty"`
}

// NewAuditEventSource creates a new AuditEventSource instance.
func NewAuditEventSource() *AuditEventSource {
	return &AuditEventSource{}
}

// UnmarshalJSON populates AuditEventSource from JSON data.
func (m *AuditEventSource) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Site *FhirString `json:"site,omitempty"`
		Observer *Reference `json:"observer,omitempty"`
		Type []*Coding `json:"type,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Site = temp.Site
	m.Observer = temp.Observer
	m.Type = temp.Type
	return nil
}

// MarshalJSON converts AuditEventSource to JSON data.
func (m *AuditEventSource) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Site interface{} `json:"site,omitempty"`
		SiteElement map[string]interface{} `json:"_site,omitempty"`
		Observer *Reference `json:"observer,omitempty"`
		Type []*Coding `json:"type,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Site != nil && m.Site.Value != nil {
		output.Site = m.Site.Value
		if m.Site.Element != nil {
			output.SiteElement = toMapOrNil(m.Site.Element.MarshalJSON())
		}
	}
	output.Observer = m.Observer
	output.Type = m.Type
	return json.Marshal(output)
}

// Clone creates a deep copy of AuditEventSource.
func (m *AuditEventSource) Clone() *AuditEventSource {
	if m == nil { return nil }
	return &AuditEventSource{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Site: m.Site.Clone(),
		Observer: m.Observer.Clone(),
		Type: cloneSlices(m.Type),
	}
}

// Equals checks equality between two AuditEventSource instances.
func (m *AuditEventSource) Equals(other *AuditEventSource) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Site.Equals(other.Site) { return false }
	if !m.Observer.Equals(other.Observer) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	return true
}

// AuditEventEntity
// Specific instances of data or objects that have been accessed.
type AuditEventEntity struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	What *Reference `json:"what,omitempty"`
	Type *Coding `json:"type,omitempty"`
	Role *Coding `json:"role,omitempty"`
	Lifecycle *Coding `json:"lifecycle,omitempty"`
	SecurityLabel []*Coding `json:"securitylabel,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Query *FhirBase64Binary `json:"query,omitempty"`
	Detail []*AuditEventDetail `json:"detail,omitempty"`
}

// NewAuditEventEntity creates a new AuditEventEntity instance.
func NewAuditEventEntity() *AuditEventEntity {
	return &AuditEventEntity{}
}

// UnmarshalJSON populates AuditEventEntity from JSON data.
func (m *AuditEventEntity) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		What *Reference `json:"what,omitempty"`
		Type *Coding `json:"type,omitempty"`
		Role *Coding `json:"role,omitempty"`
		Lifecycle *Coding `json:"lifecycle,omitempty"`
		SecurityLabel []*Coding `json:"securitylabel,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Query *FhirBase64Binary `json:"query,omitempty"`
		Detail []*AuditEventDetail `json:"detail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.What = temp.What
	m.Type = temp.Type
	m.Role = temp.Role
	m.Lifecycle = temp.Lifecycle
	m.SecurityLabel = temp.SecurityLabel
	m.Name = temp.Name
	m.Description = temp.Description
	m.Query = temp.Query
	m.Detail = temp.Detail
	return nil
}

// MarshalJSON converts AuditEventEntity to JSON data.
func (m *AuditEventEntity) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		What *Reference `json:"what,omitempty"`
		Type *Coding `json:"type,omitempty"`
		Role *Coding `json:"role,omitempty"`
		Lifecycle *Coding `json:"lifecycle,omitempty"`
		SecurityLabel []*Coding `json:"securitylabel,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Query interface{} `json:"query,omitempty"`
		QueryElement map[string]interface{} `json:"_query,omitempty"`
		Detail []*AuditEventDetail `json:"detail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.What = m.What
	output.Type = m.Type
	output.Role = m.Role
	output.Lifecycle = m.Lifecycle
	output.SecurityLabel = m.SecurityLabel
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	if m.Query != nil && m.Query.Value != nil {
		output.Query = m.Query.Value
		if m.Query.Element != nil {
			output.QueryElement = toMapOrNil(m.Query.Element.MarshalJSON())
		}
	}
	output.Detail = m.Detail
	return json.Marshal(output)
}

// Clone creates a deep copy of AuditEventEntity.
func (m *AuditEventEntity) Clone() *AuditEventEntity {
	if m == nil { return nil }
	return &AuditEventEntity{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		What: m.What.Clone(),
		Type: m.Type.Clone(),
		Role: m.Role.Clone(),
		Lifecycle: m.Lifecycle.Clone(),
		SecurityLabel: cloneSlices(m.SecurityLabel),
		Name: m.Name.Clone(),
		Description: m.Description.Clone(),
		Query: m.Query.Clone(),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks equality between two AuditEventEntity instances.
func (m *AuditEventEntity) Equals(other *AuditEventEntity) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.What.Equals(other.What) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Lifecycle.Equals(other.Lifecycle) { return false }
	if !compareSlices(m.SecurityLabel, other.SecurityLabel) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Query.Equals(other.Query) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// AuditEventDetail
// Tagged value pairs for conveying additional information about the entity.
type AuditEventDetail struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *FhirString `json:"type,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
}

// NewAuditEventDetail creates a new AuditEventDetail instance.
func NewAuditEventDetail() *AuditEventDetail {
	return &AuditEventDetail{}
}

// UnmarshalJSON populates AuditEventDetail from JSON data.
func (m *AuditEventDetail) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *FhirString `json:"type,omitempty"`
		ValueString *FhirString `json:"valuestring,omitempty"`
		ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.ValueString = temp.ValueString
	m.ValueBase64Binary = temp.ValueBase64Binary
	return nil
}

// MarshalJSON converts AuditEventDetail to JSON data.
func (m *AuditEventDetail) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type interface{} `json:"type,omitempty"`
		TypeElement map[string]interface{} `json:"_type,omitempty"`
		ValueString interface{} `json:"valuestring,omitempty"`
		ValueStringElement map[string]interface{} `json:"_valuestring,omitempty"`
		ValueBase64Binary interface{} `json:"valuebase64binary,omitempty"`
		ValueBase64BinaryElement map[string]interface{} `json:"_valuebase64binary,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Type != nil && m.Type.Value != nil {
		output.Type = m.Type.Value
		if m.Type.Element != nil {
			output.TypeElement = toMapOrNil(m.Type.Element.MarshalJSON())
		}
	}
	if m.ValueString != nil && m.ValueString.Value != nil {
		output.ValueString = m.ValueString.Value
		if m.ValueString.Element != nil {
			output.ValueStringElement = toMapOrNil(m.ValueString.Element.MarshalJSON())
		}
	}
	if m.ValueBase64Binary != nil && m.ValueBase64Binary.Value != nil {
		output.ValueBase64Binary = m.ValueBase64Binary.Value
		if m.ValueBase64Binary.Element != nil {
			output.ValueBase64BinaryElement = toMapOrNil(m.ValueBase64Binary.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of AuditEventDetail.
func (m *AuditEventDetail) Clone() *AuditEventDetail {
	if m == nil { return nil }
	return &AuditEventDetail{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
	}
}

// Equals checks equality between two AuditEventDetail instances.
func (m *AuditEventDetail) Equals(other *AuditEventDetail) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	return true
}

