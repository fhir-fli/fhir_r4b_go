// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Specimen
// A sample to be used for analysis.
type Specimen struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	AccessionIdentifier *Identifier `json:"accessionidentifier,omitempty"`
	Status *SpecimenStatus `json:"status,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	ReceivedTime *FhirDateTime `json:"receivedtime,omitempty"`
	Parent []*Reference `json:"parent,omitempty"`
	Request []*Reference `json:"request,omitempty"`
	Collection *SpecimenCollection `json:"collection,omitempty"`
	Processing []*SpecimenProcessing `json:"processing,omitempty"`
	Container []*SpecimenContainer `json:"container,omitempty"`
	Condition []*CodeableConcept `json:"condition,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewSpecimen creates a new Specimen instance
func NewSpecimen() *Specimen {
	return &Specimen{}
}

// FromJSON populates Specimen from JSON data
func (m *Specimen) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Specimen to JSON data
func (m *Specimen) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Specimen
func (m *Specimen) Clone() *Specimen {
	if m == nil { return nil }
	return &Specimen{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		AccessionIdentifier: m.AccessionIdentifier.Clone(),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		Subject: m.Subject.Clone(),
		ReceivedTime: m.ReceivedTime.Clone(),
		Parent: cloneSlices(m.Parent),
		Request: cloneSlices(m.Request),
		Collection: m.Collection.Clone(),
		Processing: cloneSlices(m.Processing),
		Container: cloneSlices(m.Container),
		Condition: cloneSlices(m.Condition),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks for equality with another Specimen instance
func (m *Specimen) Equals(other *Specimen) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.AccessionIdentifier.Equals(other.AccessionIdentifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.ReceivedTime.Equals(other.ReceivedTime) { return false }
	if !compareSlices(m.Parent, other.Parent) { return false }
	if !compareSlices(m.Request, other.Request) { return false }
	if !m.Collection.Equals(other.Collection) { return false }
	if !compareSlices(m.Processing, other.Processing) { return false }
	if !compareSlices(m.Container, other.Container) { return false }
	if !compareSlices(m.Condition, other.Condition) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// SpecimenCollection
// Details concerning the specimen collection.
type SpecimenCollection struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Collector *Reference `json:"collector,omitempty"`
	CollectedDateTime *FhirDateTime `json:"collecteddatetime,omitempty"`
	CollectedPeriod *Period `json:"collectedperiod,omitempty"`
	Duration *FhirDuration `json:"duration,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	BodySite *CodeableConcept `json:"bodysite,omitempty"`
	FastingStatusCodeableConcept *CodeableConcept `json:"fastingstatuscodeableconcept,omitempty"`
	FastingStatusDuration *FhirDuration `json:"fastingstatusduration,omitempty"`
}

// NewSpecimenCollection creates a new SpecimenCollection instance
func NewSpecimenCollection() *SpecimenCollection {
	return &SpecimenCollection{}
}

// FromJSON populates SpecimenCollection from JSON data
func (m *SpecimenCollection) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenCollection to JSON data
func (m *SpecimenCollection) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenCollection
func (m *SpecimenCollection) Clone() *SpecimenCollection {
	if m == nil { return nil }
	return &SpecimenCollection{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Collector: m.Collector.Clone(),
		CollectedDateTime: m.CollectedDateTime.Clone(),
		CollectedPeriod: m.CollectedPeriod.Clone(),
		Duration: m.Duration.Clone(),
		Quantity: m.Quantity.Clone(),
		Method: m.Method.Clone(),
		BodySite: m.BodySite.Clone(),
		FastingStatusCodeableConcept: m.FastingStatusCodeableConcept.Clone(),
		FastingStatusDuration: m.FastingStatusDuration.Clone(),
	}
}

// Equals checks for equality with another SpecimenCollection instance
func (m *SpecimenCollection) Equals(other *SpecimenCollection) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Collector.Equals(other.Collector) { return false }
	if !m.CollectedDateTime.Equals(other.CollectedDateTime) { return false }
	if !m.CollectedPeriod.Equals(other.CollectedPeriod) { return false }
	if !m.Duration.Equals(other.Duration) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !m.FastingStatusCodeableConcept.Equals(other.FastingStatusCodeableConcept) { return false }
	if !m.FastingStatusDuration.Equals(other.FastingStatusDuration) { return false }
	return true
}

// SpecimenProcessing
// Details concerning processing and processing steps for the specimen.
type SpecimenProcessing struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Procedure *CodeableConcept `json:"procedure,omitempty"`
	Additive []*Reference `json:"additive,omitempty"`
	TimeDateTime *FhirDateTime `json:"timedatetime,omitempty"`
	TimePeriod *Period `json:"timeperiod,omitempty"`
}

// NewSpecimenProcessing creates a new SpecimenProcessing instance
func NewSpecimenProcessing() *SpecimenProcessing {
	return &SpecimenProcessing{}
}

// FromJSON populates SpecimenProcessing from JSON data
func (m *SpecimenProcessing) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenProcessing to JSON data
func (m *SpecimenProcessing) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenProcessing
func (m *SpecimenProcessing) Clone() *SpecimenProcessing {
	if m == nil { return nil }
	return &SpecimenProcessing{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Procedure: m.Procedure.Clone(),
		Additive: cloneSlices(m.Additive),
		TimeDateTime: m.TimeDateTime.Clone(),
		TimePeriod: m.TimePeriod.Clone(),
	}
}

// Equals checks for equality with another SpecimenProcessing instance
func (m *SpecimenProcessing) Equals(other *SpecimenProcessing) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Procedure.Equals(other.Procedure) { return false }
	if !compareSlices(m.Additive, other.Additive) { return false }
	if !m.TimeDateTime.Equals(other.TimeDateTime) { return false }
	if !m.TimePeriod.Equals(other.TimePeriod) { return false }
	return true
}

// SpecimenContainer
// The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
type SpecimenContainer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Capacity *Quantity `json:"capacity,omitempty"`
	SpecimenQuantity *Quantity `json:"specimenquantity,omitempty"`
	AdditiveCodeableConcept *CodeableConcept `json:"additivecodeableconcept,omitempty"`
	AdditiveReference *Reference `json:"additivereference,omitempty"`
}

// NewSpecimenContainer creates a new SpecimenContainer instance
func NewSpecimenContainer() *SpecimenContainer {
	return &SpecimenContainer{}
}

// FromJSON populates SpecimenContainer from JSON data
func (m *SpecimenContainer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenContainer to JSON data
func (m *SpecimenContainer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenContainer
func (m *SpecimenContainer) Clone() *SpecimenContainer {
	if m == nil { return nil }
	return &SpecimenContainer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Description: m.Description.Clone(),
		Type: m.Type.Clone(),
		Capacity: m.Capacity.Clone(),
		SpecimenQuantity: m.SpecimenQuantity.Clone(),
		AdditiveCodeableConcept: m.AdditiveCodeableConcept.Clone(),
		AdditiveReference: m.AdditiveReference.Clone(),
	}
}

// Equals checks for equality with another SpecimenContainer instance
func (m *SpecimenContainer) Equals(other *SpecimenContainer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Capacity.Equals(other.Capacity) { return false }
	if !m.SpecimenQuantity.Equals(other.SpecimenQuantity) { return false }
	if !m.AdditiveCodeableConcept.Equals(other.AdditiveCodeableConcept) { return false }
	if !m.AdditiveReference.Equals(other.AdditiveReference) { return false }
	return true
}

