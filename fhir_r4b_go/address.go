// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// Address
// An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
type Address struct {
	extends DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Use *AddressUse `json:"use,omitempty"`
	Type *AddressType `json:"type,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	Line []*FhirString `json:"line,omitempty"`
	City *FhirString `json:"city,omitempty"`
	District *FhirString `json:"district,omitempty"`
	State *FhirString `json:"state,omitempty"`
	PostalCode *FhirString `json:"postalcode,omitempty"`
	Country *FhirString `json:"country,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewAddress creates a new Address instance.
func NewAddress() *Address {
	return &Address{}
}

// UnmarshalJSON populates Address from JSON data.
func (m *Address) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Use *AddressUse `json:"use,omitempty"`
		Type *AddressType `json:"type,omitempty"`
		Text *FhirString `json:"text,omitempty"`
		Line []interface{} `json:"line,omitempty"`
		City *FhirString `json:"city,omitempty"`
		District *FhirString `json:"district,omitempty"`
		State *FhirString `json:"state,omitempty"`
		PostalCode *FhirString `json:"postalcode,omitempty"`
		Country *FhirString `json:"country,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.Use = temp.Use
	m.Type = temp.Type
	m.Text = temp.Text
	if len(temp.Line) > 0 {
		m.Line = make([]*FhirString, len(temp.Line))
		for i := range temp.Line {
			itemMap, ok := temp.Line[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Line[%d]: expected map", i) }
			primitive, err := NewFhirStringFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Line[%d]: %v", i, err) }
			m.Line[i] = primitive
		}
	}
	m.City = temp.City
	m.District = temp.District
	m.State = temp.State
	m.PostalCode = temp.PostalCode
	m.Country = temp.Country
	m.Period = temp.Period
	return nil
}

// MarshalJSON converts Address to JSON data.
func (m *Address) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Use *AddressUse `json:"use,omitempty"`
		Type *AddressType `json:"type,omitempty"`
		Text interface{} `json:"text,omitempty"`
		TextElement map[string]interface{} `json:"_text,omitempty"`
		Line []interface{} `json:"line,omitempty"`
		LineElement []map[string]interface{} `json:"_line,omitempty"`
		City interface{} `json:"city,omitempty"`
		CityElement map[string]interface{} `json:"_city,omitempty"`
		District interface{} `json:"district,omitempty"`
		DistrictElement map[string]interface{} `json:"_district,omitempty"`
		State interface{} `json:"state,omitempty"`
		StateElement map[string]interface{} `json:"_state,omitempty"`
		PostalCode interface{} `json:"postalcode,omitempty"`
		PostalCodeElement map[string]interface{} `json:"_postalcode,omitempty"`
		Country interface{} `json:"country,omitempty"`
		CountryElement map[string]interface{} `json:"_country,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.Use = m.Use
	output.Type = m.Type
	if m.Text != nil && m.Text.Value != nil {
		output.Text = m.Text.Value
		if m.Text.Element != nil {
			output.TextElement = toMapOrNil(m.Text.Element.MarshalJSON())
		}
	}
	if len(m.Line) > 0 {
		output.Line = make([]interface{}, len(m.Line))
		output.LineElement = make([]map[string]interface{}, len(m.Line))
		for i, item := range m.Line {
			if item != nil && item.Value != nil {
				output.Line[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.LineElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	if m.City != nil && m.City.Value != nil {
		output.City = m.City.Value
		if m.City.Element != nil {
			output.CityElement = toMapOrNil(m.City.Element.MarshalJSON())
		}
	}
	if m.District != nil && m.District.Value != nil {
		output.District = m.District.Value
		if m.District.Element != nil {
			output.DistrictElement = toMapOrNil(m.District.Element.MarshalJSON())
		}
	}
	if m.State != nil && m.State.Value != nil {
		output.State = m.State.Value
		if m.State.Element != nil {
			output.StateElement = toMapOrNil(m.State.Element.MarshalJSON())
		}
	}
	if m.PostalCode != nil && m.PostalCode.Value != nil {
		output.PostalCode = m.PostalCode.Value
		if m.PostalCode.Element != nil {
			output.PostalCodeElement = toMapOrNil(m.PostalCode.Element.MarshalJSON())
		}
	}
	if m.Country != nil && m.Country.Value != nil {
		output.Country = m.Country.Value
		if m.Country.Element != nil {
			output.CountryElement = toMapOrNil(m.Country.Element.MarshalJSON())
		}
	}
	output.Period = m.Period
	return json.Marshal(output)
}

// Clone creates a deep copy of Address.
func (m *Address) Clone() *Address {
	if m == nil { return nil }
	return &Address{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Use: m.Use.Clone(),
		Type: m.Type.Clone(),
		Text: m.Text.Clone(),
		Line: cloneSlices(m.Line),
		City: m.City.Clone(),
		District: m.District.Clone(),
		State: m.State.Clone(),
		PostalCode: m.PostalCode.Clone(),
		Country: m.Country.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks equality between two Address instances.
func (m *Address) Equals(other *Address) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Line, other.Line) { return false }
	if !m.City.Equals(other.City) { return false }
	if !m.District.Equals(other.District) { return false }
	if !m.State.Equals(other.State) { return false }
	if !m.PostalCode.Equals(other.PostalCode) { return false }
	if !m.Country.Equals(other.Country) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

