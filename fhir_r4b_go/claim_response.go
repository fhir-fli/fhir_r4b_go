// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ClaimResponse
// This resource provides the adjudication details from the processing of a Claim resource.
type ClaimResponse struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *FinancialResourceStatusCodes `json:"status,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	SubType *CodeableConcept `json:"subtype,omitempty"`
	Use *Use `json:"use,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	Created *FhirDateTime `json:"created,omitempty"`
	Insurer *Reference `json:"insurer,omitempty"`
	Requestor *Reference `json:"requestor,omitempty"`
	Request *Reference `json:"request,omitempty"`
	Outcome *RemittanceOutcome `json:"outcome,omitempty"`
	Disposition *FhirString `json:"disposition,omitempty"`
	PreAuthRef *FhirString `json:"preauthref,omitempty"`
	PreAuthPeriod *Period `json:"preauthperiod,omitempty"`
	PayeeType *CodeableConcept `json:"payeetype,omitempty"`
	Item []*ClaimResponseItem `json:"item,omitempty"`
	AddItem []*ClaimResponseAddItem `json:"additem,omitempty"`
	Adjudication []*ClaimResponseAdjudication `json:"adjudication,omitempty"`
	Total []*ClaimResponseTotal `json:"total,omitempty"`
	Payment *ClaimResponsePayment `json:"payment,omitempty"`
	FundsReserve *CodeableConcept `json:"fundsreserve,omitempty"`
	FormCode *CodeableConcept `json:"formcode,omitempty"`
	Form *Attachment `json:"form,omitempty"`
	ProcessNote []*ClaimResponseProcessNote `json:"processnote,omitempty"`
	CommunicationRequest []*Reference `json:"communicationrequest,omitempty"`
	Insurance []*ClaimResponseInsurance `json:"insurance,omitempty"`
	Error []*ClaimResponseError `json:"error,omitempty"`
}

// NewClaimResponse creates a new ClaimResponse instance
func NewClaimResponse() *ClaimResponse {
	return &ClaimResponse{}
}

// FromJSON populates ClaimResponse from JSON data
func (m *ClaimResponse) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponse to JSON data
func (m *ClaimResponse) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponse
func (m *ClaimResponse) Clone() *ClaimResponse {
	if m == nil { return nil }
	return &ClaimResponse{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		SubType: m.SubType.Clone(),
		Use: m.Use.Clone(),
		Patient: m.Patient.Clone(),
		Created: m.Created.Clone(),
		Insurer: m.Insurer.Clone(),
		Requestor: m.Requestor.Clone(),
		Request: m.Request.Clone(),
		Outcome: m.Outcome.Clone(),
		Disposition: m.Disposition.Clone(),
		PreAuthRef: m.PreAuthRef.Clone(),
		PreAuthPeriod: m.PreAuthPeriod.Clone(),
		PayeeType: m.PayeeType.Clone(),
		Item: cloneSlices(m.Item),
		AddItem: cloneSlices(m.AddItem),
		Adjudication: cloneSlices(m.Adjudication),
		Total: cloneSlices(m.Total),
		Payment: m.Payment.Clone(),
		FundsReserve: m.FundsReserve.Clone(),
		FormCode: m.FormCode.Clone(),
		Form: m.Form.Clone(),
		ProcessNote: cloneSlices(m.ProcessNote),
		CommunicationRequest: cloneSlices(m.CommunicationRequest),
		Insurance: cloneSlices(m.Insurance),
		Error: cloneSlices(m.Error),
	}
}

// Equals checks for equality with another ClaimResponse instance
func (m *ClaimResponse) Equals(other *ClaimResponse) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.SubType.Equals(other.SubType) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.Created.Equals(other.Created) { return false }
	if !m.Insurer.Equals(other.Insurer) { return false }
	if !m.Requestor.Equals(other.Requestor) { return false }
	if !m.Request.Equals(other.Request) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	if !m.Disposition.Equals(other.Disposition) { return false }
	if !m.PreAuthRef.Equals(other.PreAuthRef) { return false }
	if !m.PreAuthPeriod.Equals(other.PreAuthPeriod) { return false }
	if !m.PayeeType.Equals(other.PayeeType) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	if !compareSlices(m.AddItem, other.AddItem) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Total, other.Total) { return false }
	if !m.Payment.Equals(other.Payment) { return false }
	if !m.FundsReserve.Equals(other.FundsReserve) { return false }
	if !m.FormCode.Equals(other.FormCode) { return false }
	if !m.Form.Equals(other.Form) { return false }
	if !compareSlices(m.ProcessNote, other.ProcessNote) { return false }
	if !compareSlices(m.CommunicationRequest, other.CommunicationRequest) { return false }
	if !compareSlices(m.Insurance, other.Insurance) { return false }
	if !compareSlices(m.Error, other.Error) { return false }
	return true
}

// ClaimResponseItem
// A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
type ClaimResponseItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemSequence *FhirPositiveInt `json:"itemsequence,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ClaimResponseAdjudication `json:"adjudication,omitempty"`
	Detail []*ClaimResponseDetail `json:"detail,omitempty"`
}

// NewClaimResponseItem creates a new ClaimResponseItem instance
func NewClaimResponseItem() *ClaimResponseItem {
	return &ClaimResponseItem{}
}

// FromJSON populates ClaimResponseItem from JSON data
func (m *ClaimResponseItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseItem to JSON data
func (m *ClaimResponseItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseItem
func (m *ClaimResponseItem) Clone() *ClaimResponseItem {
	if m == nil { return nil }
	return &ClaimResponseItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemSequence: m.ItemSequence.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks for equality with another ClaimResponseItem instance
func (m *ClaimResponseItem) Equals(other *ClaimResponseItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ItemSequence.Equals(other.ItemSequence) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// ClaimResponseAdjudication
// If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
type ClaimResponseAdjudication struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Reason *CodeableConcept `json:"reason,omitempty"`
	Amount *Money `json:"amount,omitempty"`
	Value *FhirDecimal `json:"value,omitempty"`
}

// NewClaimResponseAdjudication creates a new ClaimResponseAdjudication instance
func NewClaimResponseAdjudication() *ClaimResponseAdjudication {
	return &ClaimResponseAdjudication{}
}

// FromJSON populates ClaimResponseAdjudication from JSON data
func (m *ClaimResponseAdjudication) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseAdjudication to JSON data
func (m *ClaimResponseAdjudication) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseAdjudication
func (m *ClaimResponseAdjudication) Clone() *ClaimResponseAdjudication {
	if m == nil { return nil }
	return &ClaimResponseAdjudication{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Reason: m.Reason.Clone(),
		Amount: m.Amount.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another ClaimResponseAdjudication instance
func (m *ClaimResponseAdjudication) Equals(other *ClaimResponseAdjudication) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// ClaimResponseDetail
// A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
type ClaimResponseDetail struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DetailSequence *FhirPositiveInt `json:"detailsequence,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ClaimResponseAdjudication `json:"adjudication,omitempty"`
	SubDetail []*ClaimResponseSubDetail `json:"subdetail,omitempty"`
}

// NewClaimResponseDetail creates a new ClaimResponseDetail instance
func NewClaimResponseDetail() *ClaimResponseDetail {
	return &ClaimResponseDetail{}
}

// FromJSON populates ClaimResponseDetail from JSON data
func (m *ClaimResponseDetail) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseDetail to JSON data
func (m *ClaimResponseDetail) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseDetail
func (m *ClaimResponseDetail) Clone() *ClaimResponseDetail {
	if m == nil { return nil }
	return &ClaimResponseDetail{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DetailSequence: m.DetailSequence.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		SubDetail: cloneSlices(m.SubDetail),
	}
}

// Equals checks for equality with another ClaimResponseDetail instance
func (m *ClaimResponseDetail) Equals(other *ClaimResponseDetail) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.DetailSequence.Equals(other.DetailSequence) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.SubDetail, other.SubDetail) { return false }
	return true
}

// ClaimResponseSubDetail
// A sub-detail adjudication of a simple product or service.
type ClaimResponseSubDetail struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	SubDetailSequence *FhirPositiveInt `json:"subdetailsequence,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ClaimResponseAdjudication `json:"adjudication,omitempty"`
}

// NewClaimResponseSubDetail creates a new ClaimResponseSubDetail instance
func NewClaimResponseSubDetail() *ClaimResponseSubDetail {
	return &ClaimResponseSubDetail{}
}

// FromJSON populates ClaimResponseSubDetail from JSON data
func (m *ClaimResponseSubDetail) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseSubDetail to JSON data
func (m *ClaimResponseSubDetail) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseSubDetail
func (m *ClaimResponseSubDetail) Clone() *ClaimResponseSubDetail {
	if m == nil { return nil }
	return &ClaimResponseSubDetail{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		SubDetailSequence: m.SubDetailSequence.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
	}
}

// Equals checks for equality with another ClaimResponseSubDetail instance
func (m *ClaimResponseSubDetail) Equals(other *ClaimResponseSubDetail) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.SubDetailSequence.Equals(other.SubDetailSequence) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	return true
}

// ClaimResponseAddItem
// The first-tier service adjudications for payor added product or service lines.
type ClaimResponseAddItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemSequence []*FhirPositiveInt `json:"itemsequence,omitempty"`
	DetailSequence []*FhirPositiveInt `json:"detailsequence,omitempty"`
	SubdetailSequence []*FhirPositiveInt `json:"subdetailsequence,omitempty"`
	Provider []*Reference `json:"provider,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	ServicedDate *FhirDate `json:"serviceddate,omitempty"`
	ServicedPeriod *Period `json:"servicedperiod,omitempty"`
	LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
	LocationAddress *Address `json:"locationaddress,omitempty"`
	LocationReference *Reference `json:"locationreference,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	BodySite *CodeableConcept `json:"bodysite,omitempty"`
	SubSite []*CodeableConcept `json:"subsite,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ClaimResponseAdjudication `json:"adjudication,omitempty"`
	Detail []*ClaimResponseDetail `json:"detail,omitempty"`
}

// NewClaimResponseAddItem creates a new ClaimResponseAddItem instance
func NewClaimResponseAddItem() *ClaimResponseAddItem {
	return &ClaimResponseAddItem{}
}

// FromJSON populates ClaimResponseAddItem from JSON data
func (m *ClaimResponseAddItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseAddItem to JSON data
func (m *ClaimResponseAddItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseAddItem
func (m *ClaimResponseAddItem) Clone() *ClaimResponseAddItem {
	if m == nil { return nil }
	return &ClaimResponseAddItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemSequence: cloneSlices(m.ItemSequence),
		DetailSequence: cloneSlices(m.DetailSequence),
		SubdetailSequence: cloneSlices(m.SubdetailSequence),
		Provider: cloneSlices(m.Provider),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		ServicedDate: m.ServicedDate.Clone(),
		ServicedPeriod: m.ServicedPeriod.Clone(),
		LocationCodeableConcept: m.LocationCodeableConcept.Clone(),
		LocationAddress: m.LocationAddress.Clone(),
		LocationReference: m.LocationReference.Clone(),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		BodySite: m.BodySite.Clone(),
		SubSite: cloneSlices(m.SubSite),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks for equality with another ClaimResponseAddItem instance
func (m *ClaimResponseAddItem) Equals(other *ClaimResponseAddItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.ItemSequence, other.ItemSequence) { return false }
	if !compareSlices(m.DetailSequence, other.DetailSequence) { return false }
	if !compareSlices(m.SubdetailSequence, other.SubdetailSequence) { return false }
	if !compareSlices(m.Provider, other.Provider) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.ServicedDate.Equals(other.ServicedDate) { return false }
	if !m.ServicedPeriod.Equals(other.ServicedPeriod) { return false }
	if !m.LocationCodeableConcept.Equals(other.LocationCodeableConcept) { return false }
	if !m.LocationAddress.Equals(other.LocationAddress) { return false }
	if !m.LocationReference.Equals(other.LocationReference) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !compareSlices(m.SubSite, other.SubSite) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// ClaimResponseDetail1
// The second-tier service adjudications for payor added services.
type ClaimResponseDetail1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ClaimResponseAdjudication `json:"adjudication,omitempty"`
	SubDetail []*ClaimResponseSubDetail `json:"subdetail,omitempty"`
}

// NewClaimResponseDetail1 creates a new ClaimResponseDetail1 instance
func NewClaimResponseDetail1() *ClaimResponseDetail1 {
	return &ClaimResponseDetail1{}
}

// FromJSON populates ClaimResponseDetail1 from JSON data
func (m *ClaimResponseDetail1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseDetail1 to JSON data
func (m *ClaimResponseDetail1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseDetail1
func (m *ClaimResponseDetail1) Clone() *ClaimResponseDetail1 {
	if m == nil { return nil }
	return &ClaimResponseDetail1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		SubDetail: cloneSlices(m.SubDetail),
	}
}

// Equals checks for equality with another ClaimResponseDetail1 instance
func (m *ClaimResponseDetail1) Equals(other *ClaimResponseDetail1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.SubDetail, other.SubDetail) { return false }
	return true
}

// ClaimResponseSubDetail1
// The third-tier service adjudications for payor added services.
type ClaimResponseSubDetail1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ClaimResponseAdjudication `json:"adjudication,omitempty"`
}

// NewClaimResponseSubDetail1 creates a new ClaimResponseSubDetail1 instance
func NewClaimResponseSubDetail1() *ClaimResponseSubDetail1 {
	return &ClaimResponseSubDetail1{}
}

// FromJSON populates ClaimResponseSubDetail1 from JSON data
func (m *ClaimResponseSubDetail1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseSubDetail1 to JSON data
func (m *ClaimResponseSubDetail1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseSubDetail1
func (m *ClaimResponseSubDetail1) Clone() *ClaimResponseSubDetail1 {
	if m == nil { return nil }
	return &ClaimResponseSubDetail1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
	}
}

// Equals checks for equality with another ClaimResponseSubDetail1 instance
func (m *ClaimResponseSubDetail1) Equals(other *ClaimResponseSubDetail1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	return true
}

// ClaimResponseTotal
// Categorized monetary totals for the adjudication.
type ClaimResponseTotal struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Amount *Money `json:"amount,omitempty"`
}

// NewClaimResponseTotal creates a new ClaimResponseTotal instance
func NewClaimResponseTotal() *ClaimResponseTotal {
	return &ClaimResponseTotal{}
}

// FromJSON populates ClaimResponseTotal from JSON data
func (m *ClaimResponseTotal) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseTotal to JSON data
func (m *ClaimResponseTotal) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseTotal
func (m *ClaimResponseTotal) Clone() *ClaimResponseTotal {
	if m == nil { return nil }
	return &ClaimResponseTotal{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks for equality with another ClaimResponseTotal instance
func (m *ClaimResponseTotal) Equals(other *ClaimResponseTotal) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

// ClaimResponsePayment
// Payment details for the adjudication of the claim.
type ClaimResponsePayment struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Adjustment *Money `json:"adjustment,omitempty"`
	AdjustmentReason *CodeableConcept `json:"adjustmentreason,omitempty"`
	Date *FhirDate `json:"date,omitempty"`
	Amount *Money `json:"amount,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
}

// NewClaimResponsePayment creates a new ClaimResponsePayment instance
func NewClaimResponsePayment() *ClaimResponsePayment {
	return &ClaimResponsePayment{}
}

// FromJSON populates ClaimResponsePayment from JSON data
func (m *ClaimResponsePayment) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponsePayment to JSON data
func (m *ClaimResponsePayment) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponsePayment
func (m *ClaimResponsePayment) Clone() *ClaimResponsePayment {
	if m == nil { return nil }
	return &ClaimResponsePayment{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Adjustment: m.Adjustment.Clone(),
		AdjustmentReason: m.AdjustmentReason.Clone(),
		Date: m.Date.Clone(),
		Amount: m.Amount.Clone(),
		Identifier: m.Identifier.Clone(),
	}
}

// Equals checks for equality with another ClaimResponsePayment instance
func (m *ClaimResponsePayment) Equals(other *ClaimResponsePayment) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Adjustment.Equals(other.Adjustment) { return false }
	if !m.AdjustmentReason.Equals(other.AdjustmentReason) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	return true
}

// ClaimResponseProcessNote
// A note that describes or explains adjudication results in a human readable form.
type ClaimResponseProcessNote struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Number *FhirPositiveInt `json:"number,omitempty"`
	Type *NoteType `json:"type,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	Language *CodeableConcept `json:"language,omitempty"`
}

// NewClaimResponseProcessNote creates a new ClaimResponseProcessNote instance
func NewClaimResponseProcessNote() *ClaimResponseProcessNote {
	return &ClaimResponseProcessNote{}
}

// FromJSON populates ClaimResponseProcessNote from JSON data
func (m *ClaimResponseProcessNote) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseProcessNote to JSON data
func (m *ClaimResponseProcessNote) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseProcessNote
func (m *ClaimResponseProcessNote) Clone() *ClaimResponseProcessNote {
	if m == nil { return nil }
	return &ClaimResponseProcessNote{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Number: m.Number.Clone(),
		Type: m.Type.Clone(),
		Text: m.Text.Clone(),
		Language: m.Language.Clone(),
	}
}

// Equals checks for equality with another ClaimResponseProcessNote instance
func (m *ClaimResponseProcessNote) Equals(other *ClaimResponseProcessNote) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Number.Equals(other.Number) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !m.Language.Equals(other.Language) { return false }
	return true
}

// ClaimResponseInsurance
// Financial instruments for reimbursement for the health care products and services specified on the claim.
type ClaimResponseInsurance struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Focal *FhirBoolean `json:"focal,omitempty"`
	Coverage *Reference `json:"coverage,omitempty"`
	BusinessArrangement *FhirString `json:"businessarrangement,omitempty"`
	ClaimResponse *Reference `json:"claimresponse,omitempty"`
}

// NewClaimResponseInsurance creates a new ClaimResponseInsurance instance
func NewClaimResponseInsurance() *ClaimResponseInsurance {
	return &ClaimResponseInsurance{}
}

// FromJSON populates ClaimResponseInsurance from JSON data
func (m *ClaimResponseInsurance) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseInsurance to JSON data
func (m *ClaimResponseInsurance) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseInsurance
func (m *ClaimResponseInsurance) Clone() *ClaimResponseInsurance {
	if m == nil { return nil }
	return &ClaimResponseInsurance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Focal: m.Focal.Clone(),
		Coverage: m.Coverage.Clone(),
		BusinessArrangement: m.BusinessArrangement.Clone(),
		ClaimResponse: m.ClaimResponse.Clone(),
	}
}

// Equals checks for equality with another ClaimResponseInsurance instance
func (m *ClaimResponseInsurance) Equals(other *ClaimResponseInsurance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Focal.Equals(other.Focal) { return false }
	if !m.Coverage.Equals(other.Coverage) { return false }
	if !m.BusinessArrangement.Equals(other.BusinessArrangement) { return false }
	if !m.ClaimResponse.Equals(other.ClaimResponse) { return false }
	return true
}

// ClaimResponseError
// Errors encountered during the processing of the adjudication.
type ClaimResponseError struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemSequence *FhirPositiveInt `json:"itemsequence,omitempty"`
	DetailSequence *FhirPositiveInt `json:"detailsequence,omitempty"`
	SubDetailSequence *FhirPositiveInt `json:"subdetailsequence,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
}

// NewClaimResponseError creates a new ClaimResponseError instance
func NewClaimResponseError() *ClaimResponseError {
	return &ClaimResponseError{}
}

// FromJSON populates ClaimResponseError from JSON data
func (m *ClaimResponseError) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClaimResponseError to JSON data
func (m *ClaimResponseError) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClaimResponseError
func (m *ClaimResponseError) Clone() *ClaimResponseError {
	if m == nil { return nil }
	return &ClaimResponseError{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemSequence: m.ItemSequence.Clone(),
		DetailSequence: m.DetailSequence.Clone(),
		SubDetailSequence: m.SubDetailSequence.Clone(),
		Code: m.Code.Clone(),
	}
}

// Equals checks for equality with another ClaimResponseError instance
func (m *ClaimResponseError) Equals(other *ClaimResponseError) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ItemSequence.Equals(other.ItemSequence) { return false }
	if !m.DetailSequence.Equals(other.DetailSequence) { return false }
	if !m.SubDetailSequence.Equals(other.SubDetailSequence) { return false }
	if !m.Code.Equals(other.Code) { return false }
	return true
}

