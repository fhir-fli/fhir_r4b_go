// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// TerminologyCapabilities
// A TerminologyCapabilities resource documents a set of capabilities (behaviors) of a FHIR Terminology Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
type TerminologyCapabilities struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	Kind *CapabilityStatementKind `json:"kind,omitempty"`
	Software *TerminologyCapabilitiesSoftware `json:"software,omitempty"`
	Implementation *TerminologyCapabilitiesImplementation `json:"implementation,omitempty"`
	LockedDate *FhirBoolean `json:"lockeddate,omitempty"`
	CodeSystem []*TerminologyCapabilitiesCodeSystem `json:"codesystem,omitempty"`
	Expansion *TerminologyCapabilitiesExpansion `json:"expansion,omitempty"`
	CodeSearch *CodeSearchSupport `json:"codesearch,omitempty"`
	ValidateCode *TerminologyCapabilitiesValidateCode `json:"validatecode,omitempty"`
	Translation *TerminologyCapabilitiesTranslation `json:"translation,omitempty"`
	Closure *TerminologyCapabilitiesClosure `json:"closure,omitempty"`
}

// NewTerminologyCapabilities creates a new TerminologyCapabilities instance
func NewTerminologyCapabilities() *TerminologyCapabilities {
	return &TerminologyCapabilities{}
}

// FromJSON populates TerminologyCapabilities from JSON data
func (m *TerminologyCapabilities) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilities to JSON data
func (m *TerminologyCapabilities) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilities
func (m *TerminologyCapabilities) Clone() *TerminologyCapabilities {
	if m == nil { return nil }
	return &TerminologyCapabilities{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		Kind: m.Kind.Clone(),
		Software: m.Software.Clone(),
		Implementation: m.Implementation.Clone(),
		LockedDate: m.LockedDate.Clone(),
		CodeSystem: cloneSlices(m.CodeSystem),
		Expansion: m.Expansion.Clone(),
		CodeSearch: m.CodeSearch.Clone(),
		ValidateCode: m.ValidateCode.Clone(),
		Translation: m.Translation.Clone(),
		Closure: m.Closure.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilities instance
func (m *TerminologyCapabilities) Equals(other *TerminologyCapabilities) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.Kind.Equals(other.Kind) { return false }
	if !m.Software.Equals(other.Software) { return false }
	if !m.Implementation.Equals(other.Implementation) { return false }
	if !m.LockedDate.Equals(other.LockedDate) { return false }
	if !compareSlices(m.CodeSystem, other.CodeSystem) { return false }
	if !m.Expansion.Equals(other.Expansion) { return false }
	if !m.CodeSearch.Equals(other.CodeSearch) { return false }
	if !m.ValidateCode.Equals(other.ValidateCode) { return false }
	if !m.Translation.Equals(other.Translation) { return false }
	if !m.Closure.Equals(other.Closure) { return false }
	return true
}

// TerminologyCapabilitiesSoftware
// Software that is covered by this terminology capability statement.  It is used when the statement describes the capabilities of a particular software version, independent of an installation.
type TerminologyCapabilitiesSoftware struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Version *FhirString `json:"version,omitempty"`
}

// NewTerminologyCapabilitiesSoftware creates a new TerminologyCapabilitiesSoftware instance
func NewTerminologyCapabilitiesSoftware() *TerminologyCapabilitiesSoftware {
	return &TerminologyCapabilitiesSoftware{}
}

// FromJSON populates TerminologyCapabilitiesSoftware from JSON data
func (m *TerminologyCapabilitiesSoftware) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesSoftware to JSON data
func (m *TerminologyCapabilitiesSoftware) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesSoftware
func (m *TerminologyCapabilitiesSoftware) Clone() *TerminologyCapabilitiesSoftware {
	if m == nil { return nil }
	return &TerminologyCapabilitiesSoftware{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Version: m.Version.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesSoftware instance
func (m *TerminologyCapabilitiesSoftware) Equals(other *TerminologyCapabilitiesSoftware) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Version.Equals(other.Version) { return false }
	return true
}

// TerminologyCapabilitiesImplementation
// Identifies a specific implementation instance that is described by the terminology capability statement - i.e. a particular installation, rather than the capabilities of a software program.
type TerminologyCapabilitiesImplementation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Url *FhirUrl `json:"url,omitempty"`
}

// NewTerminologyCapabilitiesImplementation creates a new TerminologyCapabilitiesImplementation instance
func NewTerminologyCapabilitiesImplementation() *TerminologyCapabilitiesImplementation {
	return &TerminologyCapabilitiesImplementation{}
}

// FromJSON populates TerminologyCapabilitiesImplementation from JSON data
func (m *TerminologyCapabilitiesImplementation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesImplementation to JSON data
func (m *TerminologyCapabilitiesImplementation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesImplementation
func (m *TerminologyCapabilitiesImplementation) Clone() *TerminologyCapabilitiesImplementation {
	if m == nil { return nil }
	return &TerminologyCapabilitiesImplementation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Url: m.Url.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesImplementation instance
func (m *TerminologyCapabilitiesImplementation) Equals(other *TerminologyCapabilitiesImplementation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Url.Equals(other.Url) { return false }
	return true
}

// TerminologyCapabilitiesCodeSystem
// Identifies a code system that is supported by the server. If there is a no code system URL, then this declares the general assumptions a client can make about support for any CodeSystem resource.
type TerminologyCapabilitiesCodeSystem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Uri *FhirCanonical `json:"uri,omitempty"`
	Version []*TerminologyCapabilitiesVersion `json:"version,omitempty"`
	Subsumption *FhirBoolean `json:"subsumption,omitempty"`
}

// NewTerminologyCapabilitiesCodeSystem creates a new TerminologyCapabilitiesCodeSystem instance
func NewTerminologyCapabilitiesCodeSystem() *TerminologyCapabilitiesCodeSystem {
	return &TerminologyCapabilitiesCodeSystem{}
}

// FromJSON populates TerminologyCapabilitiesCodeSystem from JSON data
func (m *TerminologyCapabilitiesCodeSystem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesCodeSystem to JSON data
func (m *TerminologyCapabilitiesCodeSystem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesCodeSystem
func (m *TerminologyCapabilitiesCodeSystem) Clone() *TerminologyCapabilitiesCodeSystem {
	if m == nil { return nil }
	return &TerminologyCapabilitiesCodeSystem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Uri: m.Uri.Clone(),
		Version: cloneSlices(m.Version),
		Subsumption: m.Subsumption.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesCodeSystem instance
func (m *TerminologyCapabilitiesCodeSystem) Equals(other *TerminologyCapabilitiesCodeSystem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Uri.Equals(other.Uri) { return false }
	if !compareSlices(m.Version, other.Version) { return false }
	if !m.Subsumption.Equals(other.Subsumption) { return false }
	return true
}

// TerminologyCapabilitiesVersion
// For the code system, a list of versions that are supported by the server.
type TerminologyCapabilitiesVersion struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirString `json:"code,omitempty"`
	IsDefault *FhirBoolean `json:"isdefault,omitempty"`
	Compositional *FhirBoolean `json:"compositional,omitempty"`
	Language []*FhirCode `json:"language,omitempty"`
	Filter []*TerminologyCapabilitiesFilter `json:"filter,omitempty"`
	Property []*FhirCode `json:"property,omitempty"`
}

// NewTerminologyCapabilitiesVersion creates a new TerminologyCapabilitiesVersion instance
func NewTerminologyCapabilitiesVersion() *TerminologyCapabilitiesVersion {
	return &TerminologyCapabilitiesVersion{}
}

// FromJSON populates TerminologyCapabilitiesVersion from JSON data
func (m *TerminologyCapabilitiesVersion) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesVersion to JSON data
func (m *TerminologyCapabilitiesVersion) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesVersion
func (m *TerminologyCapabilitiesVersion) Clone() *TerminologyCapabilitiesVersion {
	if m == nil { return nil }
	return &TerminologyCapabilitiesVersion{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		IsDefault: m.IsDefault.Clone(),
		Compositional: m.Compositional.Clone(),
		Language: cloneSlices(m.Language),
		Filter: cloneSlices(m.Filter),
		Property: cloneSlices(m.Property),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesVersion instance
func (m *TerminologyCapabilitiesVersion) Equals(other *TerminologyCapabilitiesVersion) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.IsDefault.Equals(other.IsDefault) { return false }
	if !m.Compositional.Equals(other.Compositional) { return false }
	if !compareSlices(m.Language, other.Language) { return false }
	if !compareSlices(m.Filter, other.Filter) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	return true
}

// TerminologyCapabilitiesFilter
// Filter Properties supported.
type TerminologyCapabilitiesFilter struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Op []*FhirCode `json:"op,omitempty"`
}

// NewTerminologyCapabilitiesFilter creates a new TerminologyCapabilitiesFilter instance
func NewTerminologyCapabilitiesFilter() *TerminologyCapabilitiesFilter {
	return &TerminologyCapabilitiesFilter{}
}

// FromJSON populates TerminologyCapabilitiesFilter from JSON data
func (m *TerminologyCapabilitiesFilter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesFilter to JSON data
func (m *TerminologyCapabilitiesFilter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesFilter
func (m *TerminologyCapabilitiesFilter) Clone() *TerminologyCapabilitiesFilter {
	if m == nil { return nil }
	return &TerminologyCapabilitiesFilter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Op: cloneSlices(m.Op),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesFilter instance
func (m *TerminologyCapabilitiesFilter) Equals(other *TerminologyCapabilitiesFilter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.Op, other.Op) { return false }
	return true
}

// TerminologyCapabilitiesExpansion
// Information about the [ValueSet/$expand](valueset-operation-expand.html) operation.
type TerminologyCapabilitiesExpansion struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Hierarchical *FhirBoolean `json:"hierarchical,omitempty"`
	Paging *FhirBoolean `json:"paging,omitempty"`
	Incomplete *FhirBoolean `json:"incomplete,omitempty"`
	Parameter []*TerminologyCapabilitiesParameter `json:"parameter,omitempty"`
	TextFilter *FhirMarkdown `json:"textfilter,omitempty"`
}

// NewTerminologyCapabilitiesExpansion creates a new TerminologyCapabilitiesExpansion instance
func NewTerminologyCapabilitiesExpansion() *TerminologyCapabilitiesExpansion {
	return &TerminologyCapabilitiesExpansion{}
}

// FromJSON populates TerminologyCapabilitiesExpansion from JSON data
func (m *TerminologyCapabilitiesExpansion) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesExpansion to JSON data
func (m *TerminologyCapabilitiesExpansion) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesExpansion
func (m *TerminologyCapabilitiesExpansion) Clone() *TerminologyCapabilitiesExpansion {
	if m == nil { return nil }
	return &TerminologyCapabilitiesExpansion{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Hierarchical: m.Hierarchical.Clone(),
		Paging: m.Paging.Clone(),
		Incomplete: m.Incomplete.Clone(),
		Parameter: cloneSlices(m.Parameter),
		TextFilter: m.TextFilter.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesExpansion instance
func (m *TerminologyCapabilitiesExpansion) Equals(other *TerminologyCapabilitiesExpansion) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Hierarchical.Equals(other.Hierarchical) { return false }
	if !m.Paging.Equals(other.Paging) { return false }
	if !m.Incomplete.Equals(other.Incomplete) { return false }
	if !compareSlices(m.Parameter, other.Parameter) { return false }
	if !m.TextFilter.Equals(other.TextFilter) { return false }
	return true
}

// TerminologyCapabilitiesParameter
// Supported expansion parameter.
type TerminologyCapabilitiesParameter struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirCode `json:"name,omitempty"`
	Documentation *FhirString `json:"documentation,omitempty"`
}

// NewTerminologyCapabilitiesParameter creates a new TerminologyCapabilitiesParameter instance
func NewTerminologyCapabilitiesParameter() *TerminologyCapabilitiesParameter {
	return &TerminologyCapabilitiesParameter{}
}

// FromJSON populates TerminologyCapabilitiesParameter from JSON data
func (m *TerminologyCapabilitiesParameter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesParameter to JSON data
func (m *TerminologyCapabilitiesParameter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesParameter
func (m *TerminologyCapabilitiesParameter) Clone() *TerminologyCapabilitiesParameter {
	if m == nil { return nil }
	return &TerminologyCapabilitiesParameter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesParameter instance
func (m *TerminologyCapabilitiesParameter) Equals(other *TerminologyCapabilitiesParameter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// TerminologyCapabilitiesValidateCode
// Information about the [ValueSet/$validate-code](valueset-operation-validate-code.html) operation.
type TerminologyCapabilitiesValidateCode struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Translations *FhirBoolean `json:"translations,omitempty"`
}

// NewTerminologyCapabilitiesValidateCode creates a new TerminologyCapabilitiesValidateCode instance
func NewTerminologyCapabilitiesValidateCode() *TerminologyCapabilitiesValidateCode {
	return &TerminologyCapabilitiesValidateCode{}
}

// FromJSON populates TerminologyCapabilitiesValidateCode from JSON data
func (m *TerminologyCapabilitiesValidateCode) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesValidateCode to JSON data
func (m *TerminologyCapabilitiesValidateCode) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesValidateCode
func (m *TerminologyCapabilitiesValidateCode) Clone() *TerminologyCapabilitiesValidateCode {
	if m == nil { return nil }
	return &TerminologyCapabilitiesValidateCode{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Translations: m.Translations.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesValidateCode instance
func (m *TerminologyCapabilitiesValidateCode) Equals(other *TerminologyCapabilitiesValidateCode) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Translations.Equals(other.Translations) { return false }
	return true
}

// TerminologyCapabilitiesTranslation
// Information about the [ConceptMap/$translate](conceptmap-operation-translate.html) operation.
type TerminologyCapabilitiesTranslation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	NeedsMap *FhirBoolean `json:"needsmap,omitempty"`
}

// NewTerminologyCapabilitiesTranslation creates a new TerminologyCapabilitiesTranslation instance
func NewTerminologyCapabilitiesTranslation() *TerminologyCapabilitiesTranslation {
	return &TerminologyCapabilitiesTranslation{}
}

// FromJSON populates TerminologyCapabilitiesTranslation from JSON data
func (m *TerminologyCapabilitiesTranslation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesTranslation to JSON data
func (m *TerminologyCapabilitiesTranslation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesTranslation
func (m *TerminologyCapabilitiesTranslation) Clone() *TerminologyCapabilitiesTranslation {
	if m == nil { return nil }
	return &TerminologyCapabilitiesTranslation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		NeedsMap: m.NeedsMap.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesTranslation instance
func (m *TerminologyCapabilitiesTranslation) Equals(other *TerminologyCapabilitiesTranslation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.NeedsMap.Equals(other.NeedsMap) { return false }
	return true
}

// TerminologyCapabilitiesClosure
// Whether the $closure operation is supported.
type TerminologyCapabilitiesClosure struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Translation *FhirBoolean `json:"translation,omitempty"`
}

// NewTerminologyCapabilitiesClosure creates a new TerminologyCapabilitiesClosure instance
func NewTerminologyCapabilitiesClosure() *TerminologyCapabilitiesClosure {
	return &TerminologyCapabilitiesClosure{}
}

// FromJSON populates TerminologyCapabilitiesClosure from JSON data
func (m *TerminologyCapabilitiesClosure) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TerminologyCapabilitiesClosure to JSON data
func (m *TerminologyCapabilitiesClosure) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TerminologyCapabilitiesClosure
func (m *TerminologyCapabilitiesClosure) Clone() *TerminologyCapabilitiesClosure {
	if m == nil { return nil }
	return &TerminologyCapabilitiesClosure{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Translation: m.Translation.Clone(),
	}
}

// Equals checks for equality with another TerminologyCapabilitiesClosure instance
func (m *TerminologyCapabilitiesClosure) Equals(other *TerminologyCapabilitiesClosure) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Translation.Equals(other.Translation) { return false }
	return true
}

