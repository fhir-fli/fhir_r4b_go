// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// FhirExtension
// Optional Extension Element - found in all resources.
type FhirExtension struct {
	extends DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Url *FhirString `json:"url,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueCanonical *FhirCanonical `json:"valuecanonical,omitempty"`
	ValueCode *FhirCode `json:"valuecode,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueId *FhirId `json:"valueid,omitempty"`
	ValueInstant *FhirInstant `json:"valueinstant,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueMarkdown *FhirMarkdown `json:"valuemarkdown,omitempty"`
	ValueOid *FhirOid `json:"valueoid,omitempty"`
	ValuePositiveInt *FhirPositiveInt `json:"valuepositiveint,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueUnsignedInt *FhirUnsignedInt `json:"valueunsignedint,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueUrl *FhirUrl `json:"valueurl,omitempty"`
	ValueUuid *FhirUuid `json:"valueuuid,omitempty"`
	ValueAddress *Address `json:"valueaddress,omitempty"`
	ValueAge *Age `json:"valueage,omitempty"`
	ValueAnnotation *Annotation `json:"valueannotation,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueCodeableReference *CodeableReference `json:"valuecodeablereference,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueContactPoint *ContactPoint `json:"valuecontactpoint,omitempty"`
	ValueCount *Count `json:"valuecount,omitempty"`
	ValueDistance *Distance `json:"valuedistance,omitempty"`
	ValueDuration *FhirDuration `json:"valueduration,omitempty"`
	ValueHumanName *HumanName `json:"valuehumanname,omitempty"`
	ValueIdentifier *Identifier `json:"valueidentifier,omitempty"`
	ValueMoney *Money `json:"valuemoney,omitempty"`
	ValuePeriod *Period `json:"valueperiod,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueRange *Range `json:"valuerange,omitempty"`
	ValueRatio *Ratio `json:"valueratio,omitempty"`
	ValueRatioRange *RatioRange `json:"valueratiorange,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
	ValueSignature *Signature `json:"valuesignature,omitempty"`
	ValueTiming *Timing `json:"valuetiming,omitempty"`
	ValueContactDetail *ContactDetail `json:"valuecontactdetail,omitempty"`
	ValueContributor *Contributor `json:"valuecontributor,omitempty"`
	ValueDataRequirement *DataRequirement `json:"valuedatarequirement,omitempty"`
	ValueExpression *FhirExpression `json:"valueexpression,omitempty"`
	ValueParameterDefinition *ParameterDefinition `json:"valueparameterdefinition,omitempty"`
	ValueRelatedArtifact *RelatedArtifact `json:"valuerelatedartifact,omitempty"`
	ValueTriggerDefinition *TriggerDefinition `json:"valuetriggerdefinition,omitempty"`
	ValueUsageContext *UsageContext `json:"valueusagecontext,omitempty"`
	ValueDosage *Dosage `json:"valuedosage,omitempty"`
}

// NewFhirExtension creates a new FhirExtension instance.
func NewFhirExtension() *FhirExtension {
	return &FhirExtension{}
}

// FromJSON populates FhirExtension from JSON data.
func (m *FhirExtension) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Url *FhirString `json:"url,omitempty"`
		ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
		ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
		ValueCanonical *FhirCanonical `json:"valuecanonical,omitempty"`
		ValueCode *FhirCode `json:"valuecode,omitempty"`
		ValueDate *FhirDate `json:"valuedate,omitempty"`
		ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
		ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
		ValueId *FhirId `json:"valueid,omitempty"`
		ValueInstant *FhirInstant `json:"valueinstant,omitempty"`
		ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
		ValueMarkdown *FhirMarkdown `json:"valuemarkdown,omitempty"`
		ValueOid *FhirOid `json:"valueoid,omitempty"`
		ValuePositiveInt *FhirPositiveInt `json:"valuepositiveint,omitempty"`
		ValueString *FhirString `json:"valuestring,omitempty"`
		ValueTime *FhirTime `json:"valuetime,omitempty"`
		ValueUnsignedInt *FhirUnsignedInt `json:"valueunsignedint,omitempty"`
		ValueUri *FhirUri `json:"valueuri,omitempty"`
		ValueUrl *FhirUrl `json:"valueurl,omitempty"`
		ValueUuid *FhirUuid `json:"valueuuid,omitempty"`
		ValueAddress *Address `json:"valueaddress,omitempty"`
		ValueAge *Age `json:"valueage,omitempty"`
		ValueAnnotation *Annotation `json:"valueannotation,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueCodeableReference *CodeableReference `json:"valuecodeablereference,omitempty"`
		ValueCoding *Coding `json:"valuecoding,omitempty"`
		ValueContactPoint *ContactPoint `json:"valuecontactpoint,omitempty"`
		ValueCount *Count `json:"valuecount,omitempty"`
		ValueDistance *Distance `json:"valuedistance,omitempty"`
		ValueDuration *FhirDuration `json:"valueduration,omitempty"`
		ValueHumanName *HumanName `json:"valuehumanname,omitempty"`
		ValueIdentifier *Identifier `json:"valueidentifier,omitempty"`
		ValueMoney *Money `json:"valuemoney,omitempty"`
		ValuePeriod *Period `json:"valueperiod,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueRange *Range `json:"valuerange,omitempty"`
		ValueRatio *Ratio `json:"valueratio,omitempty"`
		ValueRatioRange *RatioRange `json:"valueratiorange,omitempty"`
		ValueReference *Reference `json:"valuereference,omitempty"`
		ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
		ValueSignature *Signature `json:"valuesignature,omitempty"`
		ValueTiming *Timing `json:"valuetiming,omitempty"`
		ValueContactDetail *ContactDetail `json:"valuecontactdetail,omitempty"`
		ValueContributor *Contributor `json:"valuecontributor,omitempty"`
		ValueDataRequirement *DataRequirement `json:"valuedatarequirement,omitempty"`
		ValueExpression *FhirExpression `json:"valueexpression,omitempty"`
		ValueParameterDefinition *ParameterDefinition `json:"valueparameterdefinition,omitempty"`
		ValueRelatedArtifact *RelatedArtifact `json:"valuerelatedartifact,omitempty"`
		ValueTriggerDefinition *TriggerDefinition `json:"valuetriggerdefinition,omitempty"`
		ValueUsageContext *UsageContext `json:"valueusagecontext,omitempty"`
		ValueDosage *Dosage `json:"valuedosage,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.Url = temp.Url
	m.ValueBase64Binary = temp.ValueBase64Binary
	m.ValueBoolean = temp.ValueBoolean
	m.ValueCanonical = temp.ValueCanonical
	m.ValueCode = temp.ValueCode
	m.ValueDate = temp.ValueDate
	m.ValueDateTime = temp.ValueDateTime
	m.ValueDecimal = temp.ValueDecimal
	m.ValueId = temp.ValueId
	m.ValueInstant = temp.ValueInstant
	m.ValueInteger = temp.ValueInteger
	m.ValueMarkdown = temp.ValueMarkdown
	m.ValueOid = temp.ValueOid
	m.ValuePositiveInt = temp.ValuePositiveInt
	m.ValueString = temp.ValueString
	m.ValueTime = temp.ValueTime
	m.ValueUnsignedInt = temp.ValueUnsignedInt
	m.ValueUri = temp.ValueUri
	m.ValueUrl = temp.ValueUrl
	m.ValueUuid = temp.ValueUuid
	m.ValueAddress = temp.ValueAddress
	m.ValueAge = temp.ValueAge
	m.ValueAnnotation = temp.ValueAnnotation
	m.ValueAttachment = temp.ValueAttachment
	m.ValueCodeableConcept = temp.ValueCodeableConcept
	m.ValueCodeableReference = temp.ValueCodeableReference
	m.ValueCoding = temp.ValueCoding
	m.ValueContactPoint = temp.ValueContactPoint
	m.ValueCount = temp.ValueCount
	m.ValueDistance = temp.ValueDistance
	m.ValueDuration = temp.ValueDuration
	m.ValueHumanName = temp.ValueHumanName
	m.ValueIdentifier = temp.ValueIdentifier
	m.ValueMoney = temp.ValueMoney
	m.ValuePeriod = temp.ValuePeriod
	m.ValueQuantity = temp.ValueQuantity
	m.ValueRange = temp.ValueRange
	m.ValueRatio = temp.ValueRatio
	m.ValueRatioRange = temp.ValueRatioRange
	m.ValueReference = temp.ValueReference
	m.ValueSampledData = temp.ValueSampledData
	m.ValueSignature = temp.ValueSignature
	m.ValueTiming = temp.ValueTiming
	m.ValueContactDetail = temp.ValueContactDetail
	m.ValueContributor = temp.ValueContributor
	m.ValueDataRequirement = temp.ValueDataRequirement
	m.ValueExpression = temp.ValueExpression
	m.ValueParameterDefinition = temp.ValueParameterDefinition
	m.ValueRelatedArtifact = temp.ValueRelatedArtifact
	m.ValueTriggerDefinition = temp.ValueTriggerDefinition
	m.ValueUsageContext = temp.ValueUsageContext
	m.ValueDosage = temp.ValueDosage
	return nil
}

// ToJSON converts FhirExtension to JSON data.
func (m *FhirExtension) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
		ValueBase64Binary interface{} `json:"valuebase64binary,omitempty"`
		ValueBase64BinaryElement map[string]interface{} `json:"_valuebase64binary,omitempty"`
		ValueBoolean interface{} `json:"valueboolean,omitempty"`
		ValueBooleanElement map[string]interface{} `json:"_valueboolean,omitempty"`
		ValueCanonical interface{} `json:"valuecanonical,omitempty"`
		ValueCanonicalElement map[string]interface{} `json:"_valuecanonical,omitempty"`
		ValueCode interface{} `json:"valuecode,omitempty"`
		ValueCodeElement map[string]interface{} `json:"_valuecode,omitempty"`
		ValueDate interface{} `json:"valuedate,omitempty"`
		ValueDateElement map[string]interface{} `json:"_valuedate,omitempty"`
		ValueDateTime interface{} `json:"valuedatetime,omitempty"`
		ValueDateTimeElement map[string]interface{} `json:"_valuedatetime,omitempty"`
		ValueDecimal interface{} `json:"valuedecimal,omitempty"`
		ValueDecimalElement map[string]interface{} `json:"_valuedecimal,omitempty"`
		ValueId interface{} `json:"valueid,omitempty"`
		ValueIdElement map[string]interface{} `json:"_valueid,omitempty"`
		ValueInstant interface{} `json:"valueinstant,omitempty"`
		ValueInstantElement map[string]interface{} `json:"_valueinstant,omitempty"`
		ValueInteger interface{} `json:"valueinteger,omitempty"`
		ValueIntegerElement map[string]interface{} `json:"_valueinteger,omitempty"`
		ValueMarkdown interface{} `json:"valuemarkdown,omitempty"`
		ValueMarkdownElement map[string]interface{} `json:"_valuemarkdown,omitempty"`
		ValueOid interface{} `json:"valueoid,omitempty"`
		ValueOidElement map[string]interface{} `json:"_valueoid,omitempty"`
		ValuePositiveInt interface{} `json:"valuepositiveint,omitempty"`
		ValuePositiveIntElement map[string]interface{} `json:"_valuepositiveint,omitempty"`
		ValueString interface{} `json:"valuestring,omitempty"`
		ValueStringElement map[string]interface{} `json:"_valuestring,omitempty"`
		ValueTime interface{} `json:"valuetime,omitempty"`
		ValueTimeElement map[string]interface{} `json:"_valuetime,omitempty"`
		ValueUnsignedInt interface{} `json:"valueunsignedint,omitempty"`
		ValueUnsignedIntElement map[string]interface{} `json:"_valueunsignedint,omitempty"`
		ValueUri interface{} `json:"valueuri,omitempty"`
		ValueUriElement map[string]interface{} `json:"_valueuri,omitempty"`
		ValueUrl interface{} `json:"valueurl,omitempty"`
		ValueUrlElement map[string]interface{} `json:"_valueurl,omitempty"`
		ValueUuid interface{} `json:"valueuuid,omitempty"`
		ValueUuidElement map[string]interface{} `json:"_valueuuid,omitempty"`
		ValueAddress *Address `json:"valueaddress,omitempty"`
		ValueAge *Age `json:"valueage,omitempty"`
		ValueAnnotation *Annotation `json:"valueannotation,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueCodeableReference *CodeableReference `json:"valuecodeablereference,omitempty"`
		ValueCoding *Coding `json:"valuecoding,omitempty"`
		ValueContactPoint *ContactPoint `json:"valuecontactpoint,omitempty"`
		ValueCount *Count `json:"valuecount,omitempty"`
		ValueDistance *Distance `json:"valuedistance,omitempty"`
		ValueDuration *FhirDuration `json:"valueduration,omitempty"`
		ValueHumanName *HumanName `json:"valuehumanname,omitempty"`
		ValueIdentifier *Identifier `json:"valueidentifier,omitempty"`
		ValueMoney *Money `json:"valuemoney,omitempty"`
		ValuePeriod *Period `json:"valueperiod,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueRange *Range `json:"valuerange,omitempty"`
		ValueRatio *Ratio `json:"valueratio,omitempty"`
		ValueRatioRange *RatioRange `json:"valueratiorange,omitempty"`
		ValueReference *Reference `json:"valuereference,omitempty"`
		ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
		ValueSignature *Signature `json:"valuesignature,omitempty"`
		ValueTiming *Timing `json:"valuetiming,omitempty"`
		ValueContactDetail *ContactDetail `json:"valuecontactdetail,omitempty"`
		ValueContributor *Contributor `json:"valuecontributor,omitempty"`
		ValueDataRequirement *DataRequirement `json:"valuedatarequirement,omitempty"`
		ValueExpression *FhirExpression `json:"valueexpression,omitempty"`
		ValueParameterDefinition *ParameterDefinition `json:"valueparameterdefinition,omitempty"`
		ValueRelatedArtifact *RelatedArtifact `json:"valuerelatedartifact,omitempty"`
		ValueTriggerDefinition *TriggerDefinition `json:"valuetriggerdefinition,omitempty"`
		ValueUsageContext *UsageContext `json:"valueusagecontext,omitempty"`
		ValueDosage *Dosage `json:"valuedosage,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.ToJSON())
		}
	}
	if m.ValueBase64Binary != nil && m.ValueBase64Binary.Value != nil {
		output.ValueBase64Binary = m.ValueBase64Binary.Value
		if m.ValueBase64Binary.Element != nil {
			output.ValueBase64BinaryElement = toMapOrNil(m.ValueBase64Binary.Element.ToJSON())
		}
	}
	if m.ValueBoolean != nil && m.ValueBoolean.Value != nil {
		output.ValueBoolean = m.ValueBoolean.Value
		if m.ValueBoolean.Element != nil {
			output.ValueBooleanElement = toMapOrNil(m.ValueBoolean.Element.ToJSON())
		}
	}
	if m.ValueCanonical != nil && m.ValueCanonical.Value != nil {
		output.ValueCanonical = m.ValueCanonical.Value
		if m.ValueCanonical.Element != nil {
			output.ValueCanonicalElement = toMapOrNil(m.ValueCanonical.Element.ToJSON())
		}
	}
	if m.ValueCode != nil && m.ValueCode.Value != nil {
		output.ValueCode = m.ValueCode.Value
		if m.ValueCode.Element != nil {
			output.ValueCodeElement = toMapOrNil(m.ValueCode.Element.ToJSON())
		}
	}
	if m.ValueDate != nil && m.ValueDate.Value != nil {
		output.ValueDate = m.ValueDate.Value
		if m.ValueDate.Element != nil {
			output.ValueDateElement = toMapOrNil(m.ValueDate.Element.ToJSON())
		}
	}
	if m.ValueDateTime != nil && m.ValueDateTime.Value != nil {
		output.ValueDateTime = m.ValueDateTime.Value
		if m.ValueDateTime.Element != nil {
			output.ValueDateTimeElement = toMapOrNil(m.ValueDateTime.Element.ToJSON())
		}
	}
	if m.ValueDecimal != nil && m.ValueDecimal.Value != nil {
		output.ValueDecimal = m.ValueDecimal.Value
		if m.ValueDecimal.Element != nil {
			output.ValueDecimalElement = toMapOrNil(m.ValueDecimal.Element.ToJSON())
		}
	}
	if m.ValueId != nil && m.ValueId.Value != nil {
		output.ValueId = m.ValueId.Value
		if m.ValueId.Element != nil {
			output.ValueIdElement = toMapOrNil(m.ValueId.Element.ToJSON())
		}
	}
	if m.ValueInstant != nil && m.ValueInstant.Value != nil {
		output.ValueInstant = m.ValueInstant.Value
		if m.ValueInstant.Element != nil {
			output.ValueInstantElement = toMapOrNil(m.ValueInstant.Element.ToJSON())
		}
	}
	if m.ValueInteger != nil && m.ValueInteger.Value != nil {
		output.ValueInteger = m.ValueInteger.Value
		if m.ValueInteger.Element != nil {
			output.ValueIntegerElement = toMapOrNil(m.ValueInteger.Element.ToJSON())
		}
	}
	if m.ValueMarkdown != nil && m.ValueMarkdown.Value != nil {
		output.ValueMarkdown = m.ValueMarkdown.Value
		if m.ValueMarkdown.Element != nil {
			output.ValueMarkdownElement = toMapOrNil(m.ValueMarkdown.Element.ToJSON())
		}
	}
	if m.ValueOid != nil && m.ValueOid.Value != nil {
		output.ValueOid = m.ValueOid.Value
		if m.ValueOid.Element != nil {
			output.ValueOidElement = toMapOrNil(m.ValueOid.Element.ToJSON())
		}
	}
	if m.ValuePositiveInt != nil && m.ValuePositiveInt.Value != nil {
		output.ValuePositiveInt = m.ValuePositiveInt.Value
		if m.ValuePositiveInt.Element != nil {
			output.ValuePositiveIntElement = toMapOrNil(m.ValuePositiveInt.Element.ToJSON())
		}
	}
	if m.ValueString != nil && m.ValueString.Value != nil {
		output.ValueString = m.ValueString.Value
		if m.ValueString.Element != nil {
			output.ValueStringElement = toMapOrNil(m.ValueString.Element.ToJSON())
		}
	}
	if m.ValueTime != nil && m.ValueTime.Value != nil {
		output.ValueTime = m.ValueTime.Value
		if m.ValueTime.Element != nil {
			output.ValueTimeElement = toMapOrNil(m.ValueTime.Element.ToJSON())
		}
	}
	if m.ValueUnsignedInt != nil && m.ValueUnsignedInt.Value != nil {
		output.ValueUnsignedInt = m.ValueUnsignedInt.Value
		if m.ValueUnsignedInt.Element != nil {
			output.ValueUnsignedIntElement = toMapOrNil(m.ValueUnsignedInt.Element.ToJSON())
		}
	}
	if m.ValueUri != nil && m.ValueUri.Value != nil {
		output.ValueUri = m.ValueUri.Value
		if m.ValueUri.Element != nil {
			output.ValueUriElement = toMapOrNil(m.ValueUri.Element.ToJSON())
		}
	}
	if m.ValueUrl != nil && m.ValueUrl.Value != nil {
		output.ValueUrl = m.ValueUrl.Value
		if m.ValueUrl.Element != nil {
			output.ValueUrlElement = toMapOrNil(m.ValueUrl.Element.ToJSON())
		}
	}
	if m.ValueUuid != nil && m.ValueUuid.Value != nil {
		output.ValueUuid = m.ValueUuid.Value
		if m.ValueUuid.Element != nil {
			output.ValueUuidElement = toMapOrNil(m.ValueUuid.Element.ToJSON())
		}
	}
	output.ValueAddress = m.ValueAddress
	output.ValueAge = m.ValueAge
	output.ValueAnnotation = m.ValueAnnotation
	output.ValueAttachment = m.ValueAttachment
	output.ValueCodeableConcept = m.ValueCodeableConcept
	output.ValueCodeableReference = m.ValueCodeableReference
	output.ValueCoding = m.ValueCoding
	output.ValueContactPoint = m.ValueContactPoint
	output.ValueCount = m.ValueCount
	output.ValueDistance = m.ValueDistance
	output.ValueDuration = m.ValueDuration
	output.ValueHumanName = m.ValueHumanName
	output.ValueIdentifier = m.ValueIdentifier
	output.ValueMoney = m.ValueMoney
	output.ValuePeriod = m.ValuePeriod
	output.ValueQuantity = m.ValueQuantity
	output.ValueRange = m.ValueRange
	output.ValueRatio = m.ValueRatio
	output.ValueRatioRange = m.ValueRatioRange
	output.ValueReference = m.ValueReference
	output.ValueSampledData = m.ValueSampledData
	output.ValueSignature = m.ValueSignature
	output.ValueTiming = m.ValueTiming
	output.ValueContactDetail = m.ValueContactDetail
	output.ValueContributor = m.ValueContributor
	output.ValueDataRequirement = m.ValueDataRequirement
	output.ValueExpression = m.ValueExpression
	output.ValueParameterDefinition = m.ValueParameterDefinition
	output.ValueRelatedArtifact = m.ValueRelatedArtifact
	output.ValueTriggerDefinition = m.ValueTriggerDefinition
	output.ValueUsageContext = m.ValueUsageContext
	output.ValueDosage = m.ValueDosage
	return json.Marshal(output)
}

// Clone creates a deep copy of FhirExtension.
func (m *FhirExtension) Clone() *FhirExtension {
	if m == nil { return nil }
	return &FhirExtension{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Url: m.Url.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueCanonical: m.ValueCanonical.Clone(),
		ValueCode: m.ValueCode.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueId: m.ValueId.Clone(),
		ValueInstant: m.ValueInstant.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueMarkdown: m.ValueMarkdown.Clone(),
		ValueOid: m.ValueOid.Clone(),
		ValuePositiveInt: m.ValuePositiveInt.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueUnsignedInt: m.ValueUnsignedInt.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueUrl: m.ValueUrl.Clone(),
		ValueUuid: m.ValueUuid.Clone(),
		ValueAddress: m.ValueAddress.Clone(),
		ValueAge: m.ValueAge.Clone(),
		ValueAnnotation: m.ValueAnnotation.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueCodeableReference: m.ValueCodeableReference.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueContactPoint: m.ValueContactPoint.Clone(),
		ValueCount: m.ValueCount.Clone(),
		ValueDistance: m.ValueDistance.Clone(),
		ValueDuration: m.ValueDuration.Clone(),
		ValueHumanName: m.ValueHumanName.Clone(),
		ValueIdentifier: m.ValueIdentifier.Clone(),
		ValueMoney: m.ValueMoney.Clone(),
		ValuePeriod: m.ValuePeriod.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueRange: m.ValueRange.Clone(),
		ValueRatio: m.ValueRatio.Clone(),
		ValueRatioRange: m.ValueRatioRange.Clone(),
		ValueReference: m.ValueReference.Clone(),
		ValueSampledData: m.ValueSampledData.Clone(),
		ValueSignature: m.ValueSignature.Clone(),
		ValueTiming: m.ValueTiming.Clone(),
		ValueContactDetail: m.ValueContactDetail.Clone(),
		ValueContributor: m.ValueContributor.Clone(),
		ValueDataRequirement: m.ValueDataRequirement.Clone(),
		ValueExpression: m.ValueExpression.Clone(),
		ValueParameterDefinition: m.ValueParameterDefinition.Clone(),
		ValueRelatedArtifact: m.ValueRelatedArtifact.Clone(),
		ValueTriggerDefinition: m.ValueTriggerDefinition.Clone(),
		ValueUsageContext: m.ValueUsageContext.Clone(),
		ValueDosage: m.ValueDosage.Clone(),
	}
}

// Equals checks equality between two FhirExtension instances.
func (m *FhirExtension) Equals(other *FhirExtension) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueCanonical.Equals(other.ValueCanonical) { return false }
	if !m.ValueCode.Equals(other.ValueCode) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueId.Equals(other.ValueId) { return false }
	if !m.ValueInstant.Equals(other.ValueInstant) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueMarkdown.Equals(other.ValueMarkdown) { return false }
	if !m.ValueOid.Equals(other.ValueOid) { return false }
	if !m.ValuePositiveInt.Equals(other.ValuePositiveInt) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueUnsignedInt.Equals(other.ValueUnsignedInt) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueUrl.Equals(other.ValueUrl) { return false }
	if !m.ValueUuid.Equals(other.ValueUuid) { return false }
	if !m.ValueAddress.Equals(other.ValueAddress) { return false }
	if !m.ValueAge.Equals(other.ValueAge) { return false }
	if !m.ValueAnnotation.Equals(other.ValueAnnotation) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueCodeableReference.Equals(other.ValueCodeableReference) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueContactPoint.Equals(other.ValueContactPoint) { return false }
	if !m.ValueCount.Equals(other.ValueCount) { return false }
	if !m.ValueDistance.Equals(other.ValueDistance) { return false }
	if !m.ValueDuration.Equals(other.ValueDuration) { return false }
	if !m.ValueHumanName.Equals(other.ValueHumanName) { return false }
	if !m.ValueIdentifier.Equals(other.ValueIdentifier) { return false }
	if !m.ValueMoney.Equals(other.ValueMoney) { return false }
	if !m.ValuePeriod.Equals(other.ValuePeriod) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueRange.Equals(other.ValueRange) { return false }
	if !m.ValueRatio.Equals(other.ValueRatio) { return false }
	if !m.ValueRatioRange.Equals(other.ValueRatioRange) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !m.ValueSampledData.Equals(other.ValueSampledData) { return false }
	if !m.ValueSignature.Equals(other.ValueSignature) { return false }
	if !m.ValueTiming.Equals(other.ValueTiming) { return false }
	if !m.ValueContactDetail.Equals(other.ValueContactDetail) { return false }
	if !m.ValueContributor.Equals(other.ValueContributor) { return false }
	if !m.ValueDataRequirement.Equals(other.ValueDataRequirement) { return false }
	if !m.ValueExpression.Equals(other.ValueExpression) { return false }
	if !m.ValueParameterDefinition.Equals(other.ValueParameterDefinition) { return false }
	if !m.ValueRelatedArtifact.Equals(other.ValueRelatedArtifact) { return false }
	if !m.ValueTriggerDefinition.Equals(other.ValueTriggerDefinition) { return false }
	if !m.ValueUsageContext.Equals(other.ValueUsageContext) { return false }
	if !m.ValueDosage.Equals(other.ValueDosage) { return false }
	return true
}

