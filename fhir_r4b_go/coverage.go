// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Coverage
// Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment.
type Coverage struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *FinancialResourceStatusCodes `json:"status,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	PolicyHolder *Reference `json:"policyholder,omitempty"`
	Subscriber *Reference `json:"subscriber,omitempty"`
	SubscriberId *FhirString `json:"subscriberid,omitempty"`
	Beneficiary *Reference `json:"beneficiary,omitempty"`
	Dependent *FhirString `json:"dependent,omitempty"`
	Relationship *CodeableConcept `json:"relationship,omitempty"`
	Period *Period `json:"period,omitempty"`
	Payor []*Reference `json:"payor,omitempty"`
	Class_ []*CoverageClass `json:"class,omitempty"`
	Order *FhirPositiveInt `json:"order,omitempty"`
	Network *FhirString `json:"network,omitempty"`
	CostToBeneficiary []*CoverageCostToBeneficiary `json:"costtobeneficiary,omitempty"`
	Subrogation *FhirBoolean `json:"subrogation,omitempty"`
	Contract []*Reference `json:"contract,omitempty"`
}

// NewCoverage creates a new Coverage instance
func NewCoverage() *Coverage {
	return &Coverage{}
}

// FromJSON populates Coverage from JSON data
func (m *Coverage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Coverage to JSON data
func (m *Coverage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Coverage
func (m *Coverage) Clone() *Coverage {
	if m == nil { return nil }
	return &Coverage{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		PolicyHolder: m.PolicyHolder.Clone(),
		Subscriber: m.Subscriber.Clone(),
		SubscriberId: m.SubscriberId.Clone(),
		Beneficiary: m.Beneficiary.Clone(),
		Dependent: m.Dependent.Clone(),
		Relationship: m.Relationship.Clone(),
		Period: m.Period.Clone(),
		Payor: cloneSlices(m.Payor),
		Class_: cloneSlices(m.Class_),
		Order: m.Order.Clone(),
		Network: m.Network.Clone(),
		CostToBeneficiary: cloneSlices(m.CostToBeneficiary),
		Subrogation: m.Subrogation.Clone(),
		Contract: cloneSlices(m.Contract),
	}
}

// Equals checks for equality with another Coverage instance
func (m *Coverage) Equals(other *Coverage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.PolicyHolder.Equals(other.PolicyHolder) { return false }
	if !m.Subscriber.Equals(other.Subscriber) { return false }
	if !m.SubscriberId.Equals(other.SubscriberId) { return false }
	if !m.Beneficiary.Equals(other.Beneficiary) { return false }
	if !m.Dependent.Equals(other.Dependent) { return false }
	if !m.Relationship.Equals(other.Relationship) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !compareSlices(m.Payor, other.Payor) { return false }
	if !compareSlices(m.Class_, other.Class_) { return false }
	if !m.Order.Equals(other.Order) { return false }
	if !m.Network.Equals(other.Network) { return false }
	if !compareSlices(m.CostToBeneficiary, other.CostToBeneficiary) { return false }
	if !m.Subrogation.Equals(other.Subrogation) { return false }
	if !compareSlices(m.Contract, other.Contract) { return false }
	return true
}

// CoverageClass
// A suite of underwriter specific classifiers.
type CoverageClass struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Value *FhirString `json:"value,omitempty"`
	Name *FhirString `json:"name,omitempty"`
}

// NewCoverageClass creates a new CoverageClass instance
func NewCoverageClass() *CoverageClass {
	return &CoverageClass{}
}

// FromJSON populates CoverageClass from JSON data
func (m *CoverageClass) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageClass to JSON data
func (m *CoverageClass) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageClass
func (m *CoverageClass) Clone() *CoverageClass {
	if m == nil { return nil }
	return &CoverageClass{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Value: m.Value.Clone(),
		Name: m.Name.Clone(),
	}
}

// Equals checks for equality with another CoverageClass instance
func (m *CoverageClass) Equals(other *CoverageClass) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !m.Name.Equals(other.Name) { return false }
	return true
}

// CoverageCostToBeneficiary
// A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
type CoverageCostToBeneficiary struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueMoney *Money `json:"valuemoney,omitempty"`
	Exception []*CoverageException `json:"exception,omitempty"`
}

// NewCoverageCostToBeneficiary creates a new CoverageCostToBeneficiary instance
func NewCoverageCostToBeneficiary() *CoverageCostToBeneficiary {
	return &CoverageCostToBeneficiary{}
}

// FromJSON populates CoverageCostToBeneficiary from JSON data
func (m *CoverageCostToBeneficiary) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageCostToBeneficiary to JSON data
func (m *CoverageCostToBeneficiary) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageCostToBeneficiary
func (m *CoverageCostToBeneficiary) Clone() *CoverageCostToBeneficiary {
	if m == nil { return nil }
	return &CoverageCostToBeneficiary{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueMoney: m.ValueMoney.Clone(),
		Exception: cloneSlices(m.Exception),
	}
}

// Equals checks for equality with another CoverageCostToBeneficiary instance
func (m *CoverageCostToBeneficiary) Equals(other *CoverageCostToBeneficiary) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueMoney.Equals(other.ValueMoney) { return false }
	if !compareSlices(m.Exception, other.Exception) { return false }
	return true
}

// CoverageException
// A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
type CoverageException struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewCoverageException creates a new CoverageException instance
func NewCoverageException() *CoverageException {
	return &CoverageException{}
}

// FromJSON populates CoverageException from JSON data
func (m *CoverageException) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageException to JSON data
func (m *CoverageException) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageException
func (m *CoverageException) Clone() *CoverageException {
	if m == nil { return nil }
	return &CoverageException{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks for equality with another CoverageException instance
func (m *CoverageException) Equals(other *CoverageException) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

