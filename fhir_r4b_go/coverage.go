// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// Coverage
// Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment.
type Coverage struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *FinancialResourceStatusCodes `json:"status,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	PolicyHolder *Reference `json:"policyholder,omitempty"`
	Subscriber *Reference `json:"subscriber,omitempty"`
	SubscriberId *FhirString `json:"subscriberid,omitempty"`
	Beneficiary *Reference `json:"beneficiary,omitempty"`
	Dependent *FhirString `json:"dependent,omitempty"`
	Relationship *CodeableConcept `json:"relationship,omitempty"`
	Period *Period `json:"period,omitempty"`
	Payor []*Reference `json:"payor,omitempty"`
	Class_ []*CoverageClass `json:"class,omitempty"`
	Order *FhirPositiveInt `json:"order,omitempty"`
	Network *FhirString `json:"network,omitempty"`
	CostToBeneficiary []*CoverageCostToBeneficiary `json:"costtobeneficiary,omitempty"`
	Subrogation *FhirBoolean `json:"subrogation,omitempty"`
	Contract []*Reference `json:"contract,omitempty"`
}

// NewCoverage creates a new Coverage instance.
func NewCoverage() *Coverage {
	return &Coverage{}
}

// UnmarshalJSON populates Coverage from JSON data.
func (m *Coverage) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *FinancialResourceStatusCodes `json:"status,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		PolicyHolder *Reference `json:"policyholder,omitempty"`
		Subscriber *Reference `json:"subscriber,omitempty"`
		SubscriberId *FhirString `json:"subscriberid,omitempty"`
		Beneficiary *Reference `json:"beneficiary,omitempty"`
		Dependent *FhirString `json:"dependent,omitempty"`
		Relationship *CodeableConcept `json:"relationship,omitempty"`
		Period *Period `json:"period,omitempty"`
		Payor []*Reference `json:"payor,omitempty"`
		Class_ []*CoverageClass `json:"class,omitempty"`
		Order *FhirPositiveInt `json:"order,omitempty"`
		Network *FhirString `json:"network,omitempty"`
		CostToBeneficiary []*CoverageCostToBeneficiary `json:"costtobeneficiary,omitempty"`
		Subrogation *FhirBoolean `json:"subrogation,omitempty"`
		Contract []*Reference `json:"contract,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Status = temp.Status
	m.Type = temp.Type
	m.PolicyHolder = temp.PolicyHolder
	m.Subscriber = temp.Subscriber
	m.SubscriberId = temp.SubscriberId
	m.Beneficiary = temp.Beneficiary
	m.Dependent = temp.Dependent
	m.Relationship = temp.Relationship
	m.Period = temp.Period
	m.Payor = temp.Payor
	m.Class_ = temp.Class_
	m.Order = temp.Order
	m.Network = temp.Network
	m.CostToBeneficiary = temp.CostToBeneficiary
	m.Subrogation = temp.Subrogation
	m.Contract = temp.Contract
	return nil
}

// MarshalJSON converts Coverage to JSON data.
func (m *Coverage) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *FinancialResourceStatusCodes `json:"status,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		PolicyHolder *Reference `json:"policyholder,omitempty"`
		Subscriber *Reference `json:"subscriber,omitempty"`
		SubscriberId interface{} `json:"subscriberid,omitempty"`
		SubscriberIdElement map[string]interface{} `json:"_subscriberid,omitempty"`
		Beneficiary *Reference `json:"beneficiary,omitempty"`
		Dependent interface{} `json:"dependent,omitempty"`
		DependentElement map[string]interface{} `json:"_dependent,omitempty"`
		Relationship *CodeableConcept `json:"relationship,omitempty"`
		Period *Period `json:"period,omitempty"`
		Payor []*Reference `json:"payor,omitempty"`
		Class_ []*CoverageClass `json:"class,omitempty"`
		Order interface{} `json:"order,omitempty"`
		OrderElement map[string]interface{} `json:"_order,omitempty"`
		Network interface{} `json:"network,omitempty"`
		NetworkElement map[string]interface{} `json:"_network,omitempty"`
		CostToBeneficiary []*CoverageCostToBeneficiary `json:"costtobeneficiary,omitempty"`
		Subrogation interface{} `json:"subrogation,omitempty"`
		SubrogationElement map[string]interface{} `json:"_subrogation,omitempty"`
		Contract []*Reference `json:"contract,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Status = m.Status
	output.Type = m.Type
	output.PolicyHolder = m.PolicyHolder
	output.Subscriber = m.Subscriber
	if m.SubscriberId != nil && m.SubscriberId.Value != nil {
		output.SubscriberId = m.SubscriberId.Value
		if m.SubscriberId.Element != nil {
			output.SubscriberIdElement = toMapOrNil(m.SubscriberId.Element.MarshalJSON())
		}
	}
	output.Beneficiary = m.Beneficiary
	if m.Dependent != nil && m.Dependent.Value != nil {
		output.Dependent = m.Dependent.Value
		if m.Dependent.Element != nil {
			output.DependentElement = toMapOrNil(m.Dependent.Element.MarshalJSON())
		}
	}
	output.Relationship = m.Relationship
	output.Period = m.Period
	output.Payor = m.Payor
	output.Class_ = m.Class_
	if m.Order != nil && m.Order.Value != nil {
		output.Order = m.Order.Value
		if m.Order.Element != nil {
			output.OrderElement = toMapOrNil(m.Order.Element.MarshalJSON())
		}
	}
	if m.Network != nil && m.Network.Value != nil {
		output.Network = m.Network.Value
		if m.Network.Element != nil {
			output.NetworkElement = toMapOrNil(m.Network.Element.MarshalJSON())
		}
	}
	output.CostToBeneficiary = m.CostToBeneficiary
	if m.Subrogation != nil && m.Subrogation.Value != nil {
		output.Subrogation = m.Subrogation.Value
		if m.Subrogation.Element != nil {
			output.SubrogationElement = toMapOrNil(m.Subrogation.Element.MarshalJSON())
		}
	}
	output.Contract = m.Contract
	return json.Marshal(output)
}

// Clone creates a deep copy of Coverage.
func (m *Coverage) Clone() *Coverage {
	if m == nil { return nil }
	return &Coverage{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		PolicyHolder: m.PolicyHolder.Clone(),
		Subscriber: m.Subscriber.Clone(),
		SubscriberId: m.SubscriberId.Clone(),
		Beneficiary: m.Beneficiary.Clone(),
		Dependent: m.Dependent.Clone(),
		Relationship: m.Relationship.Clone(),
		Period: m.Period.Clone(),
		Payor: cloneSlices(m.Payor),
		Class_: cloneSlices(m.Class_),
		Order: m.Order.Clone(),
		Network: m.Network.Clone(),
		CostToBeneficiary: cloneSlices(m.CostToBeneficiary),
		Subrogation: m.Subrogation.Clone(),
		Contract: cloneSlices(m.Contract),
	}
}

// Equals checks equality between two Coverage instances.
func (m *Coverage) Equals(other *Coverage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.PolicyHolder.Equals(other.PolicyHolder) { return false }
	if !m.Subscriber.Equals(other.Subscriber) { return false }
	if !m.SubscriberId.Equals(other.SubscriberId) { return false }
	if !m.Beneficiary.Equals(other.Beneficiary) { return false }
	if !m.Dependent.Equals(other.Dependent) { return false }
	if !m.Relationship.Equals(other.Relationship) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !compareSlices(m.Payor, other.Payor) { return false }
	if !compareSlices(m.Class_, other.Class_) { return false }
	if !m.Order.Equals(other.Order) { return false }
	if !m.Network.Equals(other.Network) { return false }
	if !compareSlices(m.CostToBeneficiary, other.CostToBeneficiary) { return false }
	if !m.Subrogation.Equals(other.Subrogation) { return false }
	if !compareSlices(m.Contract, other.Contract) { return false }
	return true
}

// CoverageClass
// A suite of underwriter specific classifiers.
type CoverageClass struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Value *FhirString `json:"value,omitempty"`
	Name *FhirString `json:"name,omitempty"`
}

// NewCoverageClass creates a new CoverageClass instance.
func NewCoverageClass() *CoverageClass {
	return &CoverageClass{}
}

// UnmarshalJSON populates CoverageClass from JSON data.
func (m *CoverageClass) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Value *FhirString `json:"value,omitempty"`
		Name *FhirString `json:"name,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Value = temp.Value
	m.Name = temp.Name
	return nil
}

// MarshalJSON converts CoverageClass to JSON data.
func (m *CoverageClass) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Value interface{} `json:"value,omitempty"`
		ValueElement map[string]interface{} `json:"_value,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.Value != nil && m.Value.Value != nil {
		output.Value = m.Value.Value
		if m.Value.Element != nil {
			output.ValueElement = toMapOrNil(m.Value.Element.MarshalJSON())
		}
	}
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of CoverageClass.
func (m *CoverageClass) Clone() *CoverageClass {
	if m == nil { return nil }
	return &CoverageClass{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Value: m.Value.Clone(),
		Name: m.Name.Clone(),
	}
}

// Equals checks equality between two CoverageClass instances.
func (m *CoverageClass) Equals(other *CoverageClass) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !m.Name.Equals(other.Name) { return false }
	return true
}

// CoverageCostToBeneficiary
// A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
type CoverageCostToBeneficiary struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueMoney *Money `json:"valuemoney,omitempty"`
	Exception []*CoverageException `json:"exception,omitempty"`
}

// NewCoverageCostToBeneficiary creates a new CoverageCostToBeneficiary instance.
func NewCoverageCostToBeneficiary() *CoverageCostToBeneficiary {
	return &CoverageCostToBeneficiary{}
}

// UnmarshalJSON populates CoverageCostToBeneficiary from JSON data.
func (m *CoverageCostToBeneficiary) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueMoney *Money `json:"valuemoney,omitempty"`
		Exception []*CoverageException `json:"exception,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.ValueQuantity = temp.ValueQuantity
	m.ValueMoney = temp.ValueMoney
	m.Exception = temp.Exception
	return nil
}

// MarshalJSON converts CoverageCostToBeneficiary to JSON data.
func (m *CoverageCostToBeneficiary) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueMoney *Money `json:"valuemoney,omitempty"`
		Exception []*CoverageException `json:"exception,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.ValueQuantity = m.ValueQuantity
	output.ValueMoney = m.ValueMoney
	output.Exception = m.Exception
	return json.Marshal(output)
}

// Clone creates a deep copy of CoverageCostToBeneficiary.
func (m *CoverageCostToBeneficiary) Clone() *CoverageCostToBeneficiary {
	if m == nil { return nil }
	return &CoverageCostToBeneficiary{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueMoney: m.ValueMoney.Clone(),
		Exception: cloneSlices(m.Exception),
	}
}

// Equals checks equality between two CoverageCostToBeneficiary instances.
func (m *CoverageCostToBeneficiary) Equals(other *CoverageCostToBeneficiary) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueMoney.Equals(other.ValueMoney) { return false }
	if !compareSlices(m.Exception, other.Exception) { return false }
	return true
}

// CoverageException
// A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
type CoverageException struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewCoverageException creates a new CoverageException instance.
func NewCoverageException() *CoverageException {
	return &CoverageException{}
}

// UnmarshalJSON populates CoverageException from JSON data.
func (m *CoverageException) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Period = temp.Period
	return nil
}

// MarshalJSON converts CoverageException to JSON data.
func (m *CoverageException) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Period = m.Period
	return json.Marshal(output)
}

// Clone creates a deep copy of CoverageException.
func (m *CoverageException) Clone() *CoverageException {
	if m == nil { return nil }
	return &CoverageException{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks equality between two CoverageException instances.
func (m *CoverageException) Equals(other *CoverageException) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

