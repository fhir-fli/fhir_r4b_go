// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Observation
// Measurements and simple assertions made about a patient, device or other subject.
type Observation struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	PartOf []*Reference `json:"partof,omitempty"`
	Status *ObservationStatus `json:"status,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Focus []*Reference `json:"focus,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	EffectiveDateTime *FhirDateTime `json:"effectivedatetime,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	EffectiveTiming *Timing `json:"effectivetiming,omitempty"`
	EffectiveInstant *FhirInstant `json:"effectiveinstant,omitempty"`
	Issued *FhirInstant `json:"issued,omitempty"`
	Performer []*Reference `json:"performer,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueRange *Range `json:"valuerange,omitempty"`
	ValueRatio *Ratio `json:"valueratio,omitempty"`
	ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValuePeriod *Period `json:"valueperiod,omitempty"`
	DataAbsentReason *CodeableConcept `json:"dataabsentreason,omitempty"`
	Interpretation []*CodeableConcept `json:"interpretation,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	BodySite *CodeableConcept `json:"bodysite,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	Specimen *Reference `json:"specimen,omitempty"`
	Device *Reference `json:"device,omitempty"`
	ReferenceRange []*ObservationReferenceRange `json:"referencerange,omitempty"`
	HasMember []*Reference `json:"hasmember,omitempty"`
	DerivedFrom []*Reference `json:"derivedfrom,omitempty"`
	Component []*ObservationComponent `json:"component,omitempty"`
}

// NewObservation creates a new Observation instance
func NewObservation() *Observation {
	return &Observation{}
}

// FromJSON populates Observation from JSON data
func (m *Observation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Observation to JSON data
func (m *Observation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Observation
func (m *Observation) Clone() *Observation {
	if m == nil { return nil }
	return &Observation{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		BasedOn: cloneSlices(m.BasedOn),
		PartOf: cloneSlices(m.PartOf),
		Status: m.Status.Clone(),
		Category: cloneSlices(m.Category),
		Code: m.Code.Clone(),
		Subject: m.Subject.Clone(),
		Focus: cloneSlices(m.Focus),
		Encounter: m.Encounter.Clone(),
		EffectiveDateTime: m.EffectiveDateTime.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		EffectiveTiming: m.EffectiveTiming.Clone(),
		EffectiveInstant: m.EffectiveInstant.Clone(),
		Issued: m.Issued.Clone(),
		Performer: cloneSlices(m.Performer),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueRange: m.ValueRange.Clone(),
		ValueRatio: m.ValueRatio.Clone(),
		ValueSampledData: m.ValueSampledData.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValuePeriod: m.ValuePeriod.Clone(),
		DataAbsentReason: m.DataAbsentReason.Clone(),
		Interpretation: cloneSlices(m.Interpretation),
		Note: cloneSlices(m.Note),
		BodySite: m.BodySite.Clone(),
		Method: m.Method.Clone(),
		Specimen: m.Specimen.Clone(),
		Device: m.Device.Clone(),
		ReferenceRange: cloneSlices(m.ReferenceRange),
		HasMember: cloneSlices(m.HasMember),
		DerivedFrom: cloneSlices(m.DerivedFrom),
		Component: cloneSlices(m.Component),
	}
}

// Equals checks for equality with another Observation instance
func (m *Observation) Equals(other *Observation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !compareSlices(m.Focus, other.Focus) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.EffectiveDateTime.Equals(other.EffectiveDateTime) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !m.EffectiveTiming.Equals(other.EffectiveTiming) { return false }
	if !m.EffectiveInstant.Equals(other.EffectiveInstant) { return false }
	if !m.Issued.Equals(other.Issued) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueRange.Equals(other.ValueRange) { return false }
	if !m.ValueRatio.Equals(other.ValueRatio) { return false }
	if !m.ValueSampledData.Equals(other.ValueSampledData) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValuePeriod.Equals(other.ValuePeriod) { return false }
	if !m.DataAbsentReason.Equals(other.DataAbsentReason) { return false }
	if !compareSlices(m.Interpretation, other.Interpretation) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Specimen.Equals(other.Specimen) { return false }
	if !m.Device.Equals(other.Device) { return false }
	if !compareSlices(m.ReferenceRange, other.ReferenceRange) { return false }
	if !compareSlices(m.HasMember, other.HasMember) { return false }
	if !compareSlices(m.DerivedFrom, other.DerivedFrom) { return false }
	if !compareSlices(m.Component, other.Component) { return false }
	return true
}

// ObservationReferenceRange
// Guidance on how to interpret the value by comparison to a normal or recommended range.  Multiple reference ranges are interpreted as an "OR".   In other words, to represent two distinct target populations, two `referenceRange` elements would be used.
type ObservationReferenceRange struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Low *Quantity `json:"low,omitempty"`
	High *Quantity `json:"high,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	AppliesTo []*CodeableConcept `json:"appliesto,omitempty"`
	Age *Range `json:"age,omitempty"`
	Text *FhirString `json:"text,omitempty"`
}

// NewObservationReferenceRange creates a new ObservationReferenceRange instance
func NewObservationReferenceRange() *ObservationReferenceRange {
	return &ObservationReferenceRange{}
}

// FromJSON populates ObservationReferenceRange from JSON data
func (m *ObservationReferenceRange) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ObservationReferenceRange to JSON data
func (m *ObservationReferenceRange) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ObservationReferenceRange
func (m *ObservationReferenceRange) Clone() *ObservationReferenceRange {
	if m == nil { return nil }
	return &ObservationReferenceRange{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Low: m.Low.Clone(),
		High: m.High.Clone(),
		Type: m.Type.Clone(),
		AppliesTo: cloneSlices(m.AppliesTo),
		Age: m.Age.Clone(),
		Text: m.Text.Clone(),
	}
}

// Equals checks for equality with another ObservationReferenceRange instance
func (m *ObservationReferenceRange) Equals(other *ObservationReferenceRange) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Low.Equals(other.Low) { return false }
	if !m.High.Equals(other.High) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.AppliesTo, other.AppliesTo) { return false }
	if !m.Age.Equals(other.Age) { return false }
	if !m.Text.Equals(other.Text) { return false }
	return true
}

// ObservationComponent
// Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
type ObservationComponent struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueRange *Range `json:"valuerange,omitempty"`
	ValueRatio *Ratio `json:"valueratio,omitempty"`
	ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValuePeriod *Period `json:"valueperiod,omitempty"`
	DataAbsentReason *CodeableConcept `json:"dataabsentreason,omitempty"`
	Interpretation []*CodeableConcept `json:"interpretation,omitempty"`
	ReferenceRange []*ObservationReferenceRange `json:"referencerange,omitempty"`
}

// NewObservationComponent creates a new ObservationComponent instance
func NewObservationComponent() *ObservationComponent {
	return &ObservationComponent{}
}

// FromJSON populates ObservationComponent from JSON data
func (m *ObservationComponent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ObservationComponent to JSON data
func (m *ObservationComponent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ObservationComponent
func (m *ObservationComponent) Clone() *ObservationComponent {
	if m == nil { return nil }
	return &ObservationComponent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueRange: m.ValueRange.Clone(),
		ValueRatio: m.ValueRatio.Clone(),
		ValueSampledData: m.ValueSampledData.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValuePeriod: m.ValuePeriod.Clone(),
		DataAbsentReason: m.DataAbsentReason.Clone(),
		Interpretation: cloneSlices(m.Interpretation),
		ReferenceRange: cloneSlices(m.ReferenceRange),
	}
}

// Equals checks for equality with another ObservationComponent instance
func (m *ObservationComponent) Equals(other *ObservationComponent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueRange.Equals(other.ValueRange) { return false }
	if !m.ValueRatio.Equals(other.ValueRatio) { return false }
	if !m.ValueSampledData.Equals(other.ValueSampledData) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValuePeriod.Equals(other.ValuePeriod) { return false }
	if !m.DataAbsentReason.Equals(other.DataAbsentReason) { return false }
	if !compareSlices(m.Interpretation, other.Interpretation) { return false }
	if !compareSlices(m.ReferenceRange, other.ReferenceRange) { return false }
	return true
}

