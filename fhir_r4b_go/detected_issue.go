// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// DetectedIssue
// Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
type DetectedIssue struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ObservationStatus `json:"status,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Severity *DetectedIssueSeverity `json:"severity,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	IdentifiedDateTime *FhirDateTime `json:"identifieddatetime,omitempty"`
	IdentifiedPeriod *Period `json:"identifiedperiod,omitempty"`
	Author *Reference `json:"author,omitempty"`
	Implicated []*Reference `json:"implicated,omitempty"`
	Evidence []*DetectedIssueEvidence `json:"evidence,omitempty"`
	Detail *FhirString `json:"detail,omitempty"`
	Reference *FhirUri `json:"reference,omitempty"`
	Mitigation []*DetectedIssueMitigation `json:"mitigation,omitempty"`
}

// NewDetectedIssue creates a new DetectedIssue instance.
func NewDetectedIssue() *DetectedIssue {
	return &DetectedIssue{}
}

// UnmarshalJSON populates DetectedIssue from JSON data.
func (m *DetectedIssue) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *ObservationStatus `json:"status,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Severity *DetectedIssueSeverity `json:"severity,omitempty"`
		Patient *Reference `json:"patient,omitempty"`
		IdentifiedDateTime *FhirDateTime `json:"identifieddatetime,omitempty"`
		IdentifiedPeriod *Period `json:"identifiedperiod,omitempty"`
		Author *Reference `json:"author,omitempty"`
		Implicated []*Reference `json:"implicated,omitempty"`
		Evidence []*DetectedIssueEvidence `json:"evidence,omitempty"`
		Detail *FhirString `json:"detail,omitempty"`
		Reference *FhirUri `json:"reference,omitempty"`
		Mitigation []*DetectedIssueMitigation `json:"mitigation,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Status = temp.Status
	m.Code = temp.Code
	m.Severity = temp.Severity
	m.Patient = temp.Patient
	m.IdentifiedDateTime = temp.IdentifiedDateTime
	m.IdentifiedPeriod = temp.IdentifiedPeriod
	m.Author = temp.Author
	m.Implicated = temp.Implicated
	m.Evidence = temp.Evidence
	m.Detail = temp.Detail
	m.Reference = temp.Reference
	m.Mitigation = temp.Mitigation
	return nil
}

// MarshalJSON converts DetectedIssue to JSON data.
func (m *DetectedIssue) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *ObservationStatus `json:"status,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Severity *DetectedIssueSeverity `json:"severity,omitempty"`
		Patient *Reference `json:"patient,omitempty"`
		IdentifiedDateTime interface{} `json:"identifieddatetime,omitempty"`
		IdentifiedDateTimeElement map[string]interface{} `json:"_identifieddatetime,omitempty"`
		IdentifiedPeriod *Period `json:"identifiedperiod,omitempty"`
		Author *Reference `json:"author,omitempty"`
		Implicated []*Reference `json:"implicated,omitempty"`
		Evidence []*DetectedIssueEvidence `json:"evidence,omitempty"`
		Detail interface{} `json:"detail,omitempty"`
		DetailElement map[string]interface{} `json:"_detail,omitempty"`
		Reference interface{} `json:"reference,omitempty"`
		ReferenceElement map[string]interface{} `json:"_reference,omitempty"`
		Mitigation []*DetectedIssueMitigation `json:"mitigation,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Status = m.Status
	output.Code = m.Code
	output.Severity = m.Severity
	output.Patient = m.Patient
	if m.IdentifiedDateTime != nil && m.IdentifiedDateTime.Value != nil {
		output.IdentifiedDateTime = m.IdentifiedDateTime.Value
		if m.IdentifiedDateTime.Element != nil {
			output.IdentifiedDateTimeElement = toMapOrNil(m.IdentifiedDateTime.Element.MarshalJSON())
		}
	}
	output.IdentifiedPeriod = m.IdentifiedPeriod
	output.Author = m.Author
	output.Implicated = m.Implicated
	output.Evidence = m.Evidence
	if m.Detail != nil && m.Detail.Value != nil {
		output.Detail = m.Detail.Value
		if m.Detail.Element != nil {
			output.DetailElement = toMapOrNil(m.Detail.Element.MarshalJSON())
		}
	}
	if m.Reference != nil && m.Reference.Value != nil {
		output.Reference = m.Reference.Value
		if m.Reference.Element != nil {
			output.ReferenceElement = toMapOrNil(m.Reference.Element.MarshalJSON())
		}
	}
	output.Mitigation = m.Mitigation
	return json.Marshal(output)
}

// Clone creates a deep copy of DetectedIssue.
func (m *DetectedIssue) Clone() *DetectedIssue {
	if m == nil { return nil }
	return &DetectedIssue{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Code: m.Code.Clone(),
		Severity: m.Severity.Clone(),
		Patient: m.Patient.Clone(),
		IdentifiedDateTime: m.IdentifiedDateTime.Clone(),
		IdentifiedPeriod: m.IdentifiedPeriod.Clone(),
		Author: m.Author.Clone(),
		Implicated: cloneSlices(m.Implicated),
		Evidence: cloneSlices(m.Evidence),
		Detail: m.Detail.Clone(),
		Reference: m.Reference.Clone(),
		Mitigation: cloneSlices(m.Mitigation),
	}
}

// Equals checks equality between two DetectedIssue instances.
func (m *DetectedIssue) Equals(other *DetectedIssue) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Severity.Equals(other.Severity) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.IdentifiedDateTime.Equals(other.IdentifiedDateTime) { return false }
	if !m.IdentifiedPeriod.Equals(other.IdentifiedPeriod) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !compareSlices(m.Implicated, other.Implicated) { return false }
	if !compareSlices(m.Evidence, other.Evidence) { return false }
	if !m.Detail.Equals(other.Detail) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	if !compareSlices(m.Mitigation, other.Mitigation) { return false }
	return true
}

// DetectedIssueEvidence
// Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
type DetectedIssueEvidence struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code []*CodeableConcept `json:"code,omitempty"`
	Detail []*Reference `json:"detail,omitempty"`
}

// NewDetectedIssueEvidence creates a new DetectedIssueEvidence instance.
func NewDetectedIssueEvidence() *DetectedIssueEvidence {
	return &DetectedIssueEvidence{}
}

// UnmarshalJSON populates DetectedIssueEvidence from JSON data.
func (m *DetectedIssueEvidence) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code []*CodeableConcept `json:"code,omitempty"`
		Detail []*Reference `json:"detail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Detail = temp.Detail
	return nil
}

// MarshalJSON converts DetectedIssueEvidence to JSON data.
func (m *DetectedIssueEvidence) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code []*CodeableConcept `json:"code,omitempty"`
		Detail []*Reference `json:"detail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	output.Detail = m.Detail
	return json.Marshal(output)
}

// Clone creates a deep copy of DetectedIssueEvidence.
func (m *DetectedIssueEvidence) Clone() *DetectedIssueEvidence {
	if m == nil { return nil }
	return &DetectedIssueEvidence{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: cloneSlices(m.Code),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks equality between two DetectedIssueEvidence instances.
func (m *DetectedIssueEvidence) Equals(other *DetectedIssueEvidence) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// DetectedIssueMitigation
// Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
type DetectedIssueMitigation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Action *CodeableConcept `json:"action,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Author *Reference `json:"author,omitempty"`
}

// NewDetectedIssueMitigation creates a new DetectedIssueMitigation instance.
func NewDetectedIssueMitigation() *DetectedIssueMitigation {
	return &DetectedIssueMitigation{}
}

// UnmarshalJSON populates DetectedIssueMitigation from JSON data.
func (m *DetectedIssueMitigation) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action *CodeableConcept `json:"action,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		Author *Reference `json:"author,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Action = temp.Action
	m.Date = temp.Date
	m.Author = temp.Author
	return nil
}

// MarshalJSON converts DetectedIssueMitigation to JSON data.
func (m *DetectedIssueMitigation) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action *CodeableConcept `json:"action,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Author *Reference `json:"author,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Action = m.Action
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.MarshalJSON())
		}
	}
	output.Author = m.Author
	return json.Marshal(output)
}

// Clone creates a deep copy of DetectedIssueMitigation.
func (m *DetectedIssueMitigation) Clone() *DetectedIssueMitigation {
	if m == nil { return nil }
	return &DetectedIssueMitigation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Action: m.Action.Clone(),
		Date: m.Date.Clone(),
		Author: m.Author.Clone(),
	}
}

// Equals checks equality between two DetectedIssueMitigation instances.
func (m *DetectedIssueMitigation) Equals(other *DetectedIssueMitigation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Action.Equals(other.Action) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Author.Equals(other.Author) { return false }
	return true
}

