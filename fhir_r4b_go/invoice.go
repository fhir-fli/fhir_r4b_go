// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// Invoice
// Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose.
type Invoice struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *InvoiceStatus `json:"status,omitempty"`
	CancelledReason *FhirString `json:"cancelledreason,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Recipient *Reference `json:"recipient,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Participant []*InvoiceParticipant `json:"participant,omitempty"`
	Issuer *Reference `json:"issuer,omitempty"`
	Account *Reference `json:"account,omitempty"`
	LineItem []*InvoiceLineItem `json:"lineitem,omitempty"`
	TotalPriceComponent []*InvoicePriceComponent `json:"totalpricecomponent,omitempty"`
	TotalNet *Money `json:"totalnet,omitempty"`
	TotalGross *Money `json:"totalgross,omitempty"`
	PaymentTerms *FhirMarkdown `json:"paymentterms,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewInvoice creates a new Invoice instance.
func NewInvoice() *Invoice {
	return &Invoice{}
}

// UnmarshalJSON populates Invoice from JSON data.
func (m *Invoice) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *InvoiceStatus `json:"status,omitempty"`
		CancelledReason *FhirString `json:"cancelledreason,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Recipient *Reference `json:"recipient,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		Participant []*InvoiceParticipant `json:"participant,omitempty"`
		Issuer *Reference `json:"issuer,omitempty"`
		Account *Reference `json:"account,omitempty"`
		LineItem []*InvoiceLineItem `json:"lineitem,omitempty"`
		TotalPriceComponent []*InvoicePriceComponent `json:"totalpricecomponent,omitempty"`
		TotalNet *Money `json:"totalnet,omitempty"`
		TotalGross *Money `json:"totalgross,omitempty"`
		PaymentTerms *FhirMarkdown `json:"paymentterms,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Status = temp.Status
	m.CancelledReason = temp.CancelledReason
	m.Type = temp.Type
	m.Subject = temp.Subject
	m.Recipient = temp.Recipient
	m.Date = temp.Date
	m.Participant = temp.Participant
	m.Issuer = temp.Issuer
	m.Account = temp.Account
	m.LineItem = temp.LineItem
	m.TotalPriceComponent = temp.TotalPriceComponent
	m.TotalNet = temp.TotalNet
	m.TotalGross = temp.TotalGross
	m.PaymentTerms = temp.PaymentTerms
	m.Note = temp.Note
	return nil
}

// MarshalJSON converts Invoice to JSON data.
func (m *Invoice) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *InvoiceStatus `json:"status,omitempty"`
		CancelledReason interface{} `json:"cancelledreason,omitempty"`
		CancelledReasonElement map[string]interface{} `json:"_cancelledreason,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Recipient *Reference `json:"recipient,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Participant []*InvoiceParticipant `json:"participant,omitempty"`
		Issuer *Reference `json:"issuer,omitempty"`
		Account *Reference `json:"account,omitempty"`
		LineItem []*InvoiceLineItem `json:"lineitem,omitempty"`
		TotalPriceComponent []*InvoicePriceComponent `json:"totalpricecomponent,omitempty"`
		TotalNet *Money `json:"totalnet,omitempty"`
		TotalGross *Money `json:"totalgross,omitempty"`
		PaymentTerms interface{} `json:"paymentterms,omitempty"`
		PaymentTermsElement map[string]interface{} `json:"_paymentterms,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Status = m.Status
	if m.CancelledReason != nil && m.CancelledReason.Value != nil {
		output.CancelledReason = m.CancelledReason.Value
		if m.CancelledReason.Element != nil {
			output.CancelledReasonElement = toMapOrNil(m.CancelledReason.Element.MarshalJSON())
		}
	}
	output.Type = m.Type
	output.Subject = m.Subject
	output.Recipient = m.Recipient
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.MarshalJSON())
		}
	}
	output.Participant = m.Participant
	output.Issuer = m.Issuer
	output.Account = m.Account
	output.LineItem = m.LineItem
	output.TotalPriceComponent = m.TotalPriceComponent
	output.TotalNet = m.TotalNet
	output.TotalGross = m.TotalGross
	if m.PaymentTerms != nil && m.PaymentTerms.Value != nil {
		output.PaymentTerms = m.PaymentTerms.Value
		if m.PaymentTerms.Element != nil {
			output.PaymentTermsElement = toMapOrNil(m.PaymentTerms.Element.MarshalJSON())
		}
	}
	output.Note = m.Note
	return json.Marshal(output)
}

// Clone creates a deep copy of Invoice.
func (m *Invoice) Clone() *Invoice {
	if m == nil { return nil }
	return &Invoice{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		CancelledReason: m.CancelledReason.Clone(),
		Type: m.Type.Clone(),
		Subject: m.Subject.Clone(),
		Recipient: m.Recipient.Clone(),
		Date: m.Date.Clone(),
		Participant: cloneSlices(m.Participant),
		Issuer: m.Issuer.Clone(),
		Account: m.Account.Clone(),
		LineItem: cloneSlices(m.LineItem),
		TotalPriceComponent: cloneSlices(m.TotalPriceComponent),
		TotalNet: m.TotalNet.Clone(),
		TotalGross: m.TotalGross.Clone(),
		PaymentTerms: m.PaymentTerms.Clone(),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks equality between two Invoice instances.
func (m *Invoice) Equals(other *Invoice) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.CancelledReason.Equals(other.CancelledReason) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Recipient.Equals(other.Recipient) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !compareSlices(m.Participant, other.Participant) { return false }
	if !m.Issuer.Equals(other.Issuer) { return false }
	if !m.Account.Equals(other.Account) { return false }
	if !compareSlices(m.LineItem, other.LineItem) { return false }
	if !compareSlices(m.TotalPriceComponent, other.TotalPriceComponent) { return false }
	if !m.TotalNet.Equals(other.TotalNet) { return false }
	if !m.TotalGross.Equals(other.TotalGross) { return false }
	if !m.PaymentTerms.Equals(other.PaymentTerms) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// InvoiceParticipant
// Indicates who or what performed or participated in the charged service.
type InvoiceParticipant struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewInvoiceParticipant creates a new InvoiceParticipant instance.
func NewInvoiceParticipant() *InvoiceParticipant {
	return &InvoiceParticipant{}
}

// UnmarshalJSON populates InvoiceParticipant from JSON data.
func (m *InvoiceParticipant) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Role *CodeableConcept `json:"role,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Role = temp.Role
	m.Actor = temp.Actor
	return nil
}

// MarshalJSON converts InvoiceParticipant to JSON data.
func (m *InvoiceParticipant) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Role *CodeableConcept `json:"role,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Role = m.Role
	output.Actor = m.Actor
	return json.Marshal(output)
}

// Clone creates a deep copy of InvoiceParticipant.
func (m *InvoiceParticipant) Clone() *InvoiceParticipant {
	if m == nil { return nil }
	return &InvoiceParticipant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Role: m.Role.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks equality between two InvoiceParticipant instances.
func (m *InvoiceParticipant) Equals(other *InvoiceParticipant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

// InvoiceLineItem
// Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
type InvoiceLineItem struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	ChargeItemReference *Reference `json:"chargeitemreference,omitempty"`
	ChargeItemCodeableConcept *CodeableConcept `json:"chargeitemcodeableconcept,omitempty"`
	PriceComponent []*InvoicePriceComponent `json:"pricecomponent,omitempty"`
}

// NewInvoiceLineItem creates a new InvoiceLineItem instance.
func NewInvoiceLineItem() *InvoiceLineItem {
	return &InvoiceLineItem{}
}

// UnmarshalJSON populates InvoiceLineItem from JSON data.
func (m *InvoiceLineItem) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		ChargeItemReference *Reference `json:"chargeitemreference,omitempty"`
		ChargeItemCodeableConcept *CodeableConcept `json:"chargeitemcodeableconcept,omitempty"`
		PriceComponent []*InvoicePriceComponent `json:"pricecomponent,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.ChargeItemReference = temp.ChargeItemReference
	m.ChargeItemCodeableConcept = temp.ChargeItemCodeableConcept
	m.PriceComponent = temp.PriceComponent
	return nil
}

// MarshalJSON converts InvoiceLineItem to JSON data.
func (m *InvoiceLineItem) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		ChargeItemReference *Reference `json:"chargeitemreference,omitempty"`
		ChargeItemCodeableConcept *CodeableConcept `json:"chargeitemcodeableconcept,omitempty"`
		PriceComponent []*InvoicePriceComponent `json:"pricecomponent,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.MarshalJSON())
		}
	}
	output.ChargeItemReference = m.ChargeItemReference
	output.ChargeItemCodeableConcept = m.ChargeItemCodeableConcept
	output.PriceComponent = m.PriceComponent
	return json.Marshal(output)
}

// Clone creates a deep copy of InvoiceLineItem.
func (m *InvoiceLineItem) Clone() *InvoiceLineItem {
	if m == nil { return nil }
	return &InvoiceLineItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		ChargeItemReference: m.ChargeItemReference.Clone(),
		ChargeItemCodeableConcept: m.ChargeItemCodeableConcept.Clone(),
		PriceComponent: cloneSlices(m.PriceComponent),
	}
}

// Equals checks equality between two InvoiceLineItem instances.
func (m *InvoiceLineItem) Equals(other *InvoiceLineItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.ChargeItemReference.Equals(other.ChargeItemReference) { return false }
	if !m.ChargeItemCodeableConcept.Equals(other.ChargeItemCodeableConcept) { return false }
	if !compareSlices(m.PriceComponent, other.PriceComponent) { return false }
	return true
}

// InvoicePriceComponent
// The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
type InvoicePriceComponent struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *InvoicePriceComponentType `json:"type,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Amount *Money `json:"amount,omitempty"`
}

// NewInvoicePriceComponent creates a new InvoicePriceComponent instance.
func NewInvoicePriceComponent() *InvoicePriceComponent {
	return &InvoicePriceComponent{}
}

// UnmarshalJSON populates InvoicePriceComponent from JSON data.
func (m *InvoicePriceComponent) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *InvoicePriceComponentType `json:"type,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Factor *FhirDecimal `json:"factor,omitempty"`
		Amount *Money `json:"amount,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Code = temp.Code
	m.Factor = temp.Factor
	m.Amount = temp.Amount
	return nil
}

// MarshalJSON converts InvoicePriceComponent to JSON data.
func (m *InvoicePriceComponent) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *InvoicePriceComponentType `json:"type,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Factor interface{} `json:"factor,omitempty"`
		FactorElement map[string]interface{} `json:"_factor,omitempty"`
		Amount *Money `json:"amount,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Code = m.Code
	if m.Factor != nil && m.Factor.Value != nil {
		output.Factor = m.Factor.Value
		if m.Factor.Element != nil {
			output.FactorElement = toMapOrNil(m.Factor.Element.MarshalJSON())
		}
	}
	output.Amount = m.Amount
	return json.Marshal(output)
}

// Clone creates a deep copy of InvoicePriceComponent.
func (m *InvoicePriceComponent) Clone() *InvoicePriceComponent {
	if m == nil { return nil }
	return &InvoicePriceComponent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Code: m.Code.Clone(),
		Factor: m.Factor.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks equality between two InvoicePriceComponent instances.
func (m *InvoicePriceComponent) Equals(other *InvoicePriceComponent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

