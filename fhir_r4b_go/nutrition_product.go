// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// NutritionProduct
// A food or fluid product that is consumed by patients.
type NutritionProduct struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Status *NutritionProductStatus `json:"status,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Manufacturer []*Reference `json:"manufacturer,omitempty"`
	Nutrient []*NutritionProductNutrient `json:"nutrient,omitempty"`
	Ingredient []*NutritionProductIngredient `json:"ingredient,omitempty"`
	KnownAllergen []*CodeableReference `json:"knownallergen,omitempty"`
	ProductCharacteristic []*NutritionProductProductCharacteristic `json:"productcharacteristic,omitempty"`
	Instance *NutritionProductInstance `json:"instance,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewNutritionProduct creates a new NutritionProduct instance.
func NewNutritionProduct() *NutritionProduct {
	return &NutritionProduct{}
}

// UnmarshalJSON populates NutritionProduct from JSON data.
func (m *NutritionProduct) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Status *NutritionProductStatus `json:"status,omitempty"`
		Category []*CodeableConcept `json:"category,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Manufacturer []*Reference `json:"manufacturer,omitempty"`
		Nutrient []*NutritionProductNutrient `json:"nutrient,omitempty"`
		Ingredient []*NutritionProductIngredient `json:"ingredient,omitempty"`
		KnownAllergen []*CodeableReference `json:"knownallergen,omitempty"`
		ProductCharacteristic []*NutritionProductProductCharacteristic `json:"productcharacteristic,omitempty"`
		Instance *NutritionProductInstance `json:"instance,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Status = temp.Status
	m.Category = temp.Category
	m.Code = temp.Code
	m.Manufacturer = temp.Manufacturer
	m.Nutrient = temp.Nutrient
	m.Ingredient = temp.Ingredient
	m.KnownAllergen = temp.KnownAllergen
	m.ProductCharacteristic = temp.ProductCharacteristic
	m.Instance = temp.Instance
	m.Note = temp.Note
	return nil
}

// MarshalJSON converts NutritionProduct to JSON data.
func (m *NutritionProduct) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Status *NutritionProductStatus `json:"status,omitempty"`
		Category []*CodeableConcept `json:"category,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Manufacturer []*Reference `json:"manufacturer,omitempty"`
		Nutrient []*NutritionProductNutrient `json:"nutrient,omitempty"`
		Ingredient []*NutritionProductIngredient `json:"ingredient,omitempty"`
		KnownAllergen []*CodeableReference `json:"knownallergen,omitempty"`
		ProductCharacteristic []*NutritionProductProductCharacteristic `json:"productcharacteristic,omitempty"`
		Instance *NutritionProductInstance `json:"instance,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Status = m.Status
	output.Category = m.Category
	output.Code = m.Code
	output.Manufacturer = m.Manufacturer
	output.Nutrient = m.Nutrient
	output.Ingredient = m.Ingredient
	output.KnownAllergen = m.KnownAllergen
	output.ProductCharacteristic = m.ProductCharacteristic
	output.Instance = m.Instance
	output.Note = m.Note
	return json.Marshal(output)
}

// Clone creates a deep copy of NutritionProduct.
func (m *NutritionProduct) Clone() *NutritionProduct {
	if m == nil { return nil }
	return &NutritionProduct{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Status: m.Status.Clone(),
		Category: cloneSlices(m.Category),
		Code: m.Code.Clone(),
		Manufacturer: cloneSlices(m.Manufacturer),
		Nutrient: cloneSlices(m.Nutrient),
		Ingredient: cloneSlices(m.Ingredient),
		KnownAllergen: cloneSlices(m.KnownAllergen),
		ProductCharacteristic: cloneSlices(m.ProductCharacteristic),
		Instance: m.Instance.Clone(),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks equality between two NutritionProduct instances.
func (m *NutritionProduct) Equals(other *NutritionProduct) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.Manufacturer, other.Manufacturer) { return false }
	if !compareSlices(m.Nutrient, other.Nutrient) { return false }
	if !compareSlices(m.Ingredient, other.Ingredient) { return false }
	if !compareSlices(m.KnownAllergen, other.KnownAllergen) { return false }
	if !compareSlices(m.ProductCharacteristic, other.ProductCharacteristic) { return false }
	if !m.Instance.Equals(other.Instance) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// NutritionProductNutrient
// The product's nutritional information expressed by the nutrients.
type NutritionProductNutrient struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Item *CodeableReference `json:"item,omitempty"`
	Amount []*Ratio `json:"amount,omitempty"`
}

// NewNutritionProductNutrient creates a new NutritionProductNutrient instance.
func NewNutritionProductNutrient() *NutritionProductNutrient {
	return &NutritionProductNutrient{}
}

// UnmarshalJSON populates NutritionProductNutrient from JSON data.
func (m *NutritionProductNutrient) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Item *CodeableReference `json:"item,omitempty"`
		Amount []*Ratio `json:"amount,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Item = temp.Item
	m.Amount = temp.Amount
	return nil
}

// MarshalJSON converts NutritionProductNutrient to JSON data.
func (m *NutritionProductNutrient) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Item *CodeableReference `json:"item,omitempty"`
		Amount []*Ratio `json:"amount,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Item = m.Item
	output.Amount = m.Amount
	return json.Marshal(output)
}

// Clone creates a deep copy of NutritionProductNutrient.
func (m *NutritionProductNutrient) Clone() *NutritionProductNutrient {
	if m == nil { return nil }
	return &NutritionProductNutrient{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Item: m.Item.Clone(),
		Amount: cloneSlices(m.Amount),
	}
}

// Equals checks equality between two NutritionProductNutrient instances.
func (m *NutritionProductNutrient) Equals(other *NutritionProductNutrient) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Item.Equals(other.Item) { return false }
	if !compareSlices(m.Amount, other.Amount) { return false }
	return true
}

// NutritionProductIngredient
// Ingredients contained in this product.
type NutritionProductIngredient struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Item *CodeableReference `json:"item,omitempty"`
	Amount []*Ratio `json:"amount,omitempty"`
}

// NewNutritionProductIngredient creates a new NutritionProductIngredient instance.
func NewNutritionProductIngredient() *NutritionProductIngredient {
	return &NutritionProductIngredient{}
}

// UnmarshalJSON populates NutritionProductIngredient from JSON data.
func (m *NutritionProductIngredient) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Item *CodeableReference `json:"item,omitempty"`
		Amount []*Ratio `json:"amount,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Item = temp.Item
	m.Amount = temp.Amount
	return nil
}

// MarshalJSON converts NutritionProductIngredient to JSON data.
func (m *NutritionProductIngredient) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Item *CodeableReference `json:"item,omitempty"`
		Amount []*Ratio `json:"amount,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Item = m.Item
	output.Amount = m.Amount
	return json.Marshal(output)
}

// Clone creates a deep copy of NutritionProductIngredient.
func (m *NutritionProductIngredient) Clone() *NutritionProductIngredient {
	if m == nil { return nil }
	return &NutritionProductIngredient{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Item: m.Item.Clone(),
		Amount: cloneSlices(m.Amount),
	}
}

// Equals checks equality between two NutritionProductIngredient instances.
func (m *NutritionProductIngredient) Equals(other *NutritionProductIngredient) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Item.Equals(other.Item) { return false }
	if !compareSlices(m.Amount, other.Amount) { return false }
	return true
}

// NutritionProductProductCharacteristic
// Specifies descriptive properties of the nutrition product.
type NutritionProductProductCharacteristic struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
}

// NewNutritionProductProductCharacteristic creates a new NutritionProductProductCharacteristic instance.
func NewNutritionProductProductCharacteristic() *NutritionProductProductCharacteristic {
	return &NutritionProductProductCharacteristic{}
}

// UnmarshalJSON populates NutritionProductProductCharacteristic from JSON data.
func (m *NutritionProductProductCharacteristic) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueString *FhirString `json:"valuestring,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
		ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.ValueCodeableConcept = temp.ValueCodeableConcept
	m.ValueString = temp.ValueString
	m.ValueQuantity = temp.ValueQuantity
	m.ValueBase64Binary = temp.ValueBase64Binary
	m.ValueAttachment = temp.ValueAttachment
	m.ValueBoolean = temp.ValueBoolean
	return nil
}

// MarshalJSON converts NutritionProductProductCharacteristic to JSON data.
func (m *NutritionProductProductCharacteristic) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueString interface{} `json:"valuestring,omitempty"`
		ValueStringElement map[string]interface{} `json:"_valuestring,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueBase64Binary interface{} `json:"valuebase64binary,omitempty"`
		ValueBase64BinaryElement map[string]interface{} `json:"_valuebase64binary,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
		ValueBoolean interface{} `json:"valueboolean,omitempty"`
		ValueBooleanElement map[string]interface{} `json:"_valueboolean,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.ValueCodeableConcept = m.ValueCodeableConcept
	if m.ValueString != nil && m.ValueString.Value != nil {
		output.ValueString = m.ValueString.Value
		if m.ValueString.Element != nil {
			output.ValueStringElement = toMapOrNil(m.ValueString.Element.MarshalJSON())
		}
	}
	output.ValueQuantity = m.ValueQuantity
	if m.ValueBase64Binary != nil && m.ValueBase64Binary.Value != nil {
		output.ValueBase64Binary = m.ValueBase64Binary.Value
		if m.ValueBase64Binary.Element != nil {
			output.ValueBase64BinaryElement = toMapOrNil(m.ValueBase64Binary.Element.MarshalJSON())
		}
	}
	output.ValueAttachment = m.ValueAttachment
	if m.ValueBoolean != nil && m.ValueBoolean.Value != nil {
		output.ValueBoolean = m.ValueBoolean.Value
		if m.ValueBoolean.Element != nil {
			output.ValueBooleanElement = toMapOrNil(m.ValueBoolean.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of NutritionProductProductCharacteristic.
func (m *NutritionProductProductCharacteristic) Clone() *NutritionProductProductCharacteristic {
	if m == nil { return nil }
	return &NutritionProductProductCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
	}
}

// Equals checks equality between two NutritionProductProductCharacteristic instances.
func (m *NutritionProductProductCharacteristic) Equals(other *NutritionProductProductCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	return true
}

// NutritionProductInstance
// Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product.
type NutritionProductInstance struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	LotNumber *FhirString `json:"lotnumber,omitempty"`
	Expiry *FhirDateTime `json:"expiry,omitempty"`
	UseBy *FhirDateTime `json:"useby,omitempty"`
}

// NewNutritionProductInstance creates a new NutritionProductInstance instance.
func NewNutritionProductInstance() *NutritionProductInstance {
	return &NutritionProductInstance{}
}

// UnmarshalJSON populates NutritionProductInstance from JSON data.
func (m *NutritionProductInstance) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		LotNumber *FhirString `json:"lotnumber,omitempty"`
		Expiry *FhirDateTime `json:"expiry,omitempty"`
		UseBy *FhirDateTime `json:"useby,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Quantity = temp.Quantity
	m.Identifier = temp.Identifier
	m.LotNumber = temp.LotNumber
	m.Expiry = temp.Expiry
	m.UseBy = temp.UseBy
	return nil
}

// MarshalJSON converts NutritionProductInstance to JSON data.
func (m *NutritionProductInstance) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		LotNumber interface{} `json:"lotnumber,omitempty"`
		LotNumberElement map[string]interface{} `json:"_lotnumber,omitempty"`
		Expiry interface{} `json:"expiry,omitempty"`
		ExpiryElement map[string]interface{} `json:"_expiry,omitempty"`
		UseBy interface{} `json:"useby,omitempty"`
		UseByElement map[string]interface{} `json:"_useby,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Quantity = m.Quantity
	output.Identifier = m.Identifier
	if m.LotNumber != nil && m.LotNumber.Value != nil {
		output.LotNumber = m.LotNumber.Value
		if m.LotNumber.Element != nil {
			output.LotNumberElement = toMapOrNil(m.LotNumber.Element.MarshalJSON())
		}
	}
	if m.Expiry != nil && m.Expiry.Value != nil {
		output.Expiry = m.Expiry.Value
		if m.Expiry.Element != nil {
			output.ExpiryElement = toMapOrNil(m.Expiry.Element.MarshalJSON())
		}
	}
	if m.UseBy != nil && m.UseBy.Value != nil {
		output.UseBy = m.UseBy.Value
		if m.UseBy.Element != nil {
			output.UseByElement = toMapOrNil(m.UseBy.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of NutritionProductInstance.
func (m *NutritionProductInstance) Clone() *NutritionProductInstance {
	if m == nil { return nil }
	return &NutritionProductInstance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Quantity: m.Quantity.Clone(),
		Identifier: cloneSlices(m.Identifier),
		LotNumber: m.LotNumber.Clone(),
		Expiry: m.Expiry.Clone(),
		UseBy: m.UseBy.Clone(),
	}
}

// Equals checks equality between two NutritionProductInstance instances.
func (m *NutritionProductInstance) Equals(other *NutritionProductInstance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.LotNumber.Equals(other.LotNumber) { return false }
	if !m.Expiry.Equals(other.Expiry) { return false }
	if !m.UseBy.Equals(other.UseBy) { return false }
	return true
}

