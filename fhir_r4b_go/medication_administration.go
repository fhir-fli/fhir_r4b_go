// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// MedicationAdministration
// Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
type MedicationAdministration struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Instantiates []*FhirUri `json:"instantiates,omitempty"`
	PartOf []*Reference `json:"partof,omitempty"`
	Status *MedicationAdministrationStatusCodes `json:"status,omitempty"`
	StatusReason []*CodeableConcept `json:"statusreason,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	MedicationCodeableConcept *CodeableConcept `json:"medicationcodeableconcept,omitempty"`
	MedicationReference *Reference `json:"medicationreference,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Context *Reference `json:"context,omitempty"`
	SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
	EffectiveDateTime *FhirDateTime `json:"effectivedatetime,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	Performer []*MedicationAdministrationPerformer `json:"performer,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	Request *Reference `json:"request,omitempty"`
	Device []*Reference `json:"device,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Dosage *MedicationAdministrationDosage `json:"dosage,omitempty"`
	EventHistory []*Reference `json:"eventhistory,omitempty"`
}

// NewMedicationAdministration creates a new MedicationAdministration instance.
func NewMedicationAdministration() *MedicationAdministration {
	return &MedicationAdministration{}
}

// FromJSON populates MedicationAdministration from JSON data.
func (m *MedicationAdministration) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Instantiates []interface{} `json:"instantiates,omitempty"`
		PartOf []*Reference `json:"partof,omitempty"`
		Status *MedicationAdministrationStatusCodes `json:"status,omitempty"`
		StatusReason []*CodeableConcept `json:"statusreason,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		MedicationCodeableConcept *CodeableConcept `json:"medicationcodeableconcept,omitempty"`
		MedicationReference *Reference `json:"medicationreference,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Context *Reference `json:"context,omitempty"`
		SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
		EffectiveDateTime *FhirDateTime `json:"effectivedatetime,omitempty"`
		EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
		Performer []*MedicationAdministrationPerformer `json:"performer,omitempty"`
		ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
		ReasonReference []*Reference `json:"reasonreference,omitempty"`
		Request *Reference `json:"request,omitempty"`
		Device []*Reference `json:"device,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Dosage *MedicationAdministrationDosage `json:"dosage,omitempty"`
		EventHistory []*Reference `json:"eventhistory,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	if len(temp.Instantiates) > 0 {
		m.Instantiates = make([]*FhirUri, len(temp.Instantiates))
		for i := range temp.Instantiates {
			itemMap, ok := temp.Instantiates[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Instantiates[%d]: expected map", i) }
			primitive, err := NewFhirUriFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Instantiates[%d]: %v", i, err) }
			m.Instantiates[i] = primitive
		}
	}
	m.PartOf = temp.PartOf
	m.Status = temp.Status
	m.StatusReason = temp.StatusReason
	m.Category = temp.Category
	m.MedicationCodeableConcept = temp.MedicationCodeableConcept
	m.MedicationReference = temp.MedicationReference
	m.Subject = temp.Subject
	m.Context = temp.Context
	m.SupportingInformation = temp.SupportingInformation
	m.EffectiveDateTime = temp.EffectiveDateTime
	m.EffectivePeriod = temp.EffectivePeriod
	m.Performer = temp.Performer
	m.ReasonCode = temp.ReasonCode
	m.ReasonReference = temp.ReasonReference
	m.Request = temp.Request
	m.Device = temp.Device
	m.Note = temp.Note
	m.Dosage = temp.Dosage
	m.EventHistory = temp.EventHistory
	return nil
}

// ToJSON converts MedicationAdministration to JSON data.
func (m *MedicationAdministration) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Instantiates []interface{} `json:"instantiates,omitempty"`
		InstantiatesElement []map[string]interface{} `json:"_instantiates,omitempty"`
		PartOf []*Reference `json:"partof,omitempty"`
		Status *MedicationAdministrationStatusCodes `json:"status,omitempty"`
		StatusReason []*CodeableConcept `json:"statusreason,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		MedicationCodeableConcept *CodeableConcept `json:"medicationcodeableconcept,omitempty"`
		MedicationReference *Reference `json:"medicationreference,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Context *Reference `json:"context,omitempty"`
		SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
		EffectiveDateTime interface{} `json:"effectivedatetime,omitempty"`
		EffectiveDateTimeElement map[string]interface{} `json:"_effectivedatetime,omitempty"`
		EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
		Performer []*MedicationAdministrationPerformer `json:"performer,omitempty"`
		ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
		ReasonReference []*Reference `json:"reasonreference,omitempty"`
		Request *Reference `json:"request,omitempty"`
		Device []*Reference `json:"device,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Dosage *MedicationAdministrationDosage `json:"dosage,omitempty"`
		EventHistory []*Reference `json:"eventhistory,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.ToJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	if len(m.Instantiates) > 0 {
		output.Instantiates = make([]interface{}, len(m.Instantiates))
		output.InstantiatesElement = make([]map[string]interface{}, len(m.Instantiates))
		for i, item := range m.Instantiates {
			if item != nil && item.Value != nil {
				output.Instantiates[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.InstantiatesElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.PartOf = m.PartOf
	output.Status = m.Status
	output.StatusReason = m.StatusReason
	output.Category = m.Category
	output.MedicationCodeableConcept = m.MedicationCodeableConcept
	output.MedicationReference = m.MedicationReference
	output.Subject = m.Subject
	output.Context = m.Context
	output.SupportingInformation = m.SupportingInformation
	if m.EffectiveDateTime != nil && m.EffectiveDateTime.Value != nil {
		output.EffectiveDateTime = m.EffectiveDateTime.Value
		if m.EffectiveDateTime.Element != nil {
			output.EffectiveDateTimeElement = toMapOrNil(m.EffectiveDateTime.Element.ToJSON())
		}
	}
	output.EffectivePeriod = m.EffectivePeriod
	output.Performer = m.Performer
	output.ReasonCode = m.ReasonCode
	output.ReasonReference = m.ReasonReference
	output.Request = m.Request
	output.Device = m.Device
	output.Note = m.Note
	output.Dosage = m.Dosage
	output.EventHistory = m.EventHistory
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationAdministration.
func (m *MedicationAdministration) Clone() *MedicationAdministration {
	if m == nil { return nil }
	return &MedicationAdministration{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Instantiates: cloneSlices(m.Instantiates),
		PartOf: cloneSlices(m.PartOf),
		Status: m.Status.Clone(),
		StatusReason: cloneSlices(m.StatusReason),
		Category: m.Category.Clone(),
		MedicationCodeableConcept: m.MedicationCodeableConcept.Clone(),
		MedicationReference: m.MedicationReference.Clone(),
		Subject: m.Subject.Clone(),
		Context: m.Context.Clone(),
		SupportingInformation: cloneSlices(m.SupportingInformation),
		EffectiveDateTime: m.EffectiveDateTime.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		Performer: cloneSlices(m.Performer),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		Request: m.Request.Clone(),
		Device: cloneSlices(m.Device),
		Note: cloneSlices(m.Note),
		Dosage: m.Dosage.Clone(),
		EventHistory: cloneSlices(m.EventHistory),
	}
}

// Equals checks equality between two MedicationAdministration instances.
func (m *MedicationAdministration) Equals(other *MedicationAdministration) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.Instantiates, other.Instantiates) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.StatusReason, other.StatusReason) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.MedicationCodeableConcept.Equals(other.MedicationCodeableConcept) { return false }
	if !m.MedicationReference.Equals(other.MedicationReference) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Context.Equals(other.Context) { return false }
	if !compareSlices(m.SupportingInformation, other.SupportingInformation) { return false }
	if !m.EffectiveDateTime.Equals(other.EffectiveDateTime) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !m.Request.Equals(other.Request) { return false }
	if !compareSlices(m.Device, other.Device) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Dosage.Equals(other.Dosage) { return false }
	if !compareSlices(m.EventHistory, other.EventHistory) { return false }
	return true
}

// MedicationAdministrationPerformer
// Indicates who or what performed the medication administration and how they were involved.
type MedicationAdministrationPerformer struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Function_ *CodeableConcept `json:"function,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewMedicationAdministrationPerformer creates a new MedicationAdministrationPerformer instance.
func NewMedicationAdministrationPerformer() *MedicationAdministrationPerformer {
	return &MedicationAdministrationPerformer{}
}

// FromJSON populates MedicationAdministrationPerformer from JSON data.
func (m *MedicationAdministrationPerformer) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Function_ *CodeableConcept `json:"function,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Function_ = temp.Function_
	m.Actor = temp.Actor
	return nil
}

// ToJSON converts MedicationAdministrationPerformer to JSON data.
func (m *MedicationAdministrationPerformer) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Function_ *CodeableConcept `json:"function,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Function_ = m.Function_
	output.Actor = m.Actor
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationAdministrationPerformer.
func (m *MedicationAdministrationPerformer) Clone() *MedicationAdministrationPerformer {
	if m == nil { return nil }
	return &MedicationAdministrationPerformer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Function_: m.Function_.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks equality between two MedicationAdministrationPerformer instances.
func (m *MedicationAdministrationPerformer) Equals(other *MedicationAdministrationPerformer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Function_.Equals(other.Function_) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

// MedicationAdministrationDosage
// Describes the medication dosage information details e.g. dose, rate, site, route, etc.
type MedicationAdministrationDosage struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	Site *CodeableConcept `json:"site,omitempty"`
	Route *CodeableConcept `json:"route,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	Dose *Quantity `json:"dose,omitempty"`
	RateRatio *Ratio `json:"rateratio,omitempty"`
	RateQuantity *Quantity `json:"ratequantity,omitempty"`
}

// NewMedicationAdministrationDosage creates a new MedicationAdministrationDosage instance.
func NewMedicationAdministrationDosage() *MedicationAdministrationDosage {
	return &MedicationAdministrationDosage{}
}

// FromJSON populates MedicationAdministrationDosage from JSON data.
func (m *MedicationAdministrationDosage) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Text *FhirString `json:"text,omitempty"`
		Site *CodeableConcept `json:"site,omitempty"`
		Route *CodeableConcept `json:"route,omitempty"`
		Method *CodeableConcept `json:"method,omitempty"`
		Dose *Quantity `json:"dose,omitempty"`
		RateRatio *Ratio `json:"rateratio,omitempty"`
		RateQuantity *Quantity `json:"ratequantity,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Text = temp.Text
	m.Site = temp.Site
	m.Route = temp.Route
	m.Method = temp.Method
	m.Dose = temp.Dose
	m.RateRatio = temp.RateRatio
	m.RateQuantity = temp.RateQuantity
	return nil
}

// ToJSON converts MedicationAdministrationDosage to JSON data.
func (m *MedicationAdministrationDosage) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Text interface{} `json:"text,omitempty"`
		TextElement map[string]interface{} `json:"_text,omitempty"`
		Site *CodeableConcept `json:"site,omitempty"`
		Route *CodeableConcept `json:"route,omitempty"`
		Method *CodeableConcept `json:"method,omitempty"`
		Dose *Quantity `json:"dose,omitempty"`
		RateRatio *Ratio `json:"rateratio,omitempty"`
		RateQuantity *Quantity `json:"ratequantity,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Text != nil && m.Text.Value != nil {
		output.Text = m.Text.Value
		if m.Text.Element != nil {
			output.TextElement = toMapOrNil(m.Text.Element.ToJSON())
		}
	}
	output.Site = m.Site
	output.Route = m.Route
	output.Method = m.Method
	output.Dose = m.Dose
	output.RateRatio = m.RateRatio
	output.RateQuantity = m.RateQuantity
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationAdministrationDosage.
func (m *MedicationAdministrationDosage) Clone() *MedicationAdministrationDosage {
	if m == nil { return nil }
	return &MedicationAdministrationDosage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Text: m.Text.Clone(),
		Site: m.Site.Clone(),
		Route: m.Route.Clone(),
		Method: m.Method.Clone(),
		Dose: m.Dose.Clone(),
		RateRatio: m.RateRatio.Clone(),
		RateQuantity: m.RateQuantity.Clone(),
	}
}

// Equals checks equality between two MedicationAdministrationDosage instances.
func (m *MedicationAdministrationDosage) Equals(other *MedicationAdministrationDosage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !m.Site.Equals(other.Site) { return false }
	if !m.Route.Equals(other.Route) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Dose.Equals(other.Dose) { return false }
	if !m.RateRatio.Equals(other.RateRatio) { return false }
	if !m.RateQuantity.Equals(other.RateQuantity) { return false }
	return true
}

