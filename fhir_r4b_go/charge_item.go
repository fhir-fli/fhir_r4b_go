// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// ChargeItem
// The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.
type ChargeItem struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	DefinitionUri []*FhirUri `json:"definitionuri,omitempty"`
	DefinitionCanonical []*FhirCanonical `json:"definitioncanonical,omitempty"`
	Status *ChargeItemStatus `json:"status,omitempty"`
	PartOf []*Reference `json:"partof,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Context *Reference `json:"context,omitempty"`
	OccurrenceDateTime *FhirDateTime `json:"occurrencedatetime,omitempty"`
	OccurrencePeriod *Period `json:"occurrenceperiod,omitempty"`
	OccurrenceTiming *Timing `json:"occurrencetiming,omitempty"`
	Performer []*ChargeItemPerformer `json:"performer,omitempty"`
	PerformingOrganization *Reference `json:"performingorganization,omitempty"`
	RequestingOrganization *Reference `json:"requestingorganization,omitempty"`
	CostCenter *Reference `json:"costcenter,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Bodysite []*CodeableConcept `json:"bodysite,omitempty"`
	FactorOverride *FhirDecimal `json:"factoroverride,omitempty"`
	PriceOverride *Money `json:"priceoverride,omitempty"`
	OverrideReason *FhirString `json:"overridereason,omitempty"`
	Enterer *Reference `json:"enterer,omitempty"`
	EnteredDate *FhirDateTime `json:"entereddate,omitempty"`
	Reason []*CodeableConcept `json:"reason,omitempty"`
	Service []*Reference `json:"service,omitempty"`
	ProductReference *Reference `json:"productreference,omitempty"`
	ProductCodeableConcept *CodeableConcept `json:"productcodeableconcept,omitempty"`
	Account []*Reference `json:"account,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
}

// NewChargeItem creates a new ChargeItem instance.
func NewChargeItem() *ChargeItem {
	return &ChargeItem{}
}

// UnmarshalJSON populates ChargeItem from JSON data.
func (m *ChargeItem) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		DefinitionUri []interface{} `json:"definitionuri,omitempty"`
		DefinitionCanonical []interface{} `json:"definitioncanonical,omitempty"`
		Status *ChargeItemStatus `json:"status,omitempty"`
		PartOf []*Reference `json:"partof,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Context *Reference `json:"context,omitempty"`
		OccurrenceDateTime *FhirDateTime `json:"occurrencedatetime,omitempty"`
		OccurrencePeriod *Period `json:"occurrenceperiod,omitempty"`
		OccurrenceTiming *Timing `json:"occurrencetiming,omitempty"`
		Performer []*ChargeItemPerformer `json:"performer,omitempty"`
		PerformingOrganization *Reference `json:"performingorganization,omitempty"`
		RequestingOrganization *Reference `json:"requestingorganization,omitempty"`
		CostCenter *Reference `json:"costcenter,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Bodysite []*CodeableConcept `json:"bodysite,omitempty"`
		FactorOverride *FhirDecimal `json:"factoroverride,omitempty"`
		PriceOverride *Money `json:"priceoverride,omitempty"`
		OverrideReason *FhirString `json:"overridereason,omitempty"`
		Enterer *Reference `json:"enterer,omitempty"`
		EnteredDate *FhirDateTime `json:"entereddate,omitempty"`
		Reason []*CodeableConcept `json:"reason,omitempty"`
		Service []*Reference `json:"service,omitempty"`
		ProductReference *Reference `json:"productreference,omitempty"`
		ProductCodeableConcept *CodeableConcept `json:"productcodeableconcept,omitempty"`
		Account []*Reference `json:"account,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	if len(temp.DefinitionUri) > 0 {
		m.DefinitionUri = make([]*FhirUri, len(temp.DefinitionUri))
		for i := range temp.DefinitionUri {
			itemMap, ok := temp.DefinitionUri[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for DefinitionUri[%d]: expected map", i) }
			primitive, err := NewFhirUriFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse DefinitionUri[%d]: %v", i, err) }
			m.DefinitionUri[i] = primitive
		}
	}
	if len(temp.DefinitionCanonical) > 0 {
		m.DefinitionCanonical = make([]*FhirCanonical, len(temp.DefinitionCanonical))
		for i := range temp.DefinitionCanonical {
			itemMap, ok := temp.DefinitionCanonical[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for DefinitionCanonical[%d]: expected map", i) }
			primitive, err := NewFhirCanonicalFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse DefinitionCanonical[%d]: %v", i, err) }
			m.DefinitionCanonical[i] = primitive
		}
	}
	m.Status = temp.Status
	m.PartOf = temp.PartOf
	m.Code = temp.Code
	m.Subject = temp.Subject
	m.Context = temp.Context
	m.OccurrenceDateTime = temp.OccurrenceDateTime
	m.OccurrencePeriod = temp.OccurrencePeriod
	m.OccurrenceTiming = temp.OccurrenceTiming
	m.Performer = temp.Performer
	m.PerformingOrganization = temp.PerformingOrganization
	m.RequestingOrganization = temp.RequestingOrganization
	m.CostCenter = temp.CostCenter
	m.Quantity = temp.Quantity
	m.Bodysite = temp.Bodysite
	m.FactorOverride = temp.FactorOverride
	m.PriceOverride = temp.PriceOverride
	m.OverrideReason = temp.OverrideReason
	m.Enterer = temp.Enterer
	m.EnteredDate = temp.EnteredDate
	m.Reason = temp.Reason
	m.Service = temp.Service
	m.ProductReference = temp.ProductReference
	m.ProductCodeableConcept = temp.ProductCodeableConcept
	m.Account = temp.Account
	m.Note = temp.Note
	m.SupportingInformation = temp.SupportingInformation
	return nil
}

// MarshalJSON converts ChargeItem to JSON data.
func (m *ChargeItem) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		DefinitionUri []interface{} `json:"definitionuri,omitempty"`
		DefinitionUriElement []map[string]interface{} `json:"_definitionuri,omitempty"`
		DefinitionCanonical []interface{} `json:"definitioncanonical,omitempty"`
		DefinitionCanonicalElement []map[string]interface{} `json:"_definitioncanonical,omitempty"`
		Status *ChargeItemStatus `json:"status,omitempty"`
		PartOf []*Reference `json:"partof,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Context *Reference `json:"context,omitempty"`
		OccurrenceDateTime interface{} `json:"occurrencedatetime,omitempty"`
		OccurrenceDateTimeElement map[string]interface{} `json:"_occurrencedatetime,omitempty"`
		OccurrencePeriod *Period `json:"occurrenceperiod,omitempty"`
		OccurrenceTiming *Timing `json:"occurrencetiming,omitempty"`
		Performer []*ChargeItemPerformer `json:"performer,omitempty"`
		PerformingOrganization *Reference `json:"performingorganization,omitempty"`
		RequestingOrganization *Reference `json:"requestingorganization,omitempty"`
		CostCenter *Reference `json:"costcenter,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Bodysite []*CodeableConcept `json:"bodysite,omitempty"`
		FactorOverride interface{} `json:"factoroverride,omitempty"`
		FactorOverrideElement map[string]interface{} `json:"_factoroverride,omitempty"`
		PriceOverride *Money `json:"priceoverride,omitempty"`
		OverrideReason interface{} `json:"overridereason,omitempty"`
		OverrideReasonElement map[string]interface{} `json:"_overridereason,omitempty"`
		Enterer *Reference `json:"enterer,omitempty"`
		EnteredDate interface{} `json:"entereddate,omitempty"`
		EnteredDateElement map[string]interface{} `json:"_entereddate,omitempty"`
		Reason []*CodeableConcept `json:"reason,omitempty"`
		Service []*Reference `json:"service,omitempty"`
		ProductReference *Reference `json:"productreference,omitempty"`
		ProductCodeableConcept *CodeableConcept `json:"productcodeableconcept,omitempty"`
		Account []*Reference `json:"account,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	if len(m.DefinitionUri) > 0 {
		output.DefinitionUri = make([]interface{}, len(m.DefinitionUri))
		output.DefinitionUriElement = make([]map[string]interface{}, len(m.DefinitionUri))
		for i, item := range m.DefinitionUri {
			if item != nil && item.Value != nil {
				output.DefinitionUri[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.DefinitionUriElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	if len(m.DefinitionCanonical) > 0 {
		output.DefinitionCanonical = make([]interface{}, len(m.DefinitionCanonical))
		output.DefinitionCanonicalElement = make([]map[string]interface{}, len(m.DefinitionCanonical))
		for i, item := range m.DefinitionCanonical {
			if item != nil && item.Value != nil {
				output.DefinitionCanonical[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.DefinitionCanonicalElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	output.Status = m.Status
	output.PartOf = m.PartOf
	output.Code = m.Code
	output.Subject = m.Subject
	output.Context = m.Context
	if m.OccurrenceDateTime != nil && m.OccurrenceDateTime.Value != nil {
		output.OccurrenceDateTime = m.OccurrenceDateTime.Value
		if m.OccurrenceDateTime.Element != nil {
			output.OccurrenceDateTimeElement = toMapOrNil(m.OccurrenceDateTime.Element.MarshalJSON())
		}
	}
	output.OccurrencePeriod = m.OccurrencePeriod
	output.OccurrenceTiming = m.OccurrenceTiming
	output.Performer = m.Performer
	output.PerformingOrganization = m.PerformingOrganization
	output.RequestingOrganization = m.RequestingOrganization
	output.CostCenter = m.CostCenter
	output.Quantity = m.Quantity
	output.Bodysite = m.Bodysite
	if m.FactorOverride != nil && m.FactorOverride.Value != nil {
		output.FactorOverride = m.FactorOverride.Value
		if m.FactorOverride.Element != nil {
			output.FactorOverrideElement = toMapOrNil(m.FactorOverride.Element.MarshalJSON())
		}
	}
	output.PriceOverride = m.PriceOverride
	if m.OverrideReason != nil && m.OverrideReason.Value != nil {
		output.OverrideReason = m.OverrideReason.Value
		if m.OverrideReason.Element != nil {
			output.OverrideReasonElement = toMapOrNil(m.OverrideReason.Element.MarshalJSON())
		}
	}
	output.Enterer = m.Enterer
	if m.EnteredDate != nil && m.EnteredDate.Value != nil {
		output.EnteredDate = m.EnteredDate.Value
		if m.EnteredDate.Element != nil {
			output.EnteredDateElement = toMapOrNil(m.EnteredDate.Element.MarshalJSON())
		}
	}
	output.Reason = m.Reason
	output.Service = m.Service
	output.ProductReference = m.ProductReference
	output.ProductCodeableConcept = m.ProductCodeableConcept
	output.Account = m.Account
	output.Note = m.Note
	output.SupportingInformation = m.SupportingInformation
	return json.Marshal(output)
}

// Clone creates a deep copy of ChargeItem.
func (m *ChargeItem) Clone() *ChargeItem {
	if m == nil { return nil }
	return &ChargeItem{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		DefinitionUri: cloneSlices(m.DefinitionUri),
		DefinitionCanonical: cloneSlices(m.DefinitionCanonical),
		Status: m.Status.Clone(),
		PartOf: cloneSlices(m.PartOf),
		Code: m.Code.Clone(),
		Subject: m.Subject.Clone(),
		Context: m.Context.Clone(),
		OccurrenceDateTime: m.OccurrenceDateTime.Clone(),
		OccurrencePeriod: m.OccurrencePeriod.Clone(),
		OccurrenceTiming: m.OccurrenceTiming.Clone(),
		Performer: cloneSlices(m.Performer),
		PerformingOrganization: m.PerformingOrganization.Clone(),
		RequestingOrganization: m.RequestingOrganization.Clone(),
		CostCenter: m.CostCenter.Clone(),
		Quantity: m.Quantity.Clone(),
		Bodysite: cloneSlices(m.Bodysite),
		FactorOverride: m.FactorOverride.Clone(),
		PriceOverride: m.PriceOverride.Clone(),
		OverrideReason: m.OverrideReason.Clone(),
		Enterer: m.Enterer.Clone(),
		EnteredDate: m.EnteredDate.Clone(),
		Reason: cloneSlices(m.Reason),
		Service: cloneSlices(m.Service),
		ProductReference: m.ProductReference.Clone(),
		ProductCodeableConcept: m.ProductCodeableConcept.Clone(),
		Account: cloneSlices(m.Account),
		Note: cloneSlices(m.Note),
		SupportingInformation: cloneSlices(m.SupportingInformation),
	}
}

// Equals checks equality between two ChargeItem instances.
func (m *ChargeItem) Equals(other *ChargeItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.DefinitionUri, other.DefinitionUri) { return false }
	if !compareSlices(m.DefinitionCanonical, other.DefinitionCanonical) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Context.Equals(other.Context) { return false }
	if !m.OccurrenceDateTime.Equals(other.OccurrenceDateTime) { return false }
	if !m.OccurrencePeriod.Equals(other.OccurrencePeriod) { return false }
	if !m.OccurrenceTiming.Equals(other.OccurrenceTiming) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !m.PerformingOrganization.Equals(other.PerformingOrganization) { return false }
	if !m.RequestingOrganization.Equals(other.RequestingOrganization) { return false }
	if !m.CostCenter.Equals(other.CostCenter) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !compareSlices(m.Bodysite, other.Bodysite) { return false }
	if !m.FactorOverride.Equals(other.FactorOverride) { return false }
	if !m.PriceOverride.Equals(other.PriceOverride) { return false }
	if !m.OverrideReason.Equals(other.OverrideReason) { return false }
	if !m.Enterer.Equals(other.Enterer) { return false }
	if !m.EnteredDate.Equals(other.EnteredDate) { return false }
	if !compareSlices(m.Reason, other.Reason) { return false }
	if !compareSlices(m.Service, other.Service) { return false }
	if !m.ProductReference.Equals(other.ProductReference) { return false }
	if !m.ProductCodeableConcept.Equals(other.ProductCodeableConcept) { return false }
	if !compareSlices(m.Account, other.Account) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.SupportingInformation, other.SupportingInformation) { return false }
	return true
}

// ChargeItemPerformer
// Indicates who or what performed or participated in the charged service.
type ChargeItemPerformer struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Function_ *CodeableConcept `json:"function,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewChargeItemPerformer creates a new ChargeItemPerformer instance.
func NewChargeItemPerformer() *ChargeItemPerformer {
	return &ChargeItemPerformer{}
}

// UnmarshalJSON populates ChargeItemPerformer from JSON data.
func (m *ChargeItemPerformer) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Function_ *CodeableConcept `json:"function,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Function_ = temp.Function_
	m.Actor = temp.Actor
	return nil
}

// MarshalJSON converts ChargeItemPerformer to JSON data.
func (m *ChargeItemPerformer) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Function_ *CodeableConcept `json:"function,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Function_ = m.Function_
	output.Actor = m.Actor
	return json.Marshal(output)
}

// Clone creates a deep copy of ChargeItemPerformer.
func (m *ChargeItemPerformer) Clone() *ChargeItemPerformer {
	if m == nil { return nil }
	return &ChargeItemPerformer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Function_: m.Function_.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks equality between two ChargeItemPerformer instances.
func (m *ChargeItemPerformer) Equals(other *ChargeItemPerformer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Function_.Equals(other.Function_) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

