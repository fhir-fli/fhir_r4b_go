// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// GraphDefinition
// A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.
type GraphDefinition struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Start *FhirCode `json:"start,omitempty"`
	Profile *FhirCanonical `json:"profile,omitempty"`
	Link []*GraphDefinitionLink `json:"link,omitempty"`
}

// NewGraphDefinition creates a new GraphDefinition instance
func NewGraphDefinition() *GraphDefinition {
	return &GraphDefinition{}
}

// FromJSON populates GraphDefinition from JSON data
func (m *GraphDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts GraphDefinition to JSON data
func (m *GraphDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of GraphDefinition
func (m *GraphDefinition) Clone() *GraphDefinition {
	if m == nil { return nil }
	return &GraphDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Start: m.Start.Clone(),
		Profile: m.Profile.Clone(),
		Link: cloneSlices(m.Link),
	}
}

// Equals checks for equality with another GraphDefinition instance
func (m *GraphDefinition) Equals(other *GraphDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Start.Equals(other.Start) { return false }
	if !m.Profile.Equals(other.Profile) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	return true
}

// GraphDefinitionLink
// Links this graph makes rules about.
type GraphDefinitionLink struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	SliceName *FhirString `json:"slicename,omitempty"`
	Min *FhirInteger `json:"min,omitempty"`
	Max *FhirString `json:"max,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Target []*GraphDefinitionTarget `json:"target,omitempty"`
}

// NewGraphDefinitionLink creates a new GraphDefinitionLink instance
func NewGraphDefinitionLink() *GraphDefinitionLink {
	return &GraphDefinitionLink{}
}

// FromJSON populates GraphDefinitionLink from JSON data
func (m *GraphDefinitionLink) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts GraphDefinitionLink to JSON data
func (m *GraphDefinitionLink) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of GraphDefinitionLink
func (m *GraphDefinitionLink) Clone() *GraphDefinitionLink {
	if m == nil { return nil }
	return &GraphDefinitionLink{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Path: m.Path.Clone(),
		SliceName: m.SliceName.Clone(),
		Min: m.Min.Clone(),
		Max: m.Max.Clone(),
		Description: m.Description.Clone(),
		Target: cloneSlices(m.Target),
	}
}

// Equals checks for equality with another GraphDefinitionLink instance
func (m *GraphDefinitionLink) Equals(other *GraphDefinitionLink) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !m.SliceName.Equals(other.SliceName) { return false }
	if !m.Min.Equals(other.Min) { return false }
	if !m.Max.Equals(other.Max) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Target, other.Target) { return false }
	return true
}

// GraphDefinitionTarget
// Potential target for the link.
type GraphDefinitionTarget struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *FhirCode `json:"type,omitempty"`
	Params *FhirString `json:"params,omitempty"`
	Profile *FhirCanonical `json:"profile,omitempty"`
	Compartment []*GraphDefinitionCompartment `json:"compartment,omitempty"`
	Link []*GraphDefinitionLink `json:"link,omitempty"`
}

// NewGraphDefinitionTarget creates a new GraphDefinitionTarget instance
func NewGraphDefinitionTarget() *GraphDefinitionTarget {
	return &GraphDefinitionTarget{}
}

// FromJSON populates GraphDefinitionTarget from JSON data
func (m *GraphDefinitionTarget) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts GraphDefinitionTarget to JSON data
func (m *GraphDefinitionTarget) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of GraphDefinitionTarget
func (m *GraphDefinitionTarget) Clone() *GraphDefinitionTarget {
	if m == nil { return nil }
	return &GraphDefinitionTarget{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Params: m.Params.Clone(),
		Profile: m.Profile.Clone(),
		Compartment: cloneSlices(m.Compartment),
		Link: cloneSlices(m.Link),
	}
}

// Equals checks for equality with another GraphDefinitionTarget instance
func (m *GraphDefinitionTarget) Equals(other *GraphDefinitionTarget) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Params.Equals(other.Params) { return false }
	if !m.Profile.Equals(other.Profile) { return false }
	if !compareSlices(m.Compartment, other.Compartment) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	return true
}

// GraphDefinitionCompartment
// Compartment Consistency Rules.
type GraphDefinitionCompartment struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Use *GraphCompartmentUse `json:"use,omitempty"`
	Code *CompartmentType `json:"code,omitempty"`
	Rule *GraphCompartmentRule `json:"rule,omitempty"`
	Expression *FhirString `json:"expression,omitempty"`
	Description *FhirString `json:"description,omitempty"`
}

// NewGraphDefinitionCompartment creates a new GraphDefinitionCompartment instance
func NewGraphDefinitionCompartment() *GraphDefinitionCompartment {
	return &GraphDefinitionCompartment{}
}

// FromJSON populates GraphDefinitionCompartment from JSON data
func (m *GraphDefinitionCompartment) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts GraphDefinitionCompartment to JSON data
func (m *GraphDefinitionCompartment) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of GraphDefinitionCompartment
func (m *GraphDefinitionCompartment) Clone() *GraphDefinitionCompartment {
	if m == nil { return nil }
	return &GraphDefinitionCompartment{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Use: m.Use.Clone(),
		Code: m.Code.Clone(),
		Rule: m.Rule.Clone(),
		Expression: m.Expression.Clone(),
		Description: m.Description.Clone(),
	}
}

// Equals checks for equality with another GraphDefinitionCompartment instance
func (m *GraphDefinitionCompartment) Equals(other *GraphDefinitionCompartment) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Rule.Equals(other.Rule) { return false }
	if !m.Expression.Equals(other.Expression) { return false }
	if !m.Description.Equals(other.Description) { return false }
	return true
}

