// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// Timing
// Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
type Timing struct {
	extends BackboneType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Event []*FhirDateTime `json:"event,omitempty"`
	Repeat *TimingRepeat `json:"repeat,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
}

// NewTiming creates a new Timing instance.
func NewTiming() *Timing {
	return &Timing{}
}

// FromJSON populates Timing from JSON data.
func (m *Timing) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Event []interface{} `json:"event,omitempty"`
		Repeat *TimingRepeat `json:"repeat,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	if len(temp.Event) > 0 {
		m.Event = make([]*FhirDateTime, len(temp.Event))
		for i := range temp.Event {
			itemMap, ok := temp.Event[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Event[%d]: expected map", i) }
			primitive, err := NewFhirDateTimeFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Event[%d]: %v", i, err) }
			m.Event[i] = primitive
		}
	}
	m.Repeat = temp.Repeat
	m.Code = temp.Code
	return nil
}

// ToJSON converts Timing to JSON data.
func (m *Timing) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Event []interface{} `json:"event,omitempty"`
		EventElement []map[string]interface{} `json:"_event,omitempty"`
		Repeat *TimingRepeat `json:"repeat,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if len(m.Event) > 0 {
		output.Event = make([]interface{}, len(m.Event))
		output.EventElement = make([]map[string]interface{}, len(m.Event))
		for i, item := range m.Event {
			if item != nil && item.Value != nil {
				output.Event[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.EventElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Repeat = m.Repeat
	output.Code = m.Code
	return json.Marshal(output)
}

// Clone creates a deep copy of Timing.
func (m *Timing) Clone() *Timing {
	if m == nil { return nil }
	return &Timing{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Event: cloneSlices(m.Event),
		Repeat: m.Repeat.Clone(),
		Code: m.Code.Clone(),
	}
}

// Equals checks equality between two Timing instances.
func (m *Timing) Equals(other *Timing) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Event, other.Event) { return false }
	if !m.Repeat.Equals(other.Repeat) { return false }
	if !m.Code.Equals(other.Code) { return false }
	return true
}

// TimingRepeat
// A set of rules that describe when the event is scheduled.
type TimingRepeat struct {
	extends Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	BoundsDuration *FhirDuration `json:"boundsduration,omitempty"`
	BoundsRange *Range `json:"boundsrange,omitempty"`
	BoundsPeriod *Period `json:"boundsperiod,omitempty"`
	Count *FhirPositiveInt `json:"count,omitempty"`
	CountMax *FhirPositiveInt `json:"countmax,omitempty"`
	Duration *FhirDecimal `json:"duration,omitempty"`
	DurationMax *FhirDecimal `json:"durationmax,omitempty"`
	DurationUnit *UnitsOfTime `json:"durationunit,omitempty"`
	Frequency *FhirPositiveInt `json:"frequency,omitempty"`
	FrequencyMax *FhirPositiveInt `json:"frequencymax,omitempty"`
	Period *FhirDecimal `json:"period,omitempty"`
	PeriodMax *FhirDecimal `json:"periodmax,omitempty"`
	PeriodUnit *UnitsOfTime `json:"periodunit,omitempty"`
	DayOfWeek []*DaysOfWeek `json:"dayofweek,omitempty"`
	TimeOfDay []*FhirTime `json:"timeofday,omitempty"`
	When []*EventTiming `json:"when,omitempty"`
	Offset *FhirUnsignedInt `json:"offset,omitempty"`
}

// NewTimingRepeat creates a new TimingRepeat instance.
func NewTimingRepeat() *TimingRepeat {
	return &TimingRepeat{}
}

// FromJSON populates TimingRepeat from JSON data.
func (m *TimingRepeat) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		BoundsDuration *FhirDuration `json:"boundsduration,omitempty"`
		BoundsRange *Range `json:"boundsrange,omitempty"`
		BoundsPeriod *Period `json:"boundsperiod,omitempty"`
		Count *FhirPositiveInt `json:"count,omitempty"`
		CountMax *FhirPositiveInt `json:"countmax,omitempty"`
		Duration *FhirDecimal `json:"duration,omitempty"`
		DurationMax *FhirDecimal `json:"durationmax,omitempty"`
		DurationUnit *UnitsOfTime `json:"durationunit,omitempty"`
		Frequency *FhirPositiveInt `json:"frequency,omitempty"`
		FrequencyMax *FhirPositiveInt `json:"frequencymax,omitempty"`
		Period *FhirDecimal `json:"period,omitempty"`
		PeriodMax *FhirDecimal `json:"periodmax,omitempty"`
		PeriodUnit *UnitsOfTime `json:"periodunit,omitempty"`
		DayOfWeek []*DaysOfWeek `json:"dayofweek,omitempty"`
		TimeOfDay []interface{} `json:"timeofday,omitempty"`
		When []*EventTiming `json:"when,omitempty"`
		Offset *FhirUnsignedInt `json:"offset,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.BoundsDuration = temp.BoundsDuration
	m.BoundsRange = temp.BoundsRange
	m.BoundsPeriod = temp.BoundsPeriod
	m.Count = temp.Count
	m.CountMax = temp.CountMax
	m.Duration = temp.Duration
	m.DurationMax = temp.DurationMax
	m.DurationUnit = temp.DurationUnit
	m.Frequency = temp.Frequency
	m.FrequencyMax = temp.FrequencyMax
	m.Period = temp.Period
	m.PeriodMax = temp.PeriodMax
	m.PeriodUnit = temp.PeriodUnit
	m.DayOfWeek = temp.DayOfWeek
	if len(temp.TimeOfDay) > 0 {
		m.TimeOfDay = make([]*FhirTime, len(temp.TimeOfDay))
		for i := range temp.TimeOfDay {
			itemMap, ok := temp.TimeOfDay[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for TimeOfDay[%d]: expected map", i) }
			primitive, err := NewFhirTimeFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse TimeOfDay[%d]: %v", i, err) }
			m.TimeOfDay[i] = primitive
		}
	}
	m.When = temp.When
	m.Offset = temp.Offset
	return nil
}

// ToJSON converts TimingRepeat to JSON data.
func (m *TimingRepeat) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		BoundsDuration *FhirDuration `json:"boundsduration,omitempty"`
		BoundsRange *Range `json:"boundsrange,omitempty"`
		BoundsPeriod *Period `json:"boundsperiod,omitempty"`
		Count interface{} `json:"count,omitempty"`
		CountElement map[string]interface{} `json:"_count,omitempty"`
		CountMax interface{} `json:"countmax,omitempty"`
		CountMaxElement map[string]interface{} `json:"_countmax,omitempty"`
		Duration interface{} `json:"duration,omitempty"`
		DurationElement map[string]interface{} `json:"_duration,omitempty"`
		DurationMax interface{} `json:"durationmax,omitempty"`
		DurationMaxElement map[string]interface{} `json:"_durationmax,omitempty"`
		DurationUnit *UnitsOfTime `json:"durationunit,omitempty"`
		Frequency interface{} `json:"frequency,omitempty"`
		FrequencyElement map[string]interface{} `json:"_frequency,omitempty"`
		FrequencyMax interface{} `json:"frequencymax,omitempty"`
		FrequencyMaxElement map[string]interface{} `json:"_frequencymax,omitempty"`
		Period interface{} `json:"period,omitempty"`
		PeriodElement map[string]interface{} `json:"_period,omitempty"`
		PeriodMax interface{} `json:"periodmax,omitempty"`
		PeriodMaxElement map[string]interface{} `json:"_periodmax,omitempty"`
		PeriodUnit *UnitsOfTime `json:"periodunit,omitempty"`
		DayOfWeek []*DaysOfWeek `json:"dayofweek,omitempty"`
		TimeOfDay []interface{} `json:"timeofday,omitempty"`
		TimeOfDayElement []map[string]interface{} `json:"_timeofday,omitempty"`
		When []*EventTiming `json:"when,omitempty"`
		Offset interface{} `json:"offset,omitempty"`
		OffsetElement map[string]interface{} `json:"_offset,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.BoundsDuration = m.BoundsDuration
	output.BoundsRange = m.BoundsRange
	output.BoundsPeriod = m.BoundsPeriod
	if m.Count != nil && m.Count.Value != nil {
		output.Count = m.Count.Value
		if m.Count.Element != nil {
			output.CountElement = toMapOrNil(m.Count.Element.ToJSON())
		}
	}
	if m.CountMax != nil && m.CountMax.Value != nil {
		output.CountMax = m.CountMax.Value
		if m.CountMax.Element != nil {
			output.CountMaxElement = toMapOrNil(m.CountMax.Element.ToJSON())
		}
	}
	if m.Duration != nil && m.Duration.Value != nil {
		output.Duration = m.Duration.Value
		if m.Duration.Element != nil {
			output.DurationElement = toMapOrNil(m.Duration.Element.ToJSON())
		}
	}
	if m.DurationMax != nil && m.DurationMax.Value != nil {
		output.DurationMax = m.DurationMax.Value
		if m.DurationMax.Element != nil {
			output.DurationMaxElement = toMapOrNil(m.DurationMax.Element.ToJSON())
		}
	}
	output.DurationUnit = m.DurationUnit
	if m.Frequency != nil && m.Frequency.Value != nil {
		output.Frequency = m.Frequency.Value
		if m.Frequency.Element != nil {
			output.FrequencyElement = toMapOrNil(m.Frequency.Element.ToJSON())
		}
	}
	if m.FrequencyMax != nil && m.FrequencyMax.Value != nil {
		output.FrequencyMax = m.FrequencyMax.Value
		if m.FrequencyMax.Element != nil {
			output.FrequencyMaxElement = toMapOrNil(m.FrequencyMax.Element.ToJSON())
		}
	}
	if m.Period != nil && m.Period.Value != nil {
		output.Period = m.Period.Value
		if m.Period.Element != nil {
			output.PeriodElement = toMapOrNil(m.Period.Element.ToJSON())
		}
	}
	if m.PeriodMax != nil && m.PeriodMax.Value != nil {
		output.PeriodMax = m.PeriodMax.Value
		if m.PeriodMax.Element != nil {
			output.PeriodMaxElement = toMapOrNil(m.PeriodMax.Element.ToJSON())
		}
	}
	output.PeriodUnit = m.PeriodUnit
	output.DayOfWeek = m.DayOfWeek
	if len(m.TimeOfDay) > 0 {
		output.TimeOfDay = make([]interface{}, len(m.TimeOfDay))
		output.TimeOfDayElement = make([]map[string]interface{}, len(m.TimeOfDay))
		for i, item := range m.TimeOfDay {
			if item != nil && item.Value != nil {
				output.TimeOfDay[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.TimeOfDayElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.When = m.When
	if m.Offset != nil && m.Offset.Value != nil {
		output.Offset = m.Offset.Value
		if m.Offset.Element != nil {
			output.OffsetElement = toMapOrNil(m.Offset.Element.ToJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TimingRepeat.
func (m *TimingRepeat) Clone() *TimingRepeat {
	if m == nil { return nil }
	return &TimingRepeat{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		BoundsDuration: m.BoundsDuration.Clone(),
		BoundsRange: m.BoundsRange.Clone(),
		BoundsPeriod: m.BoundsPeriod.Clone(),
		Count: m.Count.Clone(),
		CountMax: m.CountMax.Clone(),
		Duration: m.Duration.Clone(),
		DurationMax: m.DurationMax.Clone(),
		DurationUnit: m.DurationUnit.Clone(),
		Frequency: m.Frequency.Clone(),
		FrequencyMax: m.FrequencyMax.Clone(),
		Period: m.Period.Clone(),
		PeriodMax: m.PeriodMax.Clone(),
		PeriodUnit: m.PeriodUnit.Clone(),
		DayOfWeek: cloneSlices(m.DayOfWeek),
		TimeOfDay: cloneSlices(m.TimeOfDay),
		When: cloneSlices(m.When),
		Offset: m.Offset.Clone(),
	}
}

// Equals checks equality between two TimingRepeat instances.
func (m *TimingRepeat) Equals(other *TimingRepeat) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.BoundsDuration.Equals(other.BoundsDuration) { return false }
	if !m.BoundsRange.Equals(other.BoundsRange) { return false }
	if !m.BoundsPeriod.Equals(other.BoundsPeriod) { return false }
	if !m.Count.Equals(other.Count) { return false }
	if !m.CountMax.Equals(other.CountMax) { return false }
	if !m.Duration.Equals(other.Duration) { return false }
	if !m.DurationMax.Equals(other.DurationMax) { return false }
	if !m.DurationUnit.Equals(other.DurationUnit) { return false }
	if !m.Frequency.Equals(other.Frequency) { return false }
	if !m.FrequencyMax.Equals(other.FrequencyMax) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.PeriodMax.Equals(other.PeriodMax) { return false }
	if !m.PeriodUnit.Equals(other.PeriodUnit) { return false }
	if !compareSlices(m.DayOfWeek, other.DayOfWeek) { return false }
	if !compareSlices(m.TimeOfDay, other.TimeOfDay) { return false }
	if !compareSlices(m.When, other.When) { return false }
	if !m.Offset.Equals(other.Offset) { return false }
	return true
}

