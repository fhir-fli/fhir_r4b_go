// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ImagingStudy
// Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
type ImagingStudy struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ImagingStudyStatus `json:"status,omitempty"`
	Modality []*Coding `json:"modality,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	Started *FhirDateTime `json:"started,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	Referrer *Reference `json:"referrer,omitempty"`
	Interpreter []*Reference `json:"interpreter,omitempty"`
	Endpoint []*Reference `json:"endpoint,omitempty"`
	NumberOfSeries *FhirUnsignedInt `json:"numberofseries,omitempty"`
	NumberOfInstances *FhirUnsignedInt `json:"numberofinstances,omitempty"`
	ProcedureReference *Reference `json:"procedurereference,omitempty"`
	ProcedureCode []*CodeableConcept `json:"procedurecode,omitempty"`
	Location *Reference `json:"location,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Series []*ImagingStudySeries `json:"series,omitempty"`
}

// NewImagingStudy creates a new ImagingStudy instance
func NewImagingStudy() *ImagingStudy {
	return &ImagingStudy{}
}

// FromJSON populates ImagingStudy from JSON data
func (m *ImagingStudy) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImagingStudy to JSON data
func (m *ImagingStudy) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImagingStudy
func (m *ImagingStudy) Clone() *ImagingStudy {
	if m == nil { return nil }
	return &ImagingStudy{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Modality: cloneSlices(m.Modality),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		Started: m.Started.Clone(),
		BasedOn: cloneSlices(m.BasedOn),
		Referrer: m.Referrer.Clone(),
		Interpreter: cloneSlices(m.Interpreter),
		Endpoint: cloneSlices(m.Endpoint),
		NumberOfSeries: m.NumberOfSeries.Clone(),
		NumberOfInstances: m.NumberOfInstances.Clone(),
		ProcedureReference: m.ProcedureReference.Clone(),
		ProcedureCode: cloneSlices(m.ProcedureCode),
		Location: m.Location.Clone(),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		Note: cloneSlices(m.Note),
		Description: m.Description.Clone(),
		Series: cloneSlices(m.Series),
	}
}

// Equals checks for equality with another ImagingStudy instance
func (m *ImagingStudy) Equals(other *ImagingStudy) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Modality, other.Modality) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.Started.Equals(other.Started) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !m.Referrer.Equals(other.Referrer) { return false }
	if !compareSlices(m.Interpreter, other.Interpreter) { return false }
	if !compareSlices(m.Endpoint, other.Endpoint) { return false }
	if !m.NumberOfSeries.Equals(other.NumberOfSeries) { return false }
	if !m.NumberOfInstances.Equals(other.NumberOfInstances) { return false }
	if !m.ProcedureReference.Equals(other.ProcedureReference) { return false }
	if !compareSlices(m.ProcedureCode, other.ProcedureCode) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Series, other.Series) { return false }
	return true
}

// ImagingStudySeries
// Each study has one or more series of images or other content.
type ImagingStudySeries struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Uid *FhirId `json:"uid,omitempty"`
	Number *FhirUnsignedInt `json:"number,omitempty"`
	Modality *Coding `json:"modality,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	NumberOfInstances *FhirUnsignedInt `json:"numberofinstances,omitempty"`
	Endpoint []*Reference `json:"endpoint,omitempty"`
	BodySite *Coding `json:"bodysite,omitempty"`
	Laterality *Coding `json:"laterality,omitempty"`
	Specimen []*Reference `json:"specimen,omitempty"`
	Started *FhirDateTime `json:"started,omitempty"`
	Performer []*ImagingStudyPerformer `json:"performer,omitempty"`
	Instance []*ImagingStudyInstance `json:"instance,omitempty"`
}

// NewImagingStudySeries creates a new ImagingStudySeries instance
func NewImagingStudySeries() *ImagingStudySeries {
	return &ImagingStudySeries{}
}

// FromJSON populates ImagingStudySeries from JSON data
func (m *ImagingStudySeries) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImagingStudySeries to JSON data
func (m *ImagingStudySeries) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImagingStudySeries
func (m *ImagingStudySeries) Clone() *ImagingStudySeries {
	if m == nil { return nil }
	return &ImagingStudySeries{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Uid: m.Uid.Clone(),
		Number: m.Number.Clone(),
		Modality: m.Modality.Clone(),
		Description: m.Description.Clone(),
		NumberOfInstances: m.NumberOfInstances.Clone(),
		Endpoint: cloneSlices(m.Endpoint),
		BodySite: m.BodySite.Clone(),
		Laterality: m.Laterality.Clone(),
		Specimen: cloneSlices(m.Specimen),
		Started: m.Started.Clone(),
		Performer: cloneSlices(m.Performer),
		Instance: cloneSlices(m.Instance),
	}
}

// Equals checks for equality with another ImagingStudySeries instance
func (m *ImagingStudySeries) Equals(other *ImagingStudySeries) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Uid.Equals(other.Uid) { return false }
	if !m.Number.Equals(other.Number) { return false }
	if !m.Modality.Equals(other.Modality) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.NumberOfInstances.Equals(other.NumberOfInstances) { return false }
	if !compareSlices(m.Endpoint, other.Endpoint) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !m.Laterality.Equals(other.Laterality) { return false }
	if !compareSlices(m.Specimen, other.Specimen) { return false }
	if !m.Started.Equals(other.Started) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !compareSlices(m.Instance, other.Instance) { return false }
	return true
}

// ImagingStudyPerformer
// Indicates who or what performed the series and how they were involved.
type ImagingStudyPerformer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Function_ *CodeableConcept `json:"function,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewImagingStudyPerformer creates a new ImagingStudyPerformer instance
func NewImagingStudyPerformer() *ImagingStudyPerformer {
	return &ImagingStudyPerformer{}
}

// FromJSON populates ImagingStudyPerformer from JSON data
func (m *ImagingStudyPerformer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImagingStudyPerformer to JSON data
func (m *ImagingStudyPerformer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImagingStudyPerformer
func (m *ImagingStudyPerformer) Clone() *ImagingStudyPerformer {
	if m == nil { return nil }
	return &ImagingStudyPerformer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Function_: m.Function_.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks for equality with another ImagingStudyPerformer instance
func (m *ImagingStudyPerformer) Equals(other *ImagingStudyPerformer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Function_.Equals(other.Function_) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

// ImagingStudyInstance
// A single SOP instance within the series, e.g. an image, or presentation state.
type ImagingStudyInstance struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Uid *FhirId `json:"uid,omitempty"`
	SopClass *Coding `json:"sopclass,omitempty"`
	Number *FhirUnsignedInt `json:"number,omitempty"`
	Title *FhirString `json:"title,omitempty"`
}

// NewImagingStudyInstance creates a new ImagingStudyInstance instance
func NewImagingStudyInstance() *ImagingStudyInstance {
	return &ImagingStudyInstance{}
}

// FromJSON populates ImagingStudyInstance from JSON data
func (m *ImagingStudyInstance) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImagingStudyInstance to JSON data
func (m *ImagingStudyInstance) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImagingStudyInstance
func (m *ImagingStudyInstance) Clone() *ImagingStudyInstance {
	if m == nil { return nil }
	return &ImagingStudyInstance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Uid: m.Uid.Clone(),
		SopClass: m.SopClass.Clone(),
		Number: m.Number.Clone(),
		Title: m.Title.Clone(),
	}
}

// Equals checks for equality with another ImagingStudyInstance instance
func (m *ImagingStudyInstance) Equals(other *ImagingStudyInstance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Uid.Equals(other.Uid) { return false }
	if !m.SopClass.Equals(other.SopClass) { return false }
	if !m.Number.Equals(other.Number) { return false }
	if !m.Title.Equals(other.Title) { return false }
	return true
}

