// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// ImagingStudy
// Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
type ImagingStudy struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ImagingStudyStatus `json:"status,omitempty"`
	Modality []*Coding `json:"modality,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	Started *FhirDateTime `json:"started,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	Referrer *Reference `json:"referrer,omitempty"`
	Interpreter []*Reference `json:"interpreter,omitempty"`
	Endpoint []*Reference `json:"endpoint,omitempty"`
	NumberOfSeries *FhirUnsignedInt `json:"numberofseries,omitempty"`
	NumberOfInstances *FhirUnsignedInt `json:"numberofinstances,omitempty"`
	ProcedureReference *Reference `json:"procedurereference,omitempty"`
	ProcedureCode []*CodeableConcept `json:"procedurecode,omitempty"`
	Location *Reference `json:"location,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Series []*ImagingStudySeries `json:"series,omitempty"`
}

// NewImagingStudy creates a new ImagingStudy instance.
func NewImagingStudy() *ImagingStudy {
	return &ImagingStudy{}
}

// FromJSON populates ImagingStudy from JSON data.
func (m *ImagingStudy) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *ImagingStudyStatus `json:"status,omitempty"`
		Modality []*Coding `json:"modality,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Encounter *Reference `json:"encounter,omitempty"`
		Started *FhirDateTime `json:"started,omitempty"`
		BasedOn []*Reference `json:"basedon,omitempty"`
		Referrer *Reference `json:"referrer,omitempty"`
		Interpreter []*Reference `json:"interpreter,omitempty"`
		Endpoint []*Reference `json:"endpoint,omitempty"`
		NumberOfSeries *FhirUnsignedInt `json:"numberofseries,omitempty"`
		NumberOfInstances *FhirUnsignedInt `json:"numberofinstances,omitempty"`
		ProcedureReference *Reference `json:"procedurereference,omitempty"`
		ProcedureCode []*CodeableConcept `json:"procedurecode,omitempty"`
		Location *Reference `json:"location,omitempty"`
		ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
		ReasonReference []*Reference `json:"reasonreference,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Series []*ImagingStudySeries `json:"series,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Status = temp.Status
	m.Modality = temp.Modality
	m.Subject = temp.Subject
	m.Encounter = temp.Encounter
	m.Started = temp.Started
	m.BasedOn = temp.BasedOn
	m.Referrer = temp.Referrer
	m.Interpreter = temp.Interpreter
	m.Endpoint = temp.Endpoint
	m.NumberOfSeries = temp.NumberOfSeries
	m.NumberOfInstances = temp.NumberOfInstances
	m.ProcedureReference = temp.ProcedureReference
	m.ProcedureCode = temp.ProcedureCode
	m.Location = temp.Location
	m.ReasonCode = temp.ReasonCode
	m.ReasonReference = temp.ReasonReference
	m.Note = temp.Note
	m.Description = temp.Description
	m.Series = temp.Series
	return nil
}

// ToJSON converts ImagingStudy to JSON data.
func (m *ImagingStudy) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *ImagingStudyStatus `json:"status,omitempty"`
		Modality []*Coding `json:"modality,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		Encounter *Reference `json:"encounter,omitempty"`
		Started interface{} `json:"started,omitempty"`
		StartedElement map[string]interface{} `json:"_started,omitempty"`
		BasedOn []*Reference `json:"basedon,omitempty"`
		Referrer *Reference `json:"referrer,omitempty"`
		Interpreter []*Reference `json:"interpreter,omitempty"`
		Endpoint []*Reference `json:"endpoint,omitempty"`
		NumberOfSeries interface{} `json:"numberofseries,omitempty"`
		NumberOfSeriesElement map[string]interface{} `json:"_numberofseries,omitempty"`
		NumberOfInstances interface{} `json:"numberofinstances,omitempty"`
		NumberOfInstancesElement map[string]interface{} `json:"_numberofinstances,omitempty"`
		ProcedureReference *Reference `json:"procedurereference,omitempty"`
		ProcedureCode []*CodeableConcept `json:"procedurecode,omitempty"`
		Location *Reference `json:"location,omitempty"`
		ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
		ReasonReference []*Reference `json:"reasonreference,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Series []*ImagingStudySeries `json:"series,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.ToJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Status = m.Status
	output.Modality = m.Modality
	output.Subject = m.Subject
	output.Encounter = m.Encounter
	if m.Started != nil && m.Started.Value != nil {
		output.Started = m.Started.Value
		if m.Started.Element != nil {
			output.StartedElement = toMapOrNil(m.Started.Element.ToJSON())
		}
	}
	output.BasedOn = m.BasedOn
	output.Referrer = m.Referrer
	output.Interpreter = m.Interpreter
	output.Endpoint = m.Endpoint
	if m.NumberOfSeries != nil && m.NumberOfSeries.Value != nil {
		output.NumberOfSeries = m.NumberOfSeries.Value
		if m.NumberOfSeries.Element != nil {
			output.NumberOfSeriesElement = toMapOrNil(m.NumberOfSeries.Element.ToJSON())
		}
	}
	if m.NumberOfInstances != nil && m.NumberOfInstances.Value != nil {
		output.NumberOfInstances = m.NumberOfInstances.Value
		if m.NumberOfInstances.Element != nil {
			output.NumberOfInstancesElement = toMapOrNil(m.NumberOfInstances.Element.ToJSON())
		}
	}
	output.ProcedureReference = m.ProcedureReference
	output.ProcedureCode = m.ProcedureCode
	output.Location = m.Location
	output.ReasonCode = m.ReasonCode
	output.ReasonReference = m.ReasonReference
	output.Note = m.Note
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.ToJSON())
		}
	}
	output.Series = m.Series
	return json.Marshal(output)
}

// Clone creates a deep copy of ImagingStudy.
func (m *ImagingStudy) Clone() *ImagingStudy {
	if m == nil { return nil }
	return &ImagingStudy{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Modality: cloneSlices(m.Modality),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		Started: m.Started.Clone(),
		BasedOn: cloneSlices(m.BasedOn),
		Referrer: m.Referrer.Clone(),
		Interpreter: cloneSlices(m.Interpreter),
		Endpoint: cloneSlices(m.Endpoint),
		NumberOfSeries: m.NumberOfSeries.Clone(),
		NumberOfInstances: m.NumberOfInstances.Clone(),
		ProcedureReference: m.ProcedureReference.Clone(),
		ProcedureCode: cloneSlices(m.ProcedureCode),
		Location: m.Location.Clone(),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		Note: cloneSlices(m.Note),
		Description: m.Description.Clone(),
		Series: cloneSlices(m.Series),
	}
}

// Equals checks equality between two ImagingStudy instances.
func (m *ImagingStudy) Equals(other *ImagingStudy) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Modality, other.Modality) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.Started.Equals(other.Started) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !m.Referrer.Equals(other.Referrer) { return false }
	if !compareSlices(m.Interpreter, other.Interpreter) { return false }
	if !compareSlices(m.Endpoint, other.Endpoint) { return false }
	if !m.NumberOfSeries.Equals(other.NumberOfSeries) { return false }
	if !m.NumberOfInstances.Equals(other.NumberOfInstances) { return false }
	if !m.ProcedureReference.Equals(other.ProcedureReference) { return false }
	if !compareSlices(m.ProcedureCode, other.ProcedureCode) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Series, other.Series) { return false }
	return true
}

// ImagingStudySeries
// Each study has one or more series of images or other content.
type ImagingStudySeries struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Uid *FhirId `json:"uid,omitempty"`
	Number *FhirUnsignedInt `json:"number,omitempty"`
	Modality *Coding `json:"modality,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	NumberOfInstances *FhirUnsignedInt `json:"numberofinstances,omitempty"`
	Endpoint []*Reference `json:"endpoint,omitempty"`
	BodySite *Coding `json:"bodysite,omitempty"`
	Laterality *Coding `json:"laterality,omitempty"`
	Specimen []*Reference `json:"specimen,omitempty"`
	Started *FhirDateTime `json:"started,omitempty"`
	Performer []*ImagingStudyPerformer `json:"performer,omitempty"`
	Instance []*ImagingStudyInstance `json:"instance,omitempty"`
}

// NewImagingStudySeries creates a new ImagingStudySeries instance.
func NewImagingStudySeries() *ImagingStudySeries {
	return &ImagingStudySeries{}
}

// FromJSON populates ImagingStudySeries from JSON data.
func (m *ImagingStudySeries) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Uid *FhirId `json:"uid,omitempty"`
		Number *FhirUnsignedInt `json:"number,omitempty"`
		Modality *Coding `json:"modality,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		NumberOfInstances *FhirUnsignedInt `json:"numberofinstances,omitempty"`
		Endpoint []*Reference `json:"endpoint,omitempty"`
		BodySite *Coding `json:"bodysite,omitempty"`
		Laterality *Coding `json:"laterality,omitempty"`
		Specimen []*Reference `json:"specimen,omitempty"`
		Started *FhirDateTime `json:"started,omitempty"`
		Performer []*ImagingStudyPerformer `json:"performer,omitempty"`
		Instance []*ImagingStudyInstance `json:"instance,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Uid = temp.Uid
	m.Number = temp.Number
	m.Modality = temp.Modality
	m.Description = temp.Description
	m.NumberOfInstances = temp.NumberOfInstances
	m.Endpoint = temp.Endpoint
	m.BodySite = temp.BodySite
	m.Laterality = temp.Laterality
	m.Specimen = temp.Specimen
	m.Started = temp.Started
	m.Performer = temp.Performer
	m.Instance = temp.Instance
	return nil
}

// ToJSON converts ImagingStudySeries to JSON data.
func (m *ImagingStudySeries) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Uid interface{} `json:"uid,omitempty"`
		UidElement map[string]interface{} `json:"_uid,omitempty"`
		Number interface{} `json:"number,omitempty"`
		NumberElement map[string]interface{} `json:"_number,omitempty"`
		Modality *Coding `json:"modality,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		NumberOfInstances interface{} `json:"numberofinstances,omitempty"`
		NumberOfInstancesElement map[string]interface{} `json:"_numberofinstances,omitempty"`
		Endpoint []*Reference `json:"endpoint,omitempty"`
		BodySite *Coding `json:"bodysite,omitempty"`
		Laterality *Coding `json:"laterality,omitempty"`
		Specimen []*Reference `json:"specimen,omitempty"`
		Started interface{} `json:"started,omitempty"`
		StartedElement map[string]interface{} `json:"_started,omitempty"`
		Performer []*ImagingStudyPerformer `json:"performer,omitempty"`
		Instance []*ImagingStudyInstance `json:"instance,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Uid != nil && m.Uid.Value != nil {
		output.Uid = m.Uid.Value
		if m.Uid.Element != nil {
			output.UidElement = toMapOrNil(m.Uid.Element.ToJSON())
		}
	}
	if m.Number != nil && m.Number.Value != nil {
		output.Number = m.Number.Value
		if m.Number.Element != nil {
			output.NumberElement = toMapOrNil(m.Number.Element.ToJSON())
		}
	}
	output.Modality = m.Modality
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.ToJSON())
		}
	}
	if m.NumberOfInstances != nil && m.NumberOfInstances.Value != nil {
		output.NumberOfInstances = m.NumberOfInstances.Value
		if m.NumberOfInstances.Element != nil {
			output.NumberOfInstancesElement = toMapOrNil(m.NumberOfInstances.Element.ToJSON())
		}
	}
	output.Endpoint = m.Endpoint
	output.BodySite = m.BodySite
	output.Laterality = m.Laterality
	output.Specimen = m.Specimen
	if m.Started != nil && m.Started.Value != nil {
		output.Started = m.Started.Value
		if m.Started.Element != nil {
			output.StartedElement = toMapOrNil(m.Started.Element.ToJSON())
		}
	}
	output.Performer = m.Performer
	output.Instance = m.Instance
	return json.Marshal(output)
}

// Clone creates a deep copy of ImagingStudySeries.
func (m *ImagingStudySeries) Clone() *ImagingStudySeries {
	if m == nil { return nil }
	return &ImagingStudySeries{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Uid: m.Uid.Clone(),
		Number: m.Number.Clone(),
		Modality: m.Modality.Clone(),
		Description: m.Description.Clone(),
		NumberOfInstances: m.NumberOfInstances.Clone(),
		Endpoint: cloneSlices(m.Endpoint),
		BodySite: m.BodySite.Clone(),
		Laterality: m.Laterality.Clone(),
		Specimen: cloneSlices(m.Specimen),
		Started: m.Started.Clone(),
		Performer: cloneSlices(m.Performer),
		Instance: cloneSlices(m.Instance),
	}
}

// Equals checks equality between two ImagingStudySeries instances.
func (m *ImagingStudySeries) Equals(other *ImagingStudySeries) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Uid.Equals(other.Uid) { return false }
	if !m.Number.Equals(other.Number) { return false }
	if !m.Modality.Equals(other.Modality) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.NumberOfInstances.Equals(other.NumberOfInstances) { return false }
	if !compareSlices(m.Endpoint, other.Endpoint) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !m.Laterality.Equals(other.Laterality) { return false }
	if !compareSlices(m.Specimen, other.Specimen) { return false }
	if !m.Started.Equals(other.Started) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !compareSlices(m.Instance, other.Instance) { return false }
	return true
}

// ImagingStudyPerformer
// Indicates who or what performed the series and how they were involved.
type ImagingStudyPerformer struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Function_ *CodeableConcept `json:"function,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewImagingStudyPerformer creates a new ImagingStudyPerformer instance.
func NewImagingStudyPerformer() *ImagingStudyPerformer {
	return &ImagingStudyPerformer{}
}

// FromJSON populates ImagingStudyPerformer from JSON data.
func (m *ImagingStudyPerformer) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Function_ *CodeableConcept `json:"function,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Function_ = temp.Function_
	m.Actor = temp.Actor
	return nil
}

// ToJSON converts ImagingStudyPerformer to JSON data.
func (m *ImagingStudyPerformer) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Function_ *CodeableConcept `json:"function,omitempty"`
		Actor *Reference `json:"actor,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Function_ = m.Function_
	output.Actor = m.Actor
	return json.Marshal(output)
}

// Clone creates a deep copy of ImagingStudyPerformer.
func (m *ImagingStudyPerformer) Clone() *ImagingStudyPerformer {
	if m == nil { return nil }
	return &ImagingStudyPerformer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Function_: m.Function_.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks equality between two ImagingStudyPerformer instances.
func (m *ImagingStudyPerformer) Equals(other *ImagingStudyPerformer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Function_.Equals(other.Function_) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

// ImagingStudyInstance
// A single SOP instance within the series, e.g. an image, or presentation state.
type ImagingStudyInstance struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Uid *FhirId `json:"uid,omitempty"`
	SopClass *Coding `json:"sopclass,omitempty"`
	Number *FhirUnsignedInt `json:"number,omitempty"`
	Title *FhirString `json:"title,omitempty"`
}

// NewImagingStudyInstance creates a new ImagingStudyInstance instance.
func NewImagingStudyInstance() *ImagingStudyInstance {
	return &ImagingStudyInstance{}
}

// FromJSON populates ImagingStudyInstance from JSON data.
func (m *ImagingStudyInstance) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Uid *FhirId `json:"uid,omitempty"`
		SopClass *Coding `json:"sopclass,omitempty"`
		Number *FhirUnsignedInt `json:"number,omitempty"`
		Title *FhirString `json:"title,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Uid = temp.Uid
	m.SopClass = temp.SopClass
	m.Number = temp.Number
	m.Title = temp.Title
	return nil
}

// ToJSON converts ImagingStudyInstance to JSON data.
func (m *ImagingStudyInstance) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Uid interface{} `json:"uid,omitempty"`
		UidElement map[string]interface{} `json:"_uid,omitempty"`
		SopClass *Coding `json:"sopclass,omitempty"`
		Number interface{} `json:"number,omitempty"`
		NumberElement map[string]interface{} `json:"_number,omitempty"`
		Title interface{} `json:"title,omitempty"`
		TitleElement map[string]interface{} `json:"_title,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Uid != nil && m.Uid.Value != nil {
		output.Uid = m.Uid.Value
		if m.Uid.Element != nil {
			output.UidElement = toMapOrNil(m.Uid.Element.ToJSON())
		}
	}
	output.SopClass = m.SopClass
	if m.Number != nil && m.Number.Value != nil {
		output.Number = m.Number.Value
		if m.Number.Element != nil {
			output.NumberElement = toMapOrNil(m.Number.Element.ToJSON())
		}
	}
	if m.Title != nil && m.Title.Value != nil {
		output.Title = m.Title.Value
		if m.Title.Element != nil {
			output.TitleElement = toMapOrNil(m.Title.Element.ToJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ImagingStudyInstance.
func (m *ImagingStudyInstance) Clone() *ImagingStudyInstance {
	if m == nil { return nil }
	return &ImagingStudyInstance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Uid: m.Uid.Clone(),
		SopClass: m.SopClass.Clone(),
		Number: m.Number.Clone(),
		Title: m.Title.Clone(),
	}
}

// Equals checks equality between two ImagingStudyInstance instances.
func (m *ImagingStudyInstance) Equals(other *ImagingStudyInstance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Uid.Equals(other.Uid) { return false }
	if !m.SopClass.Equals(other.SopClass) { return false }
	if !m.Number.Equals(other.Number) { return false }
	if !m.Title.Equals(other.Title) { return false }
	return true
}

