// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// MedicationKnowledge
// Information about a medication that is used to support knowledge.
type MedicationKnowledge struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Status *MedicationKnowledgeStatusCodes `json:"status,omitempty"`
	Manufacturer *Reference `json:"manufacturer,omitempty"`
	DoseForm *CodeableConcept `json:"doseform,omitempty"`
	Amount *Quantity `json:"amount,omitempty"`
	Synonym []*FhirString `json:"synonym,omitempty"`
	RelatedMedicationKnowledge []*MedicationKnowledgeRelatedMedicationKnowledge `json:"relatedmedicationknowledge,omitempty"`
	AssociatedMedication []*Reference `json:"associatedmedication,omitempty"`
	ProductType []*CodeableConcept `json:"producttype,omitempty"`
	Monograph []*MedicationKnowledgeMonograph `json:"monograph,omitempty"`
	Ingredient []*MedicationKnowledgeIngredient `json:"ingredient,omitempty"`
	PreparationInstruction *FhirMarkdown `json:"preparationinstruction,omitempty"`
	IntendedRoute []*CodeableConcept `json:"intendedroute,omitempty"`
	Cost []*MedicationKnowledgeCost `json:"cost,omitempty"`
	MonitoringProgram []*MedicationKnowledgeMonitoringProgram `json:"monitoringprogram,omitempty"`
	AdministrationGuidelines []*MedicationKnowledgeAdministrationGuidelines `json:"administrationguidelines,omitempty"`
	MedicineClassification []*MedicationKnowledgeMedicineClassification `json:"medicineclassification,omitempty"`
	Packaging *MedicationKnowledgePackaging `json:"packaging,omitempty"`
	DrugCharacteristic []*MedicationKnowledgeDrugCharacteristic `json:"drugcharacteristic,omitempty"`
	Contraindication []*Reference `json:"contraindication,omitempty"`
	Regulatory []*MedicationKnowledgeRegulatory `json:"regulatory,omitempty"`
	Kinetics []*MedicationKnowledgeKinetics `json:"kinetics,omitempty"`
}

// NewMedicationKnowledge creates a new MedicationKnowledge instance.
func NewMedicationKnowledge() *MedicationKnowledge {
	return &MedicationKnowledge{}
}

// FromJSON populates MedicationKnowledge from JSON data.
func (m *MedicationKnowledge) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Status *MedicationKnowledgeStatusCodes `json:"status,omitempty"`
		Manufacturer *Reference `json:"manufacturer,omitempty"`
		DoseForm *CodeableConcept `json:"doseform,omitempty"`
		Amount *Quantity `json:"amount,omitempty"`
		Synonym []interface{} `json:"synonym,omitempty"`
		RelatedMedicationKnowledge []*MedicationKnowledgeRelatedMedicationKnowledge `json:"relatedmedicationknowledge,omitempty"`
		AssociatedMedication []*Reference `json:"associatedmedication,omitempty"`
		ProductType []*CodeableConcept `json:"producttype,omitempty"`
		Monograph []*MedicationKnowledgeMonograph `json:"monograph,omitempty"`
		Ingredient []*MedicationKnowledgeIngredient `json:"ingredient,omitempty"`
		PreparationInstruction *FhirMarkdown `json:"preparationinstruction,omitempty"`
		IntendedRoute []*CodeableConcept `json:"intendedroute,omitempty"`
		Cost []*MedicationKnowledgeCost `json:"cost,omitempty"`
		MonitoringProgram []*MedicationKnowledgeMonitoringProgram `json:"monitoringprogram,omitempty"`
		AdministrationGuidelines []*MedicationKnowledgeAdministrationGuidelines `json:"administrationguidelines,omitempty"`
		MedicineClassification []*MedicationKnowledgeMedicineClassification `json:"medicineclassification,omitempty"`
		Packaging *MedicationKnowledgePackaging `json:"packaging,omitempty"`
		DrugCharacteristic []*MedicationKnowledgeDrugCharacteristic `json:"drugcharacteristic,omitempty"`
		Contraindication []*Reference `json:"contraindication,omitempty"`
		Regulatory []*MedicationKnowledgeRegulatory `json:"regulatory,omitempty"`
		Kinetics []*MedicationKnowledgeKinetics `json:"kinetics,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Status = temp.Status
	m.Manufacturer = temp.Manufacturer
	m.DoseForm = temp.DoseForm
	m.Amount = temp.Amount
	if len(temp.Synonym) > 0 {
		m.Synonym = make([]*FhirString, len(temp.Synonym))
		for i := range temp.Synonym {
			itemMap, ok := temp.Synonym[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Synonym[%d]: expected map", i) }
			primitive, err := NewFhirStringFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Synonym[%d]: %v", i, err) }
			m.Synonym[i] = primitive
		}
	}
	m.RelatedMedicationKnowledge = temp.RelatedMedicationKnowledge
	m.AssociatedMedication = temp.AssociatedMedication
	m.ProductType = temp.ProductType
	m.Monograph = temp.Monograph
	m.Ingredient = temp.Ingredient
	m.PreparationInstruction = temp.PreparationInstruction
	m.IntendedRoute = temp.IntendedRoute
	m.Cost = temp.Cost
	m.MonitoringProgram = temp.MonitoringProgram
	m.AdministrationGuidelines = temp.AdministrationGuidelines
	m.MedicineClassification = temp.MedicineClassification
	m.Packaging = temp.Packaging
	m.DrugCharacteristic = temp.DrugCharacteristic
	m.Contraindication = temp.Contraindication
	m.Regulatory = temp.Regulatory
	m.Kinetics = temp.Kinetics
	return nil
}

// ToJSON converts MedicationKnowledge to JSON data.
func (m *MedicationKnowledge) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Status *MedicationKnowledgeStatusCodes `json:"status,omitempty"`
		Manufacturer *Reference `json:"manufacturer,omitempty"`
		DoseForm *CodeableConcept `json:"doseform,omitempty"`
		Amount *Quantity `json:"amount,omitempty"`
		Synonym []interface{} `json:"synonym,omitempty"`
		SynonymElement []map[string]interface{} `json:"_synonym,omitempty"`
		RelatedMedicationKnowledge []*MedicationKnowledgeRelatedMedicationKnowledge `json:"relatedmedicationknowledge,omitempty"`
		AssociatedMedication []*Reference `json:"associatedmedication,omitempty"`
		ProductType []*CodeableConcept `json:"producttype,omitempty"`
		Monograph []*MedicationKnowledgeMonograph `json:"monograph,omitempty"`
		Ingredient []*MedicationKnowledgeIngredient `json:"ingredient,omitempty"`
		PreparationInstruction interface{} `json:"preparationinstruction,omitempty"`
		PreparationInstructionElement map[string]interface{} `json:"_preparationinstruction,omitempty"`
		IntendedRoute []*CodeableConcept `json:"intendedroute,omitempty"`
		Cost []*MedicationKnowledgeCost `json:"cost,omitempty"`
		MonitoringProgram []*MedicationKnowledgeMonitoringProgram `json:"monitoringprogram,omitempty"`
		AdministrationGuidelines []*MedicationKnowledgeAdministrationGuidelines `json:"administrationguidelines,omitempty"`
		MedicineClassification []*MedicationKnowledgeMedicineClassification `json:"medicineclassification,omitempty"`
		Packaging *MedicationKnowledgePackaging `json:"packaging,omitempty"`
		DrugCharacteristic []*MedicationKnowledgeDrugCharacteristic `json:"drugcharacteristic,omitempty"`
		Contraindication []*Reference `json:"contraindication,omitempty"`
		Regulatory []*MedicationKnowledgeRegulatory `json:"regulatory,omitempty"`
		Kinetics []*MedicationKnowledgeKinetics `json:"kinetics,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.ToJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	output.Status = m.Status
	output.Manufacturer = m.Manufacturer
	output.DoseForm = m.DoseForm
	output.Amount = m.Amount
	if len(m.Synonym) > 0 {
		output.Synonym = make([]interface{}, len(m.Synonym))
		output.SynonymElement = make([]map[string]interface{}, len(m.Synonym))
		for i, item := range m.Synonym {
			if item != nil && item.Value != nil {
				output.Synonym[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.SynonymElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.RelatedMedicationKnowledge = m.RelatedMedicationKnowledge
	output.AssociatedMedication = m.AssociatedMedication
	output.ProductType = m.ProductType
	output.Monograph = m.Monograph
	output.Ingredient = m.Ingredient
	if m.PreparationInstruction != nil && m.PreparationInstruction.Value != nil {
		output.PreparationInstruction = m.PreparationInstruction.Value
		if m.PreparationInstruction.Element != nil {
			output.PreparationInstructionElement = toMapOrNil(m.PreparationInstruction.Element.ToJSON())
		}
	}
	output.IntendedRoute = m.IntendedRoute
	output.Cost = m.Cost
	output.MonitoringProgram = m.MonitoringProgram
	output.AdministrationGuidelines = m.AdministrationGuidelines
	output.MedicineClassification = m.MedicineClassification
	output.Packaging = m.Packaging
	output.DrugCharacteristic = m.DrugCharacteristic
	output.Contraindication = m.Contraindication
	output.Regulatory = m.Regulatory
	output.Kinetics = m.Kinetics
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledge.
func (m *MedicationKnowledge) Clone() *MedicationKnowledge {
	if m == nil { return nil }
	return &MedicationKnowledge{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Status: m.Status.Clone(),
		Manufacturer: m.Manufacturer.Clone(),
		DoseForm: m.DoseForm.Clone(),
		Amount: m.Amount.Clone(),
		Synonym: cloneSlices(m.Synonym),
		RelatedMedicationKnowledge: cloneSlices(m.RelatedMedicationKnowledge),
		AssociatedMedication: cloneSlices(m.AssociatedMedication),
		ProductType: cloneSlices(m.ProductType),
		Monograph: cloneSlices(m.Monograph),
		Ingredient: cloneSlices(m.Ingredient),
		PreparationInstruction: m.PreparationInstruction.Clone(),
		IntendedRoute: cloneSlices(m.IntendedRoute),
		Cost: cloneSlices(m.Cost),
		MonitoringProgram: cloneSlices(m.MonitoringProgram),
		AdministrationGuidelines: cloneSlices(m.AdministrationGuidelines),
		MedicineClassification: cloneSlices(m.MedicineClassification),
		Packaging: m.Packaging.Clone(),
		DrugCharacteristic: cloneSlices(m.DrugCharacteristic),
		Contraindication: cloneSlices(m.Contraindication),
		Regulatory: cloneSlices(m.Regulatory),
		Kinetics: cloneSlices(m.Kinetics),
	}
}

// Equals checks equality between two MedicationKnowledge instances.
func (m *MedicationKnowledge) Equals(other *MedicationKnowledge) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Manufacturer.Equals(other.Manufacturer) { return false }
	if !m.DoseForm.Equals(other.DoseForm) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !compareSlices(m.Synonym, other.Synonym) { return false }
	if !compareSlices(m.RelatedMedicationKnowledge, other.RelatedMedicationKnowledge) { return false }
	if !compareSlices(m.AssociatedMedication, other.AssociatedMedication) { return false }
	if !compareSlices(m.ProductType, other.ProductType) { return false }
	if !compareSlices(m.Monograph, other.Monograph) { return false }
	if !compareSlices(m.Ingredient, other.Ingredient) { return false }
	if !m.PreparationInstruction.Equals(other.PreparationInstruction) { return false }
	if !compareSlices(m.IntendedRoute, other.IntendedRoute) { return false }
	if !compareSlices(m.Cost, other.Cost) { return false }
	if !compareSlices(m.MonitoringProgram, other.MonitoringProgram) { return false }
	if !compareSlices(m.AdministrationGuidelines, other.AdministrationGuidelines) { return false }
	if !compareSlices(m.MedicineClassification, other.MedicineClassification) { return false }
	if !m.Packaging.Equals(other.Packaging) { return false }
	if !compareSlices(m.DrugCharacteristic, other.DrugCharacteristic) { return false }
	if !compareSlices(m.Contraindication, other.Contraindication) { return false }
	if !compareSlices(m.Regulatory, other.Regulatory) { return false }
	if !compareSlices(m.Kinetics, other.Kinetics) { return false }
	return true
}

// MedicationKnowledgeRelatedMedicationKnowledge
// Associated or related knowledge about a medication.
type MedicationKnowledgeRelatedMedicationKnowledge struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Reference []*Reference `json:"reference,omitempty"`
}

// NewMedicationKnowledgeRelatedMedicationKnowledge creates a new MedicationKnowledgeRelatedMedicationKnowledge instance.
func NewMedicationKnowledgeRelatedMedicationKnowledge() *MedicationKnowledgeRelatedMedicationKnowledge {
	return &MedicationKnowledgeRelatedMedicationKnowledge{}
}

// FromJSON populates MedicationKnowledgeRelatedMedicationKnowledge from JSON data.
func (m *MedicationKnowledgeRelatedMedicationKnowledge) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Reference []*Reference `json:"reference,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Reference = temp.Reference
	return nil
}

// ToJSON converts MedicationKnowledgeRelatedMedicationKnowledge to JSON data.
func (m *MedicationKnowledgeRelatedMedicationKnowledge) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Reference []*Reference `json:"reference,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Reference = m.Reference
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeRelatedMedicationKnowledge.
func (m *MedicationKnowledgeRelatedMedicationKnowledge) Clone() *MedicationKnowledgeRelatedMedicationKnowledge {
	if m == nil { return nil }
	return &MedicationKnowledgeRelatedMedicationKnowledge{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Reference: cloneSlices(m.Reference),
	}
}

// Equals checks equality between two MedicationKnowledgeRelatedMedicationKnowledge instances.
func (m *MedicationKnowledgeRelatedMedicationKnowledge) Equals(other *MedicationKnowledgeRelatedMedicationKnowledge) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Reference, other.Reference) { return false }
	return true
}

// MedicationKnowledgeMonograph
// Associated documentation about the medication.
type MedicationKnowledgeMonograph struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Source *Reference `json:"source,omitempty"`
}

// NewMedicationKnowledgeMonograph creates a new MedicationKnowledgeMonograph instance.
func NewMedicationKnowledgeMonograph() *MedicationKnowledgeMonograph {
	return &MedicationKnowledgeMonograph{}
}

// FromJSON populates MedicationKnowledgeMonograph from JSON data.
func (m *MedicationKnowledgeMonograph) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Source *Reference `json:"source,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Source = temp.Source
	return nil
}

// ToJSON converts MedicationKnowledgeMonograph to JSON data.
func (m *MedicationKnowledgeMonograph) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Source *Reference `json:"source,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Source = m.Source
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeMonograph.
func (m *MedicationKnowledgeMonograph) Clone() *MedicationKnowledgeMonograph {
	if m == nil { return nil }
	return &MedicationKnowledgeMonograph{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Source: m.Source.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeMonograph instances.
func (m *MedicationKnowledgeMonograph) Equals(other *MedicationKnowledgeMonograph) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Source.Equals(other.Source) { return false }
	return true
}

// MedicationKnowledgeIngredient
// Identifies a particular constituent of interest in the product.
type MedicationKnowledgeIngredient struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemCodeableConcept *CodeableConcept `json:"itemcodeableconcept,omitempty"`
	ItemReference *Reference `json:"itemreference,omitempty"`
	IsActive *FhirBoolean `json:"isactive,omitempty"`
	Strength *Ratio `json:"strength,omitempty"`
}

// NewMedicationKnowledgeIngredient creates a new MedicationKnowledgeIngredient instance.
func NewMedicationKnowledgeIngredient() *MedicationKnowledgeIngredient {
	return &MedicationKnowledgeIngredient{}
}

// FromJSON populates MedicationKnowledgeIngredient from JSON data.
func (m *MedicationKnowledgeIngredient) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ItemCodeableConcept *CodeableConcept `json:"itemcodeableconcept,omitempty"`
		ItemReference *Reference `json:"itemreference,omitempty"`
		IsActive *FhirBoolean `json:"isactive,omitempty"`
		Strength *Ratio `json:"strength,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.ItemCodeableConcept = temp.ItemCodeableConcept
	m.ItemReference = temp.ItemReference
	m.IsActive = temp.IsActive
	m.Strength = temp.Strength
	return nil
}

// ToJSON converts MedicationKnowledgeIngredient to JSON data.
func (m *MedicationKnowledgeIngredient) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ItemCodeableConcept *CodeableConcept `json:"itemcodeableconcept,omitempty"`
		ItemReference *Reference `json:"itemreference,omitempty"`
		IsActive interface{} `json:"isactive,omitempty"`
		IsActiveElement map[string]interface{} `json:"_isactive,omitempty"`
		Strength *Ratio `json:"strength,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.ItemCodeableConcept = m.ItemCodeableConcept
	output.ItemReference = m.ItemReference
	if m.IsActive != nil && m.IsActive.Value != nil {
		output.IsActive = m.IsActive.Value
		if m.IsActive.Element != nil {
			output.IsActiveElement = toMapOrNil(m.IsActive.Element.ToJSON())
		}
	}
	output.Strength = m.Strength
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeIngredient.
func (m *MedicationKnowledgeIngredient) Clone() *MedicationKnowledgeIngredient {
	if m == nil { return nil }
	return &MedicationKnowledgeIngredient{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemCodeableConcept: m.ItemCodeableConcept.Clone(),
		ItemReference: m.ItemReference.Clone(),
		IsActive: m.IsActive.Clone(),
		Strength: m.Strength.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeIngredient instances.
func (m *MedicationKnowledgeIngredient) Equals(other *MedicationKnowledgeIngredient) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ItemCodeableConcept.Equals(other.ItemCodeableConcept) { return false }
	if !m.ItemReference.Equals(other.ItemReference) { return false }
	if !m.IsActive.Equals(other.IsActive) { return false }
	if !m.Strength.Equals(other.Strength) { return false }
	return true
}

// MedicationKnowledgeCost
// The price of the medication.
type MedicationKnowledgeCost struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Source *FhirString `json:"source,omitempty"`
	Cost *Money `json:"cost,omitempty"`
}

// NewMedicationKnowledgeCost creates a new MedicationKnowledgeCost instance.
func NewMedicationKnowledgeCost() *MedicationKnowledgeCost {
	return &MedicationKnowledgeCost{}
}

// FromJSON populates MedicationKnowledgeCost from JSON data.
func (m *MedicationKnowledgeCost) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Source *FhirString `json:"source,omitempty"`
		Cost *Money `json:"cost,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Source = temp.Source
	m.Cost = temp.Cost
	return nil
}

// ToJSON converts MedicationKnowledgeCost to JSON data.
func (m *MedicationKnowledgeCost) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Source interface{} `json:"source,omitempty"`
		SourceElement map[string]interface{} `json:"_source,omitempty"`
		Cost *Money `json:"cost,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.Source != nil && m.Source.Value != nil {
		output.Source = m.Source.Value
		if m.Source.Element != nil {
			output.SourceElement = toMapOrNil(m.Source.Element.ToJSON())
		}
	}
	output.Cost = m.Cost
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeCost.
func (m *MedicationKnowledgeCost) Clone() *MedicationKnowledgeCost {
	if m == nil { return nil }
	return &MedicationKnowledgeCost{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Source: m.Source.Clone(),
		Cost: m.Cost.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeCost instances.
func (m *MedicationKnowledgeCost) Equals(other *MedicationKnowledgeCost) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !m.Cost.Equals(other.Cost) { return false }
	return true
}

// MedicationKnowledgeMonitoringProgram
// The program under which the medication is reviewed.
type MedicationKnowledgeMonitoringProgram struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Name *FhirString `json:"name,omitempty"`
}

// NewMedicationKnowledgeMonitoringProgram creates a new MedicationKnowledgeMonitoringProgram instance.
func NewMedicationKnowledgeMonitoringProgram() *MedicationKnowledgeMonitoringProgram {
	return &MedicationKnowledgeMonitoringProgram{}
}

// FromJSON populates MedicationKnowledgeMonitoringProgram from JSON data.
func (m *MedicationKnowledgeMonitoringProgram) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Name *FhirString `json:"name,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Name = temp.Name
	return nil
}

// ToJSON converts MedicationKnowledgeMonitoringProgram to JSON data.
func (m *MedicationKnowledgeMonitoringProgram) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.ToJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeMonitoringProgram.
func (m *MedicationKnowledgeMonitoringProgram) Clone() *MedicationKnowledgeMonitoringProgram {
	if m == nil { return nil }
	return &MedicationKnowledgeMonitoringProgram{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Name: m.Name.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeMonitoringProgram instances.
func (m *MedicationKnowledgeMonitoringProgram) Equals(other *MedicationKnowledgeMonitoringProgram) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Name.Equals(other.Name) { return false }
	return true
}

// MedicationKnowledgeAdministrationGuidelines
// Guidelines for the administration of the medication.
type MedicationKnowledgeAdministrationGuidelines struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Dosage []*MedicationKnowledgeDosage `json:"dosage,omitempty"`
	IndicationCodeableConcept *CodeableConcept `json:"indicationcodeableconcept,omitempty"`
	IndicationReference *Reference `json:"indicationreference,omitempty"`
	PatientCharacteristics []*MedicationKnowledgePatientCharacteristics `json:"patientcharacteristics,omitempty"`
}

// NewMedicationKnowledgeAdministrationGuidelines creates a new MedicationKnowledgeAdministrationGuidelines instance.
func NewMedicationKnowledgeAdministrationGuidelines() *MedicationKnowledgeAdministrationGuidelines {
	return &MedicationKnowledgeAdministrationGuidelines{}
}

// FromJSON populates MedicationKnowledgeAdministrationGuidelines from JSON data.
func (m *MedicationKnowledgeAdministrationGuidelines) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Dosage []*MedicationKnowledgeDosage `json:"dosage,omitempty"`
		IndicationCodeableConcept *CodeableConcept `json:"indicationcodeableconcept,omitempty"`
		IndicationReference *Reference `json:"indicationreference,omitempty"`
		PatientCharacteristics []*MedicationKnowledgePatientCharacteristics `json:"patientcharacteristics,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Dosage = temp.Dosage
	m.IndicationCodeableConcept = temp.IndicationCodeableConcept
	m.IndicationReference = temp.IndicationReference
	m.PatientCharacteristics = temp.PatientCharacteristics
	return nil
}

// ToJSON converts MedicationKnowledgeAdministrationGuidelines to JSON data.
func (m *MedicationKnowledgeAdministrationGuidelines) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Dosage []*MedicationKnowledgeDosage `json:"dosage,omitempty"`
		IndicationCodeableConcept *CodeableConcept `json:"indicationcodeableconcept,omitempty"`
		IndicationReference *Reference `json:"indicationreference,omitempty"`
		PatientCharacteristics []*MedicationKnowledgePatientCharacteristics `json:"patientcharacteristics,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Dosage = m.Dosage
	output.IndicationCodeableConcept = m.IndicationCodeableConcept
	output.IndicationReference = m.IndicationReference
	output.PatientCharacteristics = m.PatientCharacteristics
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeAdministrationGuidelines.
func (m *MedicationKnowledgeAdministrationGuidelines) Clone() *MedicationKnowledgeAdministrationGuidelines {
	if m == nil { return nil }
	return &MedicationKnowledgeAdministrationGuidelines{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Dosage: cloneSlices(m.Dosage),
		IndicationCodeableConcept: m.IndicationCodeableConcept.Clone(),
		IndicationReference: m.IndicationReference.Clone(),
		PatientCharacteristics: cloneSlices(m.PatientCharacteristics),
	}
}

// Equals checks equality between two MedicationKnowledgeAdministrationGuidelines instances.
func (m *MedicationKnowledgeAdministrationGuidelines) Equals(other *MedicationKnowledgeAdministrationGuidelines) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Dosage, other.Dosage) { return false }
	if !m.IndicationCodeableConcept.Equals(other.IndicationCodeableConcept) { return false }
	if !m.IndicationReference.Equals(other.IndicationReference) { return false }
	if !compareSlices(m.PatientCharacteristics, other.PatientCharacteristics) { return false }
	return true
}

// MedicationKnowledgeDosage
// Dosage for the medication for the specific guidelines.
type MedicationKnowledgeDosage struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Dosage []*Dosage `json:"dosage,omitempty"`
}

// NewMedicationKnowledgeDosage creates a new MedicationKnowledgeDosage instance.
func NewMedicationKnowledgeDosage() *MedicationKnowledgeDosage {
	return &MedicationKnowledgeDosage{}
}

// FromJSON populates MedicationKnowledgeDosage from JSON data.
func (m *MedicationKnowledgeDosage) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Dosage []*Dosage `json:"dosage,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Dosage = temp.Dosage
	return nil
}

// ToJSON converts MedicationKnowledgeDosage to JSON data.
func (m *MedicationKnowledgeDosage) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Dosage []*Dosage `json:"dosage,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Dosage = m.Dosage
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeDosage.
func (m *MedicationKnowledgeDosage) Clone() *MedicationKnowledgeDosage {
	if m == nil { return nil }
	return &MedicationKnowledgeDosage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Dosage: cloneSlices(m.Dosage),
	}
}

// Equals checks equality between two MedicationKnowledgeDosage instances.
func (m *MedicationKnowledgeDosage) Equals(other *MedicationKnowledgeDosage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Dosage, other.Dosage) { return false }
	return true
}

// MedicationKnowledgePatientCharacteristics
// Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
type MedicationKnowledgePatientCharacteristics struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	CharacteristicCodeableConcept *CodeableConcept `json:"characteristiccodeableconcept,omitempty"`
	CharacteristicQuantity *Quantity `json:"characteristicquantity,omitempty"`
	Value []*FhirString `json:"value,omitempty"`
}

// NewMedicationKnowledgePatientCharacteristics creates a new MedicationKnowledgePatientCharacteristics instance.
func NewMedicationKnowledgePatientCharacteristics() *MedicationKnowledgePatientCharacteristics {
	return &MedicationKnowledgePatientCharacteristics{}
}

// FromJSON populates MedicationKnowledgePatientCharacteristics from JSON data.
func (m *MedicationKnowledgePatientCharacteristics) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		CharacteristicCodeableConcept *CodeableConcept `json:"characteristiccodeableconcept,omitempty"`
		CharacteristicQuantity *Quantity `json:"characteristicquantity,omitempty"`
		Value []interface{} `json:"value,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.CharacteristicCodeableConcept = temp.CharacteristicCodeableConcept
	m.CharacteristicQuantity = temp.CharacteristicQuantity
	if len(temp.Value) > 0 {
		m.Value = make([]*FhirString, len(temp.Value))
		for i := range temp.Value {
			itemMap, ok := temp.Value[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Value[%d]: expected map", i) }
			primitive, err := NewFhirStringFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Value[%d]: %v", i, err) }
			m.Value[i] = primitive
		}
	}
	return nil
}

// ToJSON converts MedicationKnowledgePatientCharacteristics to JSON data.
func (m *MedicationKnowledgePatientCharacteristics) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		CharacteristicCodeableConcept *CodeableConcept `json:"characteristiccodeableconcept,omitempty"`
		CharacteristicQuantity *Quantity `json:"characteristicquantity,omitempty"`
		Value []interface{} `json:"value,omitempty"`
		ValueElement []map[string]interface{} `json:"_value,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.CharacteristicCodeableConcept = m.CharacteristicCodeableConcept
	output.CharacteristicQuantity = m.CharacteristicQuantity
	if len(m.Value) > 0 {
		output.Value = make([]interface{}, len(m.Value))
		output.ValueElement = make([]map[string]interface{}, len(m.Value))
		for i, item := range m.Value {
			if item != nil && item.Value != nil {
				output.Value[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.ValueElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgePatientCharacteristics.
func (m *MedicationKnowledgePatientCharacteristics) Clone() *MedicationKnowledgePatientCharacteristics {
	if m == nil { return nil }
	return &MedicationKnowledgePatientCharacteristics{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		CharacteristicCodeableConcept: m.CharacteristicCodeableConcept.Clone(),
		CharacteristicQuantity: m.CharacteristicQuantity.Clone(),
		Value: cloneSlices(m.Value),
	}
}

// Equals checks equality between two MedicationKnowledgePatientCharacteristics instances.
func (m *MedicationKnowledgePatientCharacteristics) Equals(other *MedicationKnowledgePatientCharacteristics) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.CharacteristicCodeableConcept.Equals(other.CharacteristicCodeableConcept) { return false }
	if !m.CharacteristicQuantity.Equals(other.CharacteristicQuantity) { return false }
	if !compareSlices(m.Value, other.Value) { return false }
	return true
}

// MedicationKnowledgeMedicineClassification
// Categorization of the medication within a formulary or classification system.
type MedicationKnowledgeMedicineClassification struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Classification []*CodeableConcept `json:"classification,omitempty"`
}

// NewMedicationKnowledgeMedicineClassification creates a new MedicationKnowledgeMedicineClassification instance.
func NewMedicationKnowledgeMedicineClassification() *MedicationKnowledgeMedicineClassification {
	return &MedicationKnowledgeMedicineClassification{}
}

// FromJSON populates MedicationKnowledgeMedicineClassification from JSON data.
func (m *MedicationKnowledgeMedicineClassification) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Classification []*CodeableConcept `json:"classification,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Classification = temp.Classification
	return nil
}

// ToJSON converts MedicationKnowledgeMedicineClassification to JSON data.
func (m *MedicationKnowledgeMedicineClassification) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Classification []*CodeableConcept `json:"classification,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Classification = m.Classification
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeMedicineClassification.
func (m *MedicationKnowledgeMedicineClassification) Clone() *MedicationKnowledgeMedicineClassification {
	if m == nil { return nil }
	return &MedicationKnowledgeMedicineClassification{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Classification: cloneSlices(m.Classification),
	}
}

// Equals checks equality between two MedicationKnowledgeMedicineClassification instances.
func (m *MedicationKnowledgeMedicineClassification) Equals(other *MedicationKnowledgeMedicineClassification) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	return true
}

// MedicationKnowledgePackaging
// Information that only applies to packages (not products).
type MedicationKnowledgePackaging struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
}

// NewMedicationKnowledgePackaging creates a new MedicationKnowledgePackaging instance.
func NewMedicationKnowledgePackaging() *MedicationKnowledgePackaging {
	return &MedicationKnowledgePackaging{}
}

// FromJSON populates MedicationKnowledgePackaging from JSON data.
func (m *MedicationKnowledgePackaging) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Quantity = temp.Quantity
	return nil
}

// ToJSON converts MedicationKnowledgePackaging to JSON data.
func (m *MedicationKnowledgePackaging) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Quantity = m.Quantity
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgePackaging.
func (m *MedicationKnowledgePackaging) Clone() *MedicationKnowledgePackaging {
	if m == nil { return nil }
	return &MedicationKnowledgePackaging{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Quantity: m.Quantity.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgePackaging instances.
func (m *MedicationKnowledgePackaging) Equals(other *MedicationKnowledgePackaging) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	return true
}

// MedicationKnowledgeDrugCharacteristic
// Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
type MedicationKnowledgeDrugCharacteristic struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
}

// NewMedicationKnowledgeDrugCharacteristic creates a new MedicationKnowledgeDrugCharacteristic instance.
func NewMedicationKnowledgeDrugCharacteristic() *MedicationKnowledgeDrugCharacteristic {
	return &MedicationKnowledgeDrugCharacteristic{}
}

// FromJSON populates MedicationKnowledgeDrugCharacteristic from JSON data.
func (m *MedicationKnowledgeDrugCharacteristic) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueString *FhirString `json:"valuestring,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.ValueCodeableConcept = temp.ValueCodeableConcept
	m.ValueString = temp.ValueString
	m.ValueQuantity = temp.ValueQuantity
	m.ValueBase64Binary = temp.ValueBase64Binary
	return nil
}

// ToJSON converts MedicationKnowledgeDrugCharacteristic to JSON data.
func (m *MedicationKnowledgeDrugCharacteristic) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueString interface{} `json:"valuestring,omitempty"`
		ValueStringElement map[string]interface{} `json:"_valuestring,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueBase64Binary interface{} `json:"valuebase64binary,omitempty"`
		ValueBase64BinaryElement map[string]interface{} `json:"_valuebase64binary,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.ValueCodeableConcept = m.ValueCodeableConcept
	if m.ValueString != nil && m.ValueString.Value != nil {
		output.ValueString = m.ValueString.Value
		if m.ValueString.Element != nil {
			output.ValueStringElement = toMapOrNil(m.ValueString.Element.ToJSON())
		}
	}
	output.ValueQuantity = m.ValueQuantity
	if m.ValueBase64Binary != nil && m.ValueBase64Binary.Value != nil {
		output.ValueBase64Binary = m.ValueBase64Binary.Value
		if m.ValueBase64Binary.Element != nil {
			output.ValueBase64BinaryElement = toMapOrNil(m.ValueBase64Binary.Element.ToJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeDrugCharacteristic.
func (m *MedicationKnowledgeDrugCharacteristic) Clone() *MedicationKnowledgeDrugCharacteristic {
	if m == nil { return nil }
	return &MedicationKnowledgeDrugCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeDrugCharacteristic instances.
func (m *MedicationKnowledgeDrugCharacteristic) Equals(other *MedicationKnowledgeDrugCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	return true
}

// MedicationKnowledgeRegulatory
// Regulatory information about a medication.
type MedicationKnowledgeRegulatory struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	RegulatoryAuthority *Reference `json:"regulatoryauthority,omitempty"`
	Substitution []*MedicationKnowledgeSubstitution `json:"substitution,omitempty"`
	Schedule []*MedicationKnowledgeSchedule `json:"schedule,omitempty"`
	MaxDispense *MedicationKnowledgeMaxDispense `json:"maxdispense,omitempty"`
}

// NewMedicationKnowledgeRegulatory creates a new MedicationKnowledgeRegulatory instance.
func NewMedicationKnowledgeRegulatory() *MedicationKnowledgeRegulatory {
	return &MedicationKnowledgeRegulatory{}
}

// FromJSON populates MedicationKnowledgeRegulatory from JSON data.
func (m *MedicationKnowledgeRegulatory) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		RegulatoryAuthority *Reference `json:"regulatoryauthority,omitempty"`
		Substitution []*MedicationKnowledgeSubstitution `json:"substitution,omitempty"`
		Schedule []*MedicationKnowledgeSchedule `json:"schedule,omitempty"`
		MaxDispense *MedicationKnowledgeMaxDispense `json:"maxdispense,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.RegulatoryAuthority = temp.RegulatoryAuthority
	m.Substitution = temp.Substitution
	m.Schedule = temp.Schedule
	m.MaxDispense = temp.MaxDispense
	return nil
}

// ToJSON converts MedicationKnowledgeRegulatory to JSON data.
func (m *MedicationKnowledgeRegulatory) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		RegulatoryAuthority *Reference `json:"regulatoryauthority,omitempty"`
		Substitution []*MedicationKnowledgeSubstitution `json:"substitution,omitempty"`
		Schedule []*MedicationKnowledgeSchedule `json:"schedule,omitempty"`
		MaxDispense *MedicationKnowledgeMaxDispense `json:"maxdispense,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.RegulatoryAuthority = m.RegulatoryAuthority
	output.Substitution = m.Substitution
	output.Schedule = m.Schedule
	output.MaxDispense = m.MaxDispense
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeRegulatory.
func (m *MedicationKnowledgeRegulatory) Clone() *MedicationKnowledgeRegulatory {
	if m == nil { return nil }
	return &MedicationKnowledgeRegulatory{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		RegulatoryAuthority: m.RegulatoryAuthority.Clone(),
		Substitution: cloneSlices(m.Substitution),
		Schedule: cloneSlices(m.Schedule),
		MaxDispense: m.MaxDispense.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeRegulatory instances.
func (m *MedicationKnowledgeRegulatory) Equals(other *MedicationKnowledgeRegulatory) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.RegulatoryAuthority.Equals(other.RegulatoryAuthority) { return false }
	if !compareSlices(m.Substitution, other.Substitution) { return false }
	if !compareSlices(m.Schedule, other.Schedule) { return false }
	if !m.MaxDispense.Equals(other.MaxDispense) { return false }
	return true
}

// MedicationKnowledgeSubstitution
// Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
type MedicationKnowledgeSubstitution struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Allowed *FhirBoolean `json:"allowed,omitempty"`
}

// NewMedicationKnowledgeSubstitution creates a new MedicationKnowledgeSubstitution instance.
func NewMedicationKnowledgeSubstitution() *MedicationKnowledgeSubstitution {
	return &MedicationKnowledgeSubstitution{}
}

// FromJSON populates MedicationKnowledgeSubstitution from JSON data.
func (m *MedicationKnowledgeSubstitution) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Allowed *FhirBoolean `json:"allowed,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Allowed = temp.Allowed
	return nil
}

// ToJSON converts MedicationKnowledgeSubstitution to JSON data.
func (m *MedicationKnowledgeSubstitution) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Allowed interface{} `json:"allowed,omitempty"`
		AllowedElement map[string]interface{} `json:"_allowed,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.Allowed != nil && m.Allowed.Value != nil {
		output.Allowed = m.Allowed.Value
		if m.Allowed.Element != nil {
			output.AllowedElement = toMapOrNil(m.Allowed.Element.ToJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeSubstitution.
func (m *MedicationKnowledgeSubstitution) Clone() *MedicationKnowledgeSubstitution {
	if m == nil { return nil }
	return &MedicationKnowledgeSubstitution{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Allowed: m.Allowed.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeSubstitution instances.
func (m *MedicationKnowledgeSubstitution) Equals(other *MedicationKnowledgeSubstitution) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Allowed.Equals(other.Allowed) { return false }
	return true
}

// MedicationKnowledgeSchedule
// Specifies the schedule of a medication in jurisdiction.
type MedicationKnowledgeSchedule struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Schedule *CodeableConcept `json:"schedule,omitempty"`
}

// NewMedicationKnowledgeSchedule creates a new MedicationKnowledgeSchedule instance.
func NewMedicationKnowledgeSchedule() *MedicationKnowledgeSchedule {
	return &MedicationKnowledgeSchedule{}
}

// FromJSON populates MedicationKnowledgeSchedule from JSON data.
func (m *MedicationKnowledgeSchedule) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Schedule *CodeableConcept `json:"schedule,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Schedule = temp.Schedule
	return nil
}

// ToJSON converts MedicationKnowledgeSchedule to JSON data.
func (m *MedicationKnowledgeSchedule) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Schedule *CodeableConcept `json:"schedule,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Schedule = m.Schedule
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeSchedule.
func (m *MedicationKnowledgeSchedule) Clone() *MedicationKnowledgeSchedule {
	if m == nil { return nil }
	return &MedicationKnowledgeSchedule{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Schedule: m.Schedule.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeSchedule instances.
func (m *MedicationKnowledgeSchedule) Equals(other *MedicationKnowledgeSchedule) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Schedule.Equals(other.Schedule) { return false }
	return true
}

// MedicationKnowledgeMaxDispense
// The maximum number of units of the medication that can be dispensed in a period.
type MedicationKnowledgeMaxDispense struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Period *FhirDuration `json:"period,omitempty"`
}

// NewMedicationKnowledgeMaxDispense creates a new MedicationKnowledgeMaxDispense instance.
func NewMedicationKnowledgeMaxDispense() *MedicationKnowledgeMaxDispense {
	return &MedicationKnowledgeMaxDispense{}
}

// FromJSON populates MedicationKnowledgeMaxDispense from JSON data.
func (m *MedicationKnowledgeMaxDispense) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Period *FhirDuration `json:"period,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Quantity = temp.Quantity
	m.Period = temp.Period
	return nil
}

// ToJSON converts MedicationKnowledgeMaxDispense to JSON data.
func (m *MedicationKnowledgeMaxDispense) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Period *FhirDuration `json:"period,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Quantity = m.Quantity
	output.Period = m.Period
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeMaxDispense.
func (m *MedicationKnowledgeMaxDispense) Clone() *MedicationKnowledgeMaxDispense {
	if m == nil { return nil }
	return &MedicationKnowledgeMaxDispense{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Quantity: m.Quantity.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeMaxDispense instances.
func (m *MedicationKnowledgeMaxDispense) Equals(other *MedicationKnowledgeMaxDispense) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// MedicationKnowledgeKinetics
// The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
type MedicationKnowledgeKinetics struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	AreaUnderCurve []*Quantity `json:"areaundercurve,omitempty"`
	LethalDose50 []*Quantity `json:"lethaldose50,omitempty"`
	HalfLifePeriod *FhirDuration `json:"halflifeperiod,omitempty"`
}

// NewMedicationKnowledgeKinetics creates a new MedicationKnowledgeKinetics instance.
func NewMedicationKnowledgeKinetics() *MedicationKnowledgeKinetics {
	return &MedicationKnowledgeKinetics{}
}

// FromJSON populates MedicationKnowledgeKinetics from JSON data.
func (m *MedicationKnowledgeKinetics) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		AreaUnderCurve []*Quantity `json:"areaundercurve,omitempty"`
		LethalDose50 []*Quantity `json:"lethaldose50,omitempty"`
		HalfLifePeriod *FhirDuration `json:"halflifeperiod,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.AreaUnderCurve = temp.AreaUnderCurve
	m.LethalDose50 = temp.LethalDose50
	m.HalfLifePeriod = temp.HalfLifePeriod
	return nil
}

// ToJSON converts MedicationKnowledgeKinetics to JSON data.
func (m *MedicationKnowledgeKinetics) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		AreaUnderCurve []*Quantity `json:"areaundercurve,omitempty"`
		LethalDose50 []*Quantity `json:"lethaldose50,omitempty"`
		HalfLifePeriod *FhirDuration `json:"halflifeperiod,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.AreaUnderCurve = m.AreaUnderCurve
	output.LethalDose50 = m.LethalDose50
	output.HalfLifePeriod = m.HalfLifePeriod
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicationKnowledgeKinetics.
func (m *MedicationKnowledgeKinetics) Clone() *MedicationKnowledgeKinetics {
	if m == nil { return nil }
	return &MedicationKnowledgeKinetics{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		AreaUnderCurve: cloneSlices(m.AreaUnderCurve),
		LethalDose50: cloneSlices(m.LethalDose50),
		HalfLifePeriod: m.HalfLifePeriod.Clone(),
	}
}

// Equals checks equality between two MedicationKnowledgeKinetics instances.
func (m *MedicationKnowledgeKinetics) Equals(other *MedicationKnowledgeKinetics) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.AreaUnderCurve, other.AreaUnderCurve) { return false }
	if !compareSlices(m.LethalDose50, other.LethalDose50) { return false }
	if !m.HalfLifePeriod.Equals(other.HalfLifePeriod) { return false }
	return true
}

