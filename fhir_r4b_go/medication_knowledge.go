// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// MedicationKnowledge
// Information about a medication that is used to support knowledge.
type MedicationKnowledge struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Status *MedicationKnowledgeStatusCodes `json:"status,omitempty"`
	Manufacturer *Reference `json:"manufacturer,omitempty"`
	DoseForm *CodeableConcept `json:"doseform,omitempty"`
	Amount *Quantity `json:"amount,omitempty"`
	Synonym []*FhirString `json:"synonym,omitempty"`
	RelatedMedicationKnowledge []*MedicationKnowledgeRelatedMedicationKnowledge `json:"relatedmedicationknowledge,omitempty"`
	AssociatedMedication []*Reference `json:"associatedmedication,omitempty"`
	ProductType []*CodeableConcept `json:"producttype,omitempty"`
	Monograph []*MedicationKnowledgeMonograph `json:"monograph,omitempty"`
	Ingredient []*MedicationKnowledgeIngredient `json:"ingredient,omitempty"`
	PreparationInstruction *FhirMarkdown `json:"preparationinstruction,omitempty"`
	IntendedRoute []*CodeableConcept `json:"intendedroute,omitempty"`
	Cost []*MedicationKnowledgeCost `json:"cost,omitempty"`
	MonitoringProgram []*MedicationKnowledgeMonitoringProgram `json:"monitoringprogram,omitempty"`
	AdministrationGuidelines []*MedicationKnowledgeAdministrationGuidelines `json:"administrationguidelines,omitempty"`
	MedicineClassification []*MedicationKnowledgeMedicineClassification `json:"medicineclassification,omitempty"`
	Packaging *MedicationKnowledgePackaging `json:"packaging,omitempty"`
	DrugCharacteristic []*MedicationKnowledgeDrugCharacteristic `json:"drugcharacteristic,omitempty"`
	Contraindication []*Reference `json:"contraindication,omitempty"`
	Regulatory []*MedicationKnowledgeRegulatory `json:"regulatory,omitempty"`
	Kinetics []*MedicationKnowledgeKinetics `json:"kinetics,omitempty"`
}

// NewMedicationKnowledge creates a new MedicationKnowledge instance
func NewMedicationKnowledge() *MedicationKnowledge {
	return &MedicationKnowledge{}
}

// FromJSON populates MedicationKnowledge from JSON data
func (m *MedicationKnowledge) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledge to JSON data
func (m *MedicationKnowledge) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledge
func (m *MedicationKnowledge) Clone() *MedicationKnowledge {
	if m == nil { return nil }
	return &MedicationKnowledge{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Status: m.Status.Clone(),
		Manufacturer: m.Manufacturer.Clone(),
		DoseForm: m.DoseForm.Clone(),
		Amount: m.Amount.Clone(),
		Synonym: cloneSlices(m.Synonym),
		RelatedMedicationKnowledge: cloneSlices(m.RelatedMedicationKnowledge),
		AssociatedMedication: cloneSlices(m.AssociatedMedication),
		ProductType: cloneSlices(m.ProductType),
		Monograph: cloneSlices(m.Monograph),
		Ingredient: cloneSlices(m.Ingredient),
		PreparationInstruction: m.PreparationInstruction.Clone(),
		IntendedRoute: cloneSlices(m.IntendedRoute),
		Cost: cloneSlices(m.Cost),
		MonitoringProgram: cloneSlices(m.MonitoringProgram),
		AdministrationGuidelines: cloneSlices(m.AdministrationGuidelines),
		MedicineClassification: cloneSlices(m.MedicineClassification),
		Packaging: m.Packaging.Clone(),
		DrugCharacteristic: cloneSlices(m.DrugCharacteristic),
		Contraindication: cloneSlices(m.Contraindication),
		Regulatory: cloneSlices(m.Regulatory),
		Kinetics: cloneSlices(m.Kinetics),
	}
}

// Equals checks for equality with another MedicationKnowledge instance
func (m *MedicationKnowledge) Equals(other *MedicationKnowledge) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Manufacturer.Equals(other.Manufacturer) { return false }
	if !m.DoseForm.Equals(other.DoseForm) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !compareSlices(m.Synonym, other.Synonym) { return false }
	if !compareSlices(m.RelatedMedicationKnowledge, other.RelatedMedicationKnowledge) { return false }
	if !compareSlices(m.AssociatedMedication, other.AssociatedMedication) { return false }
	if !compareSlices(m.ProductType, other.ProductType) { return false }
	if !compareSlices(m.Monograph, other.Monograph) { return false }
	if !compareSlices(m.Ingredient, other.Ingredient) { return false }
	if !m.PreparationInstruction.Equals(other.PreparationInstruction) { return false }
	if !compareSlices(m.IntendedRoute, other.IntendedRoute) { return false }
	if !compareSlices(m.Cost, other.Cost) { return false }
	if !compareSlices(m.MonitoringProgram, other.MonitoringProgram) { return false }
	if !compareSlices(m.AdministrationGuidelines, other.AdministrationGuidelines) { return false }
	if !compareSlices(m.MedicineClassification, other.MedicineClassification) { return false }
	if !m.Packaging.Equals(other.Packaging) { return false }
	if !compareSlices(m.DrugCharacteristic, other.DrugCharacteristic) { return false }
	if !compareSlices(m.Contraindication, other.Contraindication) { return false }
	if !compareSlices(m.Regulatory, other.Regulatory) { return false }
	if !compareSlices(m.Kinetics, other.Kinetics) { return false }
	return true
}

// MedicationKnowledgeRelatedMedicationKnowledge
// Associated or related knowledge about a medication.
type MedicationKnowledgeRelatedMedicationKnowledge struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Reference []*Reference `json:"reference,omitempty"`
}

// NewMedicationKnowledgeRelatedMedicationKnowledge creates a new MedicationKnowledgeRelatedMedicationKnowledge instance
func NewMedicationKnowledgeRelatedMedicationKnowledge() *MedicationKnowledgeRelatedMedicationKnowledge {
	return &MedicationKnowledgeRelatedMedicationKnowledge{}
}

// FromJSON populates MedicationKnowledgeRelatedMedicationKnowledge from JSON data
func (m *MedicationKnowledgeRelatedMedicationKnowledge) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeRelatedMedicationKnowledge to JSON data
func (m *MedicationKnowledgeRelatedMedicationKnowledge) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeRelatedMedicationKnowledge
func (m *MedicationKnowledgeRelatedMedicationKnowledge) Clone() *MedicationKnowledgeRelatedMedicationKnowledge {
	if m == nil { return nil }
	return &MedicationKnowledgeRelatedMedicationKnowledge{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Reference: cloneSlices(m.Reference),
	}
}

// Equals checks for equality with another MedicationKnowledgeRelatedMedicationKnowledge instance
func (m *MedicationKnowledgeRelatedMedicationKnowledge) Equals(other *MedicationKnowledgeRelatedMedicationKnowledge) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Reference, other.Reference) { return false }
	return true
}

// MedicationKnowledgeMonograph
// Associated documentation about the medication.
type MedicationKnowledgeMonograph struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Source *Reference `json:"source,omitempty"`
}

// NewMedicationKnowledgeMonograph creates a new MedicationKnowledgeMonograph instance
func NewMedicationKnowledgeMonograph() *MedicationKnowledgeMonograph {
	return &MedicationKnowledgeMonograph{}
}

// FromJSON populates MedicationKnowledgeMonograph from JSON data
func (m *MedicationKnowledgeMonograph) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeMonograph to JSON data
func (m *MedicationKnowledgeMonograph) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeMonograph
func (m *MedicationKnowledgeMonograph) Clone() *MedicationKnowledgeMonograph {
	if m == nil { return nil }
	return &MedicationKnowledgeMonograph{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Source: m.Source.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeMonograph instance
func (m *MedicationKnowledgeMonograph) Equals(other *MedicationKnowledgeMonograph) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Source.Equals(other.Source) { return false }
	return true
}

// MedicationKnowledgeIngredient
// Identifies a particular constituent of interest in the product.
type MedicationKnowledgeIngredient struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemCodeableConcept *CodeableConcept `json:"itemcodeableconcept,omitempty"`
	ItemReference *Reference `json:"itemreference,omitempty"`
	IsActive *FhirBoolean `json:"isactive,omitempty"`
	Strength *Ratio `json:"strength,omitempty"`
}

// NewMedicationKnowledgeIngredient creates a new MedicationKnowledgeIngredient instance
func NewMedicationKnowledgeIngredient() *MedicationKnowledgeIngredient {
	return &MedicationKnowledgeIngredient{}
}

// FromJSON populates MedicationKnowledgeIngredient from JSON data
func (m *MedicationKnowledgeIngredient) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeIngredient to JSON data
func (m *MedicationKnowledgeIngredient) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeIngredient
func (m *MedicationKnowledgeIngredient) Clone() *MedicationKnowledgeIngredient {
	if m == nil { return nil }
	return &MedicationKnowledgeIngredient{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemCodeableConcept: m.ItemCodeableConcept.Clone(),
		ItemReference: m.ItemReference.Clone(),
		IsActive: m.IsActive.Clone(),
		Strength: m.Strength.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeIngredient instance
func (m *MedicationKnowledgeIngredient) Equals(other *MedicationKnowledgeIngredient) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ItemCodeableConcept.Equals(other.ItemCodeableConcept) { return false }
	if !m.ItemReference.Equals(other.ItemReference) { return false }
	if !m.IsActive.Equals(other.IsActive) { return false }
	if !m.Strength.Equals(other.Strength) { return false }
	return true
}

// MedicationKnowledgeCost
// The price of the medication.
type MedicationKnowledgeCost struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Source *FhirString `json:"source,omitempty"`
	Cost *Money `json:"cost,omitempty"`
}

// NewMedicationKnowledgeCost creates a new MedicationKnowledgeCost instance
func NewMedicationKnowledgeCost() *MedicationKnowledgeCost {
	return &MedicationKnowledgeCost{}
}

// FromJSON populates MedicationKnowledgeCost from JSON data
func (m *MedicationKnowledgeCost) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeCost to JSON data
func (m *MedicationKnowledgeCost) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeCost
func (m *MedicationKnowledgeCost) Clone() *MedicationKnowledgeCost {
	if m == nil { return nil }
	return &MedicationKnowledgeCost{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Source: m.Source.Clone(),
		Cost: m.Cost.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeCost instance
func (m *MedicationKnowledgeCost) Equals(other *MedicationKnowledgeCost) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !m.Cost.Equals(other.Cost) { return false }
	return true
}

// MedicationKnowledgeMonitoringProgram
// The program under which the medication is reviewed.
type MedicationKnowledgeMonitoringProgram struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Name *FhirString `json:"name,omitempty"`
}

// NewMedicationKnowledgeMonitoringProgram creates a new MedicationKnowledgeMonitoringProgram instance
func NewMedicationKnowledgeMonitoringProgram() *MedicationKnowledgeMonitoringProgram {
	return &MedicationKnowledgeMonitoringProgram{}
}

// FromJSON populates MedicationKnowledgeMonitoringProgram from JSON data
func (m *MedicationKnowledgeMonitoringProgram) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeMonitoringProgram to JSON data
func (m *MedicationKnowledgeMonitoringProgram) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeMonitoringProgram
func (m *MedicationKnowledgeMonitoringProgram) Clone() *MedicationKnowledgeMonitoringProgram {
	if m == nil { return nil }
	return &MedicationKnowledgeMonitoringProgram{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Name: m.Name.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeMonitoringProgram instance
func (m *MedicationKnowledgeMonitoringProgram) Equals(other *MedicationKnowledgeMonitoringProgram) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Name.Equals(other.Name) { return false }
	return true
}

// MedicationKnowledgeAdministrationGuidelines
// Guidelines for the administration of the medication.
type MedicationKnowledgeAdministrationGuidelines struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Dosage []*MedicationKnowledgeDosage `json:"dosage,omitempty"`
	IndicationCodeableConcept *CodeableConcept `json:"indicationcodeableconcept,omitempty"`
	IndicationReference *Reference `json:"indicationreference,omitempty"`
	PatientCharacteristics []*MedicationKnowledgePatientCharacteristics `json:"patientcharacteristics,omitempty"`
}

// NewMedicationKnowledgeAdministrationGuidelines creates a new MedicationKnowledgeAdministrationGuidelines instance
func NewMedicationKnowledgeAdministrationGuidelines() *MedicationKnowledgeAdministrationGuidelines {
	return &MedicationKnowledgeAdministrationGuidelines{}
}

// FromJSON populates MedicationKnowledgeAdministrationGuidelines from JSON data
func (m *MedicationKnowledgeAdministrationGuidelines) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeAdministrationGuidelines to JSON data
func (m *MedicationKnowledgeAdministrationGuidelines) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeAdministrationGuidelines
func (m *MedicationKnowledgeAdministrationGuidelines) Clone() *MedicationKnowledgeAdministrationGuidelines {
	if m == nil { return nil }
	return &MedicationKnowledgeAdministrationGuidelines{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Dosage: cloneSlices(m.Dosage),
		IndicationCodeableConcept: m.IndicationCodeableConcept.Clone(),
		IndicationReference: m.IndicationReference.Clone(),
		PatientCharacteristics: cloneSlices(m.PatientCharacteristics),
	}
}

// Equals checks for equality with another MedicationKnowledgeAdministrationGuidelines instance
func (m *MedicationKnowledgeAdministrationGuidelines) Equals(other *MedicationKnowledgeAdministrationGuidelines) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Dosage, other.Dosage) { return false }
	if !m.IndicationCodeableConcept.Equals(other.IndicationCodeableConcept) { return false }
	if !m.IndicationReference.Equals(other.IndicationReference) { return false }
	if !compareSlices(m.PatientCharacteristics, other.PatientCharacteristics) { return false }
	return true
}

// MedicationKnowledgeDosage
// Dosage for the medication for the specific guidelines.
type MedicationKnowledgeDosage struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Dosage []*Dosage `json:"dosage,omitempty"`
}

// NewMedicationKnowledgeDosage creates a new MedicationKnowledgeDosage instance
func NewMedicationKnowledgeDosage() *MedicationKnowledgeDosage {
	return &MedicationKnowledgeDosage{}
}

// FromJSON populates MedicationKnowledgeDosage from JSON data
func (m *MedicationKnowledgeDosage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeDosage to JSON data
func (m *MedicationKnowledgeDosage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeDosage
func (m *MedicationKnowledgeDosage) Clone() *MedicationKnowledgeDosage {
	if m == nil { return nil }
	return &MedicationKnowledgeDosage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Dosage: cloneSlices(m.Dosage),
	}
}

// Equals checks for equality with another MedicationKnowledgeDosage instance
func (m *MedicationKnowledgeDosage) Equals(other *MedicationKnowledgeDosage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Dosage, other.Dosage) { return false }
	return true
}

// MedicationKnowledgePatientCharacteristics
// Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
type MedicationKnowledgePatientCharacteristics struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	CharacteristicCodeableConcept *CodeableConcept `json:"characteristiccodeableconcept,omitempty"`
	CharacteristicQuantity *Quantity `json:"characteristicquantity,omitempty"`
	Value []*FhirString `json:"value,omitempty"`
}

// NewMedicationKnowledgePatientCharacteristics creates a new MedicationKnowledgePatientCharacteristics instance
func NewMedicationKnowledgePatientCharacteristics() *MedicationKnowledgePatientCharacteristics {
	return &MedicationKnowledgePatientCharacteristics{}
}

// FromJSON populates MedicationKnowledgePatientCharacteristics from JSON data
func (m *MedicationKnowledgePatientCharacteristics) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgePatientCharacteristics to JSON data
func (m *MedicationKnowledgePatientCharacteristics) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgePatientCharacteristics
func (m *MedicationKnowledgePatientCharacteristics) Clone() *MedicationKnowledgePatientCharacteristics {
	if m == nil { return nil }
	return &MedicationKnowledgePatientCharacteristics{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		CharacteristicCodeableConcept: m.CharacteristicCodeableConcept.Clone(),
		CharacteristicQuantity: m.CharacteristicQuantity.Clone(),
		Value: cloneSlices(m.Value),
	}
}

// Equals checks for equality with another MedicationKnowledgePatientCharacteristics instance
func (m *MedicationKnowledgePatientCharacteristics) Equals(other *MedicationKnowledgePatientCharacteristics) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.CharacteristicCodeableConcept.Equals(other.CharacteristicCodeableConcept) { return false }
	if !m.CharacteristicQuantity.Equals(other.CharacteristicQuantity) { return false }
	if !compareSlices(m.Value, other.Value) { return false }
	return true
}

// MedicationKnowledgeMedicineClassification
// Categorization of the medication within a formulary or classification system.
type MedicationKnowledgeMedicineClassification struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Classification []*CodeableConcept `json:"classification,omitempty"`
}

// NewMedicationKnowledgeMedicineClassification creates a new MedicationKnowledgeMedicineClassification instance
func NewMedicationKnowledgeMedicineClassification() *MedicationKnowledgeMedicineClassification {
	return &MedicationKnowledgeMedicineClassification{}
}

// FromJSON populates MedicationKnowledgeMedicineClassification from JSON data
func (m *MedicationKnowledgeMedicineClassification) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeMedicineClassification to JSON data
func (m *MedicationKnowledgeMedicineClassification) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeMedicineClassification
func (m *MedicationKnowledgeMedicineClassification) Clone() *MedicationKnowledgeMedicineClassification {
	if m == nil { return nil }
	return &MedicationKnowledgeMedicineClassification{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Classification: cloneSlices(m.Classification),
	}
}

// Equals checks for equality with another MedicationKnowledgeMedicineClassification instance
func (m *MedicationKnowledgeMedicineClassification) Equals(other *MedicationKnowledgeMedicineClassification) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	return true
}

// MedicationKnowledgePackaging
// Information that only applies to packages (not products).
type MedicationKnowledgePackaging struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
}

// NewMedicationKnowledgePackaging creates a new MedicationKnowledgePackaging instance
func NewMedicationKnowledgePackaging() *MedicationKnowledgePackaging {
	return &MedicationKnowledgePackaging{}
}

// FromJSON populates MedicationKnowledgePackaging from JSON data
func (m *MedicationKnowledgePackaging) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgePackaging to JSON data
func (m *MedicationKnowledgePackaging) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgePackaging
func (m *MedicationKnowledgePackaging) Clone() *MedicationKnowledgePackaging {
	if m == nil { return nil }
	return &MedicationKnowledgePackaging{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Quantity: m.Quantity.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgePackaging instance
func (m *MedicationKnowledgePackaging) Equals(other *MedicationKnowledgePackaging) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	return true
}

// MedicationKnowledgeDrugCharacteristic
// Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
type MedicationKnowledgeDrugCharacteristic struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
}

// NewMedicationKnowledgeDrugCharacteristic creates a new MedicationKnowledgeDrugCharacteristic instance
func NewMedicationKnowledgeDrugCharacteristic() *MedicationKnowledgeDrugCharacteristic {
	return &MedicationKnowledgeDrugCharacteristic{}
}

// FromJSON populates MedicationKnowledgeDrugCharacteristic from JSON data
func (m *MedicationKnowledgeDrugCharacteristic) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeDrugCharacteristic to JSON data
func (m *MedicationKnowledgeDrugCharacteristic) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeDrugCharacteristic
func (m *MedicationKnowledgeDrugCharacteristic) Clone() *MedicationKnowledgeDrugCharacteristic {
	if m == nil { return nil }
	return &MedicationKnowledgeDrugCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeDrugCharacteristic instance
func (m *MedicationKnowledgeDrugCharacteristic) Equals(other *MedicationKnowledgeDrugCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	return true
}

// MedicationKnowledgeRegulatory
// Regulatory information about a medication.
type MedicationKnowledgeRegulatory struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	RegulatoryAuthority *Reference `json:"regulatoryauthority,omitempty"`
	Substitution []*MedicationKnowledgeSubstitution `json:"substitution,omitempty"`
	Schedule []*MedicationKnowledgeSchedule `json:"schedule,omitempty"`
	MaxDispense *MedicationKnowledgeMaxDispense `json:"maxdispense,omitempty"`
}

// NewMedicationKnowledgeRegulatory creates a new MedicationKnowledgeRegulatory instance
func NewMedicationKnowledgeRegulatory() *MedicationKnowledgeRegulatory {
	return &MedicationKnowledgeRegulatory{}
}

// FromJSON populates MedicationKnowledgeRegulatory from JSON data
func (m *MedicationKnowledgeRegulatory) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeRegulatory to JSON data
func (m *MedicationKnowledgeRegulatory) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeRegulatory
func (m *MedicationKnowledgeRegulatory) Clone() *MedicationKnowledgeRegulatory {
	if m == nil { return nil }
	return &MedicationKnowledgeRegulatory{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		RegulatoryAuthority: m.RegulatoryAuthority.Clone(),
		Substitution: cloneSlices(m.Substitution),
		Schedule: cloneSlices(m.Schedule),
		MaxDispense: m.MaxDispense.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeRegulatory instance
func (m *MedicationKnowledgeRegulatory) Equals(other *MedicationKnowledgeRegulatory) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.RegulatoryAuthority.Equals(other.RegulatoryAuthority) { return false }
	if !compareSlices(m.Substitution, other.Substitution) { return false }
	if !compareSlices(m.Schedule, other.Schedule) { return false }
	if !m.MaxDispense.Equals(other.MaxDispense) { return false }
	return true
}

// MedicationKnowledgeSubstitution
// Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
type MedicationKnowledgeSubstitution struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Allowed *FhirBoolean `json:"allowed,omitempty"`
}

// NewMedicationKnowledgeSubstitution creates a new MedicationKnowledgeSubstitution instance
func NewMedicationKnowledgeSubstitution() *MedicationKnowledgeSubstitution {
	return &MedicationKnowledgeSubstitution{}
}

// FromJSON populates MedicationKnowledgeSubstitution from JSON data
func (m *MedicationKnowledgeSubstitution) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeSubstitution to JSON data
func (m *MedicationKnowledgeSubstitution) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeSubstitution
func (m *MedicationKnowledgeSubstitution) Clone() *MedicationKnowledgeSubstitution {
	if m == nil { return nil }
	return &MedicationKnowledgeSubstitution{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Allowed: m.Allowed.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeSubstitution instance
func (m *MedicationKnowledgeSubstitution) Equals(other *MedicationKnowledgeSubstitution) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Allowed.Equals(other.Allowed) { return false }
	return true
}

// MedicationKnowledgeSchedule
// Specifies the schedule of a medication in jurisdiction.
type MedicationKnowledgeSchedule struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Schedule *CodeableConcept `json:"schedule,omitempty"`
}

// NewMedicationKnowledgeSchedule creates a new MedicationKnowledgeSchedule instance
func NewMedicationKnowledgeSchedule() *MedicationKnowledgeSchedule {
	return &MedicationKnowledgeSchedule{}
}

// FromJSON populates MedicationKnowledgeSchedule from JSON data
func (m *MedicationKnowledgeSchedule) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeSchedule to JSON data
func (m *MedicationKnowledgeSchedule) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeSchedule
func (m *MedicationKnowledgeSchedule) Clone() *MedicationKnowledgeSchedule {
	if m == nil { return nil }
	return &MedicationKnowledgeSchedule{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Schedule: m.Schedule.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeSchedule instance
func (m *MedicationKnowledgeSchedule) Equals(other *MedicationKnowledgeSchedule) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Schedule.Equals(other.Schedule) { return false }
	return true
}

// MedicationKnowledgeMaxDispense
// The maximum number of units of the medication that can be dispensed in a period.
type MedicationKnowledgeMaxDispense struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Period *FhirDuration `json:"period,omitempty"`
}

// NewMedicationKnowledgeMaxDispense creates a new MedicationKnowledgeMaxDispense instance
func NewMedicationKnowledgeMaxDispense() *MedicationKnowledgeMaxDispense {
	return &MedicationKnowledgeMaxDispense{}
}

// FromJSON populates MedicationKnowledgeMaxDispense from JSON data
func (m *MedicationKnowledgeMaxDispense) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeMaxDispense to JSON data
func (m *MedicationKnowledgeMaxDispense) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeMaxDispense
func (m *MedicationKnowledgeMaxDispense) Clone() *MedicationKnowledgeMaxDispense {
	if m == nil { return nil }
	return &MedicationKnowledgeMaxDispense{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Quantity: m.Quantity.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeMaxDispense instance
func (m *MedicationKnowledgeMaxDispense) Equals(other *MedicationKnowledgeMaxDispense) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// MedicationKnowledgeKinetics
// The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
type MedicationKnowledgeKinetics struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	AreaUnderCurve []*Quantity `json:"areaundercurve,omitempty"`
	LethalDose50 []*Quantity `json:"lethaldose50,omitempty"`
	HalfLifePeriod *FhirDuration `json:"halflifeperiod,omitempty"`
}

// NewMedicationKnowledgeKinetics creates a new MedicationKnowledgeKinetics instance
func NewMedicationKnowledgeKinetics() *MedicationKnowledgeKinetics {
	return &MedicationKnowledgeKinetics{}
}

// FromJSON populates MedicationKnowledgeKinetics from JSON data
func (m *MedicationKnowledgeKinetics) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationKnowledgeKinetics to JSON data
func (m *MedicationKnowledgeKinetics) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationKnowledgeKinetics
func (m *MedicationKnowledgeKinetics) Clone() *MedicationKnowledgeKinetics {
	if m == nil { return nil }
	return &MedicationKnowledgeKinetics{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		AreaUnderCurve: cloneSlices(m.AreaUnderCurve),
		LethalDose50: cloneSlices(m.LethalDose50),
		HalfLifePeriod: m.HalfLifePeriod.Clone(),
	}
}

// Equals checks for equality with another MedicationKnowledgeKinetics instance
func (m *MedicationKnowledgeKinetics) Equals(other *MedicationKnowledgeKinetics) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.AreaUnderCurve, other.AreaUnderCurve) { return false }
	if !compareSlices(m.LethalDose50, other.LethalDose50) { return false }
	if !m.HalfLifePeriod.Equals(other.HalfLifePeriod) { return false }
	return true
}

