// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// Provenance
// Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
type Provenance struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Target []*Reference `json:"target,omitempty"`
	OccurredPeriod *Period `json:"occurredperiod,omitempty"`
	OccurredDateTime *FhirDateTime `json:"occurreddatetime,omitempty"`
	Recorded *FhirInstant `json:"recorded,omitempty"`
	Policy []*FhirUri `json:"policy,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Reason []*CodeableConcept `json:"reason,omitempty"`
	Activity *CodeableConcept `json:"activity,omitempty"`
	Agent []*ProvenanceAgent `json:"agent,omitempty"`
	Entity []*ProvenanceEntity `json:"entity,omitempty"`
	Signature []*Signature `json:"signature,omitempty"`
}

// NewProvenance creates a new Provenance instance.
func NewProvenance() *Provenance {
	return &Provenance{}
}

// UnmarshalJSON populates Provenance from JSON data.
func (m *Provenance) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Target []*Reference `json:"target,omitempty"`
		OccurredPeriod *Period `json:"occurredperiod,omitempty"`
		OccurredDateTime *FhirDateTime `json:"occurreddatetime,omitempty"`
		Recorded *FhirInstant `json:"recorded,omitempty"`
		Policy []interface{} `json:"policy,omitempty"`
		Location *Reference `json:"location,omitempty"`
		Reason []*CodeableConcept `json:"reason,omitempty"`
		Activity *CodeableConcept `json:"activity,omitempty"`
		Agent []*ProvenanceAgent `json:"agent,omitempty"`
		Entity []*ProvenanceEntity `json:"entity,omitempty"`
		Signature []*Signature `json:"signature,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Target = temp.Target
	m.OccurredPeriod = temp.OccurredPeriod
	m.OccurredDateTime = temp.OccurredDateTime
	m.Recorded = temp.Recorded
	if len(temp.Policy) > 0 {
		m.Policy = make([]*FhirUri, len(temp.Policy))
		for i := range temp.Policy {
			itemMap, ok := temp.Policy[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Policy[%d]: expected map", i) }
			primitive, err := NewFhirUriFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Policy[%d]: %v", i, err) }
			m.Policy[i] = primitive
		}
	}
	m.Location = temp.Location
	m.Reason = temp.Reason
	m.Activity = temp.Activity
	m.Agent = temp.Agent
	m.Entity = temp.Entity
	m.Signature = temp.Signature
	return nil
}

// MarshalJSON converts Provenance to JSON data.
func (m *Provenance) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Target []*Reference `json:"target,omitempty"`
		OccurredPeriod *Period `json:"occurredperiod,omitempty"`
		OccurredDateTime interface{} `json:"occurreddatetime,omitempty"`
		OccurredDateTimeElement map[string]interface{} `json:"_occurreddatetime,omitempty"`
		Recorded interface{} `json:"recorded,omitempty"`
		RecordedElement map[string]interface{} `json:"_recorded,omitempty"`
		Policy []interface{} `json:"policy,omitempty"`
		PolicyElement []map[string]interface{} `json:"_policy,omitempty"`
		Location *Reference `json:"location,omitempty"`
		Reason []*CodeableConcept `json:"reason,omitempty"`
		Activity *CodeableConcept `json:"activity,omitempty"`
		Agent []*ProvenanceAgent `json:"agent,omitempty"`
		Entity []*ProvenanceEntity `json:"entity,omitempty"`
		Signature []*Signature `json:"signature,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Target = m.Target
	output.OccurredPeriod = m.OccurredPeriod
	if m.OccurredDateTime != nil && m.OccurredDateTime.Value != nil {
		output.OccurredDateTime = m.OccurredDateTime.Value
		if m.OccurredDateTime.Element != nil {
			output.OccurredDateTimeElement = toMapOrNil(m.OccurredDateTime.Element.MarshalJSON())
		}
	}
	if m.Recorded != nil && m.Recorded.Value != nil {
		output.Recorded = m.Recorded.Value
		if m.Recorded.Element != nil {
			output.RecordedElement = toMapOrNil(m.Recorded.Element.MarshalJSON())
		}
	}
	if len(m.Policy) > 0 {
		output.Policy = make([]interface{}, len(m.Policy))
		output.PolicyElement = make([]map[string]interface{}, len(m.Policy))
		for i, item := range m.Policy {
			if item != nil && item.Value != nil {
				output.Policy[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.PolicyElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	output.Location = m.Location
	output.Reason = m.Reason
	output.Activity = m.Activity
	output.Agent = m.Agent
	output.Entity = m.Entity
	output.Signature = m.Signature
	return json.Marshal(output)
}

// Clone creates a deep copy of Provenance.
func (m *Provenance) Clone() *Provenance {
	if m == nil { return nil }
	return &Provenance{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Target: cloneSlices(m.Target),
		OccurredPeriod: m.OccurredPeriod.Clone(),
		OccurredDateTime: m.OccurredDateTime.Clone(),
		Recorded: m.Recorded.Clone(),
		Policy: cloneSlices(m.Policy),
		Location: m.Location.Clone(),
		Reason: cloneSlices(m.Reason),
		Activity: m.Activity.Clone(),
		Agent: cloneSlices(m.Agent),
		Entity: cloneSlices(m.Entity),
		Signature: cloneSlices(m.Signature),
	}
}

// Equals checks equality between two Provenance instances.
func (m *Provenance) Equals(other *Provenance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Target, other.Target) { return false }
	if !m.OccurredPeriod.Equals(other.OccurredPeriod) { return false }
	if !m.OccurredDateTime.Equals(other.OccurredDateTime) { return false }
	if !m.Recorded.Equals(other.Recorded) { return false }
	if !compareSlices(m.Policy, other.Policy) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !compareSlices(m.Reason, other.Reason) { return false }
	if !m.Activity.Equals(other.Activity) { return false }
	if !compareSlices(m.Agent, other.Agent) { return false }
	if !compareSlices(m.Entity, other.Entity) { return false }
	if !compareSlices(m.Signature, other.Signature) { return false }
	return true
}

// ProvenanceAgent
// An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
type ProvenanceAgent struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Role []*CodeableConcept `json:"role,omitempty"`
	Who *Reference `json:"who,omitempty"`
	OnBehalfOf *Reference `json:"onbehalfof,omitempty"`
}

// NewProvenanceAgent creates a new ProvenanceAgent instance.
func NewProvenanceAgent() *ProvenanceAgent {
	return &ProvenanceAgent{}
}

// UnmarshalJSON populates ProvenanceAgent from JSON data.
func (m *ProvenanceAgent) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Role []*CodeableConcept `json:"role,omitempty"`
		Who *Reference `json:"who,omitempty"`
		OnBehalfOf *Reference `json:"onbehalfof,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Role = temp.Role
	m.Who = temp.Who
	m.OnBehalfOf = temp.OnBehalfOf
	return nil
}

// MarshalJSON converts ProvenanceAgent to JSON data.
func (m *ProvenanceAgent) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Role []*CodeableConcept `json:"role,omitempty"`
		Who *Reference `json:"who,omitempty"`
		OnBehalfOf *Reference `json:"onbehalfof,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Role = m.Role
	output.Who = m.Who
	output.OnBehalfOf = m.OnBehalfOf
	return json.Marshal(output)
}

// Clone creates a deep copy of ProvenanceAgent.
func (m *ProvenanceAgent) Clone() *ProvenanceAgent {
	if m == nil { return nil }
	return &ProvenanceAgent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Role: cloneSlices(m.Role),
		Who: m.Who.Clone(),
		OnBehalfOf: m.OnBehalfOf.Clone(),
	}
}

// Equals checks equality between two ProvenanceAgent instances.
func (m *ProvenanceAgent) Equals(other *ProvenanceAgent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Role, other.Role) { return false }
	if !m.Who.Equals(other.Who) { return false }
	if !m.OnBehalfOf.Equals(other.OnBehalfOf) { return false }
	return true
}

// ProvenanceEntity
// An entity used in this activity.
type ProvenanceEntity struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Role *ProvenanceEntityRole `json:"role,omitempty"`
	What *Reference `json:"what,omitempty"`
	Agent []*ProvenanceAgent `json:"agent,omitempty"`
}

// NewProvenanceEntity creates a new ProvenanceEntity instance.
func NewProvenanceEntity() *ProvenanceEntity {
	return &ProvenanceEntity{}
}

// UnmarshalJSON populates ProvenanceEntity from JSON data.
func (m *ProvenanceEntity) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Role *ProvenanceEntityRole `json:"role,omitempty"`
		What *Reference `json:"what,omitempty"`
		Agent []*ProvenanceAgent `json:"agent,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Role = temp.Role
	m.What = temp.What
	m.Agent = temp.Agent
	return nil
}

// MarshalJSON converts ProvenanceEntity to JSON data.
func (m *ProvenanceEntity) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Role *ProvenanceEntityRole `json:"role,omitempty"`
		What *Reference `json:"what,omitempty"`
		Agent []*ProvenanceAgent `json:"agent,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Role = m.Role
	output.What = m.What
	output.Agent = m.Agent
	return json.Marshal(output)
}

// Clone creates a deep copy of ProvenanceEntity.
func (m *ProvenanceEntity) Clone() *ProvenanceEntity {
	if m == nil { return nil }
	return &ProvenanceEntity{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Role: m.Role.Clone(),
		What: m.What.Clone(),
		Agent: cloneSlices(m.Agent),
	}
}

// Equals checks equality between two ProvenanceEntity instances.
func (m *ProvenanceEntity) Equals(other *ProvenanceEntity) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.What.Equals(other.What) { return false }
	if !compareSlices(m.Agent, other.Agent) { return false }
	return true
}

