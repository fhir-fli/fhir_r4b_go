// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// MessageHeader
// The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
type MessageHeader struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	EventCoding *Coding `json:"eventcoding,omitempty"`
	EventUri *FhirUri `json:"eventuri,omitempty"`
	Destination []*MessageHeaderDestination `json:"destination,omitempty"`
	Sender *Reference `json:"sender,omitempty"`
	Enterer *Reference `json:"enterer,omitempty"`
	Author *Reference `json:"author,omitempty"`
	Source *MessageHeaderSource `json:"source,omitempty"`
	Responsible *Reference `json:"responsible,omitempty"`
	Reason *CodeableConcept `json:"reason,omitempty"`
	Response *MessageHeaderResponse `json:"response,omitempty"`
	Focus []*Reference `json:"focus,omitempty"`
	Definition *FhirCanonical `json:"definition,omitempty"`
}

// NewMessageHeader creates a new MessageHeader instance.
func NewMessageHeader() *MessageHeader {
	return &MessageHeader{}
}

// UnmarshalJSON populates MessageHeader from JSON data.
func (m *MessageHeader) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		EventCoding *Coding `json:"eventcoding,omitempty"`
		EventUri *FhirUri `json:"eventuri,omitempty"`
		Destination []*MessageHeaderDestination `json:"destination,omitempty"`
		Sender *Reference `json:"sender,omitempty"`
		Enterer *Reference `json:"enterer,omitempty"`
		Author *Reference `json:"author,omitempty"`
		Source *MessageHeaderSource `json:"source,omitempty"`
		Responsible *Reference `json:"responsible,omitempty"`
		Reason *CodeableConcept `json:"reason,omitempty"`
		Response *MessageHeaderResponse `json:"response,omitempty"`
		Focus []*Reference `json:"focus,omitempty"`
		Definition *FhirCanonical `json:"definition,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.EventCoding = temp.EventCoding
	m.EventUri = temp.EventUri
	m.Destination = temp.Destination
	m.Sender = temp.Sender
	m.Enterer = temp.Enterer
	m.Author = temp.Author
	m.Source = temp.Source
	m.Responsible = temp.Responsible
	m.Reason = temp.Reason
	m.Response = temp.Response
	m.Focus = temp.Focus
	m.Definition = temp.Definition
	return nil
}

// MarshalJSON converts MessageHeader to JSON data.
func (m *MessageHeader) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		EventCoding *Coding `json:"eventcoding,omitempty"`
		EventUri interface{} `json:"eventuri,omitempty"`
		EventUriElement map[string]interface{} `json:"_eventuri,omitempty"`
		Destination []*MessageHeaderDestination `json:"destination,omitempty"`
		Sender *Reference `json:"sender,omitempty"`
		Enterer *Reference `json:"enterer,omitempty"`
		Author *Reference `json:"author,omitempty"`
		Source *MessageHeaderSource `json:"source,omitempty"`
		Responsible *Reference `json:"responsible,omitempty"`
		Reason *CodeableConcept `json:"reason,omitempty"`
		Response *MessageHeaderResponse `json:"response,omitempty"`
		Focus []*Reference `json:"focus,omitempty"`
		Definition interface{} `json:"definition,omitempty"`
		DefinitionElement map[string]interface{} `json:"_definition,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.EventCoding = m.EventCoding
	if m.EventUri != nil && m.EventUri.Value != nil {
		output.EventUri = m.EventUri.Value
		if m.EventUri.Element != nil {
			output.EventUriElement = toMapOrNil(m.EventUri.Element.MarshalJSON())
		}
	}
	output.Destination = m.Destination
	output.Sender = m.Sender
	output.Enterer = m.Enterer
	output.Author = m.Author
	output.Source = m.Source
	output.Responsible = m.Responsible
	output.Reason = m.Reason
	output.Response = m.Response
	output.Focus = m.Focus
	if m.Definition != nil && m.Definition.Value != nil {
		output.Definition = m.Definition.Value
		if m.Definition.Element != nil {
			output.DefinitionElement = toMapOrNil(m.Definition.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of MessageHeader.
func (m *MessageHeader) Clone() *MessageHeader {
	if m == nil { return nil }
	return &MessageHeader{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		EventCoding: m.EventCoding.Clone(),
		EventUri: m.EventUri.Clone(),
		Destination: cloneSlices(m.Destination),
		Sender: m.Sender.Clone(),
		Enterer: m.Enterer.Clone(),
		Author: m.Author.Clone(),
		Source: m.Source.Clone(),
		Responsible: m.Responsible.Clone(),
		Reason: m.Reason.Clone(),
		Response: m.Response.Clone(),
		Focus: cloneSlices(m.Focus),
		Definition: m.Definition.Clone(),
	}
}

// Equals checks equality between two MessageHeader instances.
func (m *MessageHeader) Equals(other *MessageHeader) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.EventCoding.Equals(other.EventCoding) { return false }
	if !m.EventUri.Equals(other.EventUri) { return false }
	if !compareSlices(m.Destination, other.Destination) { return false }
	if !m.Sender.Equals(other.Sender) { return false }
	if !m.Enterer.Equals(other.Enterer) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !m.Responsible.Equals(other.Responsible) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	if !m.Response.Equals(other.Response) { return false }
	if !compareSlices(m.Focus, other.Focus) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	return true
}

// MessageHeaderDestination
// The destination application which the message is intended for.
type MessageHeaderDestination struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Target *Reference `json:"target,omitempty"`
	Endpoint *FhirUrl `json:"endpoint,omitempty"`
	Receiver *Reference `json:"receiver,omitempty"`
}

// NewMessageHeaderDestination creates a new MessageHeaderDestination instance.
func NewMessageHeaderDestination() *MessageHeaderDestination {
	return &MessageHeaderDestination{}
}

// UnmarshalJSON populates MessageHeaderDestination from JSON data.
func (m *MessageHeaderDestination) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Target *Reference `json:"target,omitempty"`
		Endpoint *FhirUrl `json:"endpoint,omitempty"`
		Receiver *Reference `json:"receiver,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.Target = temp.Target
	m.Endpoint = temp.Endpoint
	m.Receiver = temp.Receiver
	return nil
}

// MarshalJSON converts MessageHeaderDestination to JSON data.
func (m *MessageHeaderDestination) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Target *Reference `json:"target,omitempty"`
		Endpoint interface{} `json:"endpoint,omitempty"`
		EndpointElement map[string]interface{} `json:"_endpoint,omitempty"`
		Receiver *Reference `json:"receiver,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	output.Target = m.Target
	if m.Endpoint != nil && m.Endpoint.Value != nil {
		output.Endpoint = m.Endpoint.Value
		if m.Endpoint.Element != nil {
			output.EndpointElement = toMapOrNil(m.Endpoint.Element.MarshalJSON())
		}
	}
	output.Receiver = m.Receiver
	return json.Marshal(output)
}

// Clone creates a deep copy of MessageHeaderDestination.
func (m *MessageHeaderDestination) Clone() *MessageHeaderDestination {
	if m == nil { return nil }
	return &MessageHeaderDestination{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Target: m.Target.Clone(),
		Endpoint: m.Endpoint.Clone(),
		Receiver: m.Receiver.Clone(),
	}
}

// Equals checks equality between two MessageHeaderDestination instances.
func (m *MessageHeaderDestination) Equals(other *MessageHeaderDestination) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Target.Equals(other.Target) { return false }
	if !m.Endpoint.Equals(other.Endpoint) { return false }
	if !m.Receiver.Equals(other.Receiver) { return false }
	return true
}

// MessageHeaderSource
// The source application from which this message originated.
type MessageHeaderSource struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Software *FhirString `json:"software,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Contact *ContactPoint `json:"contact,omitempty"`
	Endpoint *FhirUrl `json:"endpoint,omitempty"`
}

// NewMessageHeaderSource creates a new MessageHeaderSource instance.
func NewMessageHeaderSource() *MessageHeaderSource {
	return &MessageHeaderSource{}
}

// UnmarshalJSON populates MessageHeaderSource from JSON data.
func (m *MessageHeaderSource) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Software *FhirString `json:"software,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Contact *ContactPoint `json:"contact,omitempty"`
		Endpoint *FhirUrl `json:"endpoint,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.Software = temp.Software
	m.Version = temp.Version
	m.Contact = temp.Contact
	m.Endpoint = temp.Endpoint
	return nil
}

// MarshalJSON converts MessageHeaderSource to JSON data.
func (m *MessageHeaderSource) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Software interface{} `json:"software,omitempty"`
		SoftwareElement map[string]interface{} `json:"_software,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Contact *ContactPoint `json:"contact,omitempty"`
		Endpoint interface{} `json:"endpoint,omitempty"`
		EndpointElement map[string]interface{} `json:"_endpoint,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.Software != nil && m.Software.Value != nil {
		output.Software = m.Software.Value
		if m.Software.Element != nil {
			output.SoftwareElement = toMapOrNil(m.Software.Element.MarshalJSON())
		}
	}
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	output.Contact = m.Contact
	if m.Endpoint != nil && m.Endpoint.Value != nil {
		output.Endpoint = m.Endpoint.Value
		if m.Endpoint.Element != nil {
			output.EndpointElement = toMapOrNil(m.Endpoint.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of MessageHeaderSource.
func (m *MessageHeaderSource) Clone() *MessageHeaderSource {
	if m == nil { return nil }
	return &MessageHeaderSource{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Software: m.Software.Clone(),
		Version: m.Version.Clone(),
		Contact: m.Contact.Clone(),
		Endpoint: m.Endpoint.Clone(),
	}
}

// Equals checks equality between two MessageHeaderSource instances.
func (m *MessageHeaderSource) Equals(other *MessageHeaderSource) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Software.Equals(other.Software) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Contact.Equals(other.Contact) { return false }
	if !m.Endpoint.Equals(other.Endpoint) { return false }
	return true
}

// MessageHeaderResponse
// Information about the message that this message is a response to.  Only present if this message is a response.
type MessageHeaderResponse struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *FhirId `json:"identifier,omitempty"`
	Code *ResponseType `json:"code,omitempty"`
	Details *Reference `json:"details,omitempty"`
}

// NewMessageHeaderResponse creates a new MessageHeaderResponse instance.
func NewMessageHeaderResponse() *MessageHeaderResponse {
	return &MessageHeaderResponse{}
}

// UnmarshalJSON populates MessageHeaderResponse from JSON data.
func (m *MessageHeaderResponse) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier *FhirId `json:"identifier,omitempty"`
		Code *ResponseType `json:"code,omitempty"`
		Details *Reference `json:"details,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Code = temp.Code
	m.Details = temp.Details
	return nil
}

// MarshalJSON converts MessageHeaderResponse to JSON data.
func (m *MessageHeaderResponse) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier interface{} `json:"identifier,omitempty"`
		IdentifierElement map[string]interface{} `json:"_identifier,omitempty"`
		Code *ResponseType `json:"code,omitempty"`
		Details *Reference `json:"details,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Identifier != nil && m.Identifier.Value != nil {
		output.Identifier = m.Identifier.Value
		if m.Identifier.Element != nil {
			output.IdentifierElement = toMapOrNil(m.Identifier.Element.MarshalJSON())
		}
	}
	output.Code = m.Code
	output.Details = m.Details
	return json.Marshal(output)
}

// Clone creates a deep copy of MessageHeaderResponse.
func (m *MessageHeaderResponse) Clone() *MessageHeaderResponse {
	if m == nil { return nil }
	return &MessageHeaderResponse{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Code: m.Code.Clone(),
		Details: m.Details.Clone(),
	}
}

// Equals checks equality between two MessageHeaderResponse instances.
func (m *MessageHeaderResponse) Equals(other *MessageHeaderResponse) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Details.Equals(other.Details) { return false }
	return true
}

