// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// TestReport
// A summary of information based on the results of executing a TestScript.
type TestReport struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Status *TestReportStatus `json:"status,omitempty"`
	TestScript *Reference `json:"testscript,omitempty"`
	Result *TestReportResult `json:"result,omitempty"`
	Score *FhirDecimal `json:"score,omitempty"`
	Tester *FhirString `json:"tester,omitempty"`
	Issued *FhirDateTime `json:"issued,omitempty"`
	Participant []*TestReportParticipant `json:"participant,omitempty"`
	Setup *TestReportSetup `json:"setup,omitempty"`
	Test []*TestReportTest `json:"test,omitempty"`
	Teardown *TestReportTeardown `json:"teardown,omitempty"`
}

// NewTestReport creates a new TestReport instance.
func NewTestReport() *TestReport {
	return &TestReport{}
}

// UnmarshalJSON populates TestReport from JSON data.
func (m *TestReport) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Status *TestReportStatus `json:"status,omitempty"`
		TestScript *Reference `json:"testscript,omitempty"`
		Result *TestReportResult `json:"result,omitempty"`
		Score *FhirDecimal `json:"score,omitempty"`
		Tester *FhirString `json:"tester,omitempty"`
		Issued *FhirDateTime `json:"issued,omitempty"`
		Participant []*TestReportParticipant `json:"participant,omitempty"`
		Setup *TestReportSetup `json:"setup,omitempty"`
		Test []*TestReportTest `json:"test,omitempty"`
		Teardown *TestReportTeardown `json:"teardown,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Name = temp.Name
	m.Status = temp.Status
	m.TestScript = temp.TestScript
	m.Result = temp.Result
	m.Score = temp.Score
	m.Tester = temp.Tester
	m.Issued = temp.Issued
	m.Participant = temp.Participant
	m.Setup = temp.Setup
	m.Test = temp.Test
	m.Teardown = temp.Teardown
	return nil
}

// MarshalJSON converts TestReport to JSON data.
func (m *TestReport) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Status *TestReportStatus `json:"status,omitempty"`
		TestScript *Reference `json:"testscript,omitempty"`
		Result *TestReportResult `json:"result,omitempty"`
		Score interface{} `json:"score,omitempty"`
		ScoreElement map[string]interface{} `json:"_score,omitempty"`
		Tester interface{} `json:"tester,omitempty"`
		TesterElement map[string]interface{} `json:"_tester,omitempty"`
		Issued interface{} `json:"issued,omitempty"`
		IssuedElement map[string]interface{} `json:"_issued,omitempty"`
		Participant []*TestReportParticipant `json:"participant,omitempty"`
		Setup *TestReportSetup `json:"setup,omitempty"`
		Test []*TestReportTest `json:"test,omitempty"`
		Teardown *TestReportTeardown `json:"teardown,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	output.Status = m.Status
	output.TestScript = m.TestScript
	output.Result = m.Result
	if m.Score != nil && m.Score.Value != nil {
		output.Score = m.Score.Value
		if m.Score.Element != nil {
			output.ScoreElement = toMapOrNil(m.Score.Element.MarshalJSON())
		}
	}
	if m.Tester != nil && m.Tester.Value != nil {
		output.Tester = m.Tester.Value
		if m.Tester.Element != nil {
			output.TesterElement = toMapOrNil(m.Tester.Element.MarshalJSON())
		}
	}
	if m.Issued != nil && m.Issued.Value != nil {
		output.Issued = m.Issued.Value
		if m.Issued.Element != nil {
			output.IssuedElement = toMapOrNil(m.Issued.Element.MarshalJSON())
		}
	}
	output.Participant = m.Participant
	output.Setup = m.Setup
	output.Test = m.Test
	output.Teardown = m.Teardown
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReport.
func (m *TestReport) Clone() *TestReport {
	if m == nil { return nil }
	return &TestReport{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Name: m.Name.Clone(),
		Status: m.Status.Clone(),
		TestScript: m.TestScript.Clone(),
		Result: m.Result.Clone(),
		Score: m.Score.Clone(),
		Tester: m.Tester.Clone(),
		Issued: m.Issued.Clone(),
		Participant: cloneSlices(m.Participant),
		Setup: m.Setup.Clone(),
		Test: cloneSlices(m.Test),
		Teardown: m.Teardown.Clone(),
	}
}

// Equals checks equality between two TestReport instances.
func (m *TestReport) Equals(other *TestReport) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.TestScript.Equals(other.TestScript) { return false }
	if !m.Result.Equals(other.Result) { return false }
	if !m.Score.Equals(other.Score) { return false }
	if !m.Tester.Equals(other.Tester) { return false }
	if !m.Issued.Equals(other.Issued) { return false }
	if !compareSlices(m.Participant, other.Participant) { return false }
	if !m.Setup.Equals(other.Setup) { return false }
	if !compareSlices(m.Test, other.Test) { return false }
	if !m.Teardown.Equals(other.Teardown) { return false }
	return true
}

// TestReportParticipant
// A participant in the test execution, either the execution engine, a client, or a server.
type TestReportParticipant struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *TestReportParticipantType `json:"type,omitempty"`
	Uri *FhirUri `json:"uri,omitempty"`
	Display *FhirString `json:"display,omitempty"`
}

// NewTestReportParticipant creates a new TestReportParticipant instance.
func NewTestReportParticipant() *TestReportParticipant {
	return &TestReportParticipant{}
}

// UnmarshalJSON populates TestReportParticipant from JSON data.
func (m *TestReportParticipant) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *TestReportParticipantType `json:"type,omitempty"`
		Uri *FhirUri `json:"uri,omitempty"`
		Display *FhirString `json:"display,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Uri = temp.Uri
	m.Display = temp.Display
	return nil
}

// MarshalJSON converts TestReportParticipant to JSON data.
func (m *TestReportParticipant) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *TestReportParticipantType `json:"type,omitempty"`
		Uri interface{} `json:"uri,omitempty"`
		UriElement map[string]interface{} `json:"_uri,omitempty"`
		Display interface{} `json:"display,omitempty"`
		DisplayElement map[string]interface{} `json:"_display,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.Uri != nil && m.Uri.Value != nil {
		output.Uri = m.Uri.Value
		if m.Uri.Element != nil {
			output.UriElement = toMapOrNil(m.Uri.Element.MarshalJSON())
		}
	}
	if m.Display != nil && m.Display.Value != nil {
		output.Display = m.Display.Value
		if m.Display.Element != nil {
			output.DisplayElement = toMapOrNil(m.Display.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportParticipant.
func (m *TestReportParticipant) Clone() *TestReportParticipant {
	if m == nil { return nil }
	return &TestReportParticipant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Uri: m.Uri.Clone(),
		Display: m.Display.Clone(),
	}
}

// Equals checks equality between two TestReportParticipant instances.
func (m *TestReportParticipant) Equals(other *TestReportParticipant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Uri.Equals(other.Uri) { return false }
	if !m.Display.Equals(other.Display) { return false }
	return true
}

// TestReportSetup
// The results of the series of required setup operations before the tests were executed.
type TestReportSetup struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Action []*TestReportAction `json:"action,omitempty"`
}

// NewTestReportSetup creates a new TestReportSetup instance.
func NewTestReportSetup() *TestReportSetup {
	return &TestReportSetup{}
}

// UnmarshalJSON populates TestReportSetup from JSON data.
func (m *TestReportSetup) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestReportAction `json:"action,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Action = temp.Action
	return nil
}

// MarshalJSON converts TestReportSetup to JSON data.
func (m *TestReportSetup) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestReportAction `json:"action,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Action = m.Action
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportSetup.
func (m *TestReportSetup) Clone() *TestReportSetup {
	if m == nil { return nil }
	return &TestReportSetup{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks equality between two TestReportSetup instances.
func (m *TestReportSetup) Equals(other *TestReportSetup) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// TestReportAction
// Action would contain either an operation or an assertion.
type TestReportAction struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Operation *TestReportOperation `json:"operation,omitempty"`
	Assert_ *TestReportAssert `json:"assert,omitempty"`
}

// NewTestReportAction creates a new TestReportAction instance.
func NewTestReportAction() *TestReportAction {
	return &TestReportAction{}
}

// UnmarshalJSON populates TestReportAction from JSON data.
func (m *TestReportAction) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestReportOperation `json:"operation,omitempty"`
		Assert_ *TestReportAssert `json:"assert,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Operation = temp.Operation
	m.Assert_ = temp.Assert_
	return nil
}

// MarshalJSON converts TestReportAction to JSON data.
func (m *TestReportAction) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestReportOperation `json:"operation,omitempty"`
		Assert_ *TestReportAssert `json:"assert,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Operation = m.Operation
	output.Assert_ = m.Assert_
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportAction.
func (m *TestReportAction) Clone() *TestReportAction {
	if m == nil { return nil }
	return &TestReportAction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Operation: m.Operation.Clone(),
		Assert_: m.Assert_.Clone(),
	}
}

// Equals checks equality between two TestReportAction instances.
func (m *TestReportAction) Equals(other *TestReportAction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Operation.Equals(other.Operation) { return false }
	if !m.Assert_.Equals(other.Assert_) { return false }
	return true
}

// TestReportOperation
// The operation performed.
type TestReportOperation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Result *TestReportActionResult `json:"result,omitempty"`
	Message *FhirMarkdown `json:"message,omitempty"`
	Detail *FhirUri `json:"detail,omitempty"`
}

// NewTestReportOperation creates a new TestReportOperation instance.
func NewTestReportOperation() *TestReportOperation {
	return &TestReportOperation{}
}

// UnmarshalJSON populates TestReportOperation from JSON data.
func (m *TestReportOperation) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Result *TestReportActionResult `json:"result,omitempty"`
		Message *FhirMarkdown `json:"message,omitempty"`
		Detail *FhirUri `json:"detail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Result = temp.Result
	m.Message = temp.Message
	m.Detail = temp.Detail
	return nil
}

// MarshalJSON converts TestReportOperation to JSON data.
func (m *TestReportOperation) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Result *TestReportActionResult `json:"result,omitempty"`
		Message interface{} `json:"message,omitempty"`
		MessageElement map[string]interface{} `json:"_message,omitempty"`
		Detail interface{} `json:"detail,omitempty"`
		DetailElement map[string]interface{} `json:"_detail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Result = m.Result
	if m.Message != nil && m.Message.Value != nil {
		output.Message = m.Message.Value
		if m.Message.Element != nil {
			output.MessageElement = toMapOrNil(m.Message.Element.MarshalJSON())
		}
	}
	if m.Detail != nil && m.Detail.Value != nil {
		output.Detail = m.Detail.Value
		if m.Detail.Element != nil {
			output.DetailElement = toMapOrNil(m.Detail.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportOperation.
func (m *TestReportOperation) Clone() *TestReportOperation {
	if m == nil { return nil }
	return &TestReportOperation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Result: m.Result.Clone(),
		Message: m.Message.Clone(),
		Detail: m.Detail.Clone(),
	}
}

// Equals checks equality between two TestReportOperation instances.
func (m *TestReportOperation) Equals(other *TestReportOperation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Result.Equals(other.Result) { return false }
	if !m.Message.Equals(other.Message) { return false }
	if !m.Detail.Equals(other.Detail) { return false }
	return true
}

// TestReportAssert
// The results of the assertion performed on the previous operations.
type TestReportAssert struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Result *TestReportActionResult `json:"result,omitempty"`
	Message *FhirMarkdown `json:"message,omitempty"`
	Detail *FhirString `json:"detail,omitempty"`
}

// NewTestReportAssert creates a new TestReportAssert instance.
func NewTestReportAssert() *TestReportAssert {
	return &TestReportAssert{}
}

// UnmarshalJSON populates TestReportAssert from JSON data.
func (m *TestReportAssert) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Result *TestReportActionResult `json:"result,omitempty"`
		Message *FhirMarkdown `json:"message,omitempty"`
		Detail *FhirString `json:"detail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Result = temp.Result
	m.Message = temp.Message
	m.Detail = temp.Detail
	return nil
}

// MarshalJSON converts TestReportAssert to JSON data.
func (m *TestReportAssert) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Result *TestReportActionResult `json:"result,omitempty"`
		Message interface{} `json:"message,omitempty"`
		MessageElement map[string]interface{} `json:"_message,omitempty"`
		Detail interface{} `json:"detail,omitempty"`
		DetailElement map[string]interface{} `json:"_detail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Result = m.Result
	if m.Message != nil && m.Message.Value != nil {
		output.Message = m.Message.Value
		if m.Message.Element != nil {
			output.MessageElement = toMapOrNil(m.Message.Element.MarshalJSON())
		}
	}
	if m.Detail != nil && m.Detail.Value != nil {
		output.Detail = m.Detail.Value
		if m.Detail.Element != nil {
			output.DetailElement = toMapOrNil(m.Detail.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportAssert.
func (m *TestReportAssert) Clone() *TestReportAssert {
	if m == nil { return nil }
	return &TestReportAssert{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Result: m.Result.Clone(),
		Message: m.Message.Clone(),
		Detail: m.Detail.Clone(),
	}
}

// Equals checks equality between two TestReportAssert instances.
func (m *TestReportAssert) Equals(other *TestReportAssert) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Result.Equals(other.Result) { return false }
	if !m.Message.Equals(other.Message) { return false }
	if !m.Detail.Equals(other.Detail) { return false }
	return true
}

// TestReportTest
// A test executed from the test script.
type TestReportTest struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Action []*TestReportAction `json:"action,omitempty"`
}

// NewTestReportTest creates a new TestReportTest instance.
func NewTestReportTest() *TestReportTest {
	return &TestReportTest{}
}

// UnmarshalJSON populates TestReportTest from JSON data.
func (m *TestReportTest) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Action []*TestReportAction `json:"action,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.Description = temp.Description
	m.Action = temp.Action
	return nil
}

// MarshalJSON converts TestReportTest to JSON data.
func (m *TestReportTest) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Action []*TestReportAction `json:"action,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Action = m.Action
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportTest.
func (m *TestReportTest) Clone() *TestReportTest {
	if m == nil { return nil }
	return &TestReportTest{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Description: m.Description.Clone(),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks equality between two TestReportTest instances.
func (m *TestReportTest) Equals(other *TestReportTest) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// TestReportAction1
// Action would contain either an operation or an assertion.
type TestReportAction1 struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Operation *TestReportOperation `json:"operation,omitempty"`
	Assert_ *TestReportAssert `json:"assert,omitempty"`
}

// NewTestReportAction1 creates a new TestReportAction1 instance.
func NewTestReportAction1() *TestReportAction1 {
	return &TestReportAction1{}
}

// UnmarshalJSON populates TestReportAction1 from JSON data.
func (m *TestReportAction1) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestReportOperation `json:"operation,omitempty"`
		Assert_ *TestReportAssert `json:"assert,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Operation = temp.Operation
	m.Assert_ = temp.Assert_
	return nil
}

// MarshalJSON converts TestReportAction1 to JSON data.
func (m *TestReportAction1) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestReportOperation `json:"operation,omitempty"`
		Assert_ *TestReportAssert `json:"assert,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Operation = m.Operation
	output.Assert_ = m.Assert_
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportAction1.
func (m *TestReportAction1) Clone() *TestReportAction1 {
	if m == nil { return nil }
	return &TestReportAction1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Operation: m.Operation.Clone(),
		Assert_: m.Assert_.Clone(),
	}
}

// Equals checks equality between two TestReportAction1 instances.
func (m *TestReportAction1) Equals(other *TestReportAction1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Operation.Equals(other.Operation) { return false }
	if !m.Assert_.Equals(other.Assert_) { return false }
	return true
}

// TestReportTeardown
// The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
type TestReportTeardown struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Action []*TestReportAction `json:"action,omitempty"`
}

// NewTestReportTeardown creates a new TestReportTeardown instance.
func NewTestReportTeardown() *TestReportTeardown {
	return &TestReportTeardown{}
}

// UnmarshalJSON populates TestReportTeardown from JSON data.
func (m *TestReportTeardown) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestReportAction `json:"action,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Action = temp.Action
	return nil
}

// MarshalJSON converts TestReportTeardown to JSON data.
func (m *TestReportTeardown) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Action []*TestReportAction `json:"action,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Action = m.Action
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportTeardown.
func (m *TestReportTeardown) Clone() *TestReportTeardown {
	if m == nil { return nil }
	return &TestReportTeardown{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks equality between two TestReportTeardown instances.
func (m *TestReportTeardown) Equals(other *TestReportTeardown) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// TestReportAction2
// The teardown action will only contain an operation.
type TestReportAction2 struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Operation *TestReportOperation `json:"operation,omitempty"`
}

// NewTestReportAction2 creates a new TestReportAction2 instance.
func NewTestReportAction2() *TestReportAction2 {
	return &TestReportAction2{}
}

// UnmarshalJSON populates TestReportAction2 from JSON data.
func (m *TestReportAction2) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestReportOperation `json:"operation,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Operation = temp.Operation
	return nil
}

// MarshalJSON converts TestReportAction2 to JSON data.
func (m *TestReportAction2) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Operation *TestReportOperation `json:"operation,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Operation = m.Operation
	return json.Marshal(output)
}

// Clone creates a deep copy of TestReportAction2.
func (m *TestReportAction2) Clone() *TestReportAction2 {
	if m == nil { return nil }
	return &TestReportAction2{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Operation: m.Operation.Clone(),
	}
}

// Equals checks equality between two TestReportAction2 instances.
func (m *TestReportAction2) Equals(other *TestReportAction2) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Operation.Equals(other.Operation) { return false }
	return true
}

