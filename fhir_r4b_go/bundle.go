// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// Bundle
// A container for a collection of resources.
type Bundle struct {
	extends Resource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Type *BundleType `json:"type,omitempty"`
	Timestamp *FhirInstant `json:"timestamp,omitempty"`
	Total *FhirUnsignedInt `json:"total,omitempty"`
	Link []*BundleLink `json:"link,omitempty"`
	Entry []*BundleEntry `json:"entry,omitempty"`
	Signature *Signature `json:"signature,omitempty"`
}

// NewBundle creates a new Bundle instance.
func NewBundle() *Bundle {
	return &Bundle{}
}

// UnmarshalJSON populates Bundle from JSON data.
func (m *Bundle) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Type *BundleType `json:"type,omitempty"`
		Timestamp *FhirInstant `json:"timestamp,omitempty"`
		Total *FhirUnsignedInt `json:"total,omitempty"`
		Link []*BundleLink `json:"link,omitempty"`
		Entry []*BundleEntry `json:"entry,omitempty"`
		Signature *Signature `json:"signature,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Identifier = temp.Identifier
	m.Type = temp.Type
	m.Timestamp = temp.Timestamp
	m.Total = temp.Total
	m.Link = temp.Link
	m.Entry = temp.Entry
	m.Signature = temp.Signature
	return nil
}

// MarshalJSON converts Bundle to JSON data.
func (m *Bundle) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Type *BundleType `json:"type,omitempty"`
		Timestamp interface{} `json:"timestamp,omitempty"`
		TimestampElement map[string]interface{} `json:"_timestamp,omitempty"`
		Total interface{} `json:"total,omitempty"`
		TotalElement map[string]interface{} `json:"_total,omitempty"`
		Link []*BundleLink `json:"link,omitempty"`
		Entry []*BundleEntry `json:"entry,omitempty"`
		Signature *Signature `json:"signature,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Identifier = m.Identifier
	output.Type = m.Type
	if m.Timestamp != nil && m.Timestamp.Value != nil {
		output.Timestamp = m.Timestamp.Value
		if m.Timestamp.Element != nil {
			output.TimestampElement = toMapOrNil(m.Timestamp.Element.MarshalJSON())
		}
	}
	if m.Total != nil && m.Total.Value != nil {
		output.Total = m.Total.Value
		if m.Total.Element != nil {
			output.TotalElement = toMapOrNil(m.Total.Element.MarshalJSON())
		}
	}
	output.Link = m.Link
	output.Entry = m.Entry
	output.Signature = m.Signature
	return json.Marshal(output)
}

// Clone creates a deep copy of Bundle.
func (m *Bundle) Clone() *Bundle {
	if m == nil { return nil }
	return &Bundle{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Identifier: m.Identifier.Clone(),
		Type: m.Type.Clone(),
		Timestamp: m.Timestamp.Clone(),
		Total: m.Total.Clone(),
		Link: cloneSlices(m.Link),
		Entry: cloneSlices(m.Entry),
		Signature: m.Signature.Clone(),
	}
}

// Equals checks equality between two Bundle instances.
func (m *Bundle) Equals(other *Bundle) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Timestamp.Equals(other.Timestamp) { return false }
	if !m.Total.Equals(other.Total) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	if !compareSlices(m.Entry, other.Entry) { return false }
	if !m.Signature.Equals(other.Signature) { return false }
	return true
}

// BundleLink
// A series of links that provide context to this bundle.
type BundleLink struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Relation *FhirString `json:"relation,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
}

// NewBundleLink creates a new BundleLink instance.
func NewBundleLink() *BundleLink {
	return &BundleLink{}
}

// UnmarshalJSON populates BundleLink from JSON data.
func (m *BundleLink) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Relation *FhirString `json:"relation,omitempty"`
		Url *FhirUri `json:"url,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Relation = temp.Relation
	m.Url = temp.Url
	return nil
}

// MarshalJSON converts BundleLink to JSON data.
func (m *BundleLink) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Relation interface{} `json:"relation,omitempty"`
		RelationElement map[string]interface{} `json:"_relation,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Relation != nil && m.Relation.Value != nil {
		output.Relation = m.Relation.Value
		if m.Relation.Element != nil {
			output.RelationElement = toMapOrNil(m.Relation.Element.MarshalJSON())
		}
	}
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of BundleLink.
func (m *BundleLink) Clone() *BundleLink {
	if m == nil { return nil }
	return &BundleLink{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Relation: m.Relation.Clone(),
		Url: m.Url.Clone(),
	}
}

// Equals checks equality between two BundleLink instances.
func (m *BundleLink) Equals(other *BundleLink) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Relation.Equals(other.Relation) { return false }
	if !m.Url.Equals(other.Url) { return false }
	return true
}

// BundleEntry
// An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
type BundleEntry struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Link []*BundleLink `json:"link,omitempty"`
	FullUrl *FhirUri `json:"fullurl,omitempty"`
	Resource *Resource `json:"resource,omitempty"`
	Search *BundleSearch `json:"search,omitempty"`
	Request *BundleRequest `json:"request,omitempty"`
	Response *BundleResponse `json:"response,omitempty"`
}

// NewBundleEntry creates a new BundleEntry instance.
func NewBundleEntry() *BundleEntry {
	return &BundleEntry{}
}

// UnmarshalJSON populates BundleEntry from JSON data.
func (m *BundleEntry) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Link []*BundleLink `json:"link,omitempty"`
		FullUrl *FhirUri `json:"fullurl,omitempty"`
		Resource *Resource `json:"resource,omitempty"`
		Search *BundleSearch `json:"search,omitempty"`
		Request *BundleRequest `json:"request,omitempty"`
		Response *BundleResponse `json:"response,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Link = temp.Link
	m.FullUrl = temp.FullUrl
	m.Resource = temp.Resource
	m.Search = temp.Search
	m.Request = temp.Request
	m.Response = temp.Response
	return nil
}

// MarshalJSON converts BundleEntry to JSON data.
func (m *BundleEntry) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Link []*BundleLink `json:"link,omitempty"`
		FullUrl interface{} `json:"fullurl,omitempty"`
		FullUrlElement map[string]interface{} `json:"_fullurl,omitempty"`
		Resource *Resource `json:"resource,omitempty"`
		Search *BundleSearch `json:"search,omitempty"`
		Request *BundleRequest `json:"request,omitempty"`
		Response *BundleResponse `json:"response,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Link = m.Link
	if m.FullUrl != nil && m.FullUrl.Value != nil {
		output.FullUrl = m.FullUrl.Value
		if m.FullUrl.Element != nil {
			output.FullUrlElement = toMapOrNil(m.FullUrl.Element.MarshalJSON())
		}
	}
	output.Resource = m.Resource
	output.Search = m.Search
	output.Request = m.Request
	output.Response = m.Response
	return json.Marshal(output)
}

// Clone creates a deep copy of BundleEntry.
func (m *BundleEntry) Clone() *BundleEntry {
	if m == nil { return nil }
	return &BundleEntry{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Link: cloneSlices(m.Link),
		FullUrl: m.FullUrl.Clone(),
		Resource: m.Resource.Clone(),
		Search: m.Search.Clone(),
		Request: m.Request.Clone(),
		Response: m.Response.Clone(),
	}
}

// Equals checks equality between two BundleEntry instances.
func (m *BundleEntry) Equals(other *BundleEntry) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	if !m.FullUrl.Equals(other.FullUrl) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !m.Search.Equals(other.Search) { return false }
	if !m.Request.Equals(other.Request) { return false }
	if !m.Response.Equals(other.Response) { return false }
	return true
}

// BundleSearch
// Information about the search process that lead to the creation of this entry.
type BundleSearch struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Mode *SearchEntryMode `json:"mode,omitempty"`
	Score *FhirDecimal `json:"score,omitempty"`
}

// NewBundleSearch creates a new BundleSearch instance.
func NewBundleSearch() *BundleSearch {
	return &BundleSearch{}
}

// UnmarshalJSON populates BundleSearch from JSON data.
func (m *BundleSearch) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Mode *SearchEntryMode `json:"mode,omitempty"`
		Score *FhirDecimal `json:"score,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Mode = temp.Mode
	m.Score = temp.Score
	return nil
}

// MarshalJSON converts BundleSearch to JSON data.
func (m *BundleSearch) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Mode *SearchEntryMode `json:"mode,omitempty"`
		Score interface{} `json:"score,omitempty"`
		ScoreElement map[string]interface{} `json:"_score,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Mode = m.Mode
	if m.Score != nil && m.Score.Value != nil {
		output.Score = m.Score.Value
		if m.Score.Element != nil {
			output.ScoreElement = toMapOrNil(m.Score.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of BundleSearch.
func (m *BundleSearch) Clone() *BundleSearch {
	if m == nil { return nil }
	return &BundleSearch{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Mode: m.Mode.Clone(),
		Score: m.Score.Clone(),
	}
}

// Equals checks equality between two BundleSearch instances.
func (m *BundleSearch) Equals(other *BundleSearch) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !m.Score.Equals(other.Score) { return false }
	return true
}

// BundleRequest
// Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
type BundleRequest struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Method *HTTPVerb `json:"method,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	IfNoneMatch *FhirString `json:"ifnonematch,omitempty"`
	IfModifiedSince *FhirInstant `json:"ifmodifiedsince,omitempty"`
	IfMatch *FhirString `json:"ifmatch,omitempty"`
	IfNoneExist *FhirString `json:"ifnoneexist,omitempty"`
}

// NewBundleRequest creates a new BundleRequest instance.
func NewBundleRequest() *BundleRequest {
	return &BundleRequest{}
}

// UnmarshalJSON populates BundleRequest from JSON data.
func (m *BundleRequest) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Method *HTTPVerb `json:"method,omitempty"`
		Url *FhirUri `json:"url,omitempty"`
		IfNoneMatch *FhirString `json:"ifnonematch,omitempty"`
		IfModifiedSince *FhirInstant `json:"ifmodifiedsince,omitempty"`
		IfMatch *FhirString `json:"ifmatch,omitempty"`
		IfNoneExist *FhirString `json:"ifnoneexist,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Method = temp.Method
	m.Url = temp.Url
	m.IfNoneMatch = temp.IfNoneMatch
	m.IfModifiedSince = temp.IfModifiedSince
	m.IfMatch = temp.IfMatch
	m.IfNoneExist = temp.IfNoneExist
	return nil
}

// MarshalJSON converts BundleRequest to JSON data.
func (m *BundleRequest) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Method *HTTPVerb `json:"method,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
		IfNoneMatch interface{} `json:"ifnonematch,omitempty"`
		IfNoneMatchElement map[string]interface{} `json:"_ifnonematch,omitempty"`
		IfModifiedSince interface{} `json:"ifmodifiedsince,omitempty"`
		IfModifiedSinceElement map[string]interface{} `json:"_ifmodifiedsince,omitempty"`
		IfMatch interface{} `json:"ifmatch,omitempty"`
		IfMatchElement map[string]interface{} `json:"_ifmatch,omitempty"`
		IfNoneExist interface{} `json:"ifnoneexist,omitempty"`
		IfNoneExistElement map[string]interface{} `json:"_ifnoneexist,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Method = m.Method
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	if m.IfNoneMatch != nil && m.IfNoneMatch.Value != nil {
		output.IfNoneMatch = m.IfNoneMatch.Value
		if m.IfNoneMatch.Element != nil {
			output.IfNoneMatchElement = toMapOrNil(m.IfNoneMatch.Element.MarshalJSON())
		}
	}
	if m.IfModifiedSince != nil && m.IfModifiedSince.Value != nil {
		output.IfModifiedSince = m.IfModifiedSince.Value
		if m.IfModifiedSince.Element != nil {
			output.IfModifiedSinceElement = toMapOrNil(m.IfModifiedSince.Element.MarshalJSON())
		}
	}
	if m.IfMatch != nil && m.IfMatch.Value != nil {
		output.IfMatch = m.IfMatch.Value
		if m.IfMatch.Element != nil {
			output.IfMatchElement = toMapOrNil(m.IfMatch.Element.MarshalJSON())
		}
	}
	if m.IfNoneExist != nil && m.IfNoneExist.Value != nil {
		output.IfNoneExist = m.IfNoneExist.Value
		if m.IfNoneExist.Element != nil {
			output.IfNoneExistElement = toMapOrNil(m.IfNoneExist.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of BundleRequest.
func (m *BundleRequest) Clone() *BundleRequest {
	if m == nil { return nil }
	return &BundleRequest{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Method: m.Method.Clone(),
		Url: m.Url.Clone(),
		IfNoneMatch: m.IfNoneMatch.Clone(),
		IfModifiedSince: m.IfModifiedSince.Clone(),
		IfMatch: m.IfMatch.Clone(),
		IfNoneExist: m.IfNoneExist.Clone(),
	}
}

// Equals checks equality between two BundleRequest instances.
func (m *BundleRequest) Equals(other *BundleRequest) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.IfNoneMatch.Equals(other.IfNoneMatch) { return false }
	if !m.IfModifiedSince.Equals(other.IfModifiedSince) { return false }
	if !m.IfMatch.Equals(other.IfMatch) { return false }
	if !m.IfNoneExist.Equals(other.IfNoneExist) { return false }
	return true
}

// BundleResponse
// Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
type BundleResponse struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Status *FhirString `json:"status,omitempty"`
	Location *FhirUri `json:"location,omitempty"`
	Etag *FhirString `json:"etag,omitempty"`
	LastModified *FhirInstant `json:"lastmodified,omitempty"`
	Outcome *Resource `json:"outcome,omitempty"`
}

// NewBundleResponse creates a new BundleResponse instance.
func NewBundleResponse() *BundleResponse {
	return &BundleResponse{}
}

// UnmarshalJSON populates BundleResponse from JSON data.
func (m *BundleResponse) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Status *FhirString `json:"status,omitempty"`
		Location *FhirUri `json:"location,omitempty"`
		Etag *FhirString `json:"etag,omitempty"`
		LastModified *FhirInstant `json:"lastmodified,omitempty"`
		Outcome *Resource `json:"outcome,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Status = temp.Status
	m.Location = temp.Location
	m.Etag = temp.Etag
	m.LastModified = temp.LastModified
	m.Outcome = temp.Outcome
	return nil
}

// MarshalJSON converts BundleResponse to JSON data.
func (m *BundleResponse) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Status interface{} `json:"status,omitempty"`
		StatusElement map[string]interface{} `json:"_status,omitempty"`
		Location interface{} `json:"location,omitempty"`
		LocationElement map[string]interface{} `json:"_location,omitempty"`
		Etag interface{} `json:"etag,omitempty"`
		EtagElement map[string]interface{} `json:"_etag,omitempty"`
		LastModified interface{} `json:"lastmodified,omitempty"`
		LastModifiedElement map[string]interface{} `json:"_lastmodified,omitempty"`
		Outcome *Resource `json:"outcome,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Status != nil && m.Status.Value != nil {
		output.Status = m.Status.Value
		if m.Status.Element != nil {
			output.StatusElement = toMapOrNil(m.Status.Element.MarshalJSON())
		}
	}
	if m.Location != nil && m.Location.Value != nil {
		output.Location = m.Location.Value
		if m.Location.Element != nil {
			output.LocationElement = toMapOrNil(m.Location.Element.MarshalJSON())
		}
	}
	if m.Etag != nil && m.Etag.Value != nil {
		output.Etag = m.Etag.Value
		if m.Etag.Element != nil {
			output.EtagElement = toMapOrNil(m.Etag.Element.MarshalJSON())
		}
	}
	if m.LastModified != nil && m.LastModified.Value != nil {
		output.LastModified = m.LastModified.Value
		if m.LastModified.Element != nil {
			output.LastModifiedElement = toMapOrNil(m.LastModified.Element.MarshalJSON())
		}
	}
	output.Outcome = m.Outcome
	return json.Marshal(output)
}

// Clone creates a deep copy of BundleResponse.
func (m *BundleResponse) Clone() *BundleResponse {
	if m == nil { return nil }
	return &BundleResponse{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Status: m.Status.Clone(),
		Location: m.Location.Clone(),
		Etag: m.Etag.Clone(),
		LastModified: m.LastModified.Clone(),
		Outcome: m.Outcome.Clone(),
	}
}

// Equals checks equality between two BundleResponse instances.
func (m *BundleResponse) Equals(other *BundleResponse) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.Etag.Equals(other.Etag) { return false }
	if !m.LastModified.Equals(other.LastModified) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	return true
}

