// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Bundle
// A container for a collection of resources.
type Bundle struct {
	Resource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Type *BundleType `json:"type,omitempty"`
	Timestamp *FhirInstant `json:"timestamp,omitempty"`
	Total *FhirUnsignedInt `json:"total,omitempty"`
	Link []*BundleLink `json:"link,omitempty"`
	Entry []*BundleEntry `json:"entry,omitempty"`
	Signature *Signature `json:"signature,omitempty"`
}

// NewBundle creates a new Bundle instance
func NewBundle() *Bundle {
	return &Bundle{}
}

// FromJSON populates Bundle from JSON data
func (m *Bundle) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Bundle to JSON data
func (m *Bundle) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Bundle
func (m *Bundle) Clone() *Bundle {
	if m == nil { return nil }
	return &Bundle{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Identifier: m.Identifier.Clone(),
		Type: m.Type.Clone(),
		Timestamp: m.Timestamp.Clone(),
		Total: m.Total.Clone(),
		Link: cloneSlices(m.Link),
		Entry: cloneSlices(m.Entry),
		Signature: m.Signature.Clone(),
	}
}

// Equals checks for equality with another Bundle instance
func (m *Bundle) Equals(other *Bundle) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Timestamp.Equals(other.Timestamp) { return false }
	if !m.Total.Equals(other.Total) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	if !compareSlices(m.Entry, other.Entry) { return false }
	if !m.Signature.Equals(other.Signature) { return false }
	return true
}

// BundleLink
// A series of links that provide context to this bundle.
type BundleLink struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Relation *FhirString `json:"relation,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
}

// NewBundleLink creates a new BundleLink instance
func NewBundleLink() *BundleLink {
	return &BundleLink{}
}

// FromJSON populates BundleLink from JSON data
func (m *BundleLink) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BundleLink to JSON data
func (m *BundleLink) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BundleLink
func (m *BundleLink) Clone() *BundleLink {
	if m == nil { return nil }
	return &BundleLink{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Relation: m.Relation.Clone(),
		Url: m.Url.Clone(),
	}
}

// Equals checks for equality with another BundleLink instance
func (m *BundleLink) Equals(other *BundleLink) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Relation.Equals(other.Relation) { return false }
	if !m.Url.Equals(other.Url) { return false }
	return true
}

// BundleEntry
// An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
type BundleEntry struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Link []*BundleLink `json:"link,omitempty"`
	FullUrl *FhirUri `json:"fullurl,omitempty"`
	Resource *Resource `json:"resource,omitempty"`
	Search *BundleSearch `json:"search,omitempty"`
	Request *BundleRequest `json:"request,omitempty"`
	Response *BundleResponse `json:"response,omitempty"`
}

// NewBundleEntry creates a new BundleEntry instance
func NewBundleEntry() *BundleEntry {
	return &BundleEntry{}
}

// FromJSON populates BundleEntry from JSON data
func (m *BundleEntry) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BundleEntry to JSON data
func (m *BundleEntry) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BundleEntry
func (m *BundleEntry) Clone() *BundleEntry {
	if m == nil { return nil }
	return &BundleEntry{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Link: cloneSlices(m.Link),
		FullUrl: m.FullUrl.Clone(),
		Resource: m.Resource.Clone(),
		Search: m.Search.Clone(),
		Request: m.Request.Clone(),
		Response: m.Response.Clone(),
	}
}

// Equals checks for equality with another BundleEntry instance
func (m *BundleEntry) Equals(other *BundleEntry) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Link, other.Link) { return false }
	if !m.FullUrl.Equals(other.FullUrl) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !m.Search.Equals(other.Search) { return false }
	if !m.Request.Equals(other.Request) { return false }
	if !m.Response.Equals(other.Response) { return false }
	return true
}

// BundleSearch
// Information about the search process that lead to the creation of this entry.
type BundleSearch struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Mode *SearchEntryMode `json:"mode,omitempty"`
	Score *FhirDecimal `json:"score,omitempty"`
}

// NewBundleSearch creates a new BundleSearch instance
func NewBundleSearch() *BundleSearch {
	return &BundleSearch{}
}

// FromJSON populates BundleSearch from JSON data
func (m *BundleSearch) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BundleSearch to JSON data
func (m *BundleSearch) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BundleSearch
func (m *BundleSearch) Clone() *BundleSearch {
	if m == nil { return nil }
	return &BundleSearch{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Mode: m.Mode.Clone(),
		Score: m.Score.Clone(),
	}
}

// Equals checks for equality with another BundleSearch instance
func (m *BundleSearch) Equals(other *BundleSearch) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !m.Score.Equals(other.Score) { return false }
	return true
}

// BundleRequest
// Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
type BundleRequest struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Method *HTTPVerb `json:"method,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	IfNoneMatch *FhirString `json:"ifnonematch,omitempty"`
	IfModifiedSince *FhirInstant `json:"ifmodifiedsince,omitempty"`
	IfMatch *FhirString `json:"ifmatch,omitempty"`
	IfNoneExist *FhirString `json:"ifnoneexist,omitempty"`
}

// NewBundleRequest creates a new BundleRequest instance
func NewBundleRequest() *BundleRequest {
	return &BundleRequest{}
}

// FromJSON populates BundleRequest from JSON data
func (m *BundleRequest) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BundleRequest to JSON data
func (m *BundleRequest) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BundleRequest
func (m *BundleRequest) Clone() *BundleRequest {
	if m == nil { return nil }
	return &BundleRequest{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Method: m.Method.Clone(),
		Url: m.Url.Clone(),
		IfNoneMatch: m.IfNoneMatch.Clone(),
		IfModifiedSince: m.IfModifiedSince.Clone(),
		IfMatch: m.IfMatch.Clone(),
		IfNoneExist: m.IfNoneExist.Clone(),
	}
}

// Equals checks for equality with another BundleRequest instance
func (m *BundleRequest) Equals(other *BundleRequest) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.IfNoneMatch.Equals(other.IfNoneMatch) { return false }
	if !m.IfModifiedSince.Equals(other.IfModifiedSince) { return false }
	if !m.IfMatch.Equals(other.IfMatch) { return false }
	if !m.IfNoneExist.Equals(other.IfNoneExist) { return false }
	return true
}

// BundleResponse
// Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
type BundleResponse struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Status *FhirString `json:"status,omitempty"`
	Location *FhirUri `json:"location,omitempty"`
	Etag *FhirString `json:"etag,omitempty"`
	LastModified *FhirInstant `json:"lastmodified,omitempty"`
	Outcome *Resource `json:"outcome,omitempty"`
}

// NewBundleResponse creates a new BundleResponse instance
func NewBundleResponse() *BundleResponse {
	return &BundleResponse{}
}

// FromJSON populates BundleResponse from JSON data
func (m *BundleResponse) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BundleResponse to JSON data
func (m *BundleResponse) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BundleResponse
func (m *BundleResponse) Clone() *BundleResponse {
	if m == nil { return nil }
	return &BundleResponse{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Status: m.Status.Clone(),
		Location: m.Location.Clone(),
		Etag: m.Etag.Clone(),
		LastModified: m.LastModified.Clone(),
		Outcome: m.Outcome.Clone(),
	}
}

// Equals checks for equality with another BundleResponse instance
func (m *BundleResponse) Equals(other *BundleResponse) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.Etag.Equals(other.Etag) { return false }
	if !m.LastModified.Equals(other.LastModified) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	return true
}

