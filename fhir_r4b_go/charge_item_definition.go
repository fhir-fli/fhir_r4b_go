// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ChargeItemDefinition
// The ChargeItemDefinition resource provides the properties that apply to the (billing) codes necessary to calculate costs and prices. The properties may differ largely depending on type and realm, therefore this resource gives only a rough structure and requires profiling for each type of billing code system.
type ChargeItemDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	DerivedFromUri []*FhirUri `json:"derivedfromuri,omitempty"`
	PartOf []*FhirCanonical `json:"partof,omitempty"`
	Replaces []*FhirCanonical `json:"replaces,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Instance []*Reference `json:"instance,omitempty"`
	Applicability []*ChargeItemDefinitionApplicability `json:"applicability,omitempty"`
	PropertyGroup []*ChargeItemDefinitionPropertyGroup `json:"propertygroup,omitempty"`
}

// NewChargeItemDefinition creates a new ChargeItemDefinition instance
func NewChargeItemDefinition() *ChargeItemDefinition {
	return &ChargeItemDefinition{}
}

// FromJSON populates ChargeItemDefinition from JSON data
func (m *ChargeItemDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ChargeItemDefinition to JSON data
func (m *ChargeItemDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ChargeItemDefinition
func (m *ChargeItemDefinition) Clone() *ChargeItemDefinition {
	if m == nil { return nil }
	return &ChargeItemDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Title: m.Title.Clone(),
		DerivedFromUri: cloneSlices(m.DerivedFromUri),
		PartOf: cloneSlices(m.PartOf),
		Replaces: cloneSlices(m.Replaces),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Copyright: m.Copyright.Clone(),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		Code: m.Code.Clone(),
		Instance: cloneSlices(m.Instance),
		Applicability: cloneSlices(m.Applicability),
		PropertyGroup: cloneSlices(m.PropertyGroup),
	}
}

// Equals checks for equality with another ChargeItemDefinition instance
func (m *ChargeItemDefinition) Equals(other *ChargeItemDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !compareSlices(m.DerivedFromUri, other.DerivedFromUri) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !compareSlices(m.Replaces, other.Replaces) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.Instance, other.Instance) { return false }
	if !compareSlices(m.Applicability, other.Applicability) { return false }
	if !compareSlices(m.PropertyGroup, other.PropertyGroup) { return false }
	return true
}

// ChargeItemDefinitionApplicability
// Expressions that describe applicability criteria for the billing code.
type ChargeItemDefinitionApplicability struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Language *FhirString `json:"language,omitempty"`
	Expression *FhirString `json:"expression,omitempty"`
}

// NewChargeItemDefinitionApplicability creates a new ChargeItemDefinitionApplicability instance
func NewChargeItemDefinitionApplicability() *ChargeItemDefinitionApplicability {
	return &ChargeItemDefinitionApplicability{}
}

// FromJSON populates ChargeItemDefinitionApplicability from JSON data
func (m *ChargeItemDefinitionApplicability) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ChargeItemDefinitionApplicability to JSON data
func (m *ChargeItemDefinitionApplicability) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ChargeItemDefinitionApplicability
func (m *ChargeItemDefinitionApplicability) Clone() *ChargeItemDefinitionApplicability {
	if m == nil { return nil }
	return &ChargeItemDefinitionApplicability{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Language: m.Language.Clone(),
		Expression: m.Expression.Clone(),
	}
}

// Equals checks for equality with another ChargeItemDefinitionApplicability instance
func (m *ChargeItemDefinitionApplicability) Equals(other *ChargeItemDefinitionApplicability) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Expression.Equals(other.Expression) { return false }
	return true
}

// ChargeItemDefinitionPropertyGroup
// Group of properties which are applicable under the same conditions. If no applicability rules are established for the group, then all properties always apply.
type ChargeItemDefinitionPropertyGroup struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Applicability []*ChargeItemDefinitionApplicability `json:"applicability,omitempty"`
	PriceComponent []*ChargeItemDefinitionPriceComponent `json:"pricecomponent,omitempty"`
}

// NewChargeItemDefinitionPropertyGroup creates a new ChargeItemDefinitionPropertyGroup instance
func NewChargeItemDefinitionPropertyGroup() *ChargeItemDefinitionPropertyGroup {
	return &ChargeItemDefinitionPropertyGroup{}
}

// FromJSON populates ChargeItemDefinitionPropertyGroup from JSON data
func (m *ChargeItemDefinitionPropertyGroup) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ChargeItemDefinitionPropertyGroup to JSON data
func (m *ChargeItemDefinitionPropertyGroup) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ChargeItemDefinitionPropertyGroup
func (m *ChargeItemDefinitionPropertyGroup) Clone() *ChargeItemDefinitionPropertyGroup {
	if m == nil { return nil }
	return &ChargeItemDefinitionPropertyGroup{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Applicability: cloneSlices(m.Applicability),
		PriceComponent: cloneSlices(m.PriceComponent),
	}
}

// Equals checks for equality with another ChargeItemDefinitionPropertyGroup instance
func (m *ChargeItemDefinitionPropertyGroup) Equals(other *ChargeItemDefinitionPropertyGroup) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Applicability, other.Applicability) { return false }
	if !compareSlices(m.PriceComponent, other.PriceComponent) { return false }
	return true
}

// ChargeItemDefinitionPriceComponent
// The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the prices have been calculated.
type ChargeItemDefinitionPriceComponent struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *InvoicePriceComponentType `json:"type,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Amount *Money `json:"amount,omitempty"`
}

// NewChargeItemDefinitionPriceComponent creates a new ChargeItemDefinitionPriceComponent instance
func NewChargeItemDefinitionPriceComponent() *ChargeItemDefinitionPriceComponent {
	return &ChargeItemDefinitionPriceComponent{}
}

// FromJSON populates ChargeItemDefinitionPriceComponent from JSON data
func (m *ChargeItemDefinitionPriceComponent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ChargeItemDefinitionPriceComponent to JSON data
func (m *ChargeItemDefinitionPriceComponent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ChargeItemDefinitionPriceComponent
func (m *ChargeItemDefinitionPriceComponent) Clone() *ChargeItemDefinitionPriceComponent {
	if m == nil { return nil }
	return &ChargeItemDefinitionPriceComponent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Code: m.Code.Clone(),
		Factor: m.Factor.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks for equality with another ChargeItemDefinitionPriceComponent instance
func (m *ChargeItemDefinitionPriceComponent) Equals(other *ChargeItemDefinitionPriceComponent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

