// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Task
// A task to be performed.
type Task struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	InstantiatesCanonical *FhirCanonical `json:"instantiatescanonical,omitempty"`
	InstantiatesUri *FhirUri `json:"instantiatesuri,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	GroupIdentifier *Identifier `json:"groupidentifier,omitempty"`
	PartOf []*Reference `json:"partof,omitempty"`
	Status *TaskStatus `json:"status,omitempty"`
	StatusReason *CodeableConcept `json:"statusreason,omitempty"`
	BusinessStatus *CodeableConcept `json:"businessstatus,omitempty"`
	Intent *TaskIntent `json:"intent,omitempty"`
	Priority *RequestPriority `json:"priority,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Focus *Reference `json:"focus,omitempty"`
	For_ *Reference `json:"for,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	ExecutionPeriod *Period `json:"executionperiod,omitempty"`
	AuthoredOn *FhirDateTime `json:"authoredon,omitempty"`
	LastModified *FhirDateTime `json:"lastmodified,omitempty"`
	Requester *Reference `json:"requester,omitempty"`
	PerformerType []*CodeableConcept `json:"performertype,omitempty"`
	Owner *Reference `json:"owner,omitempty"`
	Location *Reference `json:"location,omitempty"`
	ReasonCode *CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference *Reference `json:"reasonreference,omitempty"`
	Insurance []*Reference `json:"insurance,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	RelevantHistory []*Reference `json:"relevanthistory,omitempty"`
	Restriction *TaskRestriction `json:"restriction,omitempty"`
	Input []*TaskInput `json:"input,omitempty"`
	Output []*TaskOutput `json:"output,omitempty"`
}

// NewTask creates a new Task instance
func NewTask() *Task {
	return &Task{}
}

// FromJSON populates Task from JSON data
func (m *Task) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Task to JSON data
func (m *Task) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Task
func (m *Task) Clone() *Task {
	if m == nil { return nil }
	return &Task{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		InstantiatesCanonical: m.InstantiatesCanonical.Clone(),
		InstantiatesUri: m.InstantiatesUri.Clone(),
		BasedOn: cloneSlices(m.BasedOn),
		GroupIdentifier: m.GroupIdentifier.Clone(),
		PartOf: cloneSlices(m.PartOf),
		Status: m.Status.Clone(),
		StatusReason: m.StatusReason.Clone(),
		BusinessStatus: m.BusinessStatus.Clone(),
		Intent: m.Intent.Clone(),
		Priority: m.Priority.Clone(),
		Code: m.Code.Clone(),
		Description: m.Description.Clone(),
		Focus: m.Focus.Clone(),
		For_: m.For_.Clone(),
		Encounter: m.Encounter.Clone(),
		ExecutionPeriod: m.ExecutionPeriod.Clone(),
		AuthoredOn: m.AuthoredOn.Clone(),
		LastModified: m.LastModified.Clone(),
		Requester: m.Requester.Clone(),
		PerformerType: cloneSlices(m.PerformerType),
		Owner: m.Owner.Clone(),
		Location: m.Location.Clone(),
		ReasonCode: m.ReasonCode.Clone(),
		ReasonReference: m.ReasonReference.Clone(),
		Insurance: cloneSlices(m.Insurance),
		Note: cloneSlices(m.Note),
		RelevantHistory: cloneSlices(m.RelevantHistory),
		Restriction: m.Restriction.Clone(),
		Input: cloneSlices(m.Input),
		Output: cloneSlices(m.Output),
	}
}

// Equals checks for equality with another Task instance
func (m *Task) Equals(other *Task) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.InstantiatesCanonical.Equals(other.InstantiatesCanonical) { return false }
	if !m.InstantiatesUri.Equals(other.InstantiatesUri) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !m.GroupIdentifier.Equals(other.GroupIdentifier) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusReason.Equals(other.StatusReason) { return false }
	if !m.BusinessStatus.Equals(other.BusinessStatus) { return false }
	if !m.Intent.Equals(other.Intent) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Focus.Equals(other.Focus) { return false }
	if !m.For_.Equals(other.For_) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.ExecutionPeriod.Equals(other.ExecutionPeriod) { return false }
	if !m.AuthoredOn.Equals(other.AuthoredOn) { return false }
	if !m.LastModified.Equals(other.LastModified) { return false }
	if !m.Requester.Equals(other.Requester) { return false }
	if !compareSlices(m.PerformerType, other.PerformerType) { return false }
	if !m.Owner.Equals(other.Owner) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.ReasonCode.Equals(other.ReasonCode) { return false }
	if !m.ReasonReference.Equals(other.ReasonReference) { return false }
	if !compareSlices(m.Insurance, other.Insurance) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.RelevantHistory, other.RelevantHistory) { return false }
	if !m.Restriction.Equals(other.Restriction) { return false }
	if !compareSlices(m.Input, other.Input) { return false }
	if !compareSlices(m.Output, other.Output) { return false }
	return true
}

// TaskRestriction
// If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
type TaskRestriction struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Repetitions *FhirPositiveInt `json:"repetitions,omitempty"`
	Period *Period `json:"period,omitempty"`
	Recipient []*Reference `json:"recipient,omitempty"`
}

// NewTaskRestriction creates a new TaskRestriction instance
func NewTaskRestriction() *TaskRestriction {
	return &TaskRestriction{}
}

// FromJSON populates TaskRestriction from JSON data
func (m *TaskRestriction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TaskRestriction to JSON data
func (m *TaskRestriction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TaskRestriction
func (m *TaskRestriction) Clone() *TaskRestriction {
	if m == nil { return nil }
	return &TaskRestriction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Repetitions: m.Repetitions.Clone(),
		Period: m.Period.Clone(),
		Recipient: cloneSlices(m.Recipient),
	}
}

// Equals checks for equality with another TaskRestriction instance
func (m *TaskRestriction) Equals(other *TaskRestriction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Repetitions.Equals(other.Repetitions) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !compareSlices(m.Recipient, other.Recipient) { return false }
	return true
}

// TaskInput
// Additional information that may be needed in the execution of the task.
type TaskInput struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueCanonical *FhirCanonical `json:"valuecanonical,omitempty"`
	ValueCode *FhirCode `json:"valuecode,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueId *FhirId `json:"valueid,omitempty"`
	ValueInstant *FhirInstant `json:"valueinstant,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueMarkdown *FhirMarkdown `json:"valuemarkdown,omitempty"`
	ValueOid *FhirOid `json:"valueoid,omitempty"`
	ValuePositiveInt *FhirPositiveInt `json:"valuepositiveint,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueUnsignedInt *FhirUnsignedInt `json:"valueunsignedint,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueUrl *FhirUrl `json:"valueurl,omitempty"`
	ValueUuid *FhirUuid `json:"valueuuid,omitempty"`
	ValueAddress *Address `json:"valueaddress,omitempty"`
	ValueAge *Age `json:"valueage,omitempty"`
	ValueAnnotation *Annotation `json:"valueannotation,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueContactPoint *ContactPoint `json:"valuecontactpoint,omitempty"`
	ValueCount *Count `json:"valuecount,omitempty"`
	ValueDistance *Distance `json:"valuedistance,omitempty"`
	ValueDuration *FhirDuration `json:"valueduration,omitempty"`
	ValueHumanName *HumanName `json:"valuehumanname,omitempty"`
	ValueIdentifier *Identifier `json:"valueidentifier,omitempty"`
	ValueMoney *Money `json:"valuemoney,omitempty"`
	ValuePeriod *Period `json:"valueperiod,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueRange *Range `json:"valuerange,omitempty"`
	ValueRatio *Ratio `json:"valueratio,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
	ValueSignature *Signature `json:"valuesignature,omitempty"`
	ValueTiming *Timing `json:"valuetiming,omitempty"`
	ValueContactDetail *ContactDetail `json:"valuecontactdetail,omitempty"`
	ValueContributor *Contributor `json:"valuecontributor,omitempty"`
	ValueDataRequirement *DataRequirement `json:"valuedatarequirement,omitempty"`
	ValueExpression *FhirExpression `json:"valueexpression,omitempty"`
	ValueParameterDefinition *ParameterDefinition `json:"valueparameterdefinition,omitempty"`
	ValueRelatedArtifact *RelatedArtifact `json:"valuerelatedartifact,omitempty"`
	ValueTriggerDefinition *TriggerDefinition `json:"valuetriggerdefinition,omitempty"`
	ValueUsageContext *UsageContext `json:"valueusagecontext,omitempty"`
	ValueDosage *Dosage `json:"valuedosage,omitempty"`
	ValueMeta *FhirMeta `json:"valuemeta,omitempty"`
}

// NewTaskInput creates a new TaskInput instance
func NewTaskInput() *TaskInput {
	return &TaskInput{}
}

// FromJSON populates TaskInput from JSON data
func (m *TaskInput) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TaskInput to JSON data
func (m *TaskInput) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TaskInput
func (m *TaskInput) Clone() *TaskInput {
	if m == nil { return nil }
	return &TaskInput{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueCanonical: m.ValueCanonical.Clone(),
		ValueCode: m.ValueCode.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueId: m.ValueId.Clone(),
		ValueInstant: m.ValueInstant.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueMarkdown: m.ValueMarkdown.Clone(),
		ValueOid: m.ValueOid.Clone(),
		ValuePositiveInt: m.ValuePositiveInt.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueUnsignedInt: m.ValueUnsignedInt.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueUrl: m.ValueUrl.Clone(),
		ValueUuid: m.ValueUuid.Clone(),
		ValueAddress: m.ValueAddress.Clone(),
		ValueAge: m.ValueAge.Clone(),
		ValueAnnotation: m.ValueAnnotation.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueContactPoint: m.ValueContactPoint.Clone(),
		ValueCount: m.ValueCount.Clone(),
		ValueDistance: m.ValueDistance.Clone(),
		ValueDuration: m.ValueDuration.Clone(),
		ValueHumanName: m.ValueHumanName.Clone(),
		ValueIdentifier: m.ValueIdentifier.Clone(),
		ValueMoney: m.ValueMoney.Clone(),
		ValuePeriod: m.ValuePeriod.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueRange: m.ValueRange.Clone(),
		ValueRatio: m.ValueRatio.Clone(),
		ValueReference: m.ValueReference.Clone(),
		ValueSampledData: m.ValueSampledData.Clone(),
		ValueSignature: m.ValueSignature.Clone(),
		ValueTiming: m.ValueTiming.Clone(),
		ValueContactDetail: m.ValueContactDetail.Clone(),
		ValueContributor: m.ValueContributor.Clone(),
		ValueDataRequirement: m.ValueDataRequirement.Clone(),
		ValueExpression: m.ValueExpression.Clone(),
		ValueParameterDefinition: m.ValueParameterDefinition.Clone(),
		ValueRelatedArtifact: m.ValueRelatedArtifact.Clone(),
		ValueTriggerDefinition: m.ValueTriggerDefinition.Clone(),
		ValueUsageContext: m.ValueUsageContext.Clone(),
		ValueDosage: m.ValueDosage.Clone(),
		ValueMeta: m.ValueMeta.Clone(),
	}
}

// Equals checks for equality with another TaskInput instance
func (m *TaskInput) Equals(other *TaskInput) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueCanonical.Equals(other.ValueCanonical) { return false }
	if !m.ValueCode.Equals(other.ValueCode) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueId.Equals(other.ValueId) { return false }
	if !m.ValueInstant.Equals(other.ValueInstant) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueMarkdown.Equals(other.ValueMarkdown) { return false }
	if !m.ValueOid.Equals(other.ValueOid) { return false }
	if !m.ValuePositiveInt.Equals(other.ValuePositiveInt) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueUnsignedInt.Equals(other.ValueUnsignedInt) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueUrl.Equals(other.ValueUrl) { return false }
	if !m.ValueUuid.Equals(other.ValueUuid) { return false }
	if !m.ValueAddress.Equals(other.ValueAddress) { return false }
	if !m.ValueAge.Equals(other.ValueAge) { return false }
	if !m.ValueAnnotation.Equals(other.ValueAnnotation) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueContactPoint.Equals(other.ValueContactPoint) { return false }
	if !m.ValueCount.Equals(other.ValueCount) { return false }
	if !m.ValueDistance.Equals(other.ValueDistance) { return false }
	if !m.ValueDuration.Equals(other.ValueDuration) { return false }
	if !m.ValueHumanName.Equals(other.ValueHumanName) { return false }
	if !m.ValueIdentifier.Equals(other.ValueIdentifier) { return false }
	if !m.ValueMoney.Equals(other.ValueMoney) { return false }
	if !m.ValuePeriod.Equals(other.ValuePeriod) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueRange.Equals(other.ValueRange) { return false }
	if !m.ValueRatio.Equals(other.ValueRatio) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !m.ValueSampledData.Equals(other.ValueSampledData) { return false }
	if !m.ValueSignature.Equals(other.ValueSignature) { return false }
	if !m.ValueTiming.Equals(other.ValueTiming) { return false }
	if !m.ValueContactDetail.Equals(other.ValueContactDetail) { return false }
	if !m.ValueContributor.Equals(other.ValueContributor) { return false }
	if !m.ValueDataRequirement.Equals(other.ValueDataRequirement) { return false }
	if !m.ValueExpression.Equals(other.ValueExpression) { return false }
	if !m.ValueParameterDefinition.Equals(other.ValueParameterDefinition) { return false }
	if !m.ValueRelatedArtifact.Equals(other.ValueRelatedArtifact) { return false }
	if !m.ValueTriggerDefinition.Equals(other.ValueTriggerDefinition) { return false }
	if !m.ValueUsageContext.Equals(other.ValueUsageContext) { return false }
	if !m.ValueDosage.Equals(other.ValueDosage) { return false }
	if !m.ValueMeta.Equals(other.ValueMeta) { return false }
	return true
}

// TaskOutput
// Outputs produced by the Task.
type TaskOutput struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueCanonical *FhirCanonical `json:"valuecanonical,omitempty"`
	ValueCode *FhirCode `json:"valuecode,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueId *FhirId `json:"valueid,omitempty"`
	ValueInstant *FhirInstant `json:"valueinstant,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueMarkdown *FhirMarkdown `json:"valuemarkdown,omitempty"`
	ValueOid *FhirOid `json:"valueoid,omitempty"`
	ValuePositiveInt *FhirPositiveInt `json:"valuepositiveint,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueUnsignedInt *FhirUnsignedInt `json:"valueunsignedint,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueUrl *FhirUrl `json:"valueurl,omitempty"`
	ValueUuid *FhirUuid `json:"valueuuid,omitempty"`
	ValueAddress *Address `json:"valueaddress,omitempty"`
	ValueAge *Age `json:"valueage,omitempty"`
	ValueAnnotation *Annotation `json:"valueannotation,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueContactPoint *ContactPoint `json:"valuecontactpoint,omitempty"`
	ValueCount *Count `json:"valuecount,omitempty"`
	ValueDistance *Distance `json:"valuedistance,omitempty"`
	ValueDuration *FhirDuration `json:"valueduration,omitempty"`
	ValueHumanName *HumanName `json:"valuehumanname,omitempty"`
	ValueIdentifier *Identifier `json:"valueidentifier,omitempty"`
	ValueMoney *Money `json:"valuemoney,omitempty"`
	ValuePeriod *Period `json:"valueperiod,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueRange *Range `json:"valuerange,omitempty"`
	ValueRatio *Ratio `json:"valueratio,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
	ValueSignature *Signature `json:"valuesignature,omitempty"`
	ValueTiming *Timing `json:"valuetiming,omitempty"`
	ValueContactDetail *ContactDetail `json:"valuecontactdetail,omitempty"`
	ValueContributor *Contributor `json:"valuecontributor,omitempty"`
	ValueDataRequirement *DataRequirement `json:"valuedatarequirement,omitempty"`
	ValueExpression *FhirExpression `json:"valueexpression,omitempty"`
	ValueParameterDefinition *ParameterDefinition `json:"valueparameterdefinition,omitempty"`
	ValueRelatedArtifact *RelatedArtifact `json:"valuerelatedartifact,omitempty"`
	ValueTriggerDefinition *TriggerDefinition `json:"valuetriggerdefinition,omitempty"`
	ValueUsageContext *UsageContext `json:"valueusagecontext,omitempty"`
	ValueDosage *Dosage `json:"valuedosage,omitempty"`
	ValueMeta *FhirMeta `json:"valuemeta,omitempty"`
}

// NewTaskOutput creates a new TaskOutput instance
func NewTaskOutput() *TaskOutput {
	return &TaskOutput{}
}

// FromJSON populates TaskOutput from JSON data
func (m *TaskOutput) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TaskOutput to JSON data
func (m *TaskOutput) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TaskOutput
func (m *TaskOutput) Clone() *TaskOutput {
	if m == nil { return nil }
	return &TaskOutput{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueCanonical: m.ValueCanonical.Clone(),
		ValueCode: m.ValueCode.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueId: m.ValueId.Clone(),
		ValueInstant: m.ValueInstant.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueMarkdown: m.ValueMarkdown.Clone(),
		ValueOid: m.ValueOid.Clone(),
		ValuePositiveInt: m.ValuePositiveInt.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueUnsignedInt: m.ValueUnsignedInt.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueUrl: m.ValueUrl.Clone(),
		ValueUuid: m.ValueUuid.Clone(),
		ValueAddress: m.ValueAddress.Clone(),
		ValueAge: m.ValueAge.Clone(),
		ValueAnnotation: m.ValueAnnotation.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueContactPoint: m.ValueContactPoint.Clone(),
		ValueCount: m.ValueCount.Clone(),
		ValueDistance: m.ValueDistance.Clone(),
		ValueDuration: m.ValueDuration.Clone(),
		ValueHumanName: m.ValueHumanName.Clone(),
		ValueIdentifier: m.ValueIdentifier.Clone(),
		ValueMoney: m.ValueMoney.Clone(),
		ValuePeriod: m.ValuePeriod.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueRange: m.ValueRange.Clone(),
		ValueRatio: m.ValueRatio.Clone(),
		ValueReference: m.ValueReference.Clone(),
		ValueSampledData: m.ValueSampledData.Clone(),
		ValueSignature: m.ValueSignature.Clone(),
		ValueTiming: m.ValueTiming.Clone(),
		ValueContactDetail: m.ValueContactDetail.Clone(),
		ValueContributor: m.ValueContributor.Clone(),
		ValueDataRequirement: m.ValueDataRequirement.Clone(),
		ValueExpression: m.ValueExpression.Clone(),
		ValueParameterDefinition: m.ValueParameterDefinition.Clone(),
		ValueRelatedArtifact: m.ValueRelatedArtifact.Clone(),
		ValueTriggerDefinition: m.ValueTriggerDefinition.Clone(),
		ValueUsageContext: m.ValueUsageContext.Clone(),
		ValueDosage: m.ValueDosage.Clone(),
		ValueMeta: m.ValueMeta.Clone(),
	}
}

// Equals checks for equality with another TaskOutput instance
func (m *TaskOutput) Equals(other *TaskOutput) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueCanonical.Equals(other.ValueCanonical) { return false }
	if !m.ValueCode.Equals(other.ValueCode) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueId.Equals(other.ValueId) { return false }
	if !m.ValueInstant.Equals(other.ValueInstant) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueMarkdown.Equals(other.ValueMarkdown) { return false }
	if !m.ValueOid.Equals(other.ValueOid) { return false }
	if !m.ValuePositiveInt.Equals(other.ValuePositiveInt) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueUnsignedInt.Equals(other.ValueUnsignedInt) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueUrl.Equals(other.ValueUrl) { return false }
	if !m.ValueUuid.Equals(other.ValueUuid) { return false }
	if !m.ValueAddress.Equals(other.ValueAddress) { return false }
	if !m.ValueAge.Equals(other.ValueAge) { return false }
	if !m.ValueAnnotation.Equals(other.ValueAnnotation) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueContactPoint.Equals(other.ValueContactPoint) { return false }
	if !m.ValueCount.Equals(other.ValueCount) { return false }
	if !m.ValueDistance.Equals(other.ValueDistance) { return false }
	if !m.ValueDuration.Equals(other.ValueDuration) { return false }
	if !m.ValueHumanName.Equals(other.ValueHumanName) { return false }
	if !m.ValueIdentifier.Equals(other.ValueIdentifier) { return false }
	if !m.ValueMoney.Equals(other.ValueMoney) { return false }
	if !m.ValuePeriod.Equals(other.ValuePeriod) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueRange.Equals(other.ValueRange) { return false }
	if !m.ValueRatio.Equals(other.ValueRatio) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !m.ValueSampledData.Equals(other.ValueSampledData) { return false }
	if !m.ValueSignature.Equals(other.ValueSignature) { return false }
	if !m.ValueTiming.Equals(other.ValueTiming) { return false }
	if !m.ValueContactDetail.Equals(other.ValueContactDetail) { return false }
	if !m.ValueContributor.Equals(other.ValueContributor) { return false }
	if !m.ValueDataRequirement.Equals(other.ValueDataRequirement) { return false }
	if !m.ValueExpression.Equals(other.ValueExpression) { return false }
	if !m.ValueParameterDefinition.Equals(other.ValueParameterDefinition) { return false }
	if !m.ValueRelatedArtifact.Equals(other.ValueRelatedArtifact) { return false }
	if !m.ValueTriggerDefinition.Equals(other.ValueTriggerDefinition) { return false }
	if !m.ValueUsageContext.Equals(other.ValueUsageContext) { return false }
	if !m.ValueDosage.Equals(other.ValueDosage) { return false }
	if !m.ValueMeta.Equals(other.ValueMeta) { return false }
	return true
}

