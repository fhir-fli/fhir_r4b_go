// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// Evidence
// The Evidence Resource provides a machine-interpretable expression of an evidence concept including the evidence variables (eg population, exposures/interventions, comparators, outcomes, measured variables, confounding variables), the statistics, and the certainty of this evidence.
type Evidence struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	CiteAsReference *Reference `json:"citeasreference,omitempty"`
	CiteAsMarkdown *FhirMarkdown `json:"citeasmarkdown,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Author []*ContactDetail `json:"author,omitempty"`
	Editor []*ContactDetail `json:"editor,omitempty"`
	Reviewer []*ContactDetail `json:"reviewer,omitempty"`
	Endorser []*ContactDetail `json:"endorser,omitempty"`
	RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Assertion *FhirMarkdown `json:"assertion,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	VariableDefinition []*EvidenceVariableDefinition `json:"variabledefinition,omitempty"`
	SynthesisType *CodeableConcept `json:"synthesistype,omitempty"`
	StudyType *CodeableConcept `json:"studytype,omitempty"`
	Statistic []*EvidenceStatistic `json:"statistic,omitempty"`
	Certainty []*EvidenceCertainty `json:"certainty,omitempty"`
}

// NewEvidence creates a new Evidence instance.
func NewEvidence() *Evidence {
	return &Evidence{}
}

// UnmarshalJSON populates Evidence from JSON data.
func (m *Evidence) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url *FhirUri `json:"url,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Title *FhirString `json:"title,omitempty"`
		CiteAsReference *Reference `json:"citeasreference,omitempty"`
		CiteAsMarkdown *FhirMarkdown `json:"citeasmarkdown,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
		LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
		Publisher *FhirString `json:"publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Author []*ContactDetail `json:"author,omitempty"`
		Editor []*ContactDetail `json:"editor,omitempty"`
		Reviewer []*ContactDetail `json:"reviewer,omitempty"`
		Endorser []*ContactDetail `json:"endorser,omitempty"`
		RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		Assertion *FhirMarkdown `json:"assertion,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		VariableDefinition []*EvidenceVariableDefinition `json:"variabledefinition,omitempty"`
		SynthesisType *CodeableConcept `json:"synthesistype,omitempty"`
		StudyType *CodeableConcept `json:"studytype,omitempty"`
		Statistic []*EvidenceStatistic `json:"statistic,omitempty"`
		Certainty []*EvidenceCertainty `json:"certainty,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Url = temp.Url
	m.Identifier = temp.Identifier
	m.Version = temp.Version
	m.Title = temp.Title
	m.CiteAsReference = temp.CiteAsReference
	m.CiteAsMarkdown = temp.CiteAsMarkdown
	m.Status = temp.Status
	m.Date = temp.Date
	m.UseContext = temp.UseContext
	m.ApprovalDate = temp.ApprovalDate
	m.LastReviewDate = temp.LastReviewDate
	m.Publisher = temp.Publisher
	m.Contact = temp.Contact
	m.Author = temp.Author
	m.Editor = temp.Editor
	m.Reviewer = temp.Reviewer
	m.Endorser = temp.Endorser
	m.RelatedArtifact = temp.RelatedArtifact
	m.Description = temp.Description
	m.Assertion = temp.Assertion
	m.Note = temp.Note
	m.VariableDefinition = temp.VariableDefinition
	m.SynthesisType = temp.SynthesisType
	m.StudyType = temp.StudyType
	m.Statistic = temp.Statistic
	m.Certainty = temp.Certainty
	return nil
}

// MarshalJSON converts Evidence to JSON data.
func (m *Evidence) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Title interface{} `json:"title,omitempty"`
		TitleElement map[string]interface{} `json:"_title,omitempty"`
		CiteAsReference *Reference `json:"citeasreference,omitempty"`
		CiteAsMarkdown interface{} `json:"citeasmarkdown,omitempty"`
		CiteAsMarkdownElement map[string]interface{} `json:"_citeasmarkdown,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		ApprovalDate interface{} `json:"approvaldate,omitempty"`
		ApprovalDateElement map[string]interface{} `json:"_approvaldate,omitempty"`
		LastReviewDate interface{} `json:"lastreviewdate,omitempty"`
		LastReviewDateElement map[string]interface{} `json:"_lastreviewdate,omitempty"`
		Publisher interface{} `json:"publisher,omitempty"`
		PublisherElement map[string]interface{} `json:"_publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Author []*ContactDetail `json:"author,omitempty"`
		Editor []*ContactDetail `json:"editor,omitempty"`
		Reviewer []*ContactDetail `json:"reviewer,omitempty"`
		Endorser []*ContactDetail `json:"endorser,omitempty"`
		RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Assertion interface{} `json:"assertion,omitempty"`
		AssertionElement map[string]interface{} `json:"_assertion,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		VariableDefinition []*EvidenceVariableDefinition `json:"variabledefinition,omitempty"`
		SynthesisType *CodeableConcept `json:"synthesistype,omitempty"`
		StudyType *CodeableConcept `json:"studytype,omitempty"`
		Statistic []*EvidenceStatistic `json:"statistic,omitempty"`
		Certainty []*EvidenceCertainty `json:"certainty,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	output.Identifier = m.Identifier
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	if m.Title != nil && m.Title.Value != nil {
		output.Title = m.Title.Value
		if m.Title.Element != nil {
			output.TitleElement = toMapOrNil(m.Title.Element.MarshalJSON())
		}
	}
	output.CiteAsReference = m.CiteAsReference
	if m.CiteAsMarkdown != nil && m.CiteAsMarkdown.Value != nil {
		output.CiteAsMarkdown = m.CiteAsMarkdown.Value
		if m.CiteAsMarkdown.Element != nil {
			output.CiteAsMarkdownElement = toMapOrNil(m.CiteAsMarkdown.Element.MarshalJSON())
		}
	}
	output.Status = m.Status
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.MarshalJSON())
		}
	}
	output.UseContext = m.UseContext
	if m.ApprovalDate != nil && m.ApprovalDate.Value != nil {
		output.ApprovalDate = m.ApprovalDate.Value
		if m.ApprovalDate.Element != nil {
			output.ApprovalDateElement = toMapOrNil(m.ApprovalDate.Element.MarshalJSON())
		}
	}
	if m.LastReviewDate != nil && m.LastReviewDate.Value != nil {
		output.LastReviewDate = m.LastReviewDate.Value
		if m.LastReviewDate.Element != nil {
			output.LastReviewDateElement = toMapOrNil(m.LastReviewDate.Element.MarshalJSON())
		}
	}
	if m.Publisher != nil && m.Publisher.Value != nil {
		output.Publisher = m.Publisher.Value
		if m.Publisher.Element != nil {
			output.PublisherElement = toMapOrNil(m.Publisher.Element.MarshalJSON())
		}
	}
	output.Contact = m.Contact
	output.Author = m.Author
	output.Editor = m.Editor
	output.Reviewer = m.Reviewer
	output.Endorser = m.Endorser
	output.RelatedArtifact = m.RelatedArtifact
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	if m.Assertion != nil && m.Assertion.Value != nil {
		output.Assertion = m.Assertion.Value
		if m.Assertion.Element != nil {
			output.AssertionElement = toMapOrNil(m.Assertion.Element.MarshalJSON())
		}
	}
	output.Note = m.Note
	output.VariableDefinition = m.VariableDefinition
	output.SynthesisType = m.SynthesisType
	output.StudyType = m.StudyType
	output.Statistic = m.Statistic
	output.Certainty = m.Certainty
	return json.Marshal(output)
}

// Clone creates a deep copy of Evidence.
func (m *Evidence) Clone() *Evidence {
	if m == nil { return nil }
	return &Evidence{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Title: m.Title.Clone(),
		CiteAsReference: m.CiteAsReference.Clone(),
		CiteAsMarkdown: m.CiteAsMarkdown.Clone(),
		Status: m.Status.Clone(),
		Date: m.Date.Clone(),
		UseContext: cloneSlices(m.UseContext),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Author: cloneSlices(m.Author),
		Editor: cloneSlices(m.Editor),
		Reviewer: cloneSlices(m.Reviewer),
		Endorser: cloneSlices(m.Endorser),
		RelatedArtifact: cloneSlices(m.RelatedArtifact),
		Description: m.Description.Clone(),
		Assertion: m.Assertion.Clone(),
		Note: cloneSlices(m.Note),
		VariableDefinition: cloneSlices(m.VariableDefinition),
		SynthesisType: m.SynthesisType.Clone(),
		StudyType: m.StudyType.Clone(),
		Statistic: cloneSlices(m.Statistic),
		Certainty: cloneSlices(m.Certainty),
	}
}

// Equals checks equality between two Evidence instances.
func (m *Evidence) Equals(other *Evidence) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.CiteAsReference.Equals(other.CiteAsReference) { return false }
	if !m.CiteAsMarkdown.Equals(other.CiteAsMarkdown) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !compareSlices(m.Author, other.Author) { return false }
	if !compareSlices(m.Editor, other.Editor) { return false }
	if !compareSlices(m.Reviewer, other.Reviewer) { return false }
	if !compareSlices(m.Endorser, other.Endorser) { return false }
	if !compareSlices(m.RelatedArtifact, other.RelatedArtifact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Assertion.Equals(other.Assertion) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.VariableDefinition, other.VariableDefinition) { return false }
	if !m.SynthesisType.Equals(other.SynthesisType) { return false }
	if !m.StudyType.Equals(other.StudyType) { return false }
	if !compareSlices(m.Statistic, other.Statistic) { return false }
	if !compareSlices(m.Certainty, other.Certainty) { return false }
	return true
}

// EvidenceVariableDefinition
// Evidence variable such as population, exposure, or outcome.
type EvidenceVariableDefinition struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	VariableRole *CodeableConcept `json:"variablerole,omitempty"`
	Observed *Reference `json:"observed,omitempty"`
	Intended *Reference `json:"intended,omitempty"`
	DirectnessMatch *CodeableConcept `json:"directnessmatch,omitempty"`
}

// NewEvidenceVariableDefinition creates a new EvidenceVariableDefinition instance.
func NewEvidenceVariableDefinition() *EvidenceVariableDefinition {
	return &EvidenceVariableDefinition{}
}

// UnmarshalJSON populates EvidenceVariableDefinition from JSON data.
func (m *EvidenceVariableDefinition) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		VariableRole *CodeableConcept `json:"variablerole,omitempty"`
		Observed *Reference `json:"observed,omitempty"`
		Intended *Reference `json:"intended,omitempty"`
		DirectnessMatch *CodeableConcept `json:"directnessmatch,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Note = temp.Note
	m.VariableRole = temp.VariableRole
	m.Observed = temp.Observed
	m.Intended = temp.Intended
	m.DirectnessMatch = temp.DirectnessMatch
	return nil
}

// MarshalJSON converts EvidenceVariableDefinition to JSON data.
func (m *EvidenceVariableDefinition) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		VariableRole *CodeableConcept `json:"variablerole,omitempty"`
		Observed *Reference `json:"observed,omitempty"`
		Intended *Reference `json:"intended,omitempty"`
		DirectnessMatch *CodeableConcept `json:"directnessmatch,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Note = m.Note
	output.VariableRole = m.VariableRole
	output.Observed = m.Observed
	output.Intended = m.Intended
	output.DirectnessMatch = m.DirectnessMatch
	return json.Marshal(output)
}

// Clone creates a deep copy of EvidenceVariableDefinition.
func (m *EvidenceVariableDefinition) Clone() *EvidenceVariableDefinition {
	if m == nil { return nil }
	return &EvidenceVariableDefinition{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		VariableRole: m.VariableRole.Clone(),
		Observed: m.Observed.Clone(),
		Intended: m.Intended.Clone(),
		DirectnessMatch: m.DirectnessMatch.Clone(),
	}
}

// Equals checks equality between two EvidenceVariableDefinition instances.
func (m *EvidenceVariableDefinition) Equals(other *EvidenceVariableDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.VariableRole.Equals(other.VariableRole) { return false }
	if !m.Observed.Equals(other.Observed) { return false }
	if !m.Intended.Equals(other.Intended) { return false }
	if !m.DirectnessMatch.Equals(other.DirectnessMatch) { return false }
	return true
}

// EvidenceStatistic
// Values and parameters for a single statistic.
type EvidenceStatistic struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	StatisticType *CodeableConcept `json:"statistictype,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	NumberOfEvents *FhirUnsignedInt `json:"numberofevents,omitempty"`
	NumberAffected *FhirUnsignedInt `json:"numberaffected,omitempty"`
	SampleSize *EvidenceSampleSize `json:"samplesize,omitempty"`
	AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
	ModelCharacteristic []*EvidenceModelCharacteristic `json:"modelcharacteristic,omitempty"`
}

// NewEvidenceStatistic creates a new EvidenceStatistic instance.
func NewEvidenceStatistic() *EvidenceStatistic {
	return &EvidenceStatistic{}
}

// UnmarshalJSON populates EvidenceStatistic from JSON data.
func (m *EvidenceStatistic) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		StatisticType *CodeableConcept `json:"statistictype,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		NumberOfEvents *FhirUnsignedInt `json:"numberofevents,omitempty"`
		NumberAffected *FhirUnsignedInt `json:"numberaffected,omitempty"`
		SampleSize *EvidenceSampleSize `json:"samplesize,omitempty"`
		AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
		ModelCharacteristic []*EvidenceModelCharacteristic `json:"modelcharacteristic,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Note = temp.Note
	m.StatisticType = temp.StatisticType
	m.Category = temp.Category
	m.Quantity = temp.Quantity
	m.NumberOfEvents = temp.NumberOfEvents
	m.NumberAffected = temp.NumberAffected
	m.SampleSize = temp.SampleSize
	m.AttributeEstimate = temp.AttributeEstimate
	m.ModelCharacteristic = temp.ModelCharacteristic
	return nil
}

// MarshalJSON converts EvidenceStatistic to JSON data.
func (m *EvidenceStatistic) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		StatisticType *CodeableConcept `json:"statistictype,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		NumberOfEvents interface{} `json:"numberofevents,omitempty"`
		NumberOfEventsElement map[string]interface{} `json:"_numberofevents,omitempty"`
		NumberAffected interface{} `json:"numberaffected,omitempty"`
		NumberAffectedElement map[string]interface{} `json:"_numberaffected,omitempty"`
		SampleSize *EvidenceSampleSize `json:"samplesize,omitempty"`
		AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
		ModelCharacteristic []*EvidenceModelCharacteristic `json:"modelcharacteristic,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Note = m.Note
	output.StatisticType = m.StatisticType
	output.Category = m.Category
	output.Quantity = m.Quantity
	if m.NumberOfEvents != nil && m.NumberOfEvents.Value != nil {
		output.NumberOfEvents = m.NumberOfEvents.Value
		if m.NumberOfEvents.Element != nil {
			output.NumberOfEventsElement = toMapOrNil(m.NumberOfEvents.Element.MarshalJSON())
		}
	}
	if m.NumberAffected != nil && m.NumberAffected.Value != nil {
		output.NumberAffected = m.NumberAffected.Value
		if m.NumberAffected.Element != nil {
			output.NumberAffectedElement = toMapOrNil(m.NumberAffected.Element.MarshalJSON())
		}
	}
	output.SampleSize = m.SampleSize
	output.AttributeEstimate = m.AttributeEstimate
	output.ModelCharacteristic = m.ModelCharacteristic
	return json.Marshal(output)
}

// Clone creates a deep copy of EvidenceStatistic.
func (m *EvidenceStatistic) Clone() *EvidenceStatistic {
	if m == nil { return nil }
	return &EvidenceStatistic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		StatisticType: m.StatisticType.Clone(),
		Category: m.Category.Clone(),
		Quantity: m.Quantity.Clone(),
		NumberOfEvents: m.NumberOfEvents.Clone(),
		NumberAffected: m.NumberAffected.Clone(),
		SampleSize: m.SampleSize.Clone(),
		AttributeEstimate: cloneSlices(m.AttributeEstimate),
		ModelCharacteristic: cloneSlices(m.ModelCharacteristic),
	}
}

// Equals checks equality between two EvidenceStatistic instances.
func (m *EvidenceStatistic) Equals(other *EvidenceStatistic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.StatisticType.Equals(other.StatisticType) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.NumberOfEvents.Equals(other.NumberOfEvents) { return false }
	if !m.NumberAffected.Equals(other.NumberAffected) { return false }
	if !m.SampleSize.Equals(other.SampleSize) { return false }
	if !compareSlices(m.AttributeEstimate, other.AttributeEstimate) { return false }
	if !compareSlices(m.ModelCharacteristic, other.ModelCharacteristic) { return false }
	return true
}

// EvidenceSampleSize
// Number of samples in the statistic.
type EvidenceSampleSize struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	NumberOfStudies *FhirUnsignedInt `json:"numberofstudies,omitempty"`
	NumberOfParticipants *FhirUnsignedInt `json:"numberofparticipants,omitempty"`
	KnownDataCount *FhirUnsignedInt `json:"knowndatacount,omitempty"`
}

// NewEvidenceSampleSize creates a new EvidenceSampleSize instance.
func NewEvidenceSampleSize() *EvidenceSampleSize {
	return &EvidenceSampleSize{}
}

// UnmarshalJSON populates EvidenceSampleSize from JSON data.
func (m *EvidenceSampleSize) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		NumberOfStudies *FhirUnsignedInt `json:"numberofstudies,omitempty"`
		NumberOfParticipants *FhirUnsignedInt `json:"numberofparticipants,omitempty"`
		KnownDataCount *FhirUnsignedInt `json:"knowndatacount,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Note = temp.Note
	m.NumberOfStudies = temp.NumberOfStudies
	m.NumberOfParticipants = temp.NumberOfParticipants
	m.KnownDataCount = temp.KnownDataCount
	return nil
}

// MarshalJSON converts EvidenceSampleSize to JSON data.
func (m *EvidenceSampleSize) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		NumberOfStudies interface{} `json:"numberofstudies,omitempty"`
		NumberOfStudiesElement map[string]interface{} `json:"_numberofstudies,omitempty"`
		NumberOfParticipants interface{} `json:"numberofparticipants,omitempty"`
		NumberOfParticipantsElement map[string]interface{} `json:"_numberofparticipants,omitempty"`
		KnownDataCount interface{} `json:"knowndatacount,omitempty"`
		KnownDataCountElement map[string]interface{} `json:"_knowndatacount,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Note = m.Note
	if m.NumberOfStudies != nil && m.NumberOfStudies.Value != nil {
		output.NumberOfStudies = m.NumberOfStudies.Value
		if m.NumberOfStudies.Element != nil {
			output.NumberOfStudiesElement = toMapOrNil(m.NumberOfStudies.Element.MarshalJSON())
		}
	}
	if m.NumberOfParticipants != nil && m.NumberOfParticipants.Value != nil {
		output.NumberOfParticipants = m.NumberOfParticipants.Value
		if m.NumberOfParticipants.Element != nil {
			output.NumberOfParticipantsElement = toMapOrNil(m.NumberOfParticipants.Element.MarshalJSON())
		}
	}
	if m.KnownDataCount != nil && m.KnownDataCount.Value != nil {
		output.KnownDataCount = m.KnownDataCount.Value
		if m.KnownDataCount.Element != nil {
			output.KnownDataCountElement = toMapOrNil(m.KnownDataCount.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of EvidenceSampleSize.
func (m *EvidenceSampleSize) Clone() *EvidenceSampleSize {
	if m == nil { return nil }
	return &EvidenceSampleSize{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		NumberOfStudies: m.NumberOfStudies.Clone(),
		NumberOfParticipants: m.NumberOfParticipants.Clone(),
		KnownDataCount: m.KnownDataCount.Clone(),
	}
}

// Equals checks equality between two EvidenceSampleSize instances.
func (m *EvidenceSampleSize) Equals(other *EvidenceSampleSize) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.NumberOfStudies.Equals(other.NumberOfStudies) { return false }
	if !m.NumberOfParticipants.Equals(other.NumberOfParticipants) { return false }
	if !m.KnownDataCount.Equals(other.KnownDataCount) { return false }
	return true
}

// EvidenceAttributeEstimate
// A statistical attribute of the statistic such as a measure of heterogeneity.
type EvidenceAttributeEstimate struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Level *FhirDecimal `json:"level,omitempty"`
	Range *Range `json:"range,omitempty"`
	AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
}

// NewEvidenceAttributeEstimate creates a new EvidenceAttributeEstimate instance.
func NewEvidenceAttributeEstimate() *EvidenceAttributeEstimate {
	return &EvidenceAttributeEstimate{}
}

// UnmarshalJSON populates EvidenceAttributeEstimate from JSON data.
func (m *EvidenceAttributeEstimate) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Level *FhirDecimal `json:"level,omitempty"`
		Range *Range `json:"range,omitempty"`
		AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Note = temp.Note
	m.Type = temp.Type
	m.Quantity = temp.Quantity
	m.Level = temp.Level
	m.Range = temp.Range
	m.AttributeEstimate = temp.AttributeEstimate
	return nil
}

// MarshalJSON converts EvidenceAttributeEstimate to JSON data.
func (m *EvidenceAttributeEstimate) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		Level interface{} `json:"level,omitempty"`
		LevelElement map[string]interface{} `json:"_level,omitempty"`
		Range *Range `json:"range,omitempty"`
		AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Note = m.Note
	output.Type = m.Type
	output.Quantity = m.Quantity
	if m.Level != nil && m.Level.Value != nil {
		output.Level = m.Level.Value
		if m.Level.Element != nil {
			output.LevelElement = toMapOrNil(m.Level.Element.MarshalJSON())
		}
	}
	output.Range = m.Range
	output.AttributeEstimate = m.AttributeEstimate
	return json.Marshal(output)
}

// Clone creates a deep copy of EvidenceAttributeEstimate.
func (m *EvidenceAttributeEstimate) Clone() *EvidenceAttributeEstimate {
	if m == nil { return nil }
	return &EvidenceAttributeEstimate{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		Type: m.Type.Clone(),
		Quantity: m.Quantity.Clone(),
		Level: m.Level.Clone(),
		Range: m.Range.Clone(),
		AttributeEstimate: cloneSlices(m.AttributeEstimate),
	}
}

// Equals checks equality between two EvidenceAttributeEstimate instances.
func (m *EvidenceAttributeEstimate) Equals(other *EvidenceAttributeEstimate) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.Level.Equals(other.Level) { return false }
	if !m.Range.Equals(other.Range) { return false }
	if !compareSlices(m.AttributeEstimate, other.AttributeEstimate) { return false }
	return true
}

// EvidenceModelCharacteristic
// A component of the method to generate the statistic.
type EvidenceModelCharacteristic struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Value *Quantity `json:"value,omitempty"`
	Variable []*EvidenceModelCharacteristicVariable `json:"variable,omitempty"`
	AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
}

// NewEvidenceModelCharacteristic creates a new EvidenceModelCharacteristic instance.
func NewEvidenceModelCharacteristic() *EvidenceModelCharacteristic {
	return &EvidenceModelCharacteristic{}
}

// UnmarshalJSON populates EvidenceModelCharacteristic from JSON data.
func (m *EvidenceModelCharacteristic) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Value *Quantity `json:"value,omitempty"`
		Variable []*EvidenceModelCharacteristicVariable `json:"variable,omitempty"`
		AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Value = temp.Value
	m.Variable = temp.Variable
	m.AttributeEstimate = temp.AttributeEstimate
	return nil
}

// MarshalJSON converts EvidenceModelCharacteristic to JSON data.
func (m *EvidenceModelCharacteristic) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Value *Quantity `json:"value,omitempty"`
		Variable []*EvidenceModelCharacteristicVariable `json:"variable,omitempty"`
		AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	output.Value = m.Value
	output.Variable = m.Variable
	output.AttributeEstimate = m.AttributeEstimate
	return json.Marshal(output)
}

// Clone creates a deep copy of EvidenceModelCharacteristic.
func (m *EvidenceModelCharacteristic) Clone() *EvidenceModelCharacteristic {
	if m == nil { return nil }
	return &EvidenceModelCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Value: m.Value.Clone(),
		Variable: cloneSlices(m.Variable),
		AttributeEstimate: cloneSlices(m.AttributeEstimate),
	}
}

// Equals checks equality between two EvidenceModelCharacteristic instances.
func (m *EvidenceModelCharacteristic) Equals(other *EvidenceModelCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !compareSlices(m.Variable, other.Variable) { return false }
	if !compareSlices(m.AttributeEstimate, other.AttributeEstimate) { return false }
	return true
}

// EvidenceModelCharacteristicVariable
// A variable adjusted for in the adjusted analysis.
type EvidenceModelCharacteristicVariable struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	VariableDefinition *Reference `json:"variabledefinition,omitempty"`
	Handling *EvidenceVariableHandling `json:"handling,omitempty"`
	ValueCategory []*CodeableConcept `json:"valuecategory,omitempty"`
	ValueQuantity []*Quantity `json:"valuequantity,omitempty"`
	ValueRange []*Range `json:"valuerange,omitempty"`
}

// NewEvidenceModelCharacteristicVariable creates a new EvidenceModelCharacteristicVariable instance.
func NewEvidenceModelCharacteristicVariable() *EvidenceModelCharacteristicVariable {
	return &EvidenceModelCharacteristicVariable{}
}

// UnmarshalJSON populates EvidenceModelCharacteristicVariable from JSON data.
func (m *EvidenceModelCharacteristicVariable) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		VariableDefinition *Reference `json:"variabledefinition,omitempty"`
		Handling *EvidenceVariableHandling `json:"handling,omitempty"`
		ValueCategory []*CodeableConcept `json:"valuecategory,omitempty"`
		ValueQuantity []*Quantity `json:"valuequantity,omitempty"`
		ValueRange []*Range `json:"valuerange,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.VariableDefinition = temp.VariableDefinition
	m.Handling = temp.Handling
	m.ValueCategory = temp.ValueCategory
	m.ValueQuantity = temp.ValueQuantity
	m.ValueRange = temp.ValueRange
	return nil
}

// MarshalJSON converts EvidenceModelCharacteristicVariable to JSON data.
func (m *EvidenceModelCharacteristicVariable) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		VariableDefinition *Reference `json:"variabledefinition,omitempty"`
		Handling *EvidenceVariableHandling `json:"handling,omitempty"`
		ValueCategory []*CodeableConcept `json:"valuecategory,omitempty"`
		ValueQuantity []*Quantity `json:"valuequantity,omitempty"`
		ValueRange []*Range `json:"valuerange,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.VariableDefinition = m.VariableDefinition
	output.Handling = m.Handling
	output.ValueCategory = m.ValueCategory
	output.ValueQuantity = m.ValueQuantity
	output.ValueRange = m.ValueRange
	return json.Marshal(output)
}

// Clone creates a deep copy of EvidenceModelCharacteristicVariable.
func (m *EvidenceModelCharacteristicVariable) Clone() *EvidenceModelCharacteristicVariable {
	if m == nil { return nil }
	return &EvidenceModelCharacteristicVariable{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		VariableDefinition: m.VariableDefinition.Clone(),
		Handling: m.Handling.Clone(),
		ValueCategory: cloneSlices(m.ValueCategory),
		ValueQuantity: cloneSlices(m.ValueQuantity),
		ValueRange: cloneSlices(m.ValueRange),
	}
}

// Equals checks equality between two EvidenceModelCharacteristicVariable instances.
func (m *EvidenceModelCharacteristicVariable) Equals(other *EvidenceModelCharacteristicVariable) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.VariableDefinition.Equals(other.VariableDefinition) { return false }
	if !m.Handling.Equals(other.Handling) { return false }
	if !compareSlices(m.ValueCategory, other.ValueCategory) { return false }
	if !compareSlices(m.ValueQuantity, other.ValueQuantity) { return false }
	if !compareSlices(m.ValueRange, other.ValueRange) { return false }
	return true
}

// EvidenceCertainty
// Assessment of certainty, confidence in the estimates, or quality of the evidence.
type EvidenceCertainty struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Rating *CodeableConcept `json:"rating,omitempty"`
	Rater *FhirString `json:"rater,omitempty"`
	Subcomponent []*EvidenceCertainty `json:"subcomponent,omitempty"`
}

// NewEvidenceCertainty creates a new EvidenceCertainty instance.
func NewEvidenceCertainty() *EvidenceCertainty {
	return &EvidenceCertainty{}
}

// UnmarshalJSON populates EvidenceCertainty from JSON data.
func (m *EvidenceCertainty) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Rating *CodeableConcept `json:"rating,omitempty"`
		Rater *FhirString `json:"rater,omitempty"`
		Subcomponent []*EvidenceCertainty `json:"subcomponent,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Note = temp.Note
	m.Type = temp.Type
	m.Rating = temp.Rating
	m.Rater = temp.Rater
	m.Subcomponent = temp.Subcomponent
	return nil
}

// MarshalJSON converts EvidenceCertainty to JSON data.
func (m *EvidenceCertainty) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Rating *CodeableConcept `json:"rating,omitempty"`
		Rater interface{} `json:"rater,omitempty"`
		RaterElement map[string]interface{} `json:"_rater,omitempty"`
		Subcomponent []*EvidenceCertainty `json:"subcomponent,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Note = m.Note
	output.Type = m.Type
	output.Rating = m.Rating
	if m.Rater != nil && m.Rater.Value != nil {
		output.Rater = m.Rater.Value
		if m.Rater.Element != nil {
			output.RaterElement = toMapOrNil(m.Rater.Element.MarshalJSON())
		}
	}
	output.Subcomponent = m.Subcomponent
	return json.Marshal(output)
}

// Clone creates a deep copy of EvidenceCertainty.
func (m *EvidenceCertainty) Clone() *EvidenceCertainty {
	if m == nil { return nil }
	return &EvidenceCertainty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		Type: m.Type.Clone(),
		Rating: m.Rating.Clone(),
		Rater: m.Rater.Clone(),
		Subcomponent: cloneSlices(m.Subcomponent),
	}
}

// Equals checks equality between two EvidenceCertainty instances.
func (m *EvidenceCertainty) Equals(other *EvidenceCertainty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Rating.Equals(other.Rating) { return false }
	if !m.Rater.Equals(other.Rater) { return false }
	if !compareSlices(m.Subcomponent, other.Subcomponent) { return false }
	return true
}

