// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// SubscriptionTopic
// Describes a stream of resource state changes or events and annotated with labels useful to filter projections from this topic.
type SubscriptionTopic struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	DerivedFrom []*FhirCanonical `json:"derivedfrom,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	ResourceTrigger []*SubscriptionTopicResourceTrigger `json:"resourcetrigger,omitempty"`
	EventTrigger []*SubscriptionTopicEventTrigger `json:"eventtrigger,omitempty"`
	CanFilterBy []*SubscriptionTopicCanFilterBy `json:"canfilterby,omitempty"`
	NotificationShape []*SubscriptionTopicNotificationShape `json:"notificationshape,omitempty"`
}

// NewSubscriptionTopic creates a new SubscriptionTopic instance
func NewSubscriptionTopic() *SubscriptionTopic {
	return &SubscriptionTopic{}
}

// FromJSON populates SubscriptionTopic from JSON data
func (m *SubscriptionTopic) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionTopic to JSON data
func (m *SubscriptionTopic) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionTopic
func (m *SubscriptionTopic) Clone() *SubscriptionTopic {
	if m == nil { return nil }
	return &SubscriptionTopic{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Title: m.Title.Clone(),
		DerivedFrom: cloneSlices(m.DerivedFrom),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		ResourceTrigger: cloneSlices(m.ResourceTrigger),
		EventTrigger: cloneSlices(m.EventTrigger),
		CanFilterBy: cloneSlices(m.CanFilterBy),
		NotificationShape: cloneSlices(m.NotificationShape),
	}
}

// Equals checks for equality with another SubscriptionTopic instance
func (m *SubscriptionTopic) Equals(other *SubscriptionTopic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !compareSlices(m.DerivedFrom, other.DerivedFrom) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !compareSlices(m.ResourceTrigger, other.ResourceTrigger) { return false }
	if !compareSlices(m.EventTrigger, other.EventTrigger) { return false }
	if !compareSlices(m.CanFilterBy, other.CanFilterBy) { return false }
	if !compareSlices(m.NotificationShape, other.NotificationShape) { return false }
	return true
}

// SubscriptionTopicResourceTrigger
// A definition of a resource-based event that triggers a notification based on the SubscriptionTopic. The criteria may be just a human readable description and/or a full FHIR search string or FHIRPath expression. Multiple triggers are considered OR joined (e.g., a resource update matching ANY of the definitions will trigger a notification).
type SubscriptionTopicResourceTrigger struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
	SupportedInteraction []*InteractionTrigger `json:"supportedinteraction,omitempty"`
	QueryCriteria *SubscriptionTopicQueryCriteria `json:"querycriteria,omitempty"`
	FhirPathCriteria *FhirString `json:"fhirpathcriteria,omitempty"`
}

// NewSubscriptionTopicResourceTrigger creates a new SubscriptionTopicResourceTrigger instance
func NewSubscriptionTopicResourceTrigger() *SubscriptionTopicResourceTrigger {
	return &SubscriptionTopicResourceTrigger{}
}

// FromJSON populates SubscriptionTopicResourceTrigger from JSON data
func (m *SubscriptionTopicResourceTrigger) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionTopicResourceTrigger to JSON data
func (m *SubscriptionTopicResourceTrigger) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionTopicResourceTrigger
func (m *SubscriptionTopicResourceTrigger) Clone() *SubscriptionTopicResourceTrigger {
	if m == nil { return nil }
	return &SubscriptionTopicResourceTrigger{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Resource: m.Resource.Clone(),
		SupportedInteraction: cloneSlices(m.SupportedInteraction),
		QueryCriteria: m.QueryCriteria.Clone(),
		FhirPathCriteria: m.FhirPathCriteria.Clone(),
	}
}

// Equals checks for equality with another SubscriptionTopicResourceTrigger instance
func (m *SubscriptionTopicResourceTrigger) Equals(other *SubscriptionTopicResourceTrigger) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !compareSlices(m.SupportedInteraction, other.SupportedInteraction) { return false }
	if !m.QueryCriteria.Equals(other.QueryCriteria) { return false }
	if !m.FhirPathCriteria.Equals(other.FhirPathCriteria) { return false }
	return true
}

// SubscriptionTopicQueryCriteria
// The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic.
type SubscriptionTopicQueryCriteria struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Previous *FhirString `json:"previous,omitempty"`
	ResultForCreate *CriteriaNotExistsBehavior `json:"resultforcreate,omitempty"`
	Current *FhirString `json:"current,omitempty"`
	ResultForDelete *CriteriaNotExistsBehavior `json:"resultfordelete,omitempty"`
	RequireBoth *FhirBoolean `json:"requireboth,omitempty"`
}

// NewSubscriptionTopicQueryCriteria creates a new SubscriptionTopicQueryCriteria instance
func NewSubscriptionTopicQueryCriteria() *SubscriptionTopicQueryCriteria {
	return &SubscriptionTopicQueryCriteria{}
}

// FromJSON populates SubscriptionTopicQueryCriteria from JSON data
func (m *SubscriptionTopicQueryCriteria) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionTopicQueryCriteria to JSON data
func (m *SubscriptionTopicQueryCriteria) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionTopicQueryCriteria
func (m *SubscriptionTopicQueryCriteria) Clone() *SubscriptionTopicQueryCriteria {
	if m == nil { return nil }
	return &SubscriptionTopicQueryCriteria{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Previous: m.Previous.Clone(),
		ResultForCreate: m.ResultForCreate.Clone(),
		Current: m.Current.Clone(),
		ResultForDelete: m.ResultForDelete.Clone(),
		RequireBoth: m.RequireBoth.Clone(),
	}
}

// Equals checks for equality with another SubscriptionTopicQueryCriteria instance
func (m *SubscriptionTopicQueryCriteria) Equals(other *SubscriptionTopicQueryCriteria) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Previous.Equals(other.Previous) { return false }
	if !m.ResultForCreate.Equals(other.ResultForCreate) { return false }
	if !m.Current.Equals(other.Current) { return false }
	if !m.ResultForDelete.Equals(other.ResultForDelete) { return false }
	if !m.RequireBoth.Equals(other.RequireBoth) { return false }
	return true
}

// SubscriptionTopicEventTrigger
// Event definition which can be used to trigger the SubscriptionTopic.
type SubscriptionTopicEventTrigger struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Event *CodeableConcept `json:"event,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
}

// NewSubscriptionTopicEventTrigger creates a new SubscriptionTopicEventTrigger instance
func NewSubscriptionTopicEventTrigger() *SubscriptionTopicEventTrigger {
	return &SubscriptionTopicEventTrigger{}
}

// FromJSON populates SubscriptionTopicEventTrigger from JSON data
func (m *SubscriptionTopicEventTrigger) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionTopicEventTrigger to JSON data
func (m *SubscriptionTopicEventTrigger) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionTopicEventTrigger
func (m *SubscriptionTopicEventTrigger) Clone() *SubscriptionTopicEventTrigger {
	if m == nil { return nil }
	return &SubscriptionTopicEventTrigger{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Event: m.Event.Clone(),
		Resource: m.Resource.Clone(),
	}
}

// Equals checks for equality with another SubscriptionTopicEventTrigger instance
func (m *SubscriptionTopicEventTrigger) Equals(other *SubscriptionTopicEventTrigger) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Event.Equals(other.Event) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	return true
}

// SubscriptionTopicCanFilterBy
// List of properties by which Subscriptions on the SubscriptionTopic can be filtered. May be defined Search Parameters (e.g., Encounter.patient) or parameters defined within this SubscriptionTopic context (e.g., hub.event).
type SubscriptionTopicCanFilterBy struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
	FilterParameter *FhirString `json:"filterparameter,omitempty"`
	FilterDefinition *FhirUri `json:"filterdefinition,omitempty"`
	Modifier []*SubscriptionSearchModifier `json:"modifier,omitempty"`
}

// NewSubscriptionTopicCanFilterBy creates a new SubscriptionTopicCanFilterBy instance
func NewSubscriptionTopicCanFilterBy() *SubscriptionTopicCanFilterBy {
	return &SubscriptionTopicCanFilterBy{}
}

// FromJSON populates SubscriptionTopicCanFilterBy from JSON data
func (m *SubscriptionTopicCanFilterBy) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionTopicCanFilterBy to JSON data
func (m *SubscriptionTopicCanFilterBy) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionTopicCanFilterBy
func (m *SubscriptionTopicCanFilterBy) Clone() *SubscriptionTopicCanFilterBy {
	if m == nil { return nil }
	return &SubscriptionTopicCanFilterBy{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Resource: m.Resource.Clone(),
		FilterParameter: m.FilterParameter.Clone(),
		FilterDefinition: m.FilterDefinition.Clone(),
		Modifier: cloneSlices(m.Modifier),
	}
}

// Equals checks for equality with another SubscriptionTopicCanFilterBy instance
func (m *SubscriptionTopicCanFilterBy) Equals(other *SubscriptionTopicCanFilterBy) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !m.FilterParameter.Equals(other.FilterParameter) { return false }
	if !m.FilterDefinition.Equals(other.FilterDefinition) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	return true
}

// SubscriptionTopicNotificationShape
// List of properties to describe the shape (e.g., resources) included in notifications from this Subscription Topic.
type SubscriptionTopicNotificationShape struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
	Include []*FhirString `json:"include,omitempty"`
	RevInclude []*FhirString `json:"revinclude,omitempty"`
}

// NewSubscriptionTopicNotificationShape creates a new SubscriptionTopicNotificationShape instance
func NewSubscriptionTopicNotificationShape() *SubscriptionTopicNotificationShape {
	return &SubscriptionTopicNotificationShape{}
}

// FromJSON populates SubscriptionTopicNotificationShape from JSON data
func (m *SubscriptionTopicNotificationShape) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionTopicNotificationShape to JSON data
func (m *SubscriptionTopicNotificationShape) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionTopicNotificationShape
func (m *SubscriptionTopicNotificationShape) Clone() *SubscriptionTopicNotificationShape {
	if m == nil { return nil }
	return &SubscriptionTopicNotificationShape{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Resource: m.Resource.Clone(),
		Include: cloneSlices(m.Include),
		RevInclude: cloneSlices(m.RevInclude),
	}
}

// Equals checks for equality with another SubscriptionTopicNotificationShape instance
func (m *SubscriptionTopicNotificationShape) Equals(other *SubscriptionTopicNotificationShape) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !compareSlices(m.Include, other.Include) { return false }
	if !compareSlices(m.RevInclude, other.RevInclude) { return false }
	return true
}

