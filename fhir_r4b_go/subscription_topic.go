// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// SubscriptionTopic
// Describes a stream of resource state changes or events and annotated with labels useful to filter projections from this topic.
type SubscriptionTopic struct {
	extends CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	DerivedFrom []*FhirCanonical `json:"derivedfrom,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	ResourceTrigger []*SubscriptionTopicResourceTrigger `json:"resourcetrigger,omitempty"`
	EventTrigger []*SubscriptionTopicEventTrigger `json:"eventtrigger,omitempty"`
	CanFilterBy []*SubscriptionTopicCanFilterBy `json:"canfilterby,omitempty"`
	NotificationShape []*SubscriptionTopicNotificationShape `json:"notificationshape,omitempty"`
}

// NewSubscriptionTopic creates a new SubscriptionTopic instance.
func NewSubscriptionTopic() *SubscriptionTopic {
	return &SubscriptionTopic{}
}

// UnmarshalJSON populates SubscriptionTopic from JSON data.
func (m *SubscriptionTopic) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url *FhirUri `json:"url,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Title *FhirString `json:"title,omitempty"`
		DerivedFrom []interface{} `json:"derivedfrom,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Experimental *FhirBoolean `json:"experimental,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		Publisher *FhirString `json:"publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Purpose *FhirMarkdown `json:"purpose,omitempty"`
		Copyright *FhirMarkdown `json:"copyright,omitempty"`
		ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
		LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
		EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
		ResourceTrigger []*SubscriptionTopicResourceTrigger `json:"resourcetrigger,omitempty"`
		EventTrigger []*SubscriptionTopicEventTrigger `json:"eventtrigger,omitempty"`
		CanFilterBy []*SubscriptionTopicCanFilterBy `json:"canfilterby,omitempty"`
		NotificationShape []*SubscriptionTopicNotificationShape `json:"notificationshape,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Url = temp.Url
	m.Identifier = temp.Identifier
	m.Version = temp.Version
	m.Title = temp.Title
	if len(temp.DerivedFrom) > 0 {
		m.DerivedFrom = make([]*FhirCanonical, len(temp.DerivedFrom))
		for i := range temp.DerivedFrom {
			itemMap, ok := temp.DerivedFrom[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for DerivedFrom[%d]: expected map", i) }
			primitive, err := NewFhirCanonicalFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse DerivedFrom[%d]: %v", i, err) }
			m.DerivedFrom[i] = primitive
		}
	}
	m.Status = temp.Status
	m.Experimental = temp.Experimental
	m.Date = temp.Date
	m.Publisher = temp.Publisher
	m.Contact = temp.Contact
	m.Description = temp.Description
	m.UseContext = temp.UseContext
	m.Jurisdiction = temp.Jurisdiction
	m.Purpose = temp.Purpose
	m.Copyright = temp.Copyright
	m.ApprovalDate = temp.ApprovalDate
	m.LastReviewDate = temp.LastReviewDate
	m.EffectivePeriod = temp.EffectivePeriod
	m.ResourceTrigger = temp.ResourceTrigger
	m.EventTrigger = temp.EventTrigger
	m.CanFilterBy = temp.CanFilterBy
	m.NotificationShape = temp.NotificationShape
	return nil
}

// MarshalJSON converts SubscriptionTopic to JSON data.
func (m *SubscriptionTopic) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Url interface{} `json:"url,omitempty"`
		UrlElement map[string]interface{} `json:"_url,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Title interface{} `json:"title,omitempty"`
		TitleElement map[string]interface{} `json:"_title,omitempty"`
		DerivedFrom []interface{} `json:"derivedfrom,omitempty"`
		DerivedFromElement []map[string]interface{} `json:"_derivedfrom,omitempty"`
		Status *PublicationStatus `json:"status,omitempty"`
		Experimental interface{} `json:"experimental,omitempty"`
		ExperimentalElement map[string]interface{} `json:"_experimental,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Publisher interface{} `json:"publisher,omitempty"`
		PublisherElement map[string]interface{} `json:"_publisher,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		UseContext []*UsageContext `json:"usecontext,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Purpose interface{} `json:"purpose,omitempty"`
		PurposeElement map[string]interface{} `json:"_purpose,omitempty"`
		Copyright interface{} `json:"copyright,omitempty"`
		CopyrightElement map[string]interface{} `json:"_copyright,omitempty"`
		ApprovalDate interface{} `json:"approvaldate,omitempty"`
		ApprovalDateElement map[string]interface{} `json:"_approvaldate,omitempty"`
		LastReviewDate interface{} `json:"lastreviewdate,omitempty"`
		LastReviewDateElement map[string]interface{} `json:"_lastreviewdate,omitempty"`
		EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
		ResourceTrigger []*SubscriptionTopicResourceTrigger `json:"resourcetrigger,omitempty"`
		EventTrigger []*SubscriptionTopicEventTrigger `json:"eventtrigger,omitempty"`
		CanFilterBy []*SubscriptionTopicCanFilterBy `json:"canfilterby,omitempty"`
		NotificationShape []*SubscriptionTopicNotificationShape `json:"notificationshape,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Url != nil && m.Url.Value != nil {
		output.Url = m.Url.Value
		if m.Url.Element != nil {
			output.UrlElement = toMapOrNil(m.Url.Element.MarshalJSON())
		}
	}
	output.Identifier = m.Identifier
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	if m.Title != nil && m.Title.Value != nil {
		output.Title = m.Title.Value
		if m.Title.Element != nil {
			output.TitleElement = toMapOrNil(m.Title.Element.MarshalJSON())
		}
	}
	if len(m.DerivedFrom) > 0 {
		output.DerivedFrom = make([]interface{}, len(m.DerivedFrom))
		output.DerivedFromElement = make([]map[string]interface{}, len(m.DerivedFrom))
		for i, item := range m.DerivedFrom {
			if item != nil && item.Value != nil {
				output.DerivedFrom[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.DerivedFromElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	output.Status = m.Status
	if m.Experimental != nil && m.Experimental.Value != nil {
		output.Experimental = m.Experimental.Value
		if m.Experimental.Element != nil {
			output.ExperimentalElement = toMapOrNil(m.Experimental.Element.MarshalJSON())
		}
	}
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.MarshalJSON())
		}
	}
	if m.Publisher != nil && m.Publisher.Value != nil {
		output.Publisher = m.Publisher.Value
		if m.Publisher.Element != nil {
			output.PublisherElement = toMapOrNil(m.Publisher.Element.MarshalJSON())
		}
	}
	output.Contact = m.Contact
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.UseContext = m.UseContext
	output.Jurisdiction = m.Jurisdiction
	if m.Purpose != nil && m.Purpose.Value != nil {
		output.Purpose = m.Purpose.Value
		if m.Purpose.Element != nil {
			output.PurposeElement = toMapOrNil(m.Purpose.Element.MarshalJSON())
		}
	}
	if m.Copyright != nil && m.Copyright.Value != nil {
		output.Copyright = m.Copyright.Value
		if m.Copyright.Element != nil {
			output.CopyrightElement = toMapOrNil(m.Copyright.Element.MarshalJSON())
		}
	}
	if m.ApprovalDate != nil && m.ApprovalDate.Value != nil {
		output.ApprovalDate = m.ApprovalDate.Value
		if m.ApprovalDate.Element != nil {
			output.ApprovalDateElement = toMapOrNil(m.ApprovalDate.Element.MarshalJSON())
		}
	}
	if m.LastReviewDate != nil && m.LastReviewDate.Value != nil {
		output.LastReviewDate = m.LastReviewDate.Value
		if m.LastReviewDate.Element != nil {
			output.LastReviewDateElement = toMapOrNil(m.LastReviewDate.Element.MarshalJSON())
		}
	}
	output.EffectivePeriod = m.EffectivePeriod
	output.ResourceTrigger = m.ResourceTrigger
	output.EventTrigger = m.EventTrigger
	output.CanFilterBy = m.CanFilterBy
	output.NotificationShape = m.NotificationShape
	return json.Marshal(output)
}

// Clone creates a deep copy of SubscriptionTopic.
func (m *SubscriptionTopic) Clone() *SubscriptionTopic {
	if m == nil { return nil }
	return &SubscriptionTopic{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Title: m.Title.Clone(),
		DerivedFrom: cloneSlices(m.DerivedFrom),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		ResourceTrigger: cloneSlices(m.ResourceTrigger),
		EventTrigger: cloneSlices(m.EventTrigger),
		CanFilterBy: cloneSlices(m.CanFilterBy),
		NotificationShape: cloneSlices(m.NotificationShape),
	}
}

// Equals checks equality between two SubscriptionTopic instances.
func (m *SubscriptionTopic) Equals(other *SubscriptionTopic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !compareSlices(m.DerivedFrom, other.DerivedFrom) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !compareSlices(m.ResourceTrigger, other.ResourceTrigger) { return false }
	if !compareSlices(m.EventTrigger, other.EventTrigger) { return false }
	if !compareSlices(m.CanFilterBy, other.CanFilterBy) { return false }
	if !compareSlices(m.NotificationShape, other.NotificationShape) { return false }
	return true
}

// SubscriptionTopicResourceTrigger
// A definition of a resource-based event that triggers a notification based on the SubscriptionTopic. The criteria may be just a human readable description and/or a full FHIR search string or FHIRPath expression. Multiple triggers are considered OR joined (e.g., a resource update matching ANY of the definitions will trigger a notification).
type SubscriptionTopicResourceTrigger struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
	SupportedInteraction []*InteractionTrigger `json:"supportedinteraction,omitempty"`
	QueryCriteria *SubscriptionTopicQueryCriteria `json:"querycriteria,omitempty"`
	FhirPathCriteria *FhirString `json:"fhirpathcriteria,omitempty"`
}

// NewSubscriptionTopicResourceTrigger creates a new SubscriptionTopicResourceTrigger instance.
func NewSubscriptionTopicResourceTrigger() *SubscriptionTopicResourceTrigger {
	return &SubscriptionTopicResourceTrigger{}
}

// UnmarshalJSON populates SubscriptionTopicResourceTrigger from JSON data.
func (m *SubscriptionTopicResourceTrigger) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		Resource *FhirUri `json:"resource,omitempty"`
		SupportedInteraction []*InteractionTrigger `json:"supportedinteraction,omitempty"`
		QueryCriteria *SubscriptionTopicQueryCriteria `json:"querycriteria,omitempty"`
		FhirPathCriteria *FhirString `json:"fhirpathcriteria,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Resource = temp.Resource
	m.SupportedInteraction = temp.SupportedInteraction
	m.QueryCriteria = temp.QueryCriteria
	m.FhirPathCriteria = temp.FhirPathCriteria
	return nil
}

// MarshalJSON converts SubscriptionTopicResourceTrigger to JSON data.
func (m *SubscriptionTopicResourceTrigger) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Resource interface{} `json:"resource,omitempty"`
		ResourceElement map[string]interface{} `json:"_resource,omitempty"`
		SupportedInteraction []*InteractionTrigger `json:"supportedinteraction,omitempty"`
		QueryCriteria *SubscriptionTopicQueryCriteria `json:"querycriteria,omitempty"`
		FhirPathCriteria interface{} `json:"fhirpathcriteria,omitempty"`
		FhirPathCriteriaElement map[string]interface{} `json:"_fhirpathcriteria,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	if m.Resource != nil && m.Resource.Value != nil {
		output.Resource = m.Resource.Value
		if m.Resource.Element != nil {
			output.ResourceElement = toMapOrNil(m.Resource.Element.MarshalJSON())
		}
	}
	output.SupportedInteraction = m.SupportedInteraction
	output.QueryCriteria = m.QueryCriteria
	if m.FhirPathCriteria != nil && m.FhirPathCriteria.Value != nil {
		output.FhirPathCriteria = m.FhirPathCriteria.Value
		if m.FhirPathCriteria.Element != nil {
			output.FhirPathCriteriaElement = toMapOrNil(m.FhirPathCriteria.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of SubscriptionTopicResourceTrigger.
func (m *SubscriptionTopicResourceTrigger) Clone() *SubscriptionTopicResourceTrigger {
	if m == nil { return nil }
	return &SubscriptionTopicResourceTrigger{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Resource: m.Resource.Clone(),
		SupportedInteraction: cloneSlices(m.SupportedInteraction),
		QueryCriteria: m.QueryCriteria.Clone(),
		FhirPathCriteria: m.FhirPathCriteria.Clone(),
	}
}

// Equals checks equality between two SubscriptionTopicResourceTrigger instances.
func (m *SubscriptionTopicResourceTrigger) Equals(other *SubscriptionTopicResourceTrigger) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !compareSlices(m.SupportedInteraction, other.SupportedInteraction) { return false }
	if !m.QueryCriteria.Equals(other.QueryCriteria) { return false }
	if !m.FhirPathCriteria.Equals(other.FhirPathCriteria) { return false }
	return true
}

// SubscriptionTopicQueryCriteria
// The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic.
type SubscriptionTopicQueryCriteria struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Previous *FhirString `json:"previous,omitempty"`
	ResultForCreate *CriteriaNotExistsBehavior `json:"resultforcreate,omitempty"`
	Current *FhirString `json:"current,omitempty"`
	ResultForDelete *CriteriaNotExistsBehavior `json:"resultfordelete,omitempty"`
	RequireBoth *FhirBoolean `json:"requireboth,omitempty"`
}

// NewSubscriptionTopicQueryCriteria creates a new SubscriptionTopicQueryCriteria instance.
func NewSubscriptionTopicQueryCriteria() *SubscriptionTopicQueryCriteria {
	return &SubscriptionTopicQueryCriteria{}
}

// UnmarshalJSON populates SubscriptionTopicQueryCriteria from JSON data.
func (m *SubscriptionTopicQueryCriteria) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Previous *FhirString `json:"previous,omitempty"`
		ResultForCreate *CriteriaNotExistsBehavior `json:"resultforcreate,omitempty"`
		Current *FhirString `json:"current,omitempty"`
		ResultForDelete *CriteriaNotExistsBehavior `json:"resultfordelete,omitempty"`
		RequireBoth *FhirBoolean `json:"requireboth,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Previous = temp.Previous
	m.ResultForCreate = temp.ResultForCreate
	m.Current = temp.Current
	m.ResultForDelete = temp.ResultForDelete
	m.RequireBoth = temp.RequireBoth
	return nil
}

// MarshalJSON converts SubscriptionTopicQueryCriteria to JSON data.
func (m *SubscriptionTopicQueryCriteria) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Previous interface{} `json:"previous,omitempty"`
		PreviousElement map[string]interface{} `json:"_previous,omitempty"`
		ResultForCreate *CriteriaNotExistsBehavior `json:"resultforcreate,omitempty"`
		Current interface{} `json:"current,omitempty"`
		CurrentElement map[string]interface{} `json:"_current,omitempty"`
		ResultForDelete *CriteriaNotExistsBehavior `json:"resultfordelete,omitempty"`
		RequireBoth interface{} `json:"requireboth,omitempty"`
		RequireBothElement map[string]interface{} `json:"_requireboth,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Previous != nil && m.Previous.Value != nil {
		output.Previous = m.Previous.Value
		if m.Previous.Element != nil {
			output.PreviousElement = toMapOrNil(m.Previous.Element.MarshalJSON())
		}
	}
	output.ResultForCreate = m.ResultForCreate
	if m.Current != nil && m.Current.Value != nil {
		output.Current = m.Current.Value
		if m.Current.Element != nil {
			output.CurrentElement = toMapOrNil(m.Current.Element.MarshalJSON())
		}
	}
	output.ResultForDelete = m.ResultForDelete
	if m.RequireBoth != nil && m.RequireBoth.Value != nil {
		output.RequireBoth = m.RequireBoth.Value
		if m.RequireBoth.Element != nil {
			output.RequireBothElement = toMapOrNil(m.RequireBoth.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of SubscriptionTopicQueryCriteria.
func (m *SubscriptionTopicQueryCriteria) Clone() *SubscriptionTopicQueryCriteria {
	if m == nil { return nil }
	return &SubscriptionTopicQueryCriteria{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Previous: m.Previous.Clone(),
		ResultForCreate: m.ResultForCreate.Clone(),
		Current: m.Current.Clone(),
		ResultForDelete: m.ResultForDelete.Clone(),
		RequireBoth: m.RequireBoth.Clone(),
	}
}

// Equals checks equality between two SubscriptionTopicQueryCriteria instances.
func (m *SubscriptionTopicQueryCriteria) Equals(other *SubscriptionTopicQueryCriteria) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Previous.Equals(other.Previous) { return false }
	if !m.ResultForCreate.Equals(other.ResultForCreate) { return false }
	if !m.Current.Equals(other.Current) { return false }
	if !m.ResultForDelete.Equals(other.ResultForDelete) { return false }
	if !m.RequireBoth.Equals(other.RequireBoth) { return false }
	return true
}

// SubscriptionTopicEventTrigger
// Event definition which can be used to trigger the SubscriptionTopic.
type SubscriptionTopicEventTrigger struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Event *CodeableConcept `json:"event,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
}

// NewSubscriptionTopicEventTrigger creates a new SubscriptionTopicEventTrigger instance.
func NewSubscriptionTopicEventTrigger() *SubscriptionTopicEventTrigger {
	return &SubscriptionTopicEventTrigger{}
}

// UnmarshalJSON populates SubscriptionTopicEventTrigger from JSON data.
func (m *SubscriptionTopicEventTrigger) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		Event *CodeableConcept `json:"event,omitempty"`
		Resource *FhirUri `json:"resource,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Event = temp.Event
	m.Resource = temp.Resource
	return nil
}

// MarshalJSON converts SubscriptionTopicEventTrigger to JSON data.
func (m *SubscriptionTopicEventTrigger) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Event *CodeableConcept `json:"event,omitempty"`
		Resource interface{} `json:"resource,omitempty"`
		ResourceElement map[string]interface{} `json:"_resource,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Event = m.Event
	if m.Resource != nil && m.Resource.Value != nil {
		output.Resource = m.Resource.Value
		if m.Resource.Element != nil {
			output.ResourceElement = toMapOrNil(m.Resource.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of SubscriptionTopicEventTrigger.
func (m *SubscriptionTopicEventTrigger) Clone() *SubscriptionTopicEventTrigger {
	if m == nil { return nil }
	return &SubscriptionTopicEventTrigger{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Event: m.Event.Clone(),
		Resource: m.Resource.Clone(),
	}
}

// Equals checks equality between two SubscriptionTopicEventTrigger instances.
func (m *SubscriptionTopicEventTrigger) Equals(other *SubscriptionTopicEventTrigger) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Event.Equals(other.Event) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	return true
}

// SubscriptionTopicCanFilterBy
// List of properties by which Subscriptions on the SubscriptionTopic can be filtered. May be defined Search Parameters (e.g., Encounter.patient) or parameters defined within this SubscriptionTopic context (e.g., hub.event).
type SubscriptionTopicCanFilterBy struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
	FilterParameter *FhirString `json:"filterparameter,omitempty"`
	FilterDefinition *FhirUri `json:"filterdefinition,omitempty"`
	Modifier []*SubscriptionSearchModifier `json:"modifier,omitempty"`
}

// NewSubscriptionTopicCanFilterBy creates a new SubscriptionTopicCanFilterBy instance.
func NewSubscriptionTopicCanFilterBy() *SubscriptionTopicCanFilterBy {
	return &SubscriptionTopicCanFilterBy{}
}

// UnmarshalJSON populates SubscriptionTopicCanFilterBy from JSON data.
func (m *SubscriptionTopicCanFilterBy) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		Resource *FhirUri `json:"resource,omitempty"`
		FilterParameter *FhirString `json:"filterparameter,omitempty"`
		FilterDefinition *FhirUri `json:"filterdefinition,omitempty"`
		Modifier []*SubscriptionSearchModifier `json:"modifier,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Description = temp.Description
	m.Resource = temp.Resource
	m.FilterParameter = temp.FilterParameter
	m.FilterDefinition = temp.FilterDefinition
	m.Modifier = temp.Modifier
	return nil
}

// MarshalJSON converts SubscriptionTopicCanFilterBy to JSON data.
func (m *SubscriptionTopicCanFilterBy) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Resource interface{} `json:"resource,omitempty"`
		ResourceElement map[string]interface{} `json:"_resource,omitempty"`
		FilterParameter interface{} `json:"filterparameter,omitempty"`
		FilterParameterElement map[string]interface{} `json:"_filterparameter,omitempty"`
		FilterDefinition interface{} `json:"filterdefinition,omitempty"`
		FilterDefinitionElement map[string]interface{} `json:"_filterdefinition,omitempty"`
		Modifier []*SubscriptionSearchModifier `json:"modifier,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	if m.Resource != nil && m.Resource.Value != nil {
		output.Resource = m.Resource.Value
		if m.Resource.Element != nil {
			output.ResourceElement = toMapOrNil(m.Resource.Element.MarshalJSON())
		}
	}
	if m.FilterParameter != nil && m.FilterParameter.Value != nil {
		output.FilterParameter = m.FilterParameter.Value
		if m.FilterParameter.Element != nil {
			output.FilterParameterElement = toMapOrNil(m.FilterParameter.Element.MarshalJSON())
		}
	}
	if m.FilterDefinition != nil && m.FilterDefinition.Value != nil {
		output.FilterDefinition = m.FilterDefinition.Value
		if m.FilterDefinition.Element != nil {
			output.FilterDefinitionElement = toMapOrNil(m.FilterDefinition.Element.MarshalJSON())
		}
	}
	output.Modifier = m.Modifier
	return json.Marshal(output)
}

// Clone creates a deep copy of SubscriptionTopicCanFilterBy.
func (m *SubscriptionTopicCanFilterBy) Clone() *SubscriptionTopicCanFilterBy {
	if m == nil { return nil }
	return &SubscriptionTopicCanFilterBy{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Resource: m.Resource.Clone(),
		FilterParameter: m.FilterParameter.Clone(),
		FilterDefinition: m.FilterDefinition.Clone(),
		Modifier: cloneSlices(m.Modifier),
	}
}

// Equals checks equality between two SubscriptionTopicCanFilterBy instances.
func (m *SubscriptionTopicCanFilterBy) Equals(other *SubscriptionTopicCanFilterBy) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !m.FilterParameter.Equals(other.FilterParameter) { return false }
	if !m.FilterDefinition.Equals(other.FilterDefinition) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	return true
}

// SubscriptionTopicNotificationShape
// List of properties to describe the shape (e.g., resources) included in notifications from this Subscription Topic.
type SubscriptionTopicNotificationShape struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Resource *FhirUri `json:"resource,omitempty"`
	Include []*FhirString `json:"include,omitempty"`
	RevInclude []*FhirString `json:"revinclude,omitempty"`
}

// NewSubscriptionTopicNotificationShape creates a new SubscriptionTopicNotificationShape instance.
func NewSubscriptionTopicNotificationShape() *SubscriptionTopicNotificationShape {
	return &SubscriptionTopicNotificationShape{}
}

// UnmarshalJSON populates SubscriptionTopicNotificationShape from JSON data.
func (m *SubscriptionTopicNotificationShape) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Resource *FhirUri `json:"resource,omitempty"`
		Include []interface{} `json:"include,omitempty"`
		RevInclude []interface{} `json:"revinclude,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Resource = temp.Resource
	if len(temp.Include) > 0 {
		m.Include = make([]*FhirString, len(temp.Include))
		for i := range temp.Include {
			itemMap, ok := temp.Include[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for Include[%d]: expected map", i) }
			primitive, err := NewFhirStringFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse Include[%d]: %v", i, err) }
			m.Include[i] = primitive
		}
	}
	if len(temp.RevInclude) > 0 {
		m.RevInclude = make([]*FhirString, len(temp.RevInclude))
		for i := range temp.RevInclude {
			itemMap, ok := temp.RevInclude[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for RevInclude[%d]: expected map", i) }
			primitive, err := NewFhirStringFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse RevInclude[%d]: %v", i, err) }
			m.RevInclude[i] = primitive
		}
	}
	return nil
}

// MarshalJSON converts SubscriptionTopicNotificationShape to JSON data.
func (m *SubscriptionTopicNotificationShape) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Resource interface{} `json:"resource,omitempty"`
		ResourceElement map[string]interface{} `json:"_resource,omitempty"`
		Include []interface{} `json:"include,omitempty"`
		IncludeElement []map[string]interface{} `json:"_include,omitempty"`
		RevInclude []interface{} `json:"revinclude,omitempty"`
		RevIncludeElement []map[string]interface{} `json:"_revinclude,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Resource != nil && m.Resource.Value != nil {
		output.Resource = m.Resource.Value
		if m.Resource.Element != nil {
			output.ResourceElement = toMapOrNil(m.Resource.Element.MarshalJSON())
		}
	}
	if len(m.Include) > 0 {
		output.Include = make([]interface{}, len(m.Include))
		output.IncludeElement = make([]map[string]interface{}, len(m.Include))
		for i, item := range m.Include {
			if item != nil && item.Value != nil {
				output.Include[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.IncludeElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	if len(m.RevInclude) > 0 {
		output.RevInclude = make([]interface{}, len(m.RevInclude))
		output.RevIncludeElement = make([]map[string]interface{}, len(m.RevInclude))
		for i, item := range m.RevInclude {
			if item != nil && item.Value != nil {
				output.RevInclude[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.RevIncludeElement[i] = toMapOrNil(item.Element.MarshalJSON())
			}
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of SubscriptionTopicNotificationShape.
func (m *SubscriptionTopicNotificationShape) Clone() *SubscriptionTopicNotificationShape {
	if m == nil { return nil }
	return &SubscriptionTopicNotificationShape{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Resource: m.Resource.Clone(),
		Include: cloneSlices(m.Include),
		RevInclude: cloneSlices(m.RevInclude),
	}
}

// Equals checks equality between two SubscriptionTopicNotificationShape instances.
func (m *SubscriptionTopicNotificationShape) Equals(other *SubscriptionTopicNotificationShape) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !compareSlices(m.Include, other.Include) { return false }
	if !compareSlices(m.RevInclude, other.RevInclude) { return false }
	return true
}

