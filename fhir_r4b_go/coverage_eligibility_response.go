// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// CoverageEligibilityResponse
// This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource.
type CoverageEligibilityResponse struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *FinancialResourceStatusCodes `json:"status,omitempty"`
	Purpose []*EligibilityResponsePurpose `json:"purpose,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	ServicedDate *FhirDate `json:"serviceddate,omitempty"`
	ServicedPeriod *Period `json:"servicedperiod,omitempty"`
	Created *FhirDateTime `json:"created,omitempty"`
	Requestor *Reference `json:"requestor,omitempty"`
	Request *Reference `json:"request,omitempty"`
	Outcome *RemittanceOutcome `json:"outcome,omitempty"`
	Disposition *FhirString `json:"disposition,omitempty"`
	Insurer *Reference `json:"insurer,omitempty"`
	Insurance []*CoverageEligibilityResponseInsurance `json:"insurance,omitempty"`
	PreAuthRef *FhirString `json:"preauthref,omitempty"`
	Form *CodeableConcept `json:"form,omitempty"`
	Error []*CoverageEligibilityResponseError `json:"error,omitempty"`
}

// NewCoverageEligibilityResponse creates a new CoverageEligibilityResponse instance
func NewCoverageEligibilityResponse() *CoverageEligibilityResponse {
	return &CoverageEligibilityResponse{}
}

// FromJSON populates CoverageEligibilityResponse from JSON data
func (m *CoverageEligibilityResponse) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageEligibilityResponse to JSON data
func (m *CoverageEligibilityResponse) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageEligibilityResponse
func (m *CoverageEligibilityResponse) Clone() *CoverageEligibilityResponse {
	if m == nil { return nil }
	return &CoverageEligibilityResponse{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Purpose: cloneSlices(m.Purpose),
		Patient: m.Patient.Clone(),
		ServicedDate: m.ServicedDate.Clone(),
		ServicedPeriod: m.ServicedPeriod.Clone(),
		Created: m.Created.Clone(),
		Requestor: m.Requestor.Clone(),
		Request: m.Request.Clone(),
		Outcome: m.Outcome.Clone(),
		Disposition: m.Disposition.Clone(),
		Insurer: m.Insurer.Clone(),
		Insurance: cloneSlices(m.Insurance),
		PreAuthRef: m.PreAuthRef.Clone(),
		Form: m.Form.Clone(),
		Error: cloneSlices(m.Error),
	}
}

// Equals checks for equality with another CoverageEligibilityResponse instance
func (m *CoverageEligibilityResponse) Equals(other *CoverageEligibilityResponse) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Purpose, other.Purpose) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.ServicedDate.Equals(other.ServicedDate) { return false }
	if !m.ServicedPeriod.Equals(other.ServicedPeriod) { return false }
	if !m.Created.Equals(other.Created) { return false }
	if !m.Requestor.Equals(other.Requestor) { return false }
	if !m.Request.Equals(other.Request) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	if !m.Disposition.Equals(other.Disposition) { return false }
	if !m.Insurer.Equals(other.Insurer) { return false }
	if !compareSlices(m.Insurance, other.Insurance) { return false }
	if !m.PreAuthRef.Equals(other.PreAuthRef) { return false }
	if !m.Form.Equals(other.Form) { return false }
	if !compareSlices(m.Error, other.Error) { return false }
	return true
}

// CoverageEligibilityResponseInsurance
// Financial instruments for reimbursement for the health care products and services.
type CoverageEligibilityResponseInsurance struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Coverage *Reference `json:"coverage,omitempty"`
	Inforce *FhirBoolean `json:"inforce,omitempty"`
	BenefitPeriod *Period `json:"benefitperiod,omitempty"`
	Item []*CoverageEligibilityResponseItem `json:"item,omitempty"`
}

// NewCoverageEligibilityResponseInsurance creates a new CoverageEligibilityResponseInsurance instance
func NewCoverageEligibilityResponseInsurance() *CoverageEligibilityResponseInsurance {
	return &CoverageEligibilityResponseInsurance{}
}

// FromJSON populates CoverageEligibilityResponseInsurance from JSON data
func (m *CoverageEligibilityResponseInsurance) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageEligibilityResponseInsurance to JSON data
func (m *CoverageEligibilityResponseInsurance) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageEligibilityResponseInsurance
func (m *CoverageEligibilityResponseInsurance) Clone() *CoverageEligibilityResponseInsurance {
	if m == nil { return nil }
	return &CoverageEligibilityResponseInsurance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Coverage: m.Coverage.Clone(),
		Inforce: m.Inforce.Clone(),
		BenefitPeriod: m.BenefitPeriod.Clone(),
		Item: cloneSlices(m.Item),
	}
}

// Equals checks for equality with another CoverageEligibilityResponseInsurance instance
func (m *CoverageEligibilityResponseInsurance) Equals(other *CoverageEligibilityResponseInsurance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Coverage.Equals(other.Coverage) { return false }
	if !m.Inforce.Equals(other.Inforce) { return false }
	if !m.BenefitPeriod.Equals(other.BenefitPeriod) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	return true
}

// CoverageEligibilityResponseItem
// Benefits and optionally current balances, and authorization details by category or service.
type CoverageEligibilityResponseItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	Provider *Reference `json:"provider,omitempty"`
	Excluded *FhirBoolean `json:"excluded,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Network *CodeableConcept `json:"network,omitempty"`
	Unit *CodeableConcept `json:"unit,omitempty"`
	Term *CodeableConcept `json:"term,omitempty"`
	Benefit []*CoverageEligibilityResponseBenefit `json:"benefit,omitempty"`
	AuthorizationRequired *FhirBoolean `json:"authorizationrequired,omitempty"`
	AuthorizationSupporting []*CodeableConcept `json:"authorizationsupporting,omitempty"`
	AuthorizationUrl *FhirUri `json:"authorizationurl,omitempty"`
}

// NewCoverageEligibilityResponseItem creates a new CoverageEligibilityResponseItem instance
func NewCoverageEligibilityResponseItem() *CoverageEligibilityResponseItem {
	return &CoverageEligibilityResponseItem{}
}

// FromJSON populates CoverageEligibilityResponseItem from JSON data
func (m *CoverageEligibilityResponseItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageEligibilityResponseItem to JSON data
func (m *CoverageEligibilityResponseItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageEligibilityResponseItem
func (m *CoverageEligibilityResponseItem) Clone() *CoverageEligibilityResponseItem {
	if m == nil { return nil }
	return &CoverageEligibilityResponseItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		Provider: m.Provider.Clone(),
		Excluded: m.Excluded.Clone(),
		Name: m.Name.Clone(),
		Description: m.Description.Clone(),
		Network: m.Network.Clone(),
		Unit: m.Unit.Clone(),
		Term: m.Term.Clone(),
		Benefit: cloneSlices(m.Benefit),
		AuthorizationRequired: m.AuthorizationRequired.Clone(),
		AuthorizationSupporting: cloneSlices(m.AuthorizationSupporting),
		AuthorizationUrl: m.AuthorizationUrl.Clone(),
	}
}

// Equals checks for equality with another CoverageEligibilityResponseItem instance
func (m *CoverageEligibilityResponseItem) Equals(other *CoverageEligibilityResponseItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !m.Provider.Equals(other.Provider) { return false }
	if !m.Excluded.Equals(other.Excluded) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Network.Equals(other.Network) { return false }
	if !m.Unit.Equals(other.Unit) { return false }
	if !m.Term.Equals(other.Term) { return false }
	if !compareSlices(m.Benefit, other.Benefit) { return false }
	if !m.AuthorizationRequired.Equals(other.AuthorizationRequired) { return false }
	if !compareSlices(m.AuthorizationSupporting, other.AuthorizationSupporting) { return false }
	if !m.AuthorizationUrl.Equals(other.AuthorizationUrl) { return false }
	return true
}

// CoverageEligibilityResponseBenefit
// Benefits used to date.
type CoverageEligibilityResponseBenefit struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	AllowedUnsignedInt *FhirUnsignedInt `json:"allowedunsignedint,omitempty"`
	AllowedString *FhirString `json:"allowedstring,omitempty"`
	AllowedMoney *Money `json:"allowedmoney,omitempty"`
	UsedUnsignedInt *FhirUnsignedInt `json:"usedunsignedint,omitempty"`
	UsedString *FhirString `json:"usedstring,omitempty"`
	UsedMoney *Money `json:"usedmoney,omitempty"`
}

// NewCoverageEligibilityResponseBenefit creates a new CoverageEligibilityResponseBenefit instance
func NewCoverageEligibilityResponseBenefit() *CoverageEligibilityResponseBenefit {
	return &CoverageEligibilityResponseBenefit{}
}

// FromJSON populates CoverageEligibilityResponseBenefit from JSON data
func (m *CoverageEligibilityResponseBenefit) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageEligibilityResponseBenefit to JSON data
func (m *CoverageEligibilityResponseBenefit) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageEligibilityResponseBenefit
func (m *CoverageEligibilityResponseBenefit) Clone() *CoverageEligibilityResponseBenefit {
	if m == nil { return nil }
	return &CoverageEligibilityResponseBenefit{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		AllowedUnsignedInt: m.AllowedUnsignedInt.Clone(),
		AllowedString: m.AllowedString.Clone(),
		AllowedMoney: m.AllowedMoney.Clone(),
		UsedUnsignedInt: m.UsedUnsignedInt.Clone(),
		UsedString: m.UsedString.Clone(),
		UsedMoney: m.UsedMoney.Clone(),
	}
}

// Equals checks for equality with another CoverageEligibilityResponseBenefit instance
func (m *CoverageEligibilityResponseBenefit) Equals(other *CoverageEligibilityResponseBenefit) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.AllowedUnsignedInt.Equals(other.AllowedUnsignedInt) { return false }
	if !m.AllowedString.Equals(other.AllowedString) { return false }
	if !m.AllowedMoney.Equals(other.AllowedMoney) { return false }
	if !m.UsedUnsignedInt.Equals(other.UsedUnsignedInt) { return false }
	if !m.UsedString.Equals(other.UsedString) { return false }
	if !m.UsedMoney.Equals(other.UsedMoney) { return false }
	return true
}

// CoverageEligibilityResponseError
// Errors encountered during the processing of the request.
type CoverageEligibilityResponseError struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
}

// NewCoverageEligibilityResponseError creates a new CoverageEligibilityResponseError instance
func NewCoverageEligibilityResponseError() *CoverageEligibilityResponseError {
	return &CoverageEligibilityResponseError{}
}

// FromJSON populates CoverageEligibilityResponseError from JSON data
func (m *CoverageEligibilityResponseError) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CoverageEligibilityResponseError to JSON data
func (m *CoverageEligibilityResponseError) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CoverageEligibilityResponseError
func (m *CoverageEligibilityResponseError) Clone() *CoverageEligibilityResponseError {
	if m == nil { return nil }
	return &CoverageEligibilityResponseError{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
	}
}

// Equals checks for equality with another CoverageEligibilityResponseError instance
func (m *CoverageEligibilityResponseError) Equals(other *CoverageEligibilityResponseError) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	return true
}

