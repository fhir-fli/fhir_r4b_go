// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// Goal
// Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
type Goal struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	LifecycleStatus *GoalLifecycleStatus `json:"lifecyclestatus,omitempty"`
	AchievementStatus *CodeableConcept `json:"achievementstatus,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Priority *CodeableConcept `json:"priority,omitempty"`
	Description *CodeableConcept `json:"description,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	StartDate *GoalStartEvent `json:"startdate,omitempty"`
	StartCodeableConcept *CodeableConcept `json:"startcodeableconcept,omitempty"`
	Target []*GoalTarget `json:"target,omitempty"`
	StatusDate *FhirDate `json:"statusdate,omitempty"`
	StatusReason *FhirString `json:"statusreason,omitempty"`
	ExpressedBy *Reference `json:"expressedby,omitempty"`
	Addresses []*Reference `json:"addresses,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	OutcomeCode []*CodeableConcept `json:"outcomecode,omitempty"`
	OutcomeReference []*Reference `json:"outcomereference,omitempty"`
}

// NewGoal creates a new Goal instance.
func NewGoal() *Goal {
	return &Goal{}
}

// UnmarshalJSON populates Goal from JSON data.
func (m *Goal) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		LifecycleStatus *GoalLifecycleStatus `json:"lifecyclestatus,omitempty"`
		AchievementStatus *CodeableConcept `json:"achievementstatus,omitempty"`
		Category []*CodeableConcept `json:"category,omitempty"`
		Priority *CodeableConcept `json:"priority,omitempty"`
		Description *CodeableConcept `json:"description,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		StartDate *GoalStartEvent `json:"startdate,omitempty"`
		StartCodeableConcept *CodeableConcept `json:"startcodeableconcept,omitempty"`
		Target []*GoalTarget `json:"target,omitempty"`
		StatusDate *FhirDate `json:"statusdate,omitempty"`
		StatusReason *FhirString `json:"statusreason,omitempty"`
		ExpressedBy *Reference `json:"expressedby,omitempty"`
		Addresses []*Reference `json:"addresses,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		OutcomeCode []*CodeableConcept `json:"outcomecode,omitempty"`
		OutcomeReference []*Reference `json:"outcomereference,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.LifecycleStatus = temp.LifecycleStatus
	m.AchievementStatus = temp.AchievementStatus
	m.Category = temp.Category
	m.Priority = temp.Priority
	m.Description = temp.Description
	m.Subject = temp.Subject
	m.StartDate = temp.StartDate
	m.StartCodeableConcept = temp.StartCodeableConcept
	m.Target = temp.Target
	m.StatusDate = temp.StatusDate
	m.StatusReason = temp.StatusReason
	m.ExpressedBy = temp.ExpressedBy
	m.Addresses = temp.Addresses
	m.Note = temp.Note
	m.OutcomeCode = temp.OutcomeCode
	m.OutcomeReference = temp.OutcomeReference
	return nil
}

// MarshalJSON converts Goal to JSON data.
func (m *Goal) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		LifecycleStatus *GoalLifecycleStatus `json:"lifecyclestatus,omitempty"`
		AchievementStatus *CodeableConcept `json:"achievementstatus,omitempty"`
		Category []*CodeableConcept `json:"category,omitempty"`
		Priority *CodeableConcept `json:"priority,omitempty"`
		Description *CodeableConcept `json:"description,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		StartDate *GoalStartEvent `json:"startdate,omitempty"`
		StartCodeableConcept *CodeableConcept `json:"startcodeableconcept,omitempty"`
		Target []*GoalTarget `json:"target,omitempty"`
		StatusDate interface{} `json:"statusdate,omitempty"`
		StatusDateElement map[string]interface{} `json:"_statusdate,omitempty"`
		StatusReason interface{} `json:"statusreason,omitempty"`
		StatusReasonElement map[string]interface{} `json:"_statusreason,omitempty"`
		ExpressedBy *Reference `json:"expressedby,omitempty"`
		Addresses []*Reference `json:"addresses,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		OutcomeCode []*CodeableConcept `json:"outcomecode,omitempty"`
		OutcomeReference []*Reference `json:"outcomereference,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.LifecycleStatus = m.LifecycleStatus
	output.AchievementStatus = m.AchievementStatus
	output.Category = m.Category
	output.Priority = m.Priority
	output.Description = m.Description
	output.Subject = m.Subject
	output.StartDate = m.StartDate
	output.StartCodeableConcept = m.StartCodeableConcept
	output.Target = m.Target
	if m.StatusDate != nil && m.StatusDate.Value != nil {
		output.StatusDate = m.StatusDate.Value
		if m.StatusDate.Element != nil {
			output.StatusDateElement = toMapOrNil(m.StatusDate.Element.MarshalJSON())
		}
	}
	if m.StatusReason != nil && m.StatusReason.Value != nil {
		output.StatusReason = m.StatusReason.Value
		if m.StatusReason.Element != nil {
			output.StatusReasonElement = toMapOrNil(m.StatusReason.Element.MarshalJSON())
		}
	}
	output.ExpressedBy = m.ExpressedBy
	output.Addresses = m.Addresses
	output.Note = m.Note
	output.OutcomeCode = m.OutcomeCode
	output.OutcomeReference = m.OutcomeReference
	return json.Marshal(output)
}

// Clone creates a deep copy of Goal.
func (m *Goal) Clone() *Goal {
	if m == nil { return nil }
	return &Goal{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		LifecycleStatus: m.LifecycleStatus.Clone(),
		AchievementStatus: m.AchievementStatus.Clone(),
		Category: cloneSlices(m.Category),
		Priority: m.Priority.Clone(),
		Description: m.Description.Clone(),
		Subject: m.Subject.Clone(),
		StartDate: m.StartDate.Clone(),
		StartCodeableConcept: m.StartCodeableConcept.Clone(),
		Target: cloneSlices(m.Target),
		StatusDate: m.StatusDate.Clone(),
		StatusReason: m.StatusReason.Clone(),
		ExpressedBy: m.ExpressedBy.Clone(),
		Addresses: cloneSlices(m.Addresses),
		Note: cloneSlices(m.Note),
		OutcomeCode: cloneSlices(m.OutcomeCode),
		OutcomeReference: cloneSlices(m.OutcomeReference),
	}
}

// Equals checks equality between two Goal instances.
func (m *Goal) Equals(other *Goal) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.LifecycleStatus.Equals(other.LifecycleStatus) { return false }
	if !m.AchievementStatus.Equals(other.AchievementStatus) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.StartDate.Equals(other.StartDate) { return false }
	if !m.StartCodeableConcept.Equals(other.StartCodeableConcept) { return false }
	if !compareSlices(m.Target, other.Target) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !m.StatusReason.Equals(other.StatusReason) { return false }
	if !m.ExpressedBy.Equals(other.ExpressedBy) { return false }
	if !compareSlices(m.Addresses, other.Addresses) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.OutcomeCode, other.OutcomeCode) { return false }
	if !compareSlices(m.OutcomeReference, other.OutcomeReference) { return false }
	return true
}

// GoalTarget
// Indicates what should be done by when.
type GoalTarget struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Measure *CodeableConcept `json:"measure,omitempty"`
	DetailQuantity *Quantity `json:"detailquantity,omitempty"`
	DetailRange *Range `json:"detailrange,omitempty"`
	DetailCodeableConcept *CodeableConcept `json:"detailcodeableconcept,omitempty"`
	DetailString *FhirString `json:"detailstring,omitempty"`
	DetailBoolean *FhirBoolean `json:"detailboolean,omitempty"`
	DetailInteger *FhirInteger `json:"detailinteger,omitempty"`
	DetailRatio *Ratio `json:"detailratio,omitempty"`
	DueDate *FhirDate `json:"duedate,omitempty"`
	DueDuration *FhirDuration `json:"dueduration,omitempty"`
}

// NewGoalTarget creates a new GoalTarget instance.
func NewGoalTarget() *GoalTarget {
	return &GoalTarget{}
}

// UnmarshalJSON populates GoalTarget from JSON data.
func (m *GoalTarget) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Measure *CodeableConcept `json:"measure,omitempty"`
		DetailQuantity *Quantity `json:"detailquantity,omitempty"`
		DetailRange *Range `json:"detailrange,omitempty"`
		DetailCodeableConcept *CodeableConcept `json:"detailcodeableconcept,omitempty"`
		DetailString *FhirString `json:"detailstring,omitempty"`
		DetailBoolean *FhirBoolean `json:"detailboolean,omitempty"`
		DetailInteger *FhirInteger `json:"detailinteger,omitempty"`
		DetailRatio *Ratio `json:"detailratio,omitempty"`
		DueDate *FhirDate `json:"duedate,omitempty"`
		DueDuration *FhirDuration `json:"dueduration,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Measure = temp.Measure
	m.DetailQuantity = temp.DetailQuantity
	m.DetailRange = temp.DetailRange
	m.DetailCodeableConcept = temp.DetailCodeableConcept
	m.DetailString = temp.DetailString
	m.DetailBoolean = temp.DetailBoolean
	m.DetailInteger = temp.DetailInteger
	m.DetailRatio = temp.DetailRatio
	m.DueDate = temp.DueDate
	m.DueDuration = temp.DueDuration
	return nil
}

// MarshalJSON converts GoalTarget to JSON data.
func (m *GoalTarget) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Measure *CodeableConcept `json:"measure,omitempty"`
		DetailQuantity *Quantity `json:"detailquantity,omitempty"`
		DetailRange *Range `json:"detailrange,omitempty"`
		DetailCodeableConcept *CodeableConcept `json:"detailcodeableconcept,omitempty"`
		DetailString interface{} `json:"detailstring,omitempty"`
		DetailStringElement map[string]interface{} `json:"_detailstring,omitempty"`
		DetailBoolean interface{} `json:"detailboolean,omitempty"`
		DetailBooleanElement map[string]interface{} `json:"_detailboolean,omitempty"`
		DetailInteger interface{} `json:"detailinteger,omitempty"`
		DetailIntegerElement map[string]interface{} `json:"_detailinteger,omitempty"`
		DetailRatio *Ratio `json:"detailratio,omitempty"`
		DueDate interface{} `json:"duedate,omitempty"`
		DueDateElement map[string]interface{} `json:"_duedate,omitempty"`
		DueDuration *FhirDuration `json:"dueduration,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Measure = m.Measure
	output.DetailQuantity = m.DetailQuantity
	output.DetailRange = m.DetailRange
	output.DetailCodeableConcept = m.DetailCodeableConcept
	if m.DetailString != nil && m.DetailString.Value != nil {
		output.DetailString = m.DetailString.Value
		if m.DetailString.Element != nil {
			output.DetailStringElement = toMapOrNil(m.DetailString.Element.MarshalJSON())
		}
	}
	if m.DetailBoolean != nil && m.DetailBoolean.Value != nil {
		output.DetailBoolean = m.DetailBoolean.Value
		if m.DetailBoolean.Element != nil {
			output.DetailBooleanElement = toMapOrNil(m.DetailBoolean.Element.MarshalJSON())
		}
	}
	if m.DetailInteger != nil && m.DetailInteger.Value != nil {
		output.DetailInteger = m.DetailInteger.Value
		if m.DetailInteger.Element != nil {
			output.DetailIntegerElement = toMapOrNil(m.DetailInteger.Element.MarshalJSON())
		}
	}
	output.DetailRatio = m.DetailRatio
	if m.DueDate != nil && m.DueDate.Value != nil {
		output.DueDate = m.DueDate.Value
		if m.DueDate.Element != nil {
			output.DueDateElement = toMapOrNil(m.DueDate.Element.MarshalJSON())
		}
	}
	output.DueDuration = m.DueDuration
	return json.Marshal(output)
}

// Clone creates a deep copy of GoalTarget.
func (m *GoalTarget) Clone() *GoalTarget {
	if m == nil { return nil }
	return &GoalTarget{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Measure: m.Measure.Clone(),
		DetailQuantity: m.DetailQuantity.Clone(),
		DetailRange: m.DetailRange.Clone(),
		DetailCodeableConcept: m.DetailCodeableConcept.Clone(),
		DetailString: m.DetailString.Clone(),
		DetailBoolean: m.DetailBoolean.Clone(),
		DetailInteger: m.DetailInteger.Clone(),
		DetailRatio: m.DetailRatio.Clone(),
		DueDate: m.DueDate.Clone(),
		DueDuration: m.DueDuration.Clone(),
	}
}

// Equals checks equality between two GoalTarget instances.
func (m *GoalTarget) Equals(other *GoalTarget) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Measure.Equals(other.Measure) { return false }
	if !m.DetailQuantity.Equals(other.DetailQuantity) { return false }
	if !m.DetailRange.Equals(other.DetailRange) { return false }
	if !m.DetailCodeableConcept.Equals(other.DetailCodeableConcept) { return false }
	if !m.DetailString.Equals(other.DetailString) { return false }
	if !m.DetailBoolean.Equals(other.DetailBoolean) { return false }
	if !m.DetailInteger.Equals(other.DetailInteger) { return false }
	if !m.DetailRatio.Equals(other.DetailRatio) { return false }
	if !m.DueDate.Equals(other.DueDate) { return false }
	if !m.DueDuration.Equals(other.DueDuration) { return false }
	return true
}

