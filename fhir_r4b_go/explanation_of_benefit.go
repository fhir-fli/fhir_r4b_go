// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
	"fmt"
)

// ExplanationOfBenefit
// This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
type ExplanationOfBenefit struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ExplanationOfBenefitStatus `json:"status,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	SubType *CodeableConcept `json:"subtype,omitempty"`
	Use *Use `json:"use,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	BillablePeriod *Period `json:"billableperiod,omitempty"`
	Created *FhirDateTime `json:"created,omitempty"`
	Enterer *Reference `json:"enterer,omitempty"`
	Insurer *Reference `json:"insurer,omitempty"`
	Provider *Reference `json:"provider,omitempty"`
	Priority *CodeableConcept `json:"priority,omitempty"`
	FundsReserveRequested *CodeableConcept `json:"fundsreserverequested,omitempty"`
	FundsReserve *CodeableConcept `json:"fundsreserve,omitempty"`
	Related []*ExplanationOfBenefitRelated `json:"related,omitempty"`
	Prescription *Reference `json:"prescription,omitempty"`
	OriginalPrescription *Reference `json:"originalprescription,omitempty"`
	Payee *ExplanationOfBenefitPayee `json:"payee,omitempty"`
	Referral *Reference `json:"referral,omitempty"`
	Facility *Reference `json:"facility,omitempty"`
	Claim *Reference `json:"claim,omitempty"`
	ClaimResponse *Reference `json:"claimresponse,omitempty"`
	Outcome *RemittanceOutcome `json:"outcome,omitempty"`
	Disposition *FhirString `json:"disposition,omitempty"`
	PreAuthRef []*FhirString `json:"preauthref,omitempty"`
	PreAuthRefPeriod []*Period `json:"preauthrefperiod,omitempty"`
	CareTeam []*ExplanationOfBenefitCareTeam `json:"careteam,omitempty"`
	SupportingInfo []*ExplanationOfBenefitSupportingInfo `json:"supportinginfo,omitempty"`
	Diagnosis []*ExplanationOfBenefitDiagnosis `json:"diagnosis,omitempty"`
	Procedure []*ExplanationOfBenefitProcedure `json:"procedure,omitempty"`
	Precedence *FhirPositiveInt `json:"precedence,omitempty"`
	Insurance []*ExplanationOfBenefitInsurance `json:"insurance,omitempty"`
	Accident *ExplanationOfBenefitAccident `json:"accident,omitempty"`
	Item []*ExplanationOfBenefitItem `json:"item,omitempty"`
	AddItem []*ExplanationOfBenefitAddItem `json:"additem,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	Total []*ExplanationOfBenefitTotal `json:"total,omitempty"`
	Payment *ExplanationOfBenefitPayment `json:"payment,omitempty"`
	FormCode *CodeableConcept `json:"formcode,omitempty"`
	Form *Attachment `json:"form,omitempty"`
	ProcessNote []*ExplanationOfBenefitProcessNote `json:"processnote,omitempty"`
	BenefitPeriod *Period `json:"benefitperiod,omitempty"`
	BenefitBalance []*ExplanationOfBenefitBenefitBalance `json:"benefitbalance,omitempty"`
}

// NewExplanationOfBenefit creates a new ExplanationOfBenefit instance.
func NewExplanationOfBenefit() *ExplanationOfBenefit {
	return &ExplanationOfBenefit{}
}

// FromJSON populates ExplanationOfBenefit from JSON data.
func (m *ExplanationOfBenefit) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *ExplanationOfBenefitStatus `json:"status,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		SubType *CodeableConcept `json:"subtype,omitempty"`
		Use *Use `json:"use,omitempty"`
		Patient *Reference `json:"patient,omitempty"`
		BillablePeriod *Period `json:"billableperiod,omitempty"`
		Created *FhirDateTime `json:"created,omitempty"`
		Enterer *Reference `json:"enterer,omitempty"`
		Insurer *Reference `json:"insurer,omitempty"`
		Provider *Reference `json:"provider,omitempty"`
		Priority *CodeableConcept `json:"priority,omitempty"`
		FundsReserveRequested *CodeableConcept `json:"fundsreserverequested,omitempty"`
		FundsReserve *CodeableConcept `json:"fundsreserve,omitempty"`
		Related []*ExplanationOfBenefitRelated `json:"related,omitempty"`
		Prescription *Reference `json:"prescription,omitempty"`
		OriginalPrescription *Reference `json:"originalprescription,omitempty"`
		Payee *ExplanationOfBenefitPayee `json:"payee,omitempty"`
		Referral *Reference `json:"referral,omitempty"`
		Facility *Reference `json:"facility,omitempty"`
		Claim *Reference `json:"claim,omitempty"`
		ClaimResponse *Reference `json:"claimresponse,omitempty"`
		Outcome *RemittanceOutcome `json:"outcome,omitempty"`
		Disposition *FhirString `json:"disposition,omitempty"`
		PreAuthRef []interface{} `json:"preauthref,omitempty"`
		PreAuthRefPeriod []*Period `json:"preauthrefperiod,omitempty"`
		CareTeam []*ExplanationOfBenefitCareTeam `json:"careteam,omitempty"`
		SupportingInfo []*ExplanationOfBenefitSupportingInfo `json:"supportinginfo,omitempty"`
		Diagnosis []*ExplanationOfBenefitDiagnosis `json:"diagnosis,omitempty"`
		Procedure []*ExplanationOfBenefitProcedure `json:"procedure,omitempty"`
		Precedence *FhirPositiveInt `json:"precedence,omitempty"`
		Insurance []*ExplanationOfBenefitInsurance `json:"insurance,omitempty"`
		Accident *ExplanationOfBenefitAccident `json:"accident,omitempty"`
		Item []*ExplanationOfBenefitItem `json:"item,omitempty"`
		AddItem []*ExplanationOfBenefitAddItem `json:"additem,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		Total []*ExplanationOfBenefitTotal `json:"total,omitempty"`
		Payment *ExplanationOfBenefitPayment `json:"payment,omitempty"`
		FormCode *CodeableConcept `json:"formcode,omitempty"`
		Form *Attachment `json:"form,omitempty"`
		ProcessNote []*ExplanationOfBenefitProcessNote `json:"processnote,omitempty"`
		BenefitPeriod *Period `json:"benefitperiod,omitempty"`
		BenefitBalance []*ExplanationOfBenefitBenefitBalance `json:"benefitbalance,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Status = temp.Status
	m.Type = temp.Type
	m.SubType = temp.SubType
	m.Use = temp.Use
	m.Patient = temp.Patient
	m.BillablePeriod = temp.BillablePeriod
	m.Created = temp.Created
	m.Enterer = temp.Enterer
	m.Insurer = temp.Insurer
	m.Provider = temp.Provider
	m.Priority = temp.Priority
	m.FundsReserveRequested = temp.FundsReserveRequested
	m.FundsReserve = temp.FundsReserve
	m.Related = temp.Related
	m.Prescription = temp.Prescription
	m.OriginalPrescription = temp.OriginalPrescription
	m.Payee = temp.Payee
	m.Referral = temp.Referral
	m.Facility = temp.Facility
	m.Claim = temp.Claim
	m.ClaimResponse = temp.ClaimResponse
	m.Outcome = temp.Outcome
	m.Disposition = temp.Disposition
	if len(temp.PreAuthRef) > 0 {
		m.PreAuthRef = make([]*FhirString, len(temp.PreAuthRef))
		for i := range temp.PreAuthRef {
			itemMap, ok := temp.PreAuthRef[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for PreAuthRef[%d]: expected map", i) }
			primitive, err := NewFhirStringFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse PreAuthRef[%d]: %v", i, err) }
			m.PreAuthRef[i] = primitive
		}
	}
	m.PreAuthRefPeriod = temp.PreAuthRefPeriod
	m.CareTeam = temp.CareTeam
	m.SupportingInfo = temp.SupportingInfo
	m.Diagnosis = temp.Diagnosis
	m.Procedure = temp.Procedure
	m.Precedence = temp.Precedence
	m.Insurance = temp.Insurance
	m.Accident = temp.Accident
	m.Item = temp.Item
	m.AddItem = temp.AddItem
	m.Adjudication = temp.Adjudication
	m.Total = temp.Total
	m.Payment = temp.Payment
	m.FormCode = temp.FormCode
	m.Form = temp.Form
	m.ProcessNote = temp.ProcessNote
	m.BenefitPeriod = temp.BenefitPeriod
	m.BenefitBalance = temp.BenefitBalance
	return nil
}

// ToJSON converts ExplanationOfBenefit to JSON data.
func (m *ExplanationOfBenefit) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *ExplanationOfBenefitStatus `json:"status,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		SubType *CodeableConcept `json:"subtype,omitempty"`
		Use *Use `json:"use,omitempty"`
		Patient *Reference `json:"patient,omitempty"`
		BillablePeriod *Period `json:"billableperiod,omitempty"`
		Created interface{} `json:"created,omitempty"`
		CreatedElement map[string]interface{} `json:"_created,omitempty"`
		Enterer *Reference `json:"enterer,omitempty"`
		Insurer *Reference `json:"insurer,omitempty"`
		Provider *Reference `json:"provider,omitempty"`
		Priority *CodeableConcept `json:"priority,omitempty"`
		FundsReserveRequested *CodeableConcept `json:"fundsreserverequested,omitempty"`
		FundsReserve *CodeableConcept `json:"fundsreserve,omitempty"`
		Related []*ExplanationOfBenefitRelated `json:"related,omitempty"`
		Prescription *Reference `json:"prescription,omitempty"`
		OriginalPrescription *Reference `json:"originalprescription,omitempty"`
		Payee *ExplanationOfBenefitPayee `json:"payee,omitempty"`
		Referral *Reference `json:"referral,omitempty"`
		Facility *Reference `json:"facility,omitempty"`
		Claim *Reference `json:"claim,omitempty"`
		ClaimResponse *Reference `json:"claimresponse,omitempty"`
		Outcome *RemittanceOutcome `json:"outcome,omitempty"`
		Disposition interface{} `json:"disposition,omitempty"`
		DispositionElement map[string]interface{} `json:"_disposition,omitempty"`
		PreAuthRef []interface{} `json:"preauthref,omitempty"`
		PreAuthRefElement []map[string]interface{} `json:"_preauthref,omitempty"`
		PreAuthRefPeriod []*Period `json:"preauthrefperiod,omitempty"`
		CareTeam []*ExplanationOfBenefitCareTeam `json:"careteam,omitempty"`
		SupportingInfo []*ExplanationOfBenefitSupportingInfo `json:"supportinginfo,omitempty"`
		Diagnosis []*ExplanationOfBenefitDiagnosis `json:"diagnosis,omitempty"`
		Procedure []*ExplanationOfBenefitProcedure `json:"procedure,omitempty"`
		Precedence interface{} `json:"precedence,omitempty"`
		PrecedenceElement map[string]interface{} `json:"_precedence,omitempty"`
		Insurance []*ExplanationOfBenefitInsurance `json:"insurance,omitempty"`
		Accident *ExplanationOfBenefitAccident `json:"accident,omitempty"`
		Item []*ExplanationOfBenefitItem `json:"item,omitempty"`
		AddItem []*ExplanationOfBenefitAddItem `json:"additem,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		Total []*ExplanationOfBenefitTotal `json:"total,omitempty"`
		Payment *ExplanationOfBenefitPayment `json:"payment,omitempty"`
		FormCode *CodeableConcept `json:"formcode,omitempty"`
		Form *Attachment `json:"form,omitempty"`
		ProcessNote []*ExplanationOfBenefitProcessNote `json:"processnote,omitempty"`
		BenefitPeriod *Period `json:"benefitperiod,omitempty"`
		BenefitBalance []*ExplanationOfBenefitBenefitBalance `json:"benefitbalance,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.ToJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Status = m.Status
	output.Type = m.Type
	output.SubType = m.SubType
	output.Use = m.Use
	output.Patient = m.Patient
	output.BillablePeriod = m.BillablePeriod
	if m.Created != nil && m.Created.Value != nil {
		output.Created = m.Created.Value
		if m.Created.Element != nil {
			output.CreatedElement = toMapOrNil(m.Created.Element.ToJSON())
		}
	}
	output.Enterer = m.Enterer
	output.Insurer = m.Insurer
	output.Provider = m.Provider
	output.Priority = m.Priority
	output.FundsReserveRequested = m.FundsReserveRequested
	output.FundsReserve = m.FundsReserve
	output.Related = m.Related
	output.Prescription = m.Prescription
	output.OriginalPrescription = m.OriginalPrescription
	output.Payee = m.Payee
	output.Referral = m.Referral
	output.Facility = m.Facility
	output.Claim = m.Claim
	output.ClaimResponse = m.ClaimResponse
	output.Outcome = m.Outcome
	if m.Disposition != nil && m.Disposition.Value != nil {
		output.Disposition = m.Disposition.Value
		if m.Disposition.Element != nil {
			output.DispositionElement = toMapOrNil(m.Disposition.Element.ToJSON())
		}
	}
	if len(m.PreAuthRef) > 0 {
		output.PreAuthRef = make([]interface{}, len(m.PreAuthRef))
		output.PreAuthRefElement = make([]map[string]interface{}, len(m.PreAuthRef))
		for i, item := range m.PreAuthRef {
			if item != nil && item.Value != nil {
				output.PreAuthRef[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.PreAuthRefElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.PreAuthRefPeriod = m.PreAuthRefPeriod
	output.CareTeam = m.CareTeam
	output.SupportingInfo = m.SupportingInfo
	output.Diagnosis = m.Diagnosis
	output.Procedure = m.Procedure
	if m.Precedence != nil && m.Precedence.Value != nil {
		output.Precedence = m.Precedence.Value
		if m.Precedence.Element != nil {
			output.PrecedenceElement = toMapOrNil(m.Precedence.Element.ToJSON())
		}
	}
	output.Insurance = m.Insurance
	output.Accident = m.Accident
	output.Item = m.Item
	output.AddItem = m.AddItem
	output.Adjudication = m.Adjudication
	output.Total = m.Total
	output.Payment = m.Payment
	output.FormCode = m.FormCode
	output.Form = m.Form
	output.ProcessNote = m.ProcessNote
	output.BenefitPeriod = m.BenefitPeriod
	output.BenefitBalance = m.BenefitBalance
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefit.
func (m *ExplanationOfBenefit) Clone() *ExplanationOfBenefit {
	if m == nil { return nil }
	return &ExplanationOfBenefit{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		SubType: m.SubType.Clone(),
		Use: m.Use.Clone(),
		Patient: m.Patient.Clone(),
		BillablePeriod: m.BillablePeriod.Clone(),
		Created: m.Created.Clone(),
		Enterer: m.Enterer.Clone(),
		Insurer: m.Insurer.Clone(),
		Provider: m.Provider.Clone(),
		Priority: m.Priority.Clone(),
		FundsReserveRequested: m.FundsReserveRequested.Clone(),
		FundsReserve: m.FundsReserve.Clone(),
		Related: cloneSlices(m.Related),
		Prescription: m.Prescription.Clone(),
		OriginalPrescription: m.OriginalPrescription.Clone(),
		Payee: m.Payee.Clone(),
		Referral: m.Referral.Clone(),
		Facility: m.Facility.Clone(),
		Claim: m.Claim.Clone(),
		ClaimResponse: m.ClaimResponse.Clone(),
		Outcome: m.Outcome.Clone(),
		Disposition: m.Disposition.Clone(),
		PreAuthRef: cloneSlices(m.PreAuthRef),
		PreAuthRefPeriod: cloneSlices(m.PreAuthRefPeriod),
		CareTeam: cloneSlices(m.CareTeam),
		SupportingInfo: cloneSlices(m.SupportingInfo),
		Diagnosis: cloneSlices(m.Diagnosis),
		Procedure: cloneSlices(m.Procedure),
		Precedence: m.Precedence.Clone(),
		Insurance: cloneSlices(m.Insurance),
		Accident: m.Accident.Clone(),
		Item: cloneSlices(m.Item),
		AddItem: cloneSlices(m.AddItem),
		Adjudication: cloneSlices(m.Adjudication),
		Total: cloneSlices(m.Total),
		Payment: m.Payment.Clone(),
		FormCode: m.FormCode.Clone(),
		Form: m.Form.Clone(),
		ProcessNote: cloneSlices(m.ProcessNote),
		BenefitPeriod: m.BenefitPeriod.Clone(),
		BenefitBalance: cloneSlices(m.BenefitBalance),
	}
}

// Equals checks equality between two ExplanationOfBenefit instances.
func (m *ExplanationOfBenefit) Equals(other *ExplanationOfBenefit) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.SubType.Equals(other.SubType) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.BillablePeriod.Equals(other.BillablePeriod) { return false }
	if !m.Created.Equals(other.Created) { return false }
	if !m.Enterer.Equals(other.Enterer) { return false }
	if !m.Insurer.Equals(other.Insurer) { return false }
	if !m.Provider.Equals(other.Provider) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.FundsReserveRequested.Equals(other.FundsReserveRequested) { return false }
	if !m.FundsReserve.Equals(other.FundsReserve) { return false }
	if !compareSlices(m.Related, other.Related) { return false }
	if !m.Prescription.Equals(other.Prescription) { return false }
	if !m.OriginalPrescription.Equals(other.OriginalPrescription) { return false }
	if !m.Payee.Equals(other.Payee) { return false }
	if !m.Referral.Equals(other.Referral) { return false }
	if !m.Facility.Equals(other.Facility) { return false }
	if !m.Claim.Equals(other.Claim) { return false }
	if !m.ClaimResponse.Equals(other.ClaimResponse) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	if !m.Disposition.Equals(other.Disposition) { return false }
	if !compareSlices(m.PreAuthRef, other.PreAuthRef) { return false }
	if !compareSlices(m.PreAuthRefPeriod, other.PreAuthRefPeriod) { return false }
	if !compareSlices(m.CareTeam, other.CareTeam) { return false }
	if !compareSlices(m.SupportingInfo, other.SupportingInfo) { return false }
	if !compareSlices(m.Diagnosis, other.Diagnosis) { return false }
	if !compareSlices(m.Procedure, other.Procedure) { return false }
	if !m.Precedence.Equals(other.Precedence) { return false }
	if !compareSlices(m.Insurance, other.Insurance) { return false }
	if !m.Accident.Equals(other.Accident) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	if !compareSlices(m.AddItem, other.AddItem) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Total, other.Total) { return false }
	if !m.Payment.Equals(other.Payment) { return false }
	if !m.FormCode.Equals(other.FormCode) { return false }
	if !m.Form.Equals(other.Form) { return false }
	if !compareSlices(m.ProcessNote, other.ProcessNote) { return false }
	if !m.BenefitPeriod.Equals(other.BenefitPeriod) { return false }
	if !compareSlices(m.BenefitBalance, other.BenefitBalance) { return false }
	return true
}

// ExplanationOfBenefitRelated
// Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
type ExplanationOfBenefitRelated struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Claim *Reference `json:"claim,omitempty"`
	Relationship *CodeableConcept `json:"relationship,omitempty"`
	Reference *Identifier `json:"reference,omitempty"`
}

// NewExplanationOfBenefitRelated creates a new ExplanationOfBenefitRelated instance.
func NewExplanationOfBenefitRelated() *ExplanationOfBenefitRelated {
	return &ExplanationOfBenefitRelated{}
}

// FromJSON populates ExplanationOfBenefitRelated from JSON data.
func (m *ExplanationOfBenefitRelated) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Claim *Reference `json:"claim,omitempty"`
		Relationship *CodeableConcept `json:"relationship,omitempty"`
		Reference *Identifier `json:"reference,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Claim = temp.Claim
	m.Relationship = temp.Relationship
	m.Reference = temp.Reference
	return nil
}

// ToJSON converts ExplanationOfBenefitRelated to JSON data.
func (m *ExplanationOfBenefitRelated) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Claim *Reference `json:"claim,omitempty"`
		Relationship *CodeableConcept `json:"relationship,omitempty"`
		Reference *Identifier `json:"reference,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Claim = m.Claim
	output.Relationship = m.Relationship
	output.Reference = m.Reference
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitRelated.
func (m *ExplanationOfBenefitRelated) Clone() *ExplanationOfBenefitRelated {
	if m == nil { return nil }
	return &ExplanationOfBenefitRelated{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Claim: m.Claim.Clone(),
		Relationship: m.Relationship.Clone(),
		Reference: m.Reference.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitRelated instances.
func (m *ExplanationOfBenefitRelated) Equals(other *ExplanationOfBenefitRelated) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Claim.Equals(other.Claim) { return false }
	if !m.Relationship.Equals(other.Relationship) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	return true
}

// ExplanationOfBenefitPayee
// The party to be reimbursed for cost of the products and services according to the terms of the policy.
type ExplanationOfBenefitPayee struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Party *Reference `json:"party,omitempty"`
}

// NewExplanationOfBenefitPayee creates a new ExplanationOfBenefitPayee instance.
func NewExplanationOfBenefitPayee() *ExplanationOfBenefitPayee {
	return &ExplanationOfBenefitPayee{}
}

// FromJSON populates ExplanationOfBenefitPayee from JSON data.
func (m *ExplanationOfBenefitPayee) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Party *Reference `json:"party,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Party = temp.Party
	return nil
}

// ToJSON converts ExplanationOfBenefitPayee to JSON data.
func (m *ExplanationOfBenefitPayee) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Party *Reference `json:"party,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Party = m.Party
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitPayee.
func (m *ExplanationOfBenefitPayee) Clone() *ExplanationOfBenefitPayee {
	if m == nil { return nil }
	return &ExplanationOfBenefitPayee{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Party: m.Party.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitPayee instances.
func (m *ExplanationOfBenefitPayee) Equals(other *ExplanationOfBenefitPayee) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Party.Equals(other.Party) { return false }
	return true
}

// ExplanationOfBenefitCareTeam
// The members of the team who provided the products and services.
type ExplanationOfBenefitCareTeam struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Provider *Reference `json:"provider,omitempty"`
	Responsible *FhirBoolean `json:"responsible,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	Qualification *CodeableConcept `json:"qualification,omitempty"`
}

// NewExplanationOfBenefitCareTeam creates a new ExplanationOfBenefitCareTeam instance.
func NewExplanationOfBenefitCareTeam() *ExplanationOfBenefitCareTeam {
	return &ExplanationOfBenefitCareTeam{}
}

// FromJSON populates ExplanationOfBenefitCareTeam from JSON data.
func (m *ExplanationOfBenefitCareTeam) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		Provider *Reference `json:"provider,omitempty"`
		Responsible *FhirBoolean `json:"responsible,omitempty"`
		Role *CodeableConcept `json:"role,omitempty"`
		Qualification *CodeableConcept `json:"qualification,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.Provider = temp.Provider
	m.Responsible = temp.Responsible
	m.Role = temp.Role
	m.Qualification = temp.Qualification
	return nil
}

// ToJSON converts ExplanationOfBenefitCareTeam to JSON data.
func (m *ExplanationOfBenefitCareTeam) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		Provider *Reference `json:"provider,omitempty"`
		Responsible interface{} `json:"responsible,omitempty"`
		ResponsibleElement map[string]interface{} `json:"_responsible,omitempty"`
		Role *CodeableConcept `json:"role,omitempty"`
		Qualification *CodeableConcept `json:"qualification,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.ToJSON())
		}
	}
	output.Provider = m.Provider
	if m.Responsible != nil && m.Responsible.Value != nil {
		output.Responsible = m.Responsible.Value
		if m.Responsible.Element != nil {
			output.ResponsibleElement = toMapOrNil(m.Responsible.Element.ToJSON())
		}
	}
	output.Role = m.Role
	output.Qualification = m.Qualification
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitCareTeam.
func (m *ExplanationOfBenefitCareTeam) Clone() *ExplanationOfBenefitCareTeam {
	if m == nil { return nil }
	return &ExplanationOfBenefitCareTeam{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Provider: m.Provider.Clone(),
		Responsible: m.Responsible.Clone(),
		Role: m.Role.Clone(),
		Qualification: m.Qualification.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitCareTeam instances.
func (m *ExplanationOfBenefitCareTeam) Equals(other *ExplanationOfBenefitCareTeam) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Provider.Equals(other.Provider) { return false }
	if !m.Responsible.Equals(other.Responsible) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Qualification.Equals(other.Qualification) { return false }
	return true
}

// ExplanationOfBenefitSupportingInfo
// Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
type ExplanationOfBenefitSupportingInfo struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	TimingDate *FhirDate `json:"timingdate,omitempty"`
	TimingPeriod *Period `json:"timingperiod,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	Reason *Coding `json:"reason,omitempty"`
}

// NewExplanationOfBenefitSupportingInfo creates a new ExplanationOfBenefitSupportingInfo instance.
func NewExplanationOfBenefitSupportingInfo() *ExplanationOfBenefitSupportingInfo {
	return &ExplanationOfBenefitSupportingInfo{}
}

// FromJSON populates ExplanationOfBenefitSupportingInfo from JSON data.
func (m *ExplanationOfBenefitSupportingInfo) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		TimingDate *FhirDate `json:"timingdate,omitempty"`
		TimingPeriod *Period `json:"timingperiod,omitempty"`
		ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
		ValueString *FhirString `json:"valuestring,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
		ValueReference *Reference `json:"valuereference,omitempty"`
		Reason *Coding `json:"reason,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.Category = temp.Category
	m.Code = temp.Code
	m.TimingDate = temp.TimingDate
	m.TimingPeriod = temp.TimingPeriod
	m.ValueBoolean = temp.ValueBoolean
	m.ValueString = temp.ValueString
	m.ValueQuantity = temp.ValueQuantity
	m.ValueAttachment = temp.ValueAttachment
	m.ValueReference = temp.ValueReference
	m.Reason = temp.Reason
	return nil
}

// ToJSON converts ExplanationOfBenefitSupportingInfo to JSON data.
func (m *ExplanationOfBenefitSupportingInfo) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		TimingDate interface{} `json:"timingdate,omitempty"`
		TimingDateElement map[string]interface{} `json:"_timingdate,omitempty"`
		TimingPeriod *Period `json:"timingperiod,omitempty"`
		ValueBoolean interface{} `json:"valueboolean,omitempty"`
		ValueBooleanElement map[string]interface{} `json:"_valueboolean,omitempty"`
		ValueString interface{} `json:"valuestring,omitempty"`
		ValueStringElement map[string]interface{} `json:"_valuestring,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
		ValueReference *Reference `json:"valuereference,omitempty"`
		Reason *Coding `json:"reason,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.ToJSON())
		}
	}
	output.Category = m.Category
	output.Code = m.Code
	if m.TimingDate != nil && m.TimingDate.Value != nil {
		output.TimingDate = m.TimingDate.Value
		if m.TimingDate.Element != nil {
			output.TimingDateElement = toMapOrNil(m.TimingDate.Element.ToJSON())
		}
	}
	output.TimingPeriod = m.TimingPeriod
	if m.ValueBoolean != nil && m.ValueBoolean.Value != nil {
		output.ValueBoolean = m.ValueBoolean.Value
		if m.ValueBoolean.Element != nil {
			output.ValueBooleanElement = toMapOrNil(m.ValueBoolean.Element.ToJSON())
		}
	}
	if m.ValueString != nil && m.ValueString.Value != nil {
		output.ValueString = m.ValueString.Value
		if m.ValueString.Element != nil {
			output.ValueStringElement = toMapOrNil(m.ValueString.Element.ToJSON())
		}
	}
	output.ValueQuantity = m.ValueQuantity
	output.ValueAttachment = m.ValueAttachment
	output.ValueReference = m.ValueReference
	output.Reason = m.Reason
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitSupportingInfo.
func (m *ExplanationOfBenefitSupportingInfo) Clone() *ExplanationOfBenefitSupportingInfo {
	if m == nil { return nil }
	return &ExplanationOfBenefitSupportingInfo{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Category: m.Category.Clone(),
		Code: m.Code.Clone(),
		TimingDate: m.TimingDate.Clone(),
		TimingPeriod: m.TimingPeriod.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueReference: m.ValueReference.Clone(),
		Reason: m.Reason.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitSupportingInfo instances.
func (m *ExplanationOfBenefitSupportingInfo) Equals(other *ExplanationOfBenefitSupportingInfo) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.TimingDate.Equals(other.TimingDate) { return false }
	if !m.TimingPeriod.Equals(other.TimingPeriod) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	return true
}

// ExplanationOfBenefitDiagnosis
// Information about diagnoses relevant to the claim items.
type ExplanationOfBenefitDiagnosis struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	DiagnosisCodeableConcept *CodeableConcept `json:"diagnosiscodeableconcept,omitempty"`
	DiagnosisReference *Reference `json:"diagnosisreference,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	OnAdmission *CodeableConcept `json:"onadmission,omitempty"`
	PackageCode *CodeableConcept `json:"packagecode,omitempty"`
}

// NewExplanationOfBenefitDiagnosis creates a new ExplanationOfBenefitDiagnosis instance.
func NewExplanationOfBenefitDiagnosis() *ExplanationOfBenefitDiagnosis {
	return &ExplanationOfBenefitDiagnosis{}
}

// FromJSON populates ExplanationOfBenefitDiagnosis from JSON data.
func (m *ExplanationOfBenefitDiagnosis) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		DiagnosisCodeableConcept *CodeableConcept `json:"diagnosiscodeableconcept,omitempty"`
		DiagnosisReference *Reference `json:"diagnosisreference,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		OnAdmission *CodeableConcept `json:"onadmission,omitempty"`
		PackageCode *CodeableConcept `json:"packagecode,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.DiagnosisCodeableConcept = temp.DiagnosisCodeableConcept
	m.DiagnosisReference = temp.DiagnosisReference
	m.Type = temp.Type
	m.OnAdmission = temp.OnAdmission
	m.PackageCode = temp.PackageCode
	return nil
}

// ToJSON converts ExplanationOfBenefitDiagnosis to JSON data.
func (m *ExplanationOfBenefitDiagnosis) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		DiagnosisCodeableConcept *CodeableConcept `json:"diagnosiscodeableconcept,omitempty"`
		DiagnosisReference *Reference `json:"diagnosisreference,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		OnAdmission *CodeableConcept `json:"onadmission,omitempty"`
		PackageCode *CodeableConcept `json:"packagecode,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.ToJSON())
		}
	}
	output.DiagnosisCodeableConcept = m.DiagnosisCodeableConcept
	output.DiagnosisReference = m.DiagnosisReference
	output.Type = m.Type
	output.OnAdmission = m.OnAdmission
	output.PackageCode = m.PackageCode
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitDiagnosis.
func (m *ExplanationOfBenefitDiagnosis) Clone() *ExplanationOfBenefitDiagnosis {
	if m == nil { return nil }
	return &ExplanationOfBenefitDiagnosis{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		DiagnosisCodeableConcept: m.DiagnosisCodeableConcept.Clone(),
		DiagnosisReference: m.DiagnosisReference.Clone(),
		Type: cloneSlices(m.Type),
		OnAdmission: m.OnAdmission.Clone(),
		PackageCode: m.PackageCode.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitDiagnosis instances.
func (m *ExplanationOfBenefitDiagnosis) Equals(other *ExplanationOfBenefitDiagnosis) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.DiagnosisCodeableConcept.Equals(other.DiagnosisCodeableConcept) { return false }
	if !m.DiagnosisReference.Equals(other.DiagnosisReference) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.OnAdmission.Equals(other.OnAdmission) { return false }
	if !m.PackageCode.Equals(other.PackageCode) { return false }
	return true
}

// ExplanationOfBenefitProcedure
// Procedures performed on the patient relevant to the billing items with the claim.
type ExplanationOfBenefitProcedure struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	ProcedureCodeableConcept *CodeableConcept `json:"procedurecodeableconcept,omitempty"`
	ProcedureReference *Reference `json:"procedurereference,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
}

// NewExplanationOfBenefitProcedure creates a new ExplanationOfBenefitProcedure instance.
func NewExplanationOfBenefitProcedure() *ExplanationOfBenefitProcedure {
	return &ExplanationOfBenefitProcedure{}
}

// FromJSON populates ExplanationOfBenefitProcedure from JSON data.
func (m *ExplanationOfBenefitProcedure) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
		ProcedureCodeableConcept *CodeableConcept `json:"procedurecodeableconcept,omitempty"`
		ProcedureReference *Reference `json:"procedurereference,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.Type = temp.Type
	m.Date = temp.Date
	m.ProcedureCodeableConcept = temp.ProcedureCodeableConcept
	m.ProcedureReference = temp.ProcedureReference
	m.Udi = temp.Udi
	return nil
}

// ToJSON converts ExplanationOfBenefitProcedure to JSON data.
func (m *ExplanationOfBenefitProcedure) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		ProcedureCodeableConcept *CodeableConcept `json:"procedurecodeableconcept,omitempty"`
		ProcedureReference *Reference `json:"procedurereference,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.ToJSON())
		}
	}
	output.Type = m.Type
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.ToJSON())
		}
	}
	output.ProcedureCodeableConcept = m.ProcedureCodeableConcept
	output.ProcedureReference = m.ProcedureReference
	output.Udi = m.Udi
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitProcedure.
func (m *ExplanationOfBenefitProcedure) Clone() *ExplanationOfBenefitProcedure {
	if m == nil { return nil }
	return &ExplanationOfBenefitProcedure{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Type: cloneSlices(m.Type),
		Date: m.Date.Clone(),
		ProcedureCodeableConcept: m.ProcedureCodeableConcept.Clone(),
		ProcedureReference: m.ProcedureReference.Clone(),
		Udi: cloneSlices(m.Udi),
	}
}

// Equals checks equality between two ExplanationOfBenefitProcedure instances.
func (m *ExplanationOfBenefitProcedure) Equals(other *ExplanationOfBenefitProcedure) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.ProcedureCodeableConcept.Equals(other.ProcedureCodeableConcept) { return false }
	if !m.ProcedureReference.Equals(other.ProcedureReference) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	return true
}

// ExplanationOfBenefitInsurance
// Financial instruments for reimbursement for the health care products and services specified on the claim.
type ExplanationOfBenefitInsurance struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Focal *FhirBoolean `json:"focal,omitempty"`
	Coverage *Reference `json:"coverage,omitempty"`
	PreAuthRef []*FhirString `json:"preauthref,omitempty"`
}

// NewExplanationOfBenefitInsurance creates a new ExplanationOfBenefitInsurance instance.
func NewExplanationOfBenefitInsurance() *ExplanationOfBenefitInsurance {
	return &ExplanationOfBenefitInsurance{}
}

// FromJSON populates ExplanationOfBenefitInsurance from JSON data.
func (m *ExplanationOfBenefitInsurance) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Focal *FhirBoolean `json:"focal,omitempty"`
		Coverage *Reference `json:"coverage,omitempty"`
		PreAuthRef []interface{} `json:"preauthref,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Focal = temp.Focal
	m.Coverage = temp.Coverage
	if len(temp.PreAuthRef) > 0 {
		m.PreAuthRef = make([]*FhirString, len(temp.PreAuthRef))
		for i := range temp.PreAuthRef {
			itemMap, ok := temp.PreAuthRef[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for PreAuthRef[%d]: expected map", i) }
			primitive, err := NewFhirStringFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse PreAuthRef[%d]: %v", i, err) }
			m.PreAuthRef[i] = primitive
		}
	}
	return nil
}

// ToJSON converts ExplanationOfBenefitInsurance to JSON data.
func (m *ExplanationOfBenefitInsurance) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Focal interface{} `json:"focal,omitempty"`
		FocalElement map[string]interface{} `json:"_focal,omitempty"`
		Coverage *Reference `json:"coverage,omitempty"`
		PreAuthRef []interface{} `json:"preauthref,omitempty"`
		PreAuthRefElement []map[string]interface{} `json:"_preauthref,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Focal != nil && m.Focal.Value != nil {
		output.Focal = m.Focal.Value
		if m.Focal.Element != nil {
			output.FocalElement = toMapOrNil(m.Focal.Element.ToJSON())
		}
	}
	output.Coverage = m.Coverage
	if len(m.PreAuthRef) > 0 {
		output.PreAuthRef = make([]interface{}, len(m.PreAuthRef))
		output.PreAuthRefElement = make([]map[string]interface{}, len(m.PreAuthRef))
		for i, item := range m.PreAuthRef {
			if item != nil && item.Value != nil {
				output.PreAuthRef[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.PreAuthRefElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitInsurance.
func (m *ExplanationOfBenefitInsurance) Clone() *ExplanationOfBenefitInsurance {
	if m == nil { return nil }
	return &ExplanationOfBenefitInsurance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Focal: m.Focal.Clone(),
		Coverage: m.Coverage.Clone(),
		PreAuthRef: cloneSlices(m.PreAuthRef),
	}
}

// Equals checks equality between two ExplanationOfBenefitInsurance instances.
func (m *ExplanationOfBenefitInsurance) Equals(other *ExplanationOfBenefitInsurance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Focal.Equals(other.Focal) { return false }
	if !m.Coverage.Equals(other.Coverage) { return false }
	if !compareSlices(m.PreAuthRef, other.PreAuthRef) { return false }
	return true
}

// ExplanationOfBenefitAccident
// Details of a accident which resulted in injuries which required the products and services listed in the claim.
type ExplanationOfBenefitAccident struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Date *FhirDate `json:"date,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	LocationAddress *Address `json:"locationaddress,omitempty"`
	LocationReference *Reference `json:"locationreference,omitempty"`
}

// NewExplanationOfBenefitAccident creates a new ExplanationOfBenefitAccident instance.
func NewExplanationOfBenefitAccident() *ExplanationOfBenefitAccident {
	return &ExplanationOfBenefitAccident{}
}

// FromJSON populates ExplanationOfBenefitAccident from JSON data.
func (m *ExplanationOfBenefitAccident) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Date *FhirDate `json:"date,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		LocationAddress *Address `json:"locationaddress,omitempty"`
		LocationReference *Reference `json:"locationreference,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Date = temp.Date
	m.Type = temp.Type
	m.LocationAddress = temp.LocationAddress
	m.LocationReference = temp.LocationReference
	return nil
}

// ToJSON converts ExplanationOfBenefitAccident to JSON data.
func (m *ExplanationOfBenefitAccident) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		LocationAddress *Address `json:"locationaddress,omitempty"`
		LocationReference *Reference `json:"locationreference,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.ToJSON())
		}
	}
	output.Type = m.Type
	output.LocationAddress = m.LocationAddress
	output.LocationReference = m.LocationReference
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitAccident.
func (m *ExplanationOfBenefitAccident) Clone() *ExplanationOfBenefitAccident {
	if m == nil { return nil }
	return &ExplanationOfBenefitAccident{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Date: m.Date.Clone(),
		Type: m.Type.Clone(),
		LocationAddress: m.LocationAddress.Clone(),
		LocationReference: m.LocationReference.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitAccident instances.
func (m *ExplanationOfBenefitAccident) Equals(other *ExplanationOfBenefitAccident) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.LocationAddress.Equals(other.LocationAddress) { return false }
	if !m.LocationReference.Equals(other.LocationReference) { return false }
	return true
}

// ExplanationOfBenefitItem
// A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
type ExplanationOfBenefitItem struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	CareTeamSequence []*FhirPositiveInt `json:"careteamsequence,omitempty"`
	DiagnosisSequence []*FhirPositiveInt `json:"diagnosissequence,omitempty"`
	ProcedureSequence []*FhirPositiveInt `json:"proceduresequence,omitempty"`
	InformationSequence []*FhirPositiveInt `json:"informationsequence,omitempty"`
	Revenue *CodeableConcept `json:"revenue,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	ServicedDate *FhirDate `json:"serviceddate,omitempty"`
	ServicedPeriod *Period `json:"servicedperiod,omitempty"`
	LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
	LocationAddress *Address `json:"locationaddress,omitempty"`
	LocationReference *Reference `json:"locationreference,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
	BodySite *CodeableConcept `json:"bodysite,omitempty"`
	SubSite []*CodeableConcept `json:"subsite,omitempty"`
	Encounter []*Reference `json:"encounter,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
}

// NewExplanationOfBenefitItem creates a new ExplanationOfBenefitItem instance.
func NewExplanationOfBenefitItem() *ExplanationOfBenefitItem {
	return &ExplanationOfBenefitItem{}
}

// FromJSON populates ExplanationOfBenefitItem from JSON data.
func (m *ExplanationOfBenefitItem) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		CareTeamSequence []interface{} `json:"careteamsequence,omitempty"`
		DiagnosisSequence []interface{} `json:"diagnosissequence,omitempty"`
		ProcedureSequence []interface{} `json:"proceduresequence,omitempty"`
		InformationSequence []interface{} `json:"informationsequence,omitempty"`
		Revenue *CodeableConcept `json:"revenue,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		ServicedDate *FhirDate `json:"serviceddate,omitempty"`
		ServicedPeriod *Period `json:"servicedperiod,omitempty"`
		LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
		LocationAddress *Address `json:"locationaddress,omitempty"`
		LocationReference *Reference `json:"locationreference,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor *FhirDecimal `json:"factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
		BodySite *CodeableConcept `json:"bodysite,omitempty"`
		SubSite []*CodeableConcept `json:"subsite,omitempty"`
		Encounter []*Reference `json:"encounter,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	if len(temp.CareTeamSequence) > 0 {
		m.CareTeamSequence = make([]*FhirPositiveInt, len(temp.CareTeamSequence))
		for i := range temp.CareTeamSequence {
			itemMap, ok := temp.CareTeamSequence[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for CareTeamSequence[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse CareTeamSequence[%d]: %v", i, err) }
			m.CareTeamSequence[i] = primitive
		}
	}
	if len(temp.DiagnosisSequence) > 0 {
		m.DiagnosisSequence = make([]*FhirPositiveInt, len(temp.DiagnosisSequence))
		for i := range temp.DiagnosisSequence {
			itemMap, ok := temp.DiagnosisSequence[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for DiagnosisSequence[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse DiagnosisSequence[%d]: %v", i, err) }
			m.DiagnosisSequence[i] = primitive
		}
	}
	if len(temp.ProcedureSequence) > 0 {
		m.ProcedureSequence = make([]*FhirPositiveInt, len(temp.ProcedureSequence))
		for i := range temp.ProcedureSequence {
			itemMap, ok := temp.ProcedureSequence[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for ProcedureSequence[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse ProcedureSequence[%d]: %v", i, err) }
			m.ProcedureSequence[i] = primitive
		}
	}
	if len(temp.InformationSequence) > 0 {
		m.InformationSequence = make([]*FhirPositiveInt, len(temp.InformationSequence))
		for i := range temp.InformationSequence {
			itemMap, ok := temp.InformationSequence[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for InformationSequence[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse InformationSequence[%d]: %v", i, err) }
			m.InformationSequence[i] = primitive
		}
	}
	m.Revenue = temp.Revenue
	m.Category = temp.Category
	m.ProductOrService = temp.ProductOrService
	m.Modifier = temp.Modifier
	m.ProgramCode = temp.ProgramCode
	m.ServicedDate = temp.ServicedDate
	m.ServicedPeriod = temp.ServicedPeriod
	m.LocationCodeableConcept = temp.LocationCodeableConcept
	m.LocationAddress = temp.LocationAddress
	m.LocationReference = temp.LocationReference
	m.Quantity = temp.Quantity
	m.UnitPrice = temp.UnitPrice
	m.Factor = temp.Factor
	m.Net = temp.Net
	m.Udi = temp.Udi
	m.BodySite = temp.BodySite
	m.SubSite = temp.SubSite
	m.Encounter = temp.Encounter
	if len(temp.NoteNumber) > 0 {
		m.NoteNumber = make([]*FhirPositiveInt, len(temp.NoteNumber))
		for i := range temp.NoteNumber {
			itemMap, ok := temp.NoteNumber[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for NoteNumber[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse NoteNumber[%d]: %v", i, err) }
			m.NoteNumber[i] = primitive
		}
	}
	m.Adjudication = temp.Adjudication
	m.Detail = temp.Detail
	return nil
}

// ToJSON converts ExplanationOfBenefitItem to JSON data.
func (m *ExplanationOfBenefitItem) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		CareTeamSequence []interface{} `json:"careteamsequence,omitempty"`
		CareTeamSequenceElement []map[string]interface{} `json:"_careteamsequence,omitempty"`
		DiagnosisSequence []interface{} `json:"diagnosissequence,omitempty"`
		DiagnosisSequenceElement []map[string]interface{} `json:"_diagnosissequence,omitempty"`
		ProcedureSequence []interface{} `json:"proceduresequence,omitempty"`
		ProcedureSequenceElement []map[string]interface{} `json:"_proceduresequence,omitempty"`
		InformationSequence []interface{} `json:"informationsequence,omitempty"`
		InformationSequenceElement []map[string]interface{} `json:"_informationsequence,omitempty"`
		Revenue *CodeableConcept `json:"revenue,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		ServicedDate interface{} `json:"serviceddate,omitempty"`
		ServicedDateElement map[string]interface{} `json:"_serviceddate,omitempty"`
		ServicedPeriod *Period `json:"servicedperiod,omitempty"`
		LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
		LocationAddress *Address `json:"locationaddress,omitempty"`
		LocationReference *Reference `json:"locationreference,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor interface{} `json:"factor,omitempty"`
		FactorElement map[string]interface{} `json:"_factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
		BodySite *CodeableConcept `json:"bodysite,omitempty"`
		SubSite []*CodeableConcept `json:"subsite,omitempty"`
		Encounter []*Reference `json:"encounter,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		NoteNumberElement []map[string]interface{} `json:"_notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.ToJSON())
		}
	}
	if len(m.CareTeamSequence) > 0 {
		output.CareTeamSequence = make([]interface{}, len(m.CareTeamSequence))
		output.CareTeamSequenceElement = make([]map[string]interface{}, len(m.CareTeamSequence))
		for i, item := range m.CareTeamSequence {
			if item != nil && item.Value != nil {
				output.CareTeamSequence[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.CareTeamSequenceElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	if len(m.DiagnosisSequence) > 0 {
		output.DiagnosisSequence = make([]interface{}, len(m.DiagnosisSequence))
		output.DiagnosisSequenceElement = make([]map[string]interface{}, len(m.DiagnosisSequence))
		for i, item := range m.DiagnosisSequence {
			if item != nil && item.Value != nil {
				output.DiagnosisSequence[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.DiagnosisSequenceElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	if len(m.ProcedureSequence) > 0 {
		output.ProcedureSequence = make([]interface{}, len(m.ProcedureSequence))
		output.ProcedureSequenceElement = make([]map[string]interface{}, len(m.ProcedureSequence))
		for i, item := range m.ProcedureSequence {
			if item != nil && item.Value != nil {
				output.ProcedureSequence[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.ProcedureSequenceElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	if len(m.InformationSequence) > 0 {
		output.InformationSequence = make([]interface{}, len(m.InformationSequence))
		output.InformationSequenceElement = make([]map[string]interface{}, len(m.InformationSequence))
		for i, item := range m.InformationSequence {
			if item != nil && item.Value != nil {
				output.InformationSequence[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.InformationSequenceElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Revenue = m.Revenue
	output.Category = m.Category
	output.ProductOrService = m.ProductOrService
	output.Modifier = m.Modifier
	output.ProgramCode = m.ProgramCode
	if m.ServicedDate != nil && m.ServicedDate.Value != nil {
		output.ServicedDate = m.ServicedDate.Value
		if m.ServicedDate.Element != nil {
			output.ServicedDateElement = toMapOrNil(m.ServicedDate.Element.ToJSON())
		}
	}
	output.ServicedPeriod = m.ServicedPeriod
	output.LocationCodeableConcept = m.LocationCodeableConcept
	output.LocationAddress = m.LocationAddress
	output.LocationReference = m.LocationReference
	output.Quantity = m.Quantity
	output.UnitPrice = m.UnitPrice
	if m.Factor != nil && m.Factor.Value != nil {
		output.Factor = m.Factor.Value
		if m.Factor.Element != nil {
			output.FactorElement = toMapOrNil(m.Factor.Element.ToJSON())
		}
	}
	output.Net = m.Net
	output.Udi = m.Udi
	output.BodySite = m.BodySite
	output.SubSite = m.SubSite
	output.Encounter = m.Encounter
	if len(m.NoteNumber) > 0 {
		output.NoteNumber = make([]interface{}, len(m.NoteNumber))
		output.NoteNumberElement = make([]map[string]interface{}, len(m.NoteNumber))
		for i, item := range m.NoteNumber {
			if item != nil && item.Value != nil {
				output.NoteNumber[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.NoteNumberElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Adjudication = m.Adjudication
	output.Detail = m.Detail
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitItem.
func (m *ExplanationOfBenefitItem) Clone() *ExplanationOfBenefitItem {
	if m == nil { return nil }
	return &ExplanationOfBenefitItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		CareTeamSequence: cloneSlices(m.CareTeamSequence),
		DiagnosisSequence: cloneSlices(m.DiagnosisSequence),
		ProcedureSequence: cloneSlices(m.ProcedureSequence),
		InformationSequence: cloneSlices(m.InformationSequence),
		Revenue: m.Revenue.Clone(),
		Category: m.Category.Clone(),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		ServicedDate: m.ServicedDate.Clone(),
		ServicedPeriod: m.ServicedPeriod.Clone(),
		LocationCodeableConcept: m.LocationCodeableConcept.Clone(),
		LocationAddress: m.LocationAddress.Clone(),
		LocationReference: m.LocationReference.Clone(),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		Udi: cloneSlices(m.Udi),
		BodySite: m.BodySite.Clone(),
		SubSite: cloneSlices(m.SubSite),
		Encounter: cloneSlices(m.Encounter),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks equality between two ExplanationOfBenefitItem instances.
func (m *ExplanationOfBenefitItem) Equals(other *ExplanationOfBenefitItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !compareSlices(m.CareTeamSequence, other.CareTeamSequence) { return false }
	if !compareSlices(m.DiagnosisSequence, other.DiagnosisSequence) { return false }
	if !compareSlices(m.ProcedureSequence, other.ProcedureSequence) { return false }
	if !compareSlices(m.InformationSequence, other.InformationSequence) { return false }
	if !m.Revenue.Equals(other.Revenue) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.ServicedDate.Equals(other.ServicedDate) { return false }
	if !m.ServicedPeriod.Equals(other.ServicedPeriod) { return false }
	if !m.LocationCodeableConcept.Equals(other.LocationCodeableConcept) { return false }
	if !m.LocationAddress.Equals(other.LocationAddress) { return false }
	if !m.LocationReference.Equals(other.LocationReference) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !compareSlices(m.SubSite, other.SubSite) { return false }
	if !compareSlices(m.Encounter, other.Encounter) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// ExplanationOfBenefitAdjudication
// If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
type ExplanationOfBenefitAdjudication struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Reason *CodeableConcept `json:"reason,omitempty"`
	Amount *Money `json:"amount,omitempty"`
	Value *FhirDecimal `json:"value,omitempty"`
}

// NewExplanationOfBenefitAdjudication creates a new ExplanationOfBenefitAdjudication instance.
func NewExplanationOfBenefitAdjudication() *ExplanationOfBenefitAdjudication {
	return &ExplanationOfBenefitAdjudication{}
}

// FromJSON populates ExplanationOfBenefitAdjudication from JSON data.
func (m *ExplanationOfBenefitAdjudication) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Reason *CodeableConcept `json:"reason,omitempty"`
		Amount *Money `json:"amount,omitempty"`
		Value *FhirDecimal `json:"value,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Category = temp.Category
	m.Reason = temp.Reason
	m.Amount = temp.Amount
	m.Value = temp.Value
	return nil
}

// ToJSON converts ExplanationOfBenefitAdjudication to JSON data.
func (m *ExplanationOfBenefitAdjudication) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Reason *CodeableConcept `json:"reason,omitempty"`
		Amount *Money `json:"amount,omitempty"`
		Value interface{} `json:"value,omitempty"`
		ValueElement map[string]interface{} `json:"_value,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Category = m.Category
	output.Reason = m.Reason
	output.Amount = m.Amount
	if m.Value != nil && m.Value.Value != nil {
		output.Value = m.Value.Value
		if m.Value.Element != nil {
			output.ValueElement = toMapOrNil(m.Value.Element.ToJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitAdjudication.
func (m *ExplanationOfBenefitAdjudication) Clone() *ExplanationOfBenefitAdjudication {
	if m == nil { return nil }
	return &ExplanationOfBenefitAdjudication{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Reason: m.Reason.Clone(),
		Amount: m.Amount.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitAdjudication instances.
func (m *ExplanationOfBenefitAdjudication) Equals(other *ExplanationOfBenefitAdjudication) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// ExplanationOfBenefitDetail
// Second-tier of goods and services.
type ExplanationOfBenefitDetail struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Revenue *CodeableConcept `json:"revenue,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
}

// NewExplanationOfBenefitDetail creates a new ExplanationOfBenefitDetail instance.
func NewExplanationOfBenefitDetail() *ExplanationOfBenefitDetail {
	return &ExplanationOfBenefitDetail{}
}

// FromJSON populates ExplanationOfBenefitDetail from JSON data.
func (m *ExplanationOfBenefitDetail) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		Revenue *CodeableConcept `json:"revenue,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor *FhirDecimal `json:"factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.Revenue = temp.Revenue
	m.Category = temp.Category
	m.ProductOrService = temp.ProductOrService
	m.Modifier = temp.Modifier
	m.ProgramCode = temp.ProgramCode
	m.Quantity = temp.Quantity
	m.UnitPrice = temp.UnitPrice
	m.Factor = temp.Factor
	m.Net = temp.Net
	m.Udi = temp.Udi
	if len(temp.NoteNumber) > 0 {
		m.NoteNumber = make([]*FhirPositiveInt, len(temp.NoteNumber))
		for i := range temp.NoteNumber {
			itemMap, ok := temp.NoteNumber[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for NoteNumber[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse NoteNumber[%d]: %v", i, err) }
			m.NoteNumber[i] = primitive
		}
	}
	m.Adjudication = temp.Adjudication
	m.SubDetail = temp.SubDetail
	return nil
}

// ToJSON converts ExplanationOfBenefitDetail to JSON data.
func (m *ExplanationOfBenefitDetail) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		Revenue *CodeableConcept `json:"revenue,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor interface{} `json:"factor,omitempty"`
		FactorElement map[string]interface{} `json:"_factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		NoteNumberElement []map[string]interface{} `json:"_notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.ToJSON())
		}
	}
	output.Revenue = m.Revenue
	output.Category = m.Category
	output.ProductOrService = m.ProductOrService
	output.Modifier = m.Modifier
	output.ProgramCode = m.ProgramCode
	output.Quantity = m.Quantity
	output.UnitPrice = m.UnitPrice
	if m.Factor != nil && m.Factor.Value != nil {
		output.Factor = m.Factor.Value
		if m.Factor.Element != nil {
			output.FactorElement = toMapOrNil(m.Factor.Element.ToJSON())
		}
	}
	output.Net = m.Net
	output.Udi = m.Udi
	if len(m.NoteNumber) > 0 {
		output.NoteNumber = make([]interface{}, len(m.NoteNumber))
		output.NoteNumberElement = make([]map[string]interface{}, len(m.NoteNumber))
		for i, item := range m.NoteNumber {
			if item != nil && item.Value != nil {
				output.NoteNumber[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.NoteNumberElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Adjudication = m.Adjudication
	output.SubDetail = m.SubDetail
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitDetail.
func (m *ExplanationOfBenefitDetail) Clone() *ExplanationOfBenefitDetail {
	if m == nil { return nil }
	return &ExplanationOfBenefitDetail{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Revenue: m.Revenue.Clone(),
		Category: m.Category.Clone(),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		Udi: cloneSlices(m.Udi),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		SubDetail: cloneSlices(m.SubDetail),
	}
}

// Equals checks equality between two ExplanationOfBenefitDetail instances.
func (m *ExplanationOfBenefitDetail) Equals(other *ExplanationOfBenefitDetail) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Revenue.Equals(other.Revenue) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.SubDetail, other.SubDetail) { return false }
	return true
}

// ExplanationOfBenefitSubDetail
// Third-tier of goods and services.
type ExplanationOfBenefitSubDetail struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Revenue *CodeableConcept `json:"revenue,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
}

// NewExplanationOfBenefitSubDetail creates a new ExplanationOfBenefitSubDetail instance.
func NewExplanationOfBenefitSubDetail() *ExplanationOfBenefitSubDetail {
	return &ExplanationOfBenefitSubDetail{}
}

// FromJSON populates ExplanationOfBenefitSubDetail from JSON data.
func (m *ExplanationOfBenefitSubDetail) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirPositiveInt `json:"sequence,omitempty"`
		Revenue *CodeableConcept `json:"revenue,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor *FhirDecimal `json:"factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.Revenue = temp.Revenue
	m.Category = temp.Category
	m.ProductOrService = temp.ProductOrService
	m.Modifier = temp.Modifier
	m.ProgramCode = temp.ProgramCode
	m.Quantity = temp.Quantity
	m.UnitPrice = temp.UnitPrice
	m.Factor = temp.Factor
	m.Net = temp.Net
	m.Udi = temp.Udi
	if len(temp.NoteNumber) > 0 {
		m.NoteNumber = make([]*FhirPositiveInt, len(temp.NoteNumber))
		for i := range temp.NoteNumber {
			itemMap, ok := temp.NoteNumber[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for NoteNumber[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse NoteNumber[%d]: %v", i, err) }
			m.NoteNumber[i] = primitive
		}
	}
	m.Adjudication = temp.Adjudication
	return nil
}

// ToJSON converts ExplanationOfBenefitSubDetail to JSON data.
func (m *ExplanationOfBenefitSubDetail) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		Revenue *CodeableConcept `json:"revenue,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor interface{} `json:"factor,omitempty"`
		FactorElement map[string]interface{} `json:"_factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		Udi []*Reference `json:"udi,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		NoteNumberElement []map[string]interface{} `json:"_notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.ToJSON())
		}
	}
	output.Revenue = m.Revenue
	output.Category = m.Category
	output.ProductOrService = m.ProductOrService
	output.Modifier = m.Modifier
	output.ProgramCode = m.ProgramCode
	output.Quantity = m.Quantity
	output.UnitPrice = m.UnitPrice
	if m.Factor != nil && m.Factor.Value != nil {
		output.Factor = m.Factor.Value
		if m.Factor.Element != nil {
			output.FactorElement = toMapOrNil(m.Factor.Element.ToJSON())
		}
	}
	output.Net = m.Net
	output.Udi = m.Udi
	if len(m.NoteNumber) > 0 {
		output.NoteNumber = make([]interface{}, len(m.NoteNumber))
		output.NoteNumberElement = make([]map[string]interface{}, len(m.NoteNumber))
		for i, item := range m.NoteNumber {
			if item != nil && item.Value != nil {
				output.NoteNumber[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.NoteNumberElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Adjudication = m.Adjudication
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitSubDetail.
func (m *ExplanationOfBenefitSubDetail) Clone() *ExplanationOfBenefitSubDetail {
	if m == nil { return nil }
	return &ExplanationOfBenefitSubDetail{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Revenue: m.Revenue.Clone(),
		Category: m.Category.Clone(),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		Udi: cloneSlices(m.Udi),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
	}
}

// Equals checks equality between two ExplanationOfBenefitSubDetail instances.
func (m *ExplanationOfBenefitSubDetail) Equals(other *ExplanationOfBenefitSubDetail) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Revenue.Equals(other.Revenue) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	return true
}

// ExplanationOfBenefitAddItem
// The first-tier service adjudications for payor added product or service lines.
type ExplanationOfBenefitAddItem struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemSequence []*FhirPositiveInt `json:"itemsequence,omitempty"`
	DetailSequence []*FhirPositiveInt `json:"detailsequence,omitempty"`
	SubDetailSequence []*FhirPositiveInt `json:"subdetailsequence,omitempty"`
	Provider []*Reference `json:"provider,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	ServicedDate *FhirDate `json:"serviceddate,omitempty"`
	ServicedPeriod *Period `json:"servicedperiod,omitempty"`
	LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
	LocationAddress *Address `json:"locationaddress,omitempty"`
	LocationReference *Reference `json:"locationreference,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	BodySite *CodeableConcept `json:"bodysite,omitempty"`
	SubSite []*CodeableConcept `json:"subsite,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
}

// NewExplanationOfBenefitAddItem creates a new ExplanationOfBenefitAddItem instance.
func NewExplanationOfBenefitAddItem() *ExplanationOfBenefitAddItem {
	return &ExplanationOfBenefitAddItem{}
}

// FromJSON populates ExplanationOfBenefitAddItem from JSON data.
func (m *ExplanationOfBenefitAddItem) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ItemSequence []interface{} `json:"itemsequence,omitempty"`
		DetailSequence []interface{} `json:"detailsequence,omitempty"`
		SubDetailSequence []interface{} `json:"subdetailsequence,omitempty"`
		Provider []*Reference `json:"provider,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		ServicedDate *FhirDate `json:"serviceddate,omitempty"`
		ServicedPeriod *Period `json:"servicedperiod,omitempty"`
		LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
		LocationAddress *Address `json:"locationaddress,omitempty"`
		LocationReference *Reference `json:"locationreference,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor *FhirDecimal `json:"factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		BodySite *CodeableConcept `json:"bodysite,omitempty"`
		SubSite []*CodeableConcept `json:"subsite,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	if len(temp.ItemSequence) > 0 {
		m.ItemSequence = make([]*FhirPositiveInt, len(temp.ItemSequence))
		for i := range temp.ItemSequence {
			itemMap, ok := temp.ItemSequence[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for ItemSequence[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse ItemSequence[%d]: %v", i, err) }
			m.ItemSequence[i] = primitive
		}
	}
	if len(temp.DetailSequence) > 0 {
		m.DetailSequence = make([]*FhirPositiveInt, len(temp.DetailSequence))
		for i := range temp.DetailSequence {
			itemMap, ok := temp.DetailSequence[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for DetailSequence[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse DetailSequence[%d]: %v", i, err) }
			m.DetailSequence[i] = primitive
		}
	}
	if len(temp.SubDetailSequence) > 0 {
		m.SubDetailSequence = make([]*FhirPositiveInt, len(temp.SubDetailSequence))
		for i := range temp.SubDetailSequence {
			itemMap, ok := temp.SubDetailSequence[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for SubDetailSequence[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse SubDetailSequence[%d]: %v", i, err) }
			m.SubDetailSequence[i] = primitive
		}
	}
	m.Provider = temp.Provider
	m.ProductOrService = temp.ProductOrService
	m.Modifier = temp.Modifier
	m.ProgramCode = temp.ProgramCode
	m.ServicedDate = temp.ServicedDate
	m.ServicedPeriod = temp.ServicedPeriod
	m.LocationCodeableConcept = temp.LocationCodeableConcept
	m.LocationAddress = temp.LocationAddress
	m.LocationReference = temp.LocationReference
	m.Quantity = temp.Quantity
	m.UnitPrice = temp.UnitPrice
	m.Factor = temp.Factor
	m.Net = temp.Net
	m.BodySite = temp.BodySite
	m.SubSite = temp.SubSite
	if len(temp.NoteNumber) > 0 {
		m.NoteNumber = make([]*FhirPositiveInt, len(temp.NoteNumber))
		for i := range temp.NoteNumber {
			itemMap, ok := temp.NoteNumber[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for NoteNumber[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse NoteNumber[%d]: %v", i, err) }
			m.NoteNumber[i] = primitive
		}
	}
	m.Adjudication = temp.Adjudication
	m.Detail = temp.Detail
	return nil
}

// ToJSON converts ExplanationOfBenefitAddItem to JSON data.
func (m *ExplanationOfBenefitAddItem) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ItemSequence []interface{} `json:"itemsequence,omitempty"`
		ItemSequenceElement []map[string]interface{} `json:"_itemsequence,omitempty"`
		DetailSequence []interface{} `json:"detailsequence,omitempty"`
		DetailSequenceElement []map[string]interface{} `json:"_detailsequence,omitempty"`
		SubDetailSequence []interface{} `json:"subdetailsequence,omitempty"`
		SubDetailSequenceElement []map[string]interface{} `json:"_subdetailsequence,omitempty"`
		Provider []*Reference `json:"provider,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
		ServicedDate interface{} `json:"serviceddate,omitempty"`
		ServicedDateElement map[string]interface{} `json:"_serviceddate,omitempty"`
		ServicedPeriod *Period `json:"servicedperiod,omitempty"`
		LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
		LocationAddress *Address `json:"locationaddress,omitempty"`
		LocationReference *Reference `json:"locationreference,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor interface{} `json:"factor,omitempty"`
		FactorElement map[string]interface{} `json:"_factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		BodySite *CodeableConcept `json:"bodysite,omitempty"`
		SubSite []*CodeableConcept `json:"subsite,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		NoteNumberElement []map[string]interface{} `json:"_notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if len(m.ItemSequence) > 0 {
		output.ItemSequence = make([]interface{}, len(m.ItemSequence))
		output.ItemSequenceElement = make([]map[string]interface{}, len(m.ItemSequence))
		for i, item := range m.ItemSequence {
			if item != nil && item.Value != nil {
				output.ItemSequence[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.ItemSequenceElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	if len(m.DetailSequence) > 0 {
		output.DetailSequence = make([]interface{}, len(m.DetailSequence))
		output.DetailSequenceElement = make([]map[string]interface{}, len(m.DetailSequence))
		for i, item := range m.DetailSequence {
			if item != nil && item.Value != nil {
				output.DetailSequence[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.DetailSequenceElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	if len(m.SubDetailSequence) > 0 {
		output.SubDetailSequence = make([]interface{}, len(m.SubDetailSequence))
		output.SubDetailSequenceElement = make([]map[string]interface{}, len(m.SubDetailSequence))
		for i, item := range m.SubDetailSequence {
			if item != nil && item.Value != nil {
				output.SubDetailSequence[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.SubDetailSequenceElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Provider = m.Provider
	output.ProductOrService = m.ProductOrService
	output.Modifier = m.Modifier
	output.ProgramCode = m.ProgramCode
	if m.ServicedDate != nil && m.ServicedDate.Value != nil {
		output.ServicedDate = m.ServicedDate.Value
		if m.ServicedDate.Element != nil {
			output.ServicedDateElement = toMapOrNil(m.ServicedDate.Element.ToJSON())
		}
	}
	output.ServicedPeriod = m.ServicedPeriod
	output.LocationCodeableConcept = m.LocationCodeableConcept
	output.LocationAddress = m.LocationAddress
	output.LocationReference = m.LocationReference
	output.Quantity = m.Quantity
	output.UnitPrice = m.UnitPrice
	if m.Factor != nil && m.Factor.Value != nil {
		output.Factor = m.Factor.Value
		if m.Factor.Element != nil {
			output.FactorElement = toMapOrNil(m.Factor.Element.ToJSON())
		}
	}
	output.Net = m.Net
	output.BodySite = m.BodySite
	output.SubSite = m.SubSite
	if len(m.NoteNumber) > 0 {
		output.NoteNumber = make([]interface{}, len(m.NoteNumber))
		output.NoteNumberElement = make([]map[string]interface{}, len(m.NoteNumber))
		for i, item := range m.NoteNumber {
			if item != nil && item.Value != nil {
				output.NoteNumber[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.NoteNumberElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Adjudication = m.Adjudication
	output.Detail = m.Detail
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitAddItem.
func (m *ExplanationOfBenefitAddItem) Clone() *ExplanationOfBenefitAddItem {
	if m == nil { return nil }
	return &ExplanationOfBenefitAddItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemSequence: cloneSlices(m.ItemSequence),
		DetailSequence: cloneSlices(m.DetailSequence),
		SubDetailSequence: cloneSlices(m.SubDetailSequence),
		Provider: cloneSlices(m.Provider),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		ServicedDate: m.ServicedDate.Clone(),
		ServicedPeriod: m.ServicedPeriod.Clone(),
		LocationCodeableConcept: m.LocationCodeableConcept.Clone(),
		LocationAddress: m.LocationAddress.Clone(),
		LocationReference: m.LocationReference.Clone(),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		BodySite: m.BodySite.Clone(),
		SubSite: cloneSlices(m.SubSite),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks equality between two ExplanationOfBenefitAddItem instances.
func (m *ExplanationOfBenefitAddItem) Equals(other *ExplanationOfBenefitAddItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.ItemSequence, other.ItemSequence) { return false }
	if !compareSlices(m.DetailSequence, other.DetailSequence) { return false }
	if !compareSlices(m.SubDetailSequence, other.SubDetailSequence) { return false }
	if !compareSlices(m.Provider, other.Provider) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.ServicedDate.Equals(other.ServicedDate) { return false }
	if !m.ServicedPeriod.Equals(other.ServicedPeriod) { return false }
	if !m.LocationCodeableConcept.Equals(other.LocationCodeableConcept) { return false }
	if !m.LocationAddress.Equals(other.LocationAddress) { return false }
	if !m.LocationReference.Equals(other.LocationReference) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !compareSlices(m.SubSite, other.SubSite) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// ExplanationOfBenefitDetail1
// The second-tier service adjudications for payor added services.
type ExplanationOfBenefitDetail1 struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
}

// NewExplanationOfBenefitDetail1 creates a new ExplanationOfBenefitDetail1 instance.
func NewExplanationOfBenefitDetail1() *ExplanationOfBenefitDetail1 {
	return &ExplanationOfBenefitDetail1{}
}

// FromJSON populates ExplanationOfBenefitDetail1 from JSON data.
func (m *ExplanationOfBenefitDetail1) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor *FhirDecimal `json:"factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.ProductOrService = temp.ProductOrService
	m.Modifier = temp.Modifier
	m.Quantity = temp.Quantity
	m.UnitPrice = temp.UnitPrice
	m.Factor = temp.Factor
	m.Net = temp.Net
	if len(temp.NoteNumber) > 0 {
		m.NoteNumber = make([]*FhirPositiveInt, len(temp.NoteNumber))
		for i := range temp.NoteNumber {
			itemMap, ok := temp.NoteNumber[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for NoteNumber[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse NoteNumber[%d]: %v", i, err) }
			m.NoteNumber[i] = primitive
		}
	}
	m.Adjudication = temp.Adjudication
	m.SubDetail = temp.SubDetail
	return nil
}

// ToJSON converts ExplanationOfBenefitDetail1 to JSON data.
func (m *ExplanationOfBenefitDetail1) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor interface{} `json:"factor,omitempty"`
		FactorElement map[string]interface{} `json:"_factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		NoteNumberElement []map[string]interface{} `json:"_notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
		SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.ProductOrService = m.ProductOrService
	output.Modifier = m.Modifier
	output.Quantity = m.Quantity
	output.UnitPrice = m.UnitPrice
	if m.Factor != nil && m.Factor.Value != nil {
		output.Factor = m.Factor.Value
		if m.Factor.Element != nil {
			output.FactorElement = toMapOrNil(m.Factor.Element.ToJSON())
		}
	}
	output.Net = m.Net
	if len(m.NoteNumber) > 0 {
		output.NoteNumber = make([]interface{}, len(m.NoteNumber))
		output.NoteNumberElement = make([]map[string]interface{}, len(m.NoteNumber))
		for i, item := range m.NoteNumber {
			if item != nil && item.Value != nil {
				output.NoteNumber[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.NoteNumberElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Adjudication = m.Adjudication
	output.SubDetail = m.SubDetail
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitDetail1.
func (m *ExplanationOfBenefitDetail1) Clone() *ExplanationOfBenefitDetail1 {
	if m == nil { return nil }
	return &ExplanationOfBenefitDetail1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		SubDetail: cloneSlices(m.SubDetail),
	}
}

// Equals checks equality between two ExplanationOfBenefitDetail1 instances.
func (m *ExplanationOfBenefitDetail1) Equals(other *ExplanationOfBenefitDetail1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.SubDetail, other.SubDetail) { return false }
	return true
}

// ExplanationOfBenefitSubDetail1
// The third-tier service adjudications for payor added services.
type ExplanationOfBenefitSubDetail1 struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
}

// NewExplanationOfBenefitSubDetail1 creates a new ExplanationOfBenefitSubDetail1 instance.
func NewExplanationOfBenefitSubDetail1() *ExplanationOfBenefitSubDetail1 {
	return &ExplanationOfBenefitSubDetail1{}
}

// FromJSON populates ExplanationOfBenefitSubDetail1 from JSON data.
func (m *ExplanationOfBenefitSubDetail1) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor *FhirDecimal `json:"factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.ProductOrService = temp.ProductOrService
	m.Modifier = temp.Modifier
	m.Quantity = temp.Quantity
	m.UnitPrice = temp.UnitPrice
	m.Factor = temp.Factor
	m.Net = temp.Net
	if len(temp.NoteNumber) > 0 {
		m.NoteNumber = make([]*FhirPositiveInt, len(temp.NoteNumber))
		for i := range temp.NoteNumber {
			itemMap, ok := temp.NoteNumber[i].(map[string]interface{})
			if !ok { return fmt.Errorf("invalid value for NoteNumber[%d]: expected map", i) }
			primitive, err := NewFhirPositiveIntFromMap(itemMap)
			if err != nil { return fmt.Errorf("failed to parse NoteNumber[%d]: %v", i, err) }
			m.NoteNumber[i] = primitive
		}
	}
	m.Adjudication = temp.Adjudication
	return nil
}

// ToJSON converts ExplanationOfBenefitSubDetail1 to JSON data.
func (m *ExplanationOfBenefitSubDetail1) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
		Modifier []*CodeableConcept `json:"modifier,omitempty"`
		Quantity *Quantity `json:"quantity,omitempty"`
		UnitPrice *Money `json:"unitprice,omitempty"`
		Factor interface{} `json:"factor,omitempty"`
		FactorElement map[string]interface{} `json:"_factor,omitempty"`
		Net *Money `json:"net,omitempty"`
		NoteNumber []interface{} `json:"notenumber,omitempty"`
		NoteNumberElement []map[string]interface{} `json:"_notenumber,omitempty"`
		Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.ProductOrService = m.ProductOrService
	output.Modifier = m.Modifier
	output.Quantity = m.Quantity
	output.UnitPrice = m.UnitPrice
	if m.Factor != nil && m.Factor.Value != nil {
		output.Factor = m.Factor.Value
		if m.Factor.Element != nil {
			output.FactorElement = toMapOrNil(m.Factor.Element.ToJSON())
		}
	}
	output.Net = m.Net
	if len(m.NoteNumber) > 0 {
		output.NoteNumber = make([]interface{}, len(m.NoteNumber))
		output.NoteNumberElement = make([]map[string]interface{}, len(m.NoteNumber))
		for i, item := range m.NoteNumber {
			if item != nil && item.Value != nil {
				output.NoteNumber[i] = item.Value
			}
			if item != nil && item.Element != nil {
				output.NoteNumberElement[i] = toMapOrNil(item.Element.ToJSON())
			}
		}
	}
	output.Adjudication = m.Adjudication
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitSubDetail1.
func (m *ExplanationOfBenefitSubDetail1) Clone() *ExplanationOfBenefitSubDetail1 {
	if m == nil { return nil }
	return &ExplanationOfBenefitSubDetail1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
	}
}

// Equals checks equality between two ExplanationOfBenefitSubDetail1 instances.
func (m *ExplanationOfBenefitSubDetail1) Equals(other *ExplanationOfBenefitSubDetail1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	return true
}

// ExplanationOfBenefitTotal
// Categorized monetary totals for the adjudication.
type ExplanationOfBenefitTotal struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Amount *Money `json:"amount,omitempty"`
}

// NewExplanationOfBenefitTotal creates a new ExplanationOfBenefitTotal instance.
func NewExplanationOfBenefitTotal() *ExplanationOfBenefitTotal {
	return &ExplanationOfBenefitTotal{}
}

// FromJSON populates ExplanationOfBenefitTotal from JSON data.
func (m *ExplanationOfBenefitTotal) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Amount *Money `json:"amount,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Category = temp.Category
	m.Amount = temp.Amount
	return nil
}

// ToJSON converts ExplanationOfBenefitTotal to JSON data.
func (m *ExplanationOfBenefitTotal) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Amount *Money `json:"amount,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Category = m.Category
	output.Amount = m.Amount
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitTotal.
func (m *ExplanationOfBenefitTotal) Clone() *ExplanationOfBenefitTotal {
	if m == nil { return nil }
	return &ExplanationOfBenefitTotal{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitTotal instances.
func (m *ExplanationOfBenefitTotal) Equals(other *ExplanationOfBenefitTotal) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

// ExplanationOfBenefitPayment
// Payment details for the adjudication of the claim.
type ExplanationOfBenefitPayment struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Adjustment *Money `json:"adjustment,omitempty"`
	AdjustmentReason *CodeableConcept `json:"adjustmentreason,omitempty"`
	Date *FhirDate `json:"date,omitempty"`
	Amount *Money `json:"amount,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
}

// NewExplanationOfBenefitPayment creates a new ExplanationOfBenefitPayment instance.
func NewExplanationOfBenefitPayment() *ExplanationOfBenefitPayment {
	return &ExplanationOfBenefitPayment{}
}

// FromJSON populates ExplanationOfBenefitPayment from JSON data.
func (m *ExplanationOfBenefitPayment) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Adjustment *Money `json:"adjustment,omitempty"`
		AdjustmentReason *CodeableConcept `json:"adjustmentreason,omitempty"`
		Date *FhirDate `json:"date,omitempty"`
		Amount *Money `json:"amount,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Adjustment = temp.Adjustment
	m.AdjustmentReason = temp.AdjustmentReason
	m.Date = temp.Date
	m.Amount = temp.Amount
	m.Identifier = temp.Identifier
	return nil
}

// ToJSON converts ExplanationOfBenefitPayment to JSON data.
func (m *ExplanationOfBenefitPayment) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Adjustment *Money `json:"adjustment,omitempty"`
		AdjustmentReason *CodeableConcept `json:"adjustmentreason,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
		Amount *Money `json:"amount,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Adjustment = m.Adjustment
	output.AdjustmentReason = m.AdjustmentReason
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.ToJSON())
		}
	}
	output.Amount = m.Amount
	output.Identifier = m.Identifier
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitPayment.
func (m *ExplanationOfBenefitPayment) Clone() *ExplanationOfBenefitPayment {
	if m == nil { return nil }
	return &ExplanationOfBenefitPayment{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Adjustment: m.Adjustment.Clone(),
		AdjustmentReason: m.AdjustmentReason.Clone(),
		Date: m.Date.Clone(),
		Amount: m.Amount.Clone(),
		Identifier: m.Identifier.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitPayment instances.
func (m *ExplanationOfBenefitPayment) Equals(other *ExplanationOfBenefitPayment) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Adjustment.Equals(other.Adjustment) { return false }
	if !m.AdjustmentReason.Equals(other.AdjustmentReason) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	return true
}

// ExplanationOfBenefitProcessNote
// A note that describes or explains adjudication results in a human readable form.
type ExplanationOfBenefitProcessNote struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Number *FhirPositiveInt `json:"number,omitempty"`
	Type *NoteType `json:"type,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	Language *CodeableConcept `json:"language,omitempty"`
}

// NewExplanationOfBenefitProcessNote creates a new ExplanationOfBenefitProcessNote instance.
func NewExplanationOfBenefitProcessNote() *ExplanationOfBenefitProcessNote {
	return &ExplanationOfBenefitProcessNote{}
}

// FromJSON populates ExplanationOfBenefitProcessNote from JSON data.
func (m *ExplanationOfBenefitProcessNote) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Number *FhirPositiveInt `json:"number,omitempty"`
		Type *NoteType `json:"type,omitempty"`
		Text *FhirString `json:"text,omitempty"`
		Language *CodeableConcept `json:"language,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Number = temp.Number
	m.Type = temp.Type
	m.Text = temp.Text
	m.Language = temp.Language
	return nil
}

// ToJSON converts ExplanationOfBenefitProcessNote to JSON data.
func (m *ExplanationOfBenefitProcessNote) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Number interface{} `json:"number,omitempty"`
		NumberElement map[string]interface{} `json:"_number,omitempty"`
		Type *NoteType `json:"type,omitempty"`
		Text interface{} `json:"text,omitempty"`
		TextElement map[string]interface{} `json:"_text,omitempty"`
		Language *CodeableConcept `json:"language,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Number != nil && m.Number.Value != nil {
		output.Number = m.Number.Value
		if m.Number.Element != nil {
			output.NumberElement = toMapOrNil(m.Number.Element.ToJSON())
		}
	}
	output.Type = m.Type
	if m.Text != nil && m.Text.Value != nil {
		output.Text = m.Text.Value
		if m.Text.Element != nil {
			output.TextElement = toMapOrNil(m.Text.Element.ToJSON())
		}
	}
	output.Language = m.Language
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitProcessNote.
func (m *ExplanationOfBenefitProcessNote) Clone() *ExplanationOfBenefitProcessNote {
	if m == nil { return nil }
	return &ExplanationOfBenefitProcessNote{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Number: m.Number.Clone(),
		Type: m.Type.Clone(),
		Text: m.Text.Clone(),
		Language: m.Language.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitProcessNote instances.
func (m *ExplanationOfBenefitProcessNote) Equals(other *ExplanationOfBenefitProcessNote) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Number.Equals(other.Number) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !m.Language.Equals(other.Language) { return false }
	return true
}

// ExplanationOfBenefitBenefitBalance
// Balance by Benefit Category.
type ExplanationOfBenefitBenefitBalance struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Excluded *FhirBoolean `json:"excluded,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Network *CodeableConcept `json:"network,omitempty"`
	Unit *CodeableConcept `json:"unit,omitempty"`
	Term *CodeableConcept `json:"term,omitempty"`
	Financial []*ExplanationOfBenefitFinancial `json:"financial,omitempty"`
}

// NewExplanationOfBenefitBenefitBalance creates a new ExplanationOfBenefitBenefitBalance instance.
func NewExplanationOfBenefitBenefitBalance() *ExplanationOfBenefitBenefitBalance {
	return &ExplanationOfBenefitBenefitBalance{}
}

// FromJSON populates ExplanationOfBenefitBenefitBalance from JSON data.
func (m *ExplanationOfBenefitBenefitBalance) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Excluded *FhirBoolean `json:"excluded,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Description *FhirString `json:"description,omitempty"`
		Network *CodeableConcept `json:"network,omitempty"`
		Unit *CodeableConcept `json:"unit,omitempty"`
		Term *CodeableConcept `json:"term,omitempty"`
		Financial []*ExplanationOfBenefitFinancial `json:"financial,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Category = temp.Category
	m.Excluded = temp.Excluded
	m.Name = temp.Name
	m.Description = temp.Description
	m.Network = temp.Network
	m.Unit = temp.Unit
	m.Term = temp.Term
	m.Financial = temp.Financial
	return nil
}

// ToJSON converts ExplanationOfBenefitBenefitBalance to JSON data.
func (m *ExplanationOfBenefitBenefitBalance) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Category *CodeableConcept `json:"category,omitempty"`
		Excluded interface{} `json:"excluded,omitempty"`
		ExcludedElement map[string]interface{} `json:"_excluded,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Network *CodeableConcept `json:"network,omitempty"`
		Unit *CodeableConcept `json:"unit,omitempty"`
		Term *CodeableConcept `json:"term,omitempty"`
		Financial []*ExplanationOfBenefitFinancial `json:"financial,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Category = m.Category
	if m.Excluded != nil && m.Excluded.Value != nil {
		output.Excluded = m.Excluded.Value
		if m.Excluded.Element != nil {
			output.ExcludedElement = toMapOrNil(m.Excluded.Element.ToJSON())
		}
	}
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.ToJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.ToJSON())
		}
	}
	output.Network = m.Network
	output.Unit = m.Unit
	output.Term = m.Term
	output.Financial = m.Financial
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitBenefitBalance.
func (m *ExplanationOfBenefitBenefitBalance) Clone() *ExplanationOfBenefitBenefitBalance {
	if m == nil { return nil }
	return &ExplanationOfBenefitBenefitBalance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Excluded: m.Excluded.Clone(),
		Name: m.Name.Clone(),
		Description: m.Description.Clone(),
		Network: m.Network.Clone(),
		Unit: m.Unit.Clone(),
		Term: m.Term.Clone(),
		Financial: cloneSlices(m.Financial),
	}
}

// Equals checks equality between two ExplanationOfBenefitBenefitBalance instances.
func (m *ExplanationOfBenefitBenefitBalance) Equals(other *ExplanationOfBenefitBenefitBalance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Excluded.Equals(other.Excluded) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Network.Equals(other.Network) { return false }
	if !m.Unit.Equals(other.Unit) { return false }
	if !m.Term.Equals(other.Term) { return false }
	if !compareSlices(m.Financial, other.Financial) { return false }
	return true
}

// ExplanationOfBenefitFinancial
// Benefits Used to date.
type ExplanationOfBenefitFinancial struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	AllowedUnsignedInt *FhirUnsignedInt `json:"allowedunsignedint,omitempty"`
	AllowedString *FhirString `json:"allowedstring,omitempty"`
	AllowedMoney *Money `json:"allowedmoney,omitempty"`
	UsedUnsignedInt *FhirUnsignedInt `json:"usedunsignedint,omitempty"`
	UsedMoney *Money `json:"usedmoney,omitempty"`
}

// NewExplanationOfBenefitFinancial creates a new ExplanationOfBenefitFinancial instance.
func NewExplanationOfBenefitFinancial() *ExplanationOfBenefitFinancial {
	return &ExplanationOfBenefitFinancial{}
}

// FromJSON populates ExplanationOfBenefitFinancial from JSON data.
func (m *ExplanationOfBenefitFinancial) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		AllowedUnsignedInt *FhirUnsignedInt `json:"allowedunsignedint,omitempty"`
		AllowedString *FhirString `json:"allowedstring,omitempty"`
		AllowedMoney *Money `json:"allowedmoney,omitempty"`
		UsedUnsignedInt *FhirUnsignedInt `json:"usedunsignedint,omitempty"`
		UsedMoney *Money `json:"usedmoney,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.AllowedUnsignedInt = temp.AllowedUnsignedInt
	m.AllowedString = temp.AllowedString
	m.AllowedMoney = temp.AllowedMoney
	m.UsedUnsignedInt = temp.UsedUnsignedInt
	m.UsedMoney = temp.UsedMoney
	return nil
}

// ToJSON converts ExplanationOfBenefitFinancial to JSON data.
func (m *ExplanationOfBenefitFinancial) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		AllowedUnsignedInt interface{} `json:"allowedunsignedint,omitempty"`
		AllowedUnsignedIntElement map[string]interface{} `json:"_allowedunsignedint,omitempty"`
		AllowedString interface{} `json:"allowedstring,omitempty"`
		AllowedStringElement map[string]interface{} `json:"_allowedstring,omitempty"`
		AllowedMoney *Money `json:"allowedmoney,omitempty"`
		UsedUnsignedInt interface{} `json:"usedunsignedint,omitempty"`
		UsedUnsignedIntElement map[string]interface{} `json:"_usedunsignedint,omitempty"`
		UsedMoney *Money `json:"usedmoney,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.AllowedUnsignedInt != nil && m.AllowedUnsignedInt.Value != nil {
		output.AllowedUnsignedInt = m.AllowedUnsignedInt.Value
		if m.AllowedUnsignedInt.Element != nil {
			output.AllowedUnsignedIntElement = toMapOrNil(m.AllowedUnsignedInt.Element.ToJSON())
		}
	}
	if m.AllowedString != nil && m.AllowedString.Value != nil {
		output.AllowedString = m.AllowedString.Value
		if m.AllowedString.Element != nil {
			output.AllowedStringElement = toMapOrNil(m.AllowedString.Element.ToJSON())
		}
	}
	output.AllowedMoney = m.AllowedMoney
	if m.UsedUnsignedInt != nil && m.UsedUnsignedInt.Value != nil {
		output.UsedUnsignedInt = m.UsedUnsignedInt.Value
		if m.UsedUnsignedInt.Element != nil {
			output.UsedUnsignedIntElement = toMapOrNil(m.UsedUnsignedInt.Element.ToJSON())
		}
	}
	output.UsedMoney = m.UsedMoney
	return json.Marshal(output)
}

// Clone creates a deep copy of ExplanationOfBenefitFinancial.
func (m *ExplanationOfBenefitFinancial) Clone() *ExplanationOfBenefitFinancial {
	if m == nil { return nil }
	return &ExplanationOfBenefitFinancial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		AllowedUnsignedInt: m.AllowedUnsignedInt.Clone(),
		AllowedString: m.AllowedString.Clone(),
		AllowedMoney: m.AllowedMoney.Clone(),
		UsedUnsignedInt: m.UsedUnsignedInt.Clone(),
		UsedMoney: m.UsedMoney.Clone(),
	}
}

// Equals checks equality between two ExplanationOfBenefitFinancial instances.
func (m *ExplanationOfBenefitFinancial) Equals(other *ExplanationOfBenefitFinancial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.AllowedUnsignedInt.Equals(other.AllowedUnsignedInt) { return false }
	if !m.AllowedString.Equals(other.AllowedString) { return false }
	if !m.AllowedMoney.Equals(other.AllowedMoney) { return false }
	if !m.UsedUnsignedInt.Equals(other.UsedUnsignedInt) { return false }
	if !m.UsedMoney.Equals(other.UsedMoney) { return false }
	return true
}

