// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ExplanationOfBenefit
// This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
type ExplanationOfBenefit struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ExplanationOfBenefitStatus `json:"status,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	SubType *CodeableConcept `json:"subtype,omitempty"`
	Use *Use `json:"use,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	BillablePeriod *Period `json:"billableperiod,omitempty"`
	Created *FhirDateTime `json:"created,omitempty"`
	Enterer *Reference `json:"enterer,omitempty"`
	Insurer *Reference `json:"insurer,omitempty"`
	Provider *Reference `json:"provider,omitempty"`
	Priority *CodeableConcept `json:"priority,omitempty"`
	FundsReserveRequested *CodeableConcept `json:"fundsreserverequested,omitempty"`
	FundsReserve *CodeableConcept `json:"fundsreserve,omitempty"`
	Related []*ExplanationOfBenefitRelated `json:"related,omitempty"`
	Prescription *Reference `json:"prescription,omitempty"`
	OriginalPrescription *Reference `json:"originalprescription,omitempty"`
	Payee *ExplanationOfBenefitPayee `json:"payee,omitempty"`
	Referral *Reference `json:"referral,omitempty"`
	Facility *Reference `json:"facility,omitempty"`
	Claim *Reference `json:"claim,omitempty"`
	ClaimResponse *Reference `json:"claimresponse,omitempty"`
	Outcome *RemittanceOutcome `json:"outcome,omitempty"`
	Disposition *FhirString `json:"disposition,omitempty"`
	PreAuthRef []*FhirString `json:"preauthref,omitempty"`
	PreAuthRefPeriod []*Period `json:"preauthrefperiod,omitempty"`
	CareTeam []*ExplanationOfBenefitCareTeam `json:"careteam,omitempty"`
	SupportingInfo []*ExplanationOfBenefitSupportingInfo `json:"supportinginfo,omitempty"`
	Diagnosis []*ExplanationOfBenefitDiagnosis `json:"diagnosis,omitempty"`
	Procedure []*ExplanationOfBenefitProcedure `json:"procedure,omitempty"`
	Precedence *FhirPositiveInt `json:"precedence,omitempty"`
	Insurance []*ExplanationOfBenefitInsurance `json:"insurance,omitempty"`
	Accident *ExplanationOfBenefitAccident `json:"accident,omitempty"`
	Item []*ExplanationOfBenefitItem `json:"item,omitempty"`
	AddItem []*ExplanationOfBenefitAddItem `json:"additem,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	Total []*ExplanationOfBenefitTotal `json:"total,omitempty"`
	Payment *ExplanationOfBenefitPayment `json:"payment,omitempty"`
	FormCode *CodeableConcept `json:"formcode,omitempty"`
	Form *Attachment `json:"form,omitempty"`
	ProcessNote []*ExplanationOfBenefitProcessNote `json:"processnote,omitempty"`
	BenefitPeriod *Period `json:"benefitperiod,omitempty"`
	BenefitBalance []*ExplanationOfBenefitBenefitBalance `json:"benefitbalance,omitempty"`
}

// NewExplanationOfBenefit creates a new ExplanationOfBenefit instance
func NewExplanationOfBenefit() *ExplanationOfBenefit {
	return &ExplanationOfBenefit{}
}

// FromJSON populates ExplanationOfBenefit from JSON data
func (m *ExplanationOfBenefit) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefit to JSON data
func (m *ExplanationOfBenefit) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefit
func (m *ExplanationOfBenefit) Clone() *ExplanationOfBenefit {
	if m == nil { return nil }
	return &ExplanationOfBenefit{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		SubType: m.SubType.Clone(),
		Use: m.Use.Clone(),
		Patient: m.Patient.Clone(),
		BillablePeriod: m.BillablePeriod.Clone(),
		Created: m.Created.Clone(),
		Enterer: m.Enterer.Clone(),
		Insurer: m.Insurer.Clone(),
		Provider: m.Provider.Clone(),
		Priority: m.Priority.Clone(),
		FundsReserveRequested: m.FundsReserveRequested.Clone(),
		FundsReserve: m.FundsReserve.Clone(),
		Related: cloneSlices(m.Related),
		Prescription: m.Prescription.Clone(),
		OriginalPrescription: m.OriginalPrescription.Clone(),
		Payee: m.Payee.Clone(),
		Referral: m.Referral.Clone(),
		Facility: m.Facility.Clone(),
		Claim: m.Claim.Clone(),
		ClaimResponse: m.ClaimResponse.Clone(),
		Outcome: m.Outcome.Clone(),
		Disposition: m.Disposition.Clone(),
		PreAuthRef: cloneSlices(m.PreAuthRef),
		PreAuthRefPeriod: cloneSlices(m.PreAuthRefPeriod),
		CareTeam: cloneSlices(m.CareTeam),
		SupportingInfo: cloneSlices(m.SupportingInfo),
		Diagnosis: cloneSlices(m.Diagnosis),
		Procedure: cloneSlices(m.Procedure),
		Precedence: m.Precedence.Clone(),
		Insurance: cloneSlices(m.Insurance),
		Accident: m.Accident.Clone(),
		Item: cloneSlices(m.Item),
		AddItem: cloneSlices(m.AddItem),
		Adjudication: cloneSlices(m.Adjudication),
		Total: cloneSlices(m.Total),
		Payment: m.Payment.Clone(),
		FormCode: m.FormCode.Clone(),
		Form: m.Form.Clone(),
		ProcessNote: cloneSlices(m.ProcessNote),
		BenefitPeriod: m.BenefitPeriod.Clone(),
		BenefitBalance: cloneSlices(m.BenefitBalance),
	}
}

// Equals checks for equality with another ExplanationOfBenefit instance
func (m *ExplanationOfBenefit) Equals(other *ExplanationOfBenefit) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.SubType.Equals(other.SubType) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.BillablePeriod.Equals(other.BillablePeriod) { return false }
	if !m.Created.Equals(other.Created) { return false }
	if !m.Enterer.Equals(other.Enterer) { return false }
	if !m.Insurer.Equals(other.Insurer) { return false }
	if !m.Provider.Equals(other.Provider) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.FundsReserveRequested.Equals(other.FundsReserveRequested) { return false }
	if !m.FundsReserve.Equals(other.FundsReserve) { return false }
	if !compareSlices(m.Related, other.Related) { return false }
	if !m.Prescription.Equals(other.Prescription) { return false }
	if !m.OriginalPrescription.Equals(other.OriginalPrescription) { return false }
	if !m.Payee.Equals(other.Payee) { return false }
	if !m.Referral.Equals(other.Referral) { return false }
	if !m.Facility.Equals(other.Facility) { return false }
	if !m.Claim.Equals(other.Claim) { return false }
	if !m.ClaimResponse.Equals(other.ClaimResponse) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	if !m.Disposition.Equals(other.Disposition) { return false }
	if !compareSlices(m.PreAuthRef, other.PreAuthRef) { return false }
	if !compareSlices(m.PreAuthRefPeriod, other.PreAuthRefPeriod) { return false }
	if !compareSlices(m.CareTeam, other.CareTeam) { return false }
	if !compareSlices(m.SupportingInfo, other.SupportingInfo) { return false }
	if !compareSlices(m.Diagnosis, other.Diagnosis) { return false }
	if !compareSlices(m.Procedure, other.Procedure) { return false }
	if !m.Precedence.Equals(other.Precedence) { return false }
	if !compareSlices(m.Insurance, other.Insurance) { return false }
	if !m.Accident.Equals(other.Accident) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	if !compareSlices(m.AddItem, other.AddItem) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Total, other.Total) { return false }
	if !m.Payment.Equals(other.Payment) { return false }
	if !m.FormCode.Equals(other.FormCode) { return false }
	if !m.Form.Equals(other.Form) { return false }
	if !compareSlices(m.ProcessNote, other.ProcessNote) { return false }
	if !m.BenefitPeriod.Equals(other.BenefitPeriod) { return false }
	if !compareSlices(m.BenefitBalance, other.BenefitBalance) { return false }
	return true
}

// ExplanationOfBenefitRelated
// Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
type ExplanationOfBenefitRelated struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Claim *Reference `json:"claim,omitempty"`
	Relationship *CodeableConcept `json:"relationship,omitempty"`
	Reference *Identifier `json:"reference,omitempty"`
}

// NewExplanationOfBenefitRelated creates a new ExplanationOfBenefitRelated instance
func NewExplanationOfBenefitRelated() *ExplanationOfBenefitRelated {
	return &ExplanationOfBenefitRelated{}
}

// FromJSON populates ExplanationOfBenefitRelated from JSON data
func (m *ExplanationOfBenefitRelated) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitRelated to JSON data
func (m *ExplanationOfBenefitRelated) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitRelated
func (m *ExplanationOfBenefitRelated) Clone() *ExplanationOfBenefitRelated {
	if m == nil { return nil }
	return &ExplanationOfBenefitRelated{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Claim: m.Claim.Clone(),
		Relationship: m.Relationship.Clone(),
		Reference: m.Reference.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitRelated instance
func (m *ExplanationOfBenefitRelated) Equals(other *ExplanationOfBenefitRelated) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Claim.Equals(other.Claim) { return false }
	if !m.Relationship.Equals(other.Relationship) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	return true
}

// ExplanationOfBenefitPayee
// The party to be reimbursed for cost of the products and services according to the terms of the policy.
type ExplanationOfBenefitPayee struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Party *Reference `json:"party,omitempty"`
}

// NewExplanationOfBenefitPayee creates a new ExplanationOfBenefitPayee instance
func NewExplanationOfBenefitPayee() *ExplanationOfBenefitPayee {
	return &ExplanationOfBenefitPayee{}
}

// FromJSON populates ExplanationOfBenefitPayee from JSON data
func (m *ExplanationOfBenefitPayee) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitPayee to JSON data
func (m *ExplanationOfBenefitPayee) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitPayee
func (m *ExplanationOfBenefitPayee) Clone() *ExplanationOfBenefitPayee {
	if m == nil { return nil }
	return &ExplanationOfBenefitPayee{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Party: m.Party.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitPayee instance
func (m *ExplanationOfBenefitPayee) Equals(other *ExplanationOfBenefitPayee) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Party.Equals(other.Party) { return false }
	return true
}

// ExplanationOfBenefitCareTeam
// The members of the team who provided the products and services.
type ExplanationOfBenefitCareTeam struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Provider *Reference `json:"provider,omitempty"`
	Responsible *FhirBoolean `json:"responsible,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	Qualification *CodeableConcept `json:"qualification,omitempty"`
}

// NewExplanationOfBenefitCareTeam creates a new ExplanationOfBenefitCareTeam instance
func NewExplanationOfBenefitCareTeam() *ExplanationOfBenefitCareTeam {
	return &ExplanationOfBenefitCareTeam{}
}

// FromJSON populates ExplanationOfBenefitCareTeam from JSON data
func (m *ExplanationOfBenefitCareTeam) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitCareTeam to JSON data
func (m *ExplanationOfBenefitCareTeam) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitCareTeam
func (m *ExplanationOfBenefitCareTeam) Clone() *ExplanationOfBenefitCareTeam {
	if m == nil { return nil }
	return &ExplanationOfBenefitCareTeam{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Provider: m.Provider.Clone(),
		Responsible: m.Responsible.Clone(),
		Role: m.Role.Clone(),
		Qualification: m.Qualification.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitCareTeam instance
func (m *ExplanationOfBenefitCareTeam) Equals(other *ExplanationOfBenefitCareTeam) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Provider.Equals(other.Provider) { return false }
	if !m.Responsible.Equals(other.Responsible) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Qualification.Equals(other.Qualification) { return false }
	return true
}

// ExplanationOfBenefitSupportingInfo
// Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
type ExplanationOfBenefitSupportingInfo struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	TimingDate *FhirDate `json:"timingdate,omitempty"`
	TimingPeriod *Period `json:"timingperiod,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	Reason *Coding `json:"reason,omitempty"`
}

// NewExplanationOfBenefitSupportingInfo creates a new ExplanationOfBenefitSupportingInfo instance
func NewExplanationOfBenefitSupportingInfo() *ExplanationOfBenefitSupportingInfo {
	return &ExplanationOfBenefitSupportingInfo{}
}

// FromJSON populates ExplanationOfBenefitSupportingInfo from JSON data
func (m *ExplanationOfBenefitSupportingInfo) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitSupportingInfo to JSON data
func (m *ExplanationOfBenefitSupportingInfo) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitSupportingInfo
func (m *ExplanationOfBenefitSupportingInfo) Clone() *ExplanationOfBenefitSupportingInfo {
	if m == nil { return nil }
	return &ExplanationOfBenefitSupportingInfo{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Category: m.Category.Clone(),
		Code: m.Code.Clone(),
		TimingDate: m.TimingDate.Clone(),
		TimingPeriod: m.TimingPeriod.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueReference: m.ValueReference.Clone(),
		Reason: m.Reason.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitSupportingInfo instance
func (m *ExplanationOfBenefitSupportingInfo) Equals(other *ExplanationOfBenefitSupportingInfo) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.TimingDate.Equals(other.TimingDate) { return false }
	if !m.TimingPeriod.Equals(other.TimingPeriod) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	return true
}

// ExplanationOfBenefitDiagnosis
// Information about diagnoses relevant to the claim items.
type ExplanationOfBenefitDiagnosis struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	DiagnosisCodeableConcept *CodeableConcept `json:"diagnosiscodeableconcept,omitempty"`
	DiagnosisReference *Reference `json:"diagnosisreference,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	OnAdmission *CodeableConcept `json:"onadmission,omitempty"`
	PackageCode *CodeableConcept `json:"packagecode,omitempty"`
}

// NewExplanationOfBenefitDiagnosis creates a new ExplanationOfBenefitDiagnosis instance
func NewExplanationOfBenefitDiagnosis() *ExplanationOfBenefitDiagnosis {
	return &ExplanationOfBenefitDiagnosis{}
}

// FromJSON populates ExplanationOfBenefitDiagnosis from JSON data
func (m *ExplanationOfBenefitDiagnosis) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitDiagnosis to JSON data
func (m *ExplanationOfBenefitDiagnosis) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitDiagnosis
func (m *ExplanationOfBenefitDiagnosis) Clone() *ExplanationOfBenefitDiagnosis {
	if m == nil { return nil }
	return &ExplanationOfBenefitDiagnosis{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		DiagnosisCodeableConcept: m.DiagnosisCodeableConcept.Clone(),
		DiagnosisReference: m.DiagnosisReference.Clone(),
		Type: cloneSlices(m.Type),
		OnAdmission: m.OnAdmission.Clone(),
		PackageCode: m.PackageCode.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitDiagnosis instance
func (m *ExplanationOfBenefitDiagnosis) Equals(other *ExplanationOfBenefitDiagnosis) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.DiagnosisCodeableConcept.Equals(other.DiagnosisCodeableConcept) { return false }
	if !m.DiagnosisReference.Equals(other.DiagnosisReference) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.OnAdmission.Equals(other.OnAdmission) { return false }
	if !m.PackageCode.Equals(other.PackageCode) { return false }
	return true
}

// ExplanationOfBenefitProcedure
// Procedures performed on the patient relevant to the billing items with the claim.
type ExplanationOfBenefitProcedure struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	ProcedureCodeableConcept *CodeableConcept `json:"procedurecodeableconcept,omitempty"`
	ProcedureReference *Reference `json:"procedurereference,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
}

// NewExplanationOfBenefitProcedure creates a new ExplanationOfBenefitProcedure instance
func NewExplanationOfBenefitProcedure() *ExplanationOfBenefitProcedure {
	return &ExplanationOfBenefitProcedure{}
}

// FromJSON populates ExplanationOfBenefitProcedure from JSON data
func (m *ExplanationOfBenefitProcedure) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitProcedure to JSON data
func (m *ExplanationOfBenefitProcedure) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitProcedure
func (m *ExplanationOfBenefitProcedure) Clone() *ExplanationOfBenefitProcedure {
	if m == nil { return nil }
	return &ExplanationOfBenefitProcedure{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Type: cloneSlices(m.Type),
		Date: m.Date.Clone(),
		ProcedureCodeableConcept: m.ProcedureCodeableConcept.Clone(),
		ProcedureReference: m.ProcedureReference.Clone(),
		Udi: cloneSlices(m.Udi),
	}
}

// Equals checks for equality with another ExplanationOfBenefitProcedure instance
func (m *ExplanationOfBenefitProcedure) Equals(other *ExplanationOfBenefitProcedure) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.ProcedureCodeableConcept.Equals(other.ProcedureCodeableConcept) { return false }
	if !m.ProcedureReference.Equals(other.ProcedureReference) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	return true
}

// ExplanationOfBenefitInsurance
// Financial instruments for reimbursement for the health care products and services specified on the claim.
type ExplanationOfBenefitInsurance struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Focal *FhirBoolean `json:"focal,omitempty"`
	Coverage *Reference `json:"coverage,omitempty"`
	PreAuthRef []*FhirString `json:"preauthref,omitempty"`
}

// NewExplanationOfBenefitInsurance creates a new ExplanationOfBenefitInsurance instance
func NewExplanationOfBenefitInsurance() *ExplanationOfBenefitInsurance {
	return &ExplanationOfBenefitInsurance{}
}

// FromJSON populates ExplanationOfBenefitInsurance from JSON data
func (m *ExplanationOfBenefitInsurance) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitInsurance to JSON data
func (m *ExplanationOfBenefitInsurance) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitInsurance
func (m *ExplanationOfBenefitInsurance) Clone() *ExplanationOfBenefitInsurance {
	if m == nil { return nil }
	return &ExplanationOfBenefitInsurance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Focal: m.Focal.Clone(),
		Coverage: m.Coverage.Clone(),
		PreAuthRef: cloneSlices(m.PreAuthRef),
	}
}

// Equals checks for equality with another ExplanationOfBenefitInsurance instance
func (m *ExplanationOfBenefitInsurance) Equals(other *ExplanationOfBenefitInsurance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Focal.Equals(other.Focal) { return false }
	if !m.Coverage.Equals(other.Coverage) { return false }
	if !compareSlices(m.PreAuthRef, other.PreAuthRef) { return false }
	return true
}

// ExplanationOfBenefitAccident
// Details of a accident which resulted in injuries which required the products and services listed in the claim.
type ExplanationOfBenefitAccident struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Date *FhirDate `json:"date,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	LocationAddress *Address `json:"locationaddress,omitempty"`
	LocationReference *Reference `json:"locationreference,omitempty"`
}

// NewExplanationOfBenefitAccident creates a new ExplanationOfBenefitAccident instance
func NewExplanationOfBenefitAccident() *ExplanationOfBenefitAccident {
	return &ExplanationOfBenefitAccident{}
}

// FromJSON populates ExplanationOfBenefitAccident from JSON data
func (m *ExplanationOfBenefitAccident) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitAccident to JSON data
func (m *ExplanationOfBenefitAccident) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitAccident
func (m *ExplanationOfBenefitAccident) Clone() *ExplanationOfBenefitAccident {
	if m == nil { return nil }
	return &ExplanationOfBenefitAccident{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Date: m.Date.Clone(),
		Type: m.Type.Clone(),
		LocationAddress: m.LocationAddress.Clone(),
		LocationReference: m.LocationReference.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitAccident instance
func (m *ExplanationOfBenefitAccident) Equals(other *ExplanationOfBenefitAccident) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.LocationAddress.Equals(other.LocationAddress) { return false }
	if !m.LocationReference.Equals(other.LocationReference) { return false }
	return true
}

// ExplanationOfBenefitItem
// A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
type ExplanationOfBenefitItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	CareTeamSequence []*FhirPositiveInt `json:"careteamsequence,omitempty"`
	DiagnosisSequence []*FhirPositiveInt `json:"diagnosissequence,omitempty"`
	ProcedureSequence []*FhirPositiveInt `json:"proceduresequence,omitempty"`
	InformationSequence []*FhirPositiveInt `json:"informationsequence,omitempty"`
	Revenue *CodeableConcept `json:"revenue,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	ServicedDate *FhirDate `json:"serviceddate,omitempty"`
	ServicedPeriod *Period `json:"servicedperiod,omitempty"`
	LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
	LocationAddress *Address `json:"locationaddress,omitempty"`
	LocationReference *Reference `json:"locationreference,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
	BodySite *CodeableConcept `json:"bodysite,omitempty"`
	SubSite []*CodeableConcept `json:"subsite,omitempty"`
	Encounter []*Reference `json:"encounter,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
}

// NewExplanationOfBenefitItem creates a new ExplanationOfBenefitItem instance
func NewExplanationOfBenefitItem() *ExplanationOfBenefitItem {
	return &ExplanationOfBenefitItem{}
}

// FromJSON populates ExplanationOfBenefitItem from JSON data
func (m *ExplanationOfBenefitItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitItem to JSON data
func (m *ExplanationOfBenefitItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitItem
func (m *ExplanationOfBenefitItem) Clone() *ExplanationOfBenefitItem {
	if m == nil { return nil }
	return &ExplanationOfBenefitItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		CareTeamSequence: cloneSlices(m.CareTeamSequence),
		DiagnosisSequence: cloneSlices(m.DiagnosisSequence),
		ProcedureSequence: cloneSlices(m.ProcedureSequence),
		InformationSequence: cloneSlices(m.InformationSequence),
		Revenue: m.Revenue.Clone(),
		Category: m.Category.Clone(),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		ServicedDate: m.ServicedDate.Clone(),
		ServicedPeriod: m.ServicedPeriod.Clone(),
		LocationCodeableConcept: m.LocationCodeableConcept.Clone(),
		LocationAddress: m.LocationAddress.Clone(),
		LocationReference: m.LocationReference.Clone(),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		Udi: cloneSlices(m.Udi),
		BodySite: m.BodySite.Clone(),
		SubSite: cloneSlices(m.SubSite),
		Encounter: cloneSlices(m.Encounter),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks for equality with another ExplanationOfBenefitItem instance
func (m *ExplanationOfBenefitItem) Equals(other *ExplanationOfBenefitItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !compareSlices(m.CareTeamSequence, other.CareTeamSequence) { return false }
	if !compareSlices(m.DiagnosisSequence, other.DiagnosisSequence) { return false }
	if !compareSlices(m.ProcedureSequence, other.ProcedureSequence) { return false }
	if !compareSlices(m.InformationSequence, other.InformationSequence) { return false }
	if !m.Revenue.Equals(other.Revenue) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.ServicedDate.Equals(other.ServicedDate) { return false }
	if !m.ServicedPeriod.Equals(other.ServicedPeriod) { return false }
	if !m.LocationCodeableConcept.Equals(other.LocationCodeableConcept) { return false }
	if !m.LocationAddress.Equals(other.LocationAddress) { return false }
	if !m.LocationReference.Equals(other.LocationReference) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !compareSlices(m.SubSite, other.SubSite) { return false }
	if !compareSlices(m.Encounter, other.Encounter) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// ExplanationOfBenefitAdjudication
// If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
type ExplanationOfBenefitAdjudication struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Reason *CodeableConcept `json:"reason,omitempty"`
	Amount *Money `json:"amount,omitempty"`
	Value *FhirDecimal `json:"value,omitempty"`
}

// NewExplanationOfBenefitAdjudication creates a new ExplanationOfBenefitAdjudication instance
func NewExplanationOfBenefitAdjudication() *ExplanationOfBenefitAdjudication {
	return &ExplanationOfBenefitAdjudication{}
}

// FromJSON populates ExplanationOfBenefitAdjudication from JSON data
func (m *ExplanationOfBenefitAdjudication) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitAdjudication to JSON data
func (m *ExplanationOfBenefitAdjudication) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitAdjudication
func (m *ExplanationOfBenefitAdjudication) Clone() *ExplanationOfBenefitAdjudication {
	if m == nil { return nil }
	return &ExplanationOfBenefitAdjudication{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Reason: m.Reason.Clone(),
		Amount: m.Amount.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitAdjudication instance
func (m *ExplanationOfBenefitAdjudication) Equals(other *ExplanationOfBenefitAdjudication) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// ExplanationOfBenefitDetail
// Second-tier of goods and services.
type ExplanationOfBenefitDetail struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Revenue *CodeableConcept `json:"revenue,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
}

// NewExplanationOfBenefitDetail creates a new ExplanationOfBenefitDetail instance
func NewExplanationOfBenefitDetail() *ExplanationOfBenefitDetail {
	return &ExplanationOfBenefitDetail{}
}

// FromJSON populates ExplanationOfBenefitDetail from JSON data
func (m *ExplanationOfBenefitDetail) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitDetail to JSON data
func (m *ExplanationOfBenefitDetail) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitDetail
func (m *ExplanationOfBenefitDetail) Clone() *ExplanationOfBenefitDetail {
	if m == nil { return nil }
	return &ExplanationOfBenefitDetail{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Revenue: m.Revenue.Clone(),
		Category: m.Category.Clone(),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		Udi: cloneSlices(m.Udi),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		SubDetail: cloneSlices(m.SubDetail),
	}
}

// Equals checks for equality with another ExplanationOfBenefitDetail instance
func (m *ExplanationOfBenefitDetail) Equals(other *ExplanationOfBenefitDetail) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Revenue.Equals(other.Revenue) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.SubDetail, other.SubDetail) { return false }
	return true
}

// ExplanationOfBenefitSubDetail
// Third-tier of goods and services.
type ExplanationOfBenefitSubDetail struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	Revenue *CodeableConcept `json:"revenue,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	Udi []*Reference `json:"udi,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
}

// NewExplanationOfBenefitSubDetail creates a new ExplanationOfBenefitSubDetail instance
func NewExplanationOfBenefitSubDetail() *ExplanationOfBenefitSubDetail {
	return &ExplanationOfBenefitSubDetail{}
}

// FromJSON populates ExplanationOfBenefitSubDetail from JSON data
func (m *ExplanationOfBenefitSubDetail) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitSubDetail to JSON data
func (m *ExplanationOfBenefitSubDetail) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitSubDetail
func (m *ExplanationOfBenefitSubDetail) Clone() *ExplanationOfBenefitSubDetail {
	if m == nil { return nil }
	return &ExplanationOfBenefitSubDetail{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Revenue: m.Revenue.Clone(),
		Category: m.Category.Clone(),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		Udi: cloneSlices(m.Udi),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
	}
}

// Equals checks for equality with another ExplanationOfBenefitSubDetail instance
func (m *ExplanationOfBenefitSubDetail) Equals(other *ExplanationOfBenefitSubDetail) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Revenue.Equals(other.Revenue) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.Udi, other.Udi) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	return true
}

// ExplanationOfBenefitAddItem
// The first-tier service adjudications for payor added product or service lines.
type ExplanationOfBenefitAddItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemSequence []*FhirPositiveInt `json:"itemsequence,omitempty"`
	DetailSequence []*FhirPositiveInt `json:"detailsequence,omitempty"`
	SubDetailSequence []*FhirPositiveInt `json:"subdetailsequence,omitempty"`
	Provider []*Reference `json:"provider,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	ProgramCode []*CodeableConcept `json:"programcode,omitempty"`
	ServicedDate *FhirDate `json:"serviceddate,omitempty"`
	ServicedPeriod *Period `json:"servicedperiod,omitempty"`
	LocationCodeableConcept *CodeableConcept `json:"locationcodeableconcept,omitempty"`
	LocationAddress *Address `json:"locationaddress,omitempty"`
	LocationReference *Reference `json:"locationreference,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	BodySite *CodeableConcept `json:"bodysite,omitempty"`
	SubSite []*CodeableConcept `json:"subsite,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	Detail []*ExplanationOfBenefitDetail `json:"detail,omitempty"`
}

// NewExplanationOfBenefitAddItem creates a new ExplanationOfBenefitAddItem instance
func NewExplanationOfBenefitAddItem() *ExplanationOfBenefitAddItem {
	return &ExplanationOfBenefitAddItem{}
}

// FromJSON populates ExplanationOfBenefitAddItem from JSON data
func (m *ExplanationOfBenefitAddItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitAddItem to JSON data
func (m *ExplanationOfBenefitAddItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitAddItem
func (m *ExplanationOfBenefitAddItem) Clone() *ExplanationOfBenefitAddItem {
	if m == nil { return nil }
	return &ExplanationOfBenefitAddItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemSequence: cloneSlices(m.ItemSequence),
		DetailSequence: cloneSlices(m.DetailSequence),
		SubDetailSequence: cloneSlices(m.SubDetailSequence),
		Provider: cloneSlices(m.Provider),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		ProgramCode: cloneSlices(m.ProgramCode),
		ServicedDate: m.ServicedDate.Clone(),
		ServicedPeriod: m.ServicedPeriod.Clone(),
		LocationCodeableConcept: m.LocationCodeableConcept.Clone(),
		LocationAddress: m.LocationAddress.Clone(),
		LocationReference: m.LocationReference.Clone(),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		BodySite: m.BodySite.Clone(),
		SubSite: cloneSlices(m.SubSite),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks for equality with another ExplanationOfBenefitAddItem instance
func (m *ExplanationOfBenefitAddItem) Equals(other *ExplanationOfBenefitAddItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.ItemSequence, other.ItemSequence) { return false }
	if !compareSlices(m.DetailSequence, other.DetailSequence) { return false }
	if !compareSlices(m.SubDetailSequence, other.SubDetailSequence) { return false }
	if !compareSlices(m.Provider, other.Provider) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !compareSlices(m.ProgramCode, other.ProgramCode) { return false }
	if !m.ServicedDate.Equals(other.ServicedDate) { return false }
	if !m.ServicedPeriod.Equals(other.ServicedPeriod) { return false }
	if !m.LocationCodeableConcept.Equals(other.LocationCodeableConcept) { return false }
	if !m.LocationAddress.Equals(other.LocationAddress) { return false }
	if !m.LocationReference.Equals(other.LocationReference) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !m.BodySite.Equals(other.BodySite) { return false }
	if !compareSlices(m.SubSite, other.SubSite) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// ExplanationOfBenefitDetail1
// The second-tier service adjudications for payor added services.
type ExplanationOfBenefitDetail1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
	SubDetail []*ExplanationOfBenefitSubDetail `json:"subdetail,omitempty"`
}

// NewExplanationOfBenefitDetail1 creates a new ExplanationOfBenefitDetail1 instance
func NewExplanationOfBenefitDetail1() *ExplanationOfBenefitDetail1 {
	return &ExplanationOfBenefitDetail1{}
}

// FromJSON populates ExplanationOfBenefitDetail1 from JSON data
func (m *ExplanationOfBenefitDetail1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitDetail1 to JSON data
func (m *ExplanationOfBenefitDetail1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitDetail1
func (m *ExplanationOfBenefitDetail1) Clone() *ExplanationOfBenefitDetail1 {
	if m == nil { return nil }
	return &ExplanationOfBenefitDetail1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
		SubDetail: cloneSlices(m.SubDetail),
	}
}

// Equals checks for equality with another ExplanationOfBenefitDetail1 instance
func (m *ExplanationOfBenefitDetail1) Equals(other *ExplanationOfBenefitDetail1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	if !compareSlices(m.SubDetail, other.SubDetail) { return false }
	return true
}

// ExplanationOfBenefitSubDetail1
// The third-tier service adjudications for payor added services.
type ExplanationOfBenefitSubDetail1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductOrService *CodeableConcept `json:"productorservice,omitempty"`
	Modifier []*CodeableConcept `json:"modifier,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Net *Money `json:"net,omitempty"`
	NoteNumber []*FhirPositiveInt `json:"notenumber,omitempty"`
	Adjudication []*ExplanationOfBenefitAdjudication `json:"adjudication,omitempty"`
}

// NewExplanationOfBenefitSubDetail1 creates a new ExplanationOfBenefitSubDetail1 instance
func NewExplanationOfBenefitSubDetail1() *ExplanationOfBenefitSubDetail1 {
	return &ExplanationOfBenefitSubDetail1{}
}

// FromJSON populates ExplanationOfBenefitSubDetail1 from JSON data
func (m *ExplanationOfBenefitSubDetail1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitSubDetail1 to JSON data
func (m *ExplanationOfBenefitSubDetail1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitSubDetail1
func (m *ExplanationOfBenefitSubDetail1) Clone() *ExplanationOfBenefitSubDetail1 {
	if m == nil { return nil }
	return &ExplanationOfBenefitSubDetail1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductOrService: m.ProductOrService.Clone(),
		Modifier: cloneSlices(m.Modifier),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Net: m.Net.Clone(),
		NoteNumber: cloneSlices(m.NoteNumber),
		Adjudication: cloneSlices(m.Adjudication),
	}
}

// Equals checks for equality with another ExplanationOfBenefitSubDetail1 instance
func (m *ExplanationOfBenefitSubDetail1) Equals(other *ExplanationOfBenefitSubDetail1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductOrService.Equals(other.ProductOrService) { return false }
	if !compareSlices(m.Modifier, other.Modifier) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !compareSlices(m.NoteNumber, other.NoteNumber) { return false }
	if !compareSlices(m.Adjudication, other.Adjudication) { return false }
	return true
}

// ExplanationOfBenefitTotal
// Categorized monetary totals for the adjudication.
type ExplanationOfBenefitTotal struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Amount *Money `json:"amount,omitempty"`
}

// NewExplanationOfBenefitTotal creates a new ExplanationOfBenefitTotal instance
func NewExplanationOfBenefitTotal() *ExplanationOfBenefitTotal {
	return &ExplanationOfBenefitTotal{}
}

// FromJSON populates ExplanationOfBenefitTotal from JSON data
func (m *ExplanationOfBenefitTotal) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitTotal to JSON data
func (m *ExplanationOfBenefitTotal) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitTotal
func (m *ExplanationOfBenefitTotal) Clone() *ExplanationOfBenefitTotal {
	if m == nil { return nil }
	return &ExplanationOfBenefitTotal{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitTotal instance
func (m *ExplanationOfBenefitTotal) Equals(other *ExplanationOfBenefitTotal) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

// ExplanationOfBenefitPayment
// Payment details for the adjudication of the claim.
type ExplanationOfBenefitPayment struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Adjustment *Money `json:"adjustment,omitempty"`
	AdjustmentReason *CodeableConcept `json:"adjustmentreason,omitempty"`
	Date *FhirDate `json:"date,omitempty"`
	Amount *Money `json:"amount,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
}

// NewExplanationOfBenefitPayment creates a new ExplanationOfBenefitPayment instance
func NewExplanationOfBenefitPayment() *ExplanationOfBenefitPayment {
	return &ExplanationOfBenefitPayment{}
}

// FromJSON populates ExplanationOfBenefitPayment from JSON data
func (m *ExplanationOfBenefitPayment) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitPayment to JSON data
func (m *ExplanationOfBenefitPayment) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitPayment
func (m *ExplanationOfBenefitPayment) Clone() *ExplanationOfBenefitPayment {
	if m == nil { return nil }
	return &ExplanationOfBenefitPayment{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Adjustment: m.Adjustment.Clone(),
		AdjustmentReason: m.AdjustmentReason.Clone(),
		Date: m.Date.Clone(),
		Amount: m.Amount.Clone(),
		Identifier: m.Identifier.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitPayment instance
func (m *ExplanationOfBenefitPayment) Equals(other *ExplanationOfBenefitPayment) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Adjustment.Equals(other.Adjustment) { return false }
	if !m.AdjustmentReason.Equals(other.AdjustmentReason) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	return true
}

// ExplanationOfBenefitProcessNote
// A note that describes or explains adjudication results in a human readable form.
type ExplanationOfBenefitProcessNote struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Number *FhirPositiveInt `json:"number,omitempty"`
	Type *NoteType `json:"type,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	Language *CodeableConcept `json:"language,omitempty"`
}

// NewExplanationOfBenefitProcessNote creates a new ExplanationOfBenefitProcessNote instance
func NewExplanationOfBenefitProcessNote() *ExplanationOfBenefitProcessNote {
	return &ExplanationOfBenefitProcessNote{}
}

// FromJSON populates ExplanationOfBenefitProcessNote from JSON data
func (m *ExplanationOfBenefitProcessNote) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitProcessNote to JSON data
func (m *ExplanationOfBenefitProcessNote) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitProcessNote
func (m *ExplanationOfBenefitProcessNote) Clone() *ExplanationOfBenefitProcessNote {
	if m == nil { return nil }
	return &ExplanationOfBenefitProcessNote{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Number: m.Number.Clone(),
		Type: m.Type.Clone(),
		Text: m.Text.Clone(),
		Language: m.Language.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitProcessNote instance
func (m *ExplanationOfBenefitProcessNote) Equals(other *ExplanationOfBenefitProcessNote) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Number.Equals(other.Number) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !m.Language.Equals(other.Language) { return false }
	return true
}

// ExplanationOfBenefitBenefitBalance
// Balance by Benefit Category.
type ExplanationOfBenefitBenefitBalance struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Excluded *FhirBoolean `json:"excluded,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Network *CodeableConcept `json:"network,omitempty"`
	Unit *CodeableConcept `json:"unit,omitempty"`
	Term *CodeableConcept `json:"term,omitempty"`
	Financial []*ExplanationOfBenefitFinancial `json:"financial,omitempty"`
}

// NewExplanationOfBenefitBenefitBalance creates a new ExplanationOfBenefitBenefitBalance instance
func NewExplanationOfBenefitBenefitBalance() *ExplanationOfBenefitBenefitBalance {
	return &ExplanationOfBenefitBenefitBalance{}
}

// FromJSON populates ExplanationOfBenefitBenefitBalance from JSON data
func (m *ExplanationOfBenefitBenefitBalance) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitBenefitBalance to JSON data
func (m *ExplanationOfBenefitBenefitBalance) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitBenefitBalance
func (m *ExplanationOfBenefitBenefitBalance) Clone() *ExplanationOfBenefitBenefitBalance {
	if m == nil { return nil }
	return &ExplanationOfBenefitBenefitBalance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Excluded: m.Excluded.Clone(),
		Name: m.Name.Clone(),
		Description: m.Description.Clone(),
		Network: m.Network.Clone(),
		Unit: m.Unit.Clone(),
		Term: m.Term.Clone(),
		Financial: cloneSlices(m.Financial),
	}
}

// Equals checks for equality with another ExplanationOfBenefitBenefitBalance instance
func (m *ExplanationOfBenefitBenefitBalance) Equals(other *ExplanationOfBenefitBenefitBalance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Excluded.Equals(other.Excluded) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Network.Equals(other.Network) { return false }
	if !m.Unit.Equals(other.Unit) { return false }
	if !m.Term.Equals(other.Term) { return false }
	if !compareSlices(m.Financial, other.Financial) { return false }
	return true
}

// ExplanationOfBenefitFinancial
// Benefits Used to date.
type ExplanationOfBenefitFinancial struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	AllowedUnsignedInt *FhirUnsignedInt `json:"allowedunsignedint,omitempty"`
	AllowedString *FhirString `json:"allowedstring,omitempty"`
	AllowedMoney *Money `json:"allowedmoney,omitempty"`
	UsedUnsignedInt *FhirUnsignedInt `json:"usedunsignedint,omitempty"`
	UsedMoney *Money `json:"usedmoney,omitempty"`
}

// NewExplanationOfBenefitFinancial creates a new ExplanationOfBenefitFinancial instance
func NewExplanationOfBenefitFinancial() *ExplanationOfBenefitFinancial {
	return &ExplanationOfBenefitFinancial{}
}

// FromJSON populates ExplanationOfBenefitFinancial from JSON data
func (m *ExplanationOfBenefitFinancial) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ExplanationOfBenefitFinancial to JSON data
func (m *ExplanationOfBenefitFinancial) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ExplanationOfBenefitFinancial
func (m *ExplanationOfBenefitFinancial) Clone() *ExplanationOfBenefitFinancial {
	if m == nil { return nil }
	return &ExplanationOfBenefitFinancial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		AllowedUnsignedInt: m.AllowedUnsignedInt.Clone(),
		AllowedString: m.AllowedString.Clone(),
		AllowedMoney: m.AllowedMoney.Clone(),
		UsedUnsignedInt: m.UsedUnsignedInt.Clone(),
		UsedMoney: m.UsedMoney.Clone(),
	}
}

// Equals checks for equality with another ExplanationOfBenefitFinancial instance
func (m *ExplanationOfBenefitFinancial) Equals(other *ExplanationOfBenefitFinancial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.AllowedUnsignedInt.Equals(other.AllowedUnsignedInt) { return false }
	if !m.AllowedString.Equals(other.AllowedString) { return false }
	if !m.AllowedMoney.Equals(other.AllowedMoney) { return false }
	if !m.UsedUnsignedInt.Equals(other.UsedUnsignedInt) { return false }
	if !m.UsedMoney.Equals(other.UsedMoney) { return false }
	return true
}

