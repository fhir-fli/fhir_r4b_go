// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// TriggerDefinition
// A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
type TriggerDefinition struct {
	extends DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Type *TriggerType `json:"type,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	TimingTiming *Timing `json:"timingtiming,omitempty"`
	TimingReference *Reference `json:"timingreference,omitempty"`
	TimingDate *FhirDate `json:"timingdate,omitempty"`
	TimingDateTime *FhirDateTime `json:"timingdatetime,omitempty"`
	Data []*DataRequirement `json:"data,omitempty"`
	Condition *FhirExpression `json:"condition,omitempty"`
}

// NewTriggerDefinition creates a new TriggerDefinition instance.
func NewTriggerDefinition() *TriggerDefinition {
	return &TriggerDefinition{}
}

// UnmarshalJSON populates TriggerDefinition from JSON data.
func (m *TriggerDefinition) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Type *TriggerType `json:"type,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		TimingTiming *Timing `json:"timingtiming,omitempty"`
		TimingReference *Reference `json:"timingreference,omitempty"`
		TimingDate *FhirDate `json:"timingdate,omitempty"`
		TimingDateTime *FhirDateTime `json:"timingdatetime,omitempty"`
		Data []*DataRequirement `json:"data,omitempty"`
		Condition *FhirExpression `json:"condition,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.Type = temp.Type
	m.Name = temp.Name
	m.TimingTiming = temp.TimingTiming
	m.TimingReference = temp.TimingReference
	m.TimingDate = temp.TimingDate
	m.TimingDateTime = temp.TimingDateTime
	m.Data = temp.Data
	m.Condition = temp.Condition
	return nil
}

// MarshalJSON converts TriggerDefinition to JSON data.
func (m *TriggerDefinition) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Type *TriggerType `json:"type,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		TimingTiming *Timing `json:"timingtiming,omitempty"`
		TimingReference *Reference `json:"timingreference,omitempty"`
		TimingDate interface{} `json:"timingdate,omitempty"`
		TimingDateElement map[string]interface{} `json:"_timingdate,omitempty"`
		TimingDateTime interface{} `json:"timingdatetime,omitempty"`
		TimingDateTimeElement map[string]interface{} `json:"_timingdatetime,omitempty"`
		Data []*DataRequirement `json:"data,omitempty"`
		Condition *FhirExpression `json:"condition,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.Type = m.Type
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	output.TimingTiming = m.TimingTiming
	output.TimingReference = m.TimingReference
	if m.TimingDate != nil && m.TimingDate.Value != nil {
		output.TimingDate = m.TimingDate.Value
		if m.TimingDate.Element != nil {
			output.TimingDateElement = toMapOrNil(m.TimingDate.Element.MarshalJSON())
		}
	}
	if m.TimingDateTime != nil && m.TimingDateTime.Value != nil {
		output.TimingDateTime = m.TimingDateTime.Value
		if m.TimingDateTime.Element != nil {
			output.TimingDateTimeElement = toMapOrNil(m.TimingDateTime.Element.MarshalJSON())
		}
	}
	output.Data = m.Data
	output.Condition = m.Condition
	return json.Marshal(output)
}

// Clone creates a deep copy of TriggerDefinition.
func (m *TriggerDefinition) Clone() *TriggerDefinition {
	if m == nil { return nil }
	return &TriggerDefinition{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Type: m.Type.Clone(),
		Name: m.Name.Clone(),
		TimingTiming: m.TimingTiming.Clone(),
		TimingReference: m.TimingReference.Clone(),
		TimingDate: m.TimingDate.Clone(),
		TimingDateTime: m.TimingDateTime.Clone(),
		Data: cloneSlices(m.Data),
		Condition: m.Condition.Clone(),
	}
}

// Equals checks equality between two TriggerDefinition instances.
func (m *TriggerDefinition) Equals(other *TriggerDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.TimingTiming.Equals(other.TimingTiming) { return false }
	if !m.TimingReference.Equals(other.TimingReference) { return false }
	if !m.TimingDate.Equals(other.TimingDate) { return false }
	if !m.TimingDateTime.Equals(other.TimingDateTime) { return false }
	if !compareSlices(m.Data, other.Data) { return false }
	if !m.Condition.Equals(other.Condition) { return false }
	return true
}

