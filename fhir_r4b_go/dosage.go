// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// Dosage
// Indicates how the medication is/was taken or should be taken by the patient.
type Dosage struct {
	extends BackboneType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirInteger `json:"sequence,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	AdditionalInstruction []*CodeableConcept `json:"additionalinstruction,omitempty"`
	PatientInstruction *FhirString `json:"patientinstruction,omitempty"`
	Timing *Timing `json:"timing,omitempty"`
	AsNeededBoolean *FhirBoolean `json:"asneededboolean,omitempty"`
	AsNeededCodeableConcept *CodeableConcept `json:"asneededcodeableconcept,omitempty"`
	Site *CodeableConcept `json:"site,omitempty"`
	Route *CodeableConcept `json:"route,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	DoseAndRate []*DosageDoseAndRate `json:"doseandrate,omitempty"`
	MaxDosePerPeriod *Ratio `json:"maxdoseperperiod,omitempty"`
	MaxDosePerAdministration *Quantity `json:"maxdoseperadministration,omitempty"`
	MaxDosePerLifetime *Quantity `json:"maxdoseperlifetime,omitempty"`
}

// NewDosage creates a new Dosage instance.
func NewDosage() *Dosage {
	return &Dosage{}
}

// UnmarshalJSON populates Dosage from JSON data.
func (m *Dosage) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence *FhirInteger `json:"sequence,omitempty"`
		Text *FhirString `json:"text,omitempty"`
		AdditionalInstruction []*CodeableConcept `json:"additionalinstruction,omitempty"`
		PatientInstruction *FhirString `json:"patientinstruction,omitempty"`
		Timing *Timing `json:"timing,omitempty"`
		AsNeededBoolean *FhirBoolean `json:"asneededboolean,omitempty"`
		AsNeededCodeableConcept *CodeableConcept `json:"asneededcodeableconcept,omitempty"`
		Site *CodeableConcept `json:"site,omitempty"`
		Route *CodeableConcept `json:"route,omitempty"`
		Method *CodeableConcept `json:"method,omitempty"`
		DoseAndRate []*DosageDoseAndRate `json:"doseandrate,omitempty"`
		MaxDosePerPeriod *Ratio `json:"maxdoseperperiod,omitempty"`
		MaxDosePerAdministration *Quantity `json:"maxdoseperadministration,omitempty"`
		MaxDosePerLifetime *Quantity `json:"maxdoseperlifetime,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Sequence = temp.Sequence
	m.Text = temp.Text
	m.AdditionalInstruction = temp.AdditionalInstruction
	m.PatientInstruction = temp.PatientInstruction
	m.Timing = temp.Timing
	m.AsNeededBoolean = temp.AsNeededBoolean
	m.AsNeededCodeableConcept = temp.AsNeededCodeableConcept
	m.Site = temp.Site
	m.Route = temp.Route
	m.Method = temp.Method
	m.DoseAndRate = temp.DoseAndRate
	m.MaxDosePerPeriod = temp.MaxDosePerPeriod
	m.MaxDosePerAdministration = temp.MaxDosePerAdministration
	m.MaxDosePerLifetime = temp.MaxDosePerLifetime
	return nil
}

// MarshalJSON converts Dosage to JSON data.
func (m *Dosage) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Sequence interface{} `json:"sequence,omitempty"`
		SequenceElement map[string]interface{} `json:"_sequence,omitempty"`
		Text interface{} `json:"text,omitempty"`
		TextElement map[string]interface{} `json:"_text,omitempty"`
		AdditionalInstruction []*CodeableConcept `json:"additionalinstruction,omitempty"`
		PatientInstruction interface{} `json:"patientinstruction,omitempty"`
		PatientInstructionElement map[string]interface{} `json:"_patientinstruction,omitempty"`
		Timing *Timing `json:"timing,omitempty"`
		AsNeededBoolean interface{} `json:"asneededboolean,omitempty"`
		AsNeededBooleanElement map[string]interface{} `json:"_asneededboolean,omitempty"`
		AsNeededCodeableConcept *CodeableConcept `json:"asneededcodeableconcept,omitempty"`
		Site *CodeableConcept `json:"site,omitempty"`
		Route *CodeableConcept `json:"route,omitempty"`
		Method *CodeableConcept `json:"method,omitempty"`
		DoseAndRate []*DosageDoseAndRate `json:"doseandrate,omitempty"`
		MaxDosePerPeriod *Ratio `json:"maxdoseperperiod,omitempty"`
		MaxDosePerAdministration *Quantity `json:"maxdoseperadministration,omitempty"`
		MaxDosePerLifetime *Quantity `json:"maxdoseperlifetime,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Sequence != nil && m.Sequence.Value != nil {
		output.Sequence = m.Sequence.Value
		if m.Sequence.Element != nil {
			output.SequenceElement = toMapOrNil(m.Sequence.Element.MarshalJSON())
		}
	}
	if m.Text != nil && m.Text.Value != nil {
		output.Text = m.Text.Value
		if m.Text.Element != nil {
			output.TextElement = toMapOrNil(m.Text.Element.MarshalJSON())
		}
	}
	output.AdditionalInstruction = m.AdditionalInstruction
	if m.PatientInstruction != nil && m.PatientInstruction.Value != nil {
		output.PatientInstruction = m.PatientInstruction.Value
		if m.PatientInstruction.Element != nil {
			output.PatientInstructionElement = toMapOrNil(m.PatientInstruction.Element.MarshalJSON())
		}
	}
	output.Timing = m.Timing
	if m.AsNeededBoolean != nil && m.AsNeededBoolean.Value != nil {
		output.AsNeededBoolean = m.AsNeededBoolean.Value
		if m.AsNeededBoolean.Element != nil {
			output.AsNeededBooleanElement = toMapOrNil(m.AsNeededBoolean.Element.MarshalJSON())
		}
	}
	output.AsNeededCodeableConcept = m.AsNeededCodeableConcept
	output.Site = m.Site
	output.Route = m.Route
	output.Method = m.Method
	output.DoseAndRate = m.DoseAndRate
	output.MaxDosePerPeriod = m.MaxDosePerPeriod
	output.MaxDosePerAdministration = m.MaxDosePerAdministration
	output.MaxDosePerLifetime = m.MaxDosePerLifetime
	return json.Marshal(output)
}

// Clone creates a deep copy of Dosage.
func (m *Dosage) Clone() *Dosage {
	if m == nil { return nil }
	return &Dosage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Text: m.Text.Clone(),
		AdditionalInstruction: cloneSlices(m.AdditionalInstruction),
		PatientInstruction: m.PatientInstruction.Clone(),
		Timing: m.Timing.Clone(),
		AsNeededBoolean: m.AsNeededBoolean.Clone(),
		AsNeededCodeableConcept: m.AsNeededCodeableConcept.Clone(),
		Site: m.Site.Clone(),
		Route: m.Route.Clone(),
		Method: m.Method.Clone(),
		DoseAndRate: cloneSlices(m.DoseAndRate),
		MaxDosePerPeriod: m.MaxDosePerPeriod.Clone(),
		MaxDosePerAdministration: m.MaxDosePerAdministration.Clone(),
		MaxDosePerLifetime: m.MaxDosePerLifetime.Clone(),
	}
}

// Equals checks equality between two Dosage instances.
func (m *Dosage) Equals(other *Dosage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.AdditionalInstruction, other.AdditionalInstruction) { return false }
	if !m.PatientInstruction.Equals(other.PatientInstruction) { return false }
	if !m.Timing.Equals(other.Timing) { return false }
	if !m.AsNeededBoolean.Equals(other.AsNeededBoolean) { return false }
	if !m.AsNeededCodeableConcept.Equals(other.AsNeededCodeableConcept) { return false }
	if !m.Site.Equals(other.Site) { return false }
	if !m.Route.Equals(other.Route) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !compareSlices(m.DoseAndRate, other.DoseAndRate) { return false }
	if !m.MaxDosePerPeriod.Equals(other.MaxDosePerPeriod) { return false }
	if !m.MaxDosePerAdministration.Equals(other.MaxDosePerAdministration) { return false }
	if !m.MaxDosePerLifetime.Equals(other.MaxDosePerLifetime) { return false }
	return true
}

// DosageDoseAndRate
// The amount of medication administered.
type DosageDoseAndRate struct {
	extends Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	DoseRange *Range `json:"doserange,omitempty"`
	DoseQuantity *Quantity `json:"dosequantity,omitempty"`
	RateRatio *Ratio `json:"rateratio,omitempty"`
	RateRange *Range `json:"raterange,omitempty"`
	RateQuantity *Quantity `json:"ratequantity,omitempty"`
}

// NewDosageDoseAndRate creates a new DosageDoseAndRate instance.
func NewDosageDoseAndRate() *DosageDoseAndRate {
	return &DosageDoseAndRate{}
}

// UnmarshalJSON populates DosageDoseAndRate from JSON data.
func (m *DosageDoseAndRate) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		DoseRange *Range `json:"doserange,omitempty"`
		DoseQuantity *Quantity `json:"dosequantity,omitempty"`
		RateRatio *Ratio `json:"rateratio,omitempty"`
		RateRange *Range `json:"raterange,omitempty"`
		RateQuantity *Quantity `json:"ratequantity,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.Type = temp.Type
	m.DoseRange = temp.DoseRange
	m.DoseQuantity = temp.DoseQuantity
	m.RateRatio = temp.RateRatio
	m.RateRange = temp.RateRange
	m.RateQuantity = temp.RateQuantity
	return nil
}

// MarshalJSON converts DosageDoseAndRate to JSON data.
func (m *DosageDoseAndRate) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		DoseRange *Range `json:"doserange,omitempty"`
		DoseQuantity *Quantity `json:"dosequantity,omitempty"`
		RateRatio *Ratio `json:"rateratio,omitempty"`
		RateRange *Range `json:"raterange,omitempty"`
		RateQuantity *Quantity `json:"ratequantity,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.Type = m.Type
	output.DoseRange = m.DoseRange
	output.DoseQuantity = m.DoseQuantity
	output.RateRatio = m.RateRatio
	output.RateRange = m.RateRange
	output.RateQuantity = m.RateQuantity
	return json.Marshal(output)
}

// Clone creates a deep copy of DosageDoseAndRate.
func (m *DosageDoseAndRate) Clone() *DosageDoseAndRate {
	if m == nil { return nil }
	return &DosageDoseAndRate{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Type: m.Type.Clone(),
		DoseRange: m.DoseRange.Clone(),
		DoseQuantity: m.DoseQuantity.Clone(),
		RateRatio: m.RateRatio.Clone(),
		RateRange: m.RateRange.Clone(),
		RateQuantity: m.RateQuantity.Clone(),
	}
}

// Equals checks equality between two DosageDoseAndRate instances.
func (m *DosageDoseAndRate) Equals(other *DosageDoseAndRate) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.DoseRange.Equals(other.DoseRange) { return false }
	if !m.DoseQuantity.Equals(other.DoseQuantity) { return false }
	if !m.RateRatio.Equals(other.RateRatio) { return false }
	if !m.RateRange.Equals(other.RateRange) { return false }
	if !m.RateQuantity.Equals(other.RateQuantity) { return false }
	return true
}

