// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Dosage
// Indicates how the medication is/was taken or should be taken by the patient.
type Dosage struct {
	BackboneType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirInteger `json:"sequence,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	AdditionalInstruction []*CodeableConcept `json:"additionalinstruction,omitempty"`
	PatientInstruction *FhirString `json:"patientinstruction,omitempty"`
	Timing *Timing `json:"timing,omitempty"`
	AsNeededBoolean *FhirBoolean `json:"asneededboolean,omitempty"`
	AsNeededCodeableConcept *CodeableConcept `json:"asneededcodeableconcept,omitempty"`
	Site *CodeableConcept `json:"site,omitempty"`
	Route *CodeableConcept `json:"route,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	DoseAndRate []*DosageDoseAndRate `json:"doseandrate,omitempty"`
	MaxDosePerPeriod *Ratio `json:"maxdoseperperiod,omitempty"`
	MaxDosePerAdministration *Quantity `json:"maxdoseperadministration,omitempty"`
	MaxDosePerLifetime *Quantity `json:"maxdoseperlifetime,omitempty"`
}

// NewDosage creates a new Dosage instance
func NewDosage() *Dosage {
	return &Dosage{}
}

// FromJSON populates Dosage from JSON data
func (m *Dosage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Dosage to JSON data
func (m *Dosage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Dosage
func (m *Dosage) Clone() *Dosage {
	if m == nil { return nil }
	return &Dosage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		Text: m.Text.Clone(),
		AdditionalInstruction: cloneSlices(m.AdditionalInstruction),
		PatientInstruction: m.PatientInstruction.Clone(),
		Timing: m.Timing.Clone(),
		AsNeededBoolean: m.AsNeededBoolean.Clone(),
		AsNeededCodeableConcept: m.AsNeededCodeableConcept.Clone(),
		Site: m.Site.Clone(),
		Route: m.Route.Clone(),
		Method: m.Method.Clone(),
		DoseAndRate: cloneSlices(m.DoseAndRate),
		MaxDosePerPeriod: m.MaxDosePerPeriod.Clone(),
		MaxDosePerAdministration: m.MaxDosePerAdministration.Clone(),
		MaxDosePerLifetime: m.MaxDosePerLifetime.Clone(),
	}
}

// Equals checks for equality with another Dosage instance
func (m *Dosage) Equals(other *Dosage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.AdditionalInstruction, other.AdditionalInstruction) { return false }
	if !m.PatientInstruction.Equals(other.PatientInstruction) { return false }
	if !m.Timing.Equals(other.Timing) { return false }
	if !m.AsNeededBoolean.Equals(other.AsNeededBoolean) { return false }
	if !m.AsNeededCodeableConcept.Equals(other.AsNeededCodeableConcept) { return false }
	if !m.Site.Equals(other.Site) { return false }
	if !m.Route.Equals(other.Route) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !compareSlices(m.DoseAndRate, other.DoseAndRate) { return false }
	if !m.MaxDosePerPeriod.Equals(other.MaxDosePerPeriod) { return false }
	if !m.MaxDosePerAdministration.Equals(other.MaxDosePerAdministration) { return false }
	if !m.MaxDosePerLifetime.Equals(other.MaxDosePerLifetime) { return false }
	return true
}

// DosageDoseAndRate
// The amount of medication administered.
type DosageDoseAndRate struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	DoseRange *Range `json:"doserange,omitempty"`
	DoseQuantity *Quantity `json:"dosequantity,omitempty"`
	RateRatio *Ratio `json:"rateratio,omitempty"`
	RateRange *Range `json:"raterange,omitempty"`
	RateQuantity *Quantity `json:"ratequantity,omitempty"`
}

// NewDosageDoseAndRate creates a new DosageDoseAndRate instance
func NewDosageDoseAndRate() *DosageDoseAndRate {
	return &DosageDoseAndRate{}
}

// FromJSON populates DosageDoseAndRate from JSON data
func (m *DosageDoseAndRate) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DosageDoseAndRate to JSON data
func (m *DosageDoseAndRate) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DosageDoseAndRate
func (m *DosageDoseAndRate) Clone() *DosageDoseAndRate {
	if m == nil { return nil }
	return &DosageDoseAndRate{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Type: m.Type.Clone(),
		DoseRange: m.DoseRange.Clone(),
		DoseQuantity: m.DoseQuantity.Clone(),
		RateRatio: m.RateRatio.Clone(),
		RateRange: m.RateRange.Clone(),
		RateQuantity: m.RateQuantity.Clone(),
	}
}

// Equals checks for equality with another DosageDoseAndRate instance
func (m *DosageDoseAndRate) Equals(other *DosageDoseAndRate) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.DoseRange.Equals(other.DoseRange) { return false }
	if !m.DoseQuantity.Equals(other.DoseQuantity) { return false }
	if !m.RateRatio.Equals(other.RateRatio) { return false }
	if !m.RateRange.Equals(other.RateRange) { return false }
	if !m.RateQuantity.Equals(other.RateQuantity) { return false }
	return true
}

