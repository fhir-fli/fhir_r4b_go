// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// SpecimenDefinition
// A kind of specimen with associated set of requirements.
type SpecimenDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	TypeCollected *CodeableConcept `json:"typecollected,omitempty"`
	PatientPreparation []*CodeableConcept `json:"patientpreparation,omitempty"`
	TimeAspect *FhirString `json:"timeaspect,omitempty"`
	Collection []*CodeableConcept `json:"collection,omitempty"`
	TypeTested []*SpecimenDefinitionTypeTested `json:"typetested,omitempty"`
}

// NewSpecimenDefinition creates a new SpecimenDefinition instance
func NewSpecimenDefinition() *SpecimenDefinition {
	return &SpecimenDefinition{}
}

// FromJSON populates SpecimenDefinition from JSON data
func (m *SpecimenDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenDefinition to JSON data
func (m *SpecimenDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenDefinition
func (m *SpecimenDefinition) Clone() *SpecimenDefinition {
	if m == nil { return nil }
	return &SpecimenDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		TypeCollected: m.TypeCollected.Clone(),
		PatientPreparation: cloneSlices(m.PatientPreparation),
		TimeAspect: m.TimeAspect.Clone(),
		Collection: cloneSlices(m.Collection),
		TypeTested: cloneSlices(m.TypeTested),
	}
}

// Equals checks for equality with another SpecimenDefinition instance
func (m *SpecimenDefinition) Equals(other *SpecimenDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.TypeCollected.Equals(other.TypeCollected) { return false }
	if !compareSlices(m.PatientPreparation, other.PatientPreparation) { return false }
	if !m.TimeAspect.Equals(other.TimeAspect) { return false }
	if !compareSlices(m.Collection, other.Collection) { return false }
	if !compareSlices(m.TypeTested, other.TypeTested) { return false }
	return true
}

// SpecimenDefinitionTypeTested
// Specimen conditioned in a container as expected by the testing laboratory.
type SpecimenDefinitionTypeTested struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	IsDerived *FhirBoolean `json:"isderived,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Preference *SpecimenContainedPreference `json:"preference,omitempty"`
	Container *SpecimenDefinitionContainer `json:"container,omitempty"`
	Requirement *FhirString `json:"requirement,omitempty"`
	RetentionTime *FhirDuration `json:"retentiontime,omitempty"`
	RejectionCriterion []*CodeableConcept `json:"rejectioncriterion,omitempty"`
	Handling []*SpecimenDefinitionHandling `json:"handling,omitempty"`
}

// NewSpecimenDefinitionTypeTested creates a new SpecimenDefinitionTypeTested instance
func NewSpecimenDefinitionTypeTested() *SpecimenDefinitionTypeTested {
	return &SpecimenDefinitionTypeTested{}
}

// FromJSON populates SpecimenDefinitionTypeTested from JSON data
func (m *SpecimenDefinitionTypeTested) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenDefinitionTypeTested to JSON data
func (m *SpecimenDefinitionTypeTested) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenDefinitionTypeTested
func (m *SpecimenDefinitionTypeTested) Clone() *SpecimenDefinitionTypeTested {
	if m == nil { return nil }
	return &SpecimenDefinitionTypeTested{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		IsDerived: m.IsDerived.Clone(),
		Type: m.Type.Clone(),
		Preference: m.Preference.Clone(),
		Container: m.Container.Clone(),
		Requirement: m.Requirement.Clone(),
		RetentionTime: m.RetentionTime.Clone(),
		RejectionCriterion: cloneSlices(m.RejectionCriterion),
		Handling: cloneSlices(m.Handling),
	}
}

// Equals checks for equality with another SpecimenDefinitionTypeTested instance
func (m *SpecimenDefinitionTypeTested) Equals(other *SpecimenDefinitionTypeTested) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.IsDerived.Equals(other.IsDerived) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Preference.Equals(other.Preference) { return false }
	if !m.Container.Equals(other.Container) { return false }
	if !m.Requirement.Equals(other.Requirement) { return false }
	if !m.RetentionTime.Equals(other.RetentionTime) { return false }
	if !compareSlices(m.RejectionCriterion, other.RejectionCriterion) { return false }
	if !compareSlices(m.Handling, other.Handling) { return false }
	return true
}

// SpecimenDefinitionContainer
// The specimen's container.
type SpecimenDefinitionContainer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Material *CodeableConcept `json:"material,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Cap *CodeableConcept `json:"cap,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Capacity *Quantity `json:"capacity,omitempty"`
	MinimumVolumeQuantity *Quantity `json:"minimumvolumequantity,omitempty"`
	MinimumVolumeString *FhirString `json:"minimumvolumestring,omitempty"`
	Additive []*SpecimenDefinitionAdditive `json:"additive,omitempty"`
	Preparation *FhirString `json:"preparation,omitempty"`
}

// NewSpecimenDefinitionContainer creates a new SpecimenDefinitionContainer instance
func NewSpecimenDefinitionContainer() *SpecimenDefinitionContainer {
	return &SpecimenDefinitionContainer{}
}

// FromJSON populates SpecimenDefinitionContainer from JSON data
func (m *SpecimenDefinitionContainer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenDefinitionContainer to JSON data
func (m *SpecimenDefinitionContainer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenDefinitionContainer
func (m *SpecimenDefinitionContainer) Clone() *SpecimenDefinitionContainer {
	if m == nil { return nil }
	return &SpecimenDefinitionContainer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Material: m.Material.Clone(),
		Type: m.Type.Clone(),
		Cap: m.Cap.Clone(),
		Description: m.Description.Clone(),
		Capacity: m.Capacity.Clone(),
		MinimumVolumeQuantity: m.MinimumVolumeQuantity.Clone(),
		MinimumVolumeString: m.MinimumVolumeString.Clone(),
		Additive: cloneSlices(m.Additive),
		Preparation: m.Preparation.Clone(),
	}
}

// Equals checks for equality with another SpecimenDefinitionContainer instance
func (m *SpecimenDefinitionContainer) Equals(other *SpecimenDefinitionContainer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Material.Equals(other.Material) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Cap.Equals(other.Cap) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Capacity.Equals(other.Capacity) { return false }
	if !m.MinimumVolumeQuantity.Equals(other.MinimumVolumeQuantity) { return false }
	if !m.MinimumVolumeString.Equals(other.MinimumVolumeString) { return false }
	if !compareSlices(m.Additive, other.Additive) { return false }
	if !m.Preparation.Equals(other.Preparation) { return false }
	return true
}

// SpecimenDefinitionAdditive
// Substance introduced in the kind of container to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
type SpecimenDefinitionAdditive struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	AdditiveCodeableConcept *CodeableConcept `json:"additivecodeableconcept,omitempty"`
	AdditiveReference *Reference `json:"additivereference,omitempty"`
}

// NewSpecimenDefinitionAdditive creates a new SpecimenDefinitionAdditive instance
func NewSpecimenDefinitionAdditive() *SpecimenDefinitionAdditive {
	return &SpecimenDefinitionAdditive{}
}

// FromJSON populates SpecimenDefinitionAdditive from JSON data
func (m *SpecimenDefinitionAdditive) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenDefinitionAdditive to JSON data
func (m *SpecimenDefinitionAdditive) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenDefinitionAdditive
func (m *SpecimenDefinitionAdditive) Clone() *SpecimenDefinitionAdditive {
	if m == nil { return nil }
	return &SpecimenDefinitionAdditive{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		AdditiveCodeableConcept: m.AdditiveCodeableConcept.Clone(),
		AdditiveReference: m.AdditiveReference.Clone(),
	}
}

// Equals checks for equality with another SpecimenDefinitionAdditive instance
func (m *SpecimenDefinitionAdditive) Equals(other *SpecimenDefinitionAdditive) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.AdditiveCodeableConcept.Equals(other.AdditiveCodeableConcept) { return false }
	if !m.AdditiveReference.Equals(other.AdditiveReference) { return false }
	return true
}

// SpecimenDefinitionHandling
// Set of instructions for preservation/transport of the specimen at a defined temperature interval, prior the testing process.
type SpecimenDefinitionHandling struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	TemperatureQualifier *CodeableConcept `json:"temperaturequalifier,omitempty"`
	TemperatureRange *Range `json:"temperaturerange,omitempty"`
	MaxDuration *FhirDuration `json:"maxduration,omitempty"`
	Instruction *FhirString `json:"instruction,omitempty"`
}

// NewSpecimenDefinitionHandling creates a new SpecimenDefinitionHandling instance
func NewSpecimenDefinitionHandling() *SpecimenDefinitionHandling {
	return &SpecimenDefinitionHandling{}
}

// FromJSON populates SpecimenDefinitionHandling from JSON data
func (m *SpecimenDefinitionHandling) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SpecimenDefinitionHandling to JSON data
func (m *SpecimenDefinitionHandling) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SpecimenDefinitionHandling
func (m *SpecimenDefinitionHandling) Clone() *SpecimenDefinitionHandling {
	if m == nil { return nil }
	return &SpecimenDefinitionHandling{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		TemperatureQualifier: m.TemperatureQualifier.Clone(),
		TemperatureRange: m.TemperatureRange.Clone(),
		MaxDuration: m.MaxDuration.Clone(),
		Instruction: m.Instruction.Clone(),
	}
}

// Equals checks for equality with another SpecimenDefinitionHandling instance
func (m *SpecimenDefinitionHandling) Equals(other *SpecimenDefinitionHandling) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.TemperatureQualifier.Equals(other.TemperatureQualifier) { return false }
	if !m.TemperatureRange.Equals(other.TemperatureRange) { return false }
	if !m.MaxDuration.Equals(other.MaxDuration) { return false }
	if !m.Instruction.Equals(other.Instruction) { return false }
	return true
}

