// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// ResearchStudy
// A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.
type ResearchStudy struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Protocol []*Reference `json:"protocol,omitempty"`
	PartOf []*Reference `json:"partof,omitempty"`
	Status *ResearchStudyStatus `json:"status,omitempty"`
	PrimaryPurposeType *CodeableConcept `json:"primarypurposetype,omitempty"`
	Phase *CodeableConcept `json:"phase,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Focus []*CodeableConcept `json:"focus,omitempty"`
	Condition []*CodeableConcept `json:"condition,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
	Keyword []*CodeableConcept `json:"keyword,omitempty"`
	Location []*CodeableConcept `json:"location,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Enrollment []*Reference `json:"enrollment,omitempty"`
	Period *Period `json:"period,omitempty"`
	Sponsor *Reference `json:"sponsor,omitempty"`
	PrincipalInvestigator *Reference `json:"principalinvestigator,omitempty"`
	Site []*Reference `json:"site,omitempty"`
	ReasonStopped *CodeableConcept `json:"reasonstopped,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Arm []*ResearchStudyArm `json:"arm,omitempty"`
	Objective []*ResearchStudyObjective `json:"objective,omitempty"`
}

// NewResearchStudy creates a new ResearchStudy instance.
func NewResearchStudy() *ResearchStudy {
	return &ResearchStudy{}
}

// UnmarshalJSON populates ResearchStudy from JSON data.
func (m *ResearchStudy) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Title *FhirString `json:"title,omitempty"`
		Protocol []*Reference `json:"protocol,omitempty"`
		PartOf []*Reference `json:"partof,omitempty"`
		Status *ResearchStudyStatus `json:"status,omitempty"`
		PrimaryPurposeType *CodeableConcept `json:"primarypurposetype,omitempty"`
		Phase *CodeableConcept `json:"phase,omitempty"`
		Category []*CodeableConcept `json:"category,omitempty"`
		Focus []*CodeableConcept `json:"focus,omitempty"`
		Condition []*CodeableConcept `json:"condition,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
		Keyword []*CodeableConcept `json:"keyword,omitempty"`
		Location []*CodeableConcept `json:"location,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		Enrollment []*Reference `json:"enrollment,omitempty"`
		Period *Period `json:"period,omitempty"`
		Sponsor *Reference `json:"sponsor,omitempty"`
		PrincipalInvestigator *Reference `json:"principalinvestigator,omitempty"`
		Site []*Reference `json:"site,omitempty"`
		ReasonStopped *CodeableConcept `json:"reasonstopped,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Arm []*ResearchStudyArm `json:"arm,omitempty"`
		Objective []*ResearchStudyObjective `json:"objective,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Title = temp.Title
	m.Protocol = temp.Protocol
	m.PartOf = temp.PartOf
	m.Status = temp.Status
	m.PrimaryPurposeType = temp.PrimaryPurposeType
	m.Phase = temp.Phase
	m.Category = temp.Category
	m.Focus = temp.Focus
	m.Condition = temp.Condition
	m.Contact = temp.Contact
	m.RelatedArtifact = temp.RelatedArtifact
	m.Keyword = temp.Keyword
	m.Location = temp.Location
	m.Description = temp.Description
	m.Enrollment = temp.Enrollment
	m.Period = temp.Period
	m.Sponsor = temp.Sponsor
	m.PrincipalInvestigator = temp.PrincipalInvestigator
	m.Site = temp.Site
	m.ReasonStopped = temp.ReasonStopped
	m.Note = temp.Note
	m.Arm = temp.Arm
	m.Objective = temp.Objective
	return nil
}

// MarshalJSON converts ResearchStudy to JSON data.
func (m *ResearchStudy) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Title interface{} `json:"title,omitempty"`
		TitleElement map[string]interface{} `json:"_title,omitempty"`
		Protocol []*Reference `json:"protocol,omitempty"`
		PartOf []*Reference `json:"partof,omitempty"`
		Status *ResearchStudyStatus `json:"status,omitempty"`
		PrimaryPurposeType *CodeableConcept `json:"primarypurposetype,omitempty"`
		Phase *CodeableConcept `json:"phase,omitempty"`
		Category []*CodeableConcept `json:"category,omitempty"`
		Focus []*CodeableConcept `json:"focus,omitempty"`
		Condition []*CodeableConcept `json:"condition,omitempty"`
		Contact []*ContactDetail `json:"contact,omitempty"`
		RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
		Keyword []*CodeableConcept `json:"keyword,omitempty"`
		Location []*CodeableConcept `json:"location,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Enrollment []*Reference `json:"enrollment,omitempty"`
		Period *Period `json:"period,omitempty"`
		Sponsor *Reference `json:"sponsor,omitempty"`
		PrincipalInvestigator *Reference `json:"principalinvestigator,omitempty"`
		Site []*Reference `json:"site,omitempty"`
		ReasonStopped *CodeableConcept `json:"reasonstopped,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Arm []*ResearchStudyArm `json:"arm,omitempty"`
		Objective []*ResearchStudyObjective `json:"objective,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	if m.Title != nil && m.Title.Value != nil {
		output.Title = m.Title.Value
		if m.Title.Element != nil {
			output.TitleElement = toMapOrNil(m.Title.Element.MarshalJSON())
		}
	}
	output.Protocol = m.Protocol
	output.PartOf = m.PartOf
	output.Status = m.Status
	output.PrimaryPurposeType = m.PrimaryPurposeType
	output.Phase = m.Phase
	output.Category = m.Category
	output.Focus = m.Focus
	output.Condition = m.Condition
	output.Contact = m.Contact
	output.RelatedArtifact = m.RelatedArtifact
	output.Keyword = m.Keyword
	output.Location = m.Location
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Enrollment = m.Enrollment
	output.Period = m.Period
	output.Sponsor = m.Sponsor
	output.PrincipalInvestigator = m.PrincipalInvestigator
	output.Site = m.Site
	output.ReasonStopped = m.ReasonStopped
	output.Note = m.Note
	output.Arm = m.Arm
	output.Objective = m.Objective
	return json.Marshal(output)
}

// Clone creates a deep copy of ResearchStudy.
func (m *ResearchStudy) Clone() *ResearchStudy {
	if m == nil { return nil }
	return &ResearchStudy{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Title: m.Title.Clone(),
		Protocol: cloneSlices(m.Protocol),
		PartOf: cloneSlices(m.PartOf),
		Status: m.Status.Clone(),
		PrimaryPurposeType: m.PrimaryPurposeType.Clone(),
		Phase: m.Phase.Clone(),
		Category: cloneSlices(m.Category),
		Focus: cloneSlices(m.Focus),
		Condition: cloneSlices(m.Condition),
		Contact: cloneSlices(m.Contact),
		RelatedArtifact: cloneSlices(m.RelatedArtifact),
		Keyword: cloneSlices(m.Keyword),
		Location: cloneSlices(m.Location),
		Description: m.Description.Clone(),
		Enrollment: cloneSlices(m.Enrollment),
		Period: m.Period.Clone(),
		Sponsor: m.Sponsor.Clone(),
		PrincipalInvestigator: m.PrincipalInvestigator.Clone(),
		Site: cloneSlices(m.Site),
		ReasonStopped: m.ReasonStopped.Clone(),
		Note: cloneSlices(m.Note),
		Arm: cloneSlices(m.Arm),
		Objective: cloneSlices(m.Objective),
	}
}

// Equals checks equality between two ResearchStudy instances.
func (m *ResearchStudy) Equals(other *ResearchStudy) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !compareSlices(m.Protocol, other.Protocol) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.PrimaryPurposeType.Equals(other.PrimaryPurposeType) { return false }
	if !m.Phase.Equals(other.Phase) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !compareSlices(m.Focus, other.Focus) { return false }
	if !compareSlices(m.Condition, other.Condition) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !compareSlices(m.RelatedArtifact, other.RelatedArtifact) { return false }
	if !compareSlices(m.Keyword, other.Keyword) { return false }
	if !compareSlices(m.Location, other.Location) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Enrollment, other.Enrollment) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.Sponsor.Equals(other.Sponsor) { return false }
	if !m.PrincipalInvestigator.Equals(other.PrincipalInvestigator) { return false }
	if !compareSlices(m.Site, other.Site) { return false }
	if !m.ReasonStopped.Equals(other.ReasonStopped) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.Arm, other.Arm) { return false }
	if !compareSlices(m.Objective, other.Objective) { return false }
	return true
}

// ResearchStudyArm
// Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
type ResearchStudyArm struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Description *FhirString `json:"description,omitempty"`
}

// NewResearchStudyArm creates a new ResearchStudyArm instance.
func NewResearchStudyArm() *ResearchStudyArm {
	return &ResearchStudyArm{}
}

// UnmarshalJSON populates ResearchStudyArm from JSON data.
func (m *ResearchStudyArm) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Description *FhirString `json:"description,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.Type = temp.Type
	m.Description = temp.Description
	return nil
}

// MarshalJSON converts ResearchStudyArm to JSON data.
func (m *ResearchStudyArm) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	output.Type = m.Type
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of ResearchStudyArm.
func (m *ResearchStudyArm) Clone() *ResearchStudyArm {
	if m == nil { return nil }
	return &ResearchStudyArm{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
		Description: m.Description.Clone(),
	}
}

// Equals checks equality between two ResearchStudyArm instances.
func (m *ResearchStudyArm) Equals(other *ResearchStudyArm) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Description.Equals(other.Description) { return false }
	return true
}

// ResearchStudyObjective
// A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
type ResearchStudyObjective struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
}

// NewResearchStudyObjective creates a new ResearchStudyObjective instance.
func NewResearchStudyObjective() *ResearchStudyObjective {
	return &ResearchStudyObjective{}
}

// UnmarshalJSON populates ResearchStudyObjective from JSON data.
func (m *ResearchStudyObjective) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.Type = temp.Type
	return nil
}

// MarshalJSON converts ResearchStudyObjective to JSON data.
func (m *ResearchStudyObjective) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.MarshalJSON())
		}
	}
	output.Type = m.Type
	return json.Marshal(output)
}

// Clone creates a deep copy of ResearchStudyObjective.
func (m *ResearchStudyObjective) Clone() *ResearchStudyObjective {
	if m == nil { return nil }
	return &ResearchStudyObjective{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks equality between two ResearchStudyObjective instances.
func (m *ResearchStudyObjective) Equals(other *ResearchStudyObjective) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

