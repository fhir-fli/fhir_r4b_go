// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ResearchDefinition
// The ResearchDefinition resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about.
type ResearchDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	ShortTitle *FhirString `json:"shorttitle,omitempty"`
	Subtitle *FhirString `json:"subtitle,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	SubjectCodeableConcept *CodeableConcept `json:"subjectcodeableconcept,omitempty"`
	SubjectReference *Reference `json:"subjectreference,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Comment []*FhirString `json:"comment,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Usage *FhirString `json:"usage,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	Topic []*CodeableConcept `json:"topic,omitempty"`
	Author []*ContactDetail `json:"author,omitempty"`
	Editor []*ContactDetail `json:"editor,omitempty"`
	Reviewer []*ContactDetail `json:"reviewer,omitempty"`
	Endorser []*ContactDetail `json:"endorser,omitempty"`
	RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
	Library_ []*FhirCanonical `json:"library,omitempty"`
	Population *Reference `json:"population,omitempty"`
	Exposure *Reference `json:"exposure,omitempty"`
	ExposureAlternative *Reference `json:"exposurealternative,omitempty"`
	Outcome *Reference `json:"outcome,omitempty"`
}

// NewResearchDefinition creates a new ResearchDefinition instance
func NewResearchDefinition() *ResearchDefinition {
	return &ResearchDefinition{}
}

// FromJSON populates ResearchDefinition from JSON data
func (m *ResearchDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ResearchDefinition to JSON data
func (m *ResearchDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ResearchDefinition
func (m *ResearchDefinition) Clone() *ResearchDefinition {
	if m == nil { return nil }
	return &ResearchDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		ShortTitle: m.ShortTitle.Clone(),
		Subtitle: m.Subtitle.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		SubjectCodeableConcept: m.SubjectCodeableConcept.Clone(),
		SubjectReference: m.SubjectReference.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		Comment: cloneSlices(m.Comment),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Usage: m.Usage.Clone(),
		Copyright: m.Copyright.Clone(),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		Topic: cloneSlices(m.Topic),
		Author: cloneSlices(m.Author),
		Editor: cloneSlices(m.Editor),
		Reviewer: cloneSlices(m.Reviewer),
		Endorser: cloneSlices(m.Endorser),
		RelatedArtifact: cloneSlices(m.RelatedArtifact),
		Library_: cloneSlices(m.Library_),
		Population: m.Population.Clone(),
		Exposure: m.Exposure.Clone(),
		ExposureAlternative: m.ExposureAlternative.Clone(),
		Outcome: m.Outcome.Clone(),
	}
}

// Equals checks for equality with another ResearchDefinition instance
func (m *ResearchDefinition) Equals(other *ResearchDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.ShortTitle.Equals(other.ShortTitle) { return false }
	if !m.Subtitle.Equals(other.Subtitle) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.SubjectCodeableConcept.Equals(other.SubjectCodeableConcept) { return false }
	if !m.SubjectReference.Equals(other.SubjectReference) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Comment, other.Comment) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Usage.Equals(other.Usage) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !compareSlices(m.Topic, other.Topic) { return false }
	if !compareSlices(m.Author, other.Author) { return false }
	if !compareSlices(m.Editor, other.Editor) { return false }
	if !compareSlices(m.Reviewer, other.Reviewer) { return false }
	if !compareSlices(m.Endorser, other.Endorser) { return false }
	if !compareSlices(m.RelatedArtifact, other.RelatedArtifact) { return false }
	if !compareSlices(m.Library_, other.Library_) { return false }
	if !m.Population.Equals(other.Population) { return false }
	if !m.Exposure.Equals(other.Exposure) { return false }
	if !m.ExposureAlternative.Equals(other.ExposureAlternative) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	return true
}

