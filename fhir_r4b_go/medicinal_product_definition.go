// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// MedicinalProductDefinition
// A medicinal product, being a substance or combination of substances that is intended to treat, prevent or diagnose a disease, or to restore, correct or modify physiological functions by exerting a pharmacological, immunological or metabolic action. This resource is intended to define and detail such products and their properties, for uses other than direct patient care (e.g. regulatory use, or drug catalogs).
type MedicinalProductDefinition struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Domain *CodeableConcept `json:"domain,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	StatusDate *FhirDateTime `json:"statusdate,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	CombinedPharmaceuticalDoseForm *CodeableConcept `json:"combinedpharmaceuticaldoseform,omitempty"`
	Route []*CodeableConcept `json:"route,omitempty"`
	Indication *FhirMarkdown `json:"indication,omitempty"`
	LegalStatusOfSupply *CodeableConcept `json:"legalstatusofsupply,omitempty"`
	AdditionalMonitoringIndicator *CodeableConcept `json:"additionalmonitoringindicator,omitempty"`
	SpecialMeasures []*CodeableConcept `json:"specialmeasures,omitempty"`
	PediatricUseIndicator *CodeableConcept `json:"pediatricuseindicator,omitempty"`
	Classification []*CodeableConcept `json:"classification,omitempty"`
	MarketingStatus []*MarketingStatus `json:"marketingstatus,omitempty"`
	PackagedMedicinalProduct []*CodeableConcept `json:"packagedmedicinalproduct,omitempty"`
	Ingredient []*CodeableConcept `json:"ingredient,omitempty"`
	Impurity []*CodeableReference `json:"impurity,omitempty"`
	AttachedDocument []*Reference `json:"attacheddocument,omitempty"`
	MasterFile []*Reference `json:"masterfile,omitempty"`
	Contact []*MedicinalProductDefinitionContact `json:"contact,omitempty"`
	ClinicalTrial []*Reference `json:"clinicaltrial,omitempty"`
	Code []*Coding `json:"code,omitempty"`
	Name []*MedicinalProductDefinitionName `json:"name,omitempty"`
	CrossReference []*MedicinalProductDefinitionCrossReference `json:"crossreference,omitempty"`
	Operation []*MedicinalProductDefinitionOperation `json:"operation,omitempty"`
	Characteristic []*MedicinalProductDefinitionCharacteristic `json:"characteristic,omitempty"`
}

// NewMedicinalProductDefinition creates a new MedicinalProductDefinition instance.
func NewMedicinalProductDefinition() *MedicinalProductDefinition {
	return &MedicinalProductDefinition{}
}

// UnmarshalJSON populates MedicinalProductDefinition from JSON data.
func (m *MedicinalProductDefinition) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Domain *CodeableConcept `json:"domain,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		StatusDate *FhirDateTime `json:"statusdate,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		CombinedPharmaceuticalDoseForm *CodeableConcept `json:"combinedpharmaceuticaldoseform,omitempty"`
		Route []*CodeableConcept `json:"route,omitempty"`
		Indication *FhirMarkdown `json:"indication,omitempty"`
		LegalStatusOfSupply *CodeableConcept `json:"legalstatusofsupply,omitempty"`
		AdditionalMonitoringIndicator *CodeableConcept `json:"additionalmonitoringindicator,omitempty"`
		SpecialMeasures []*CodeableConcept `json:"specialmeasures,omitempty"`
		PediatricUseIndicator *CodeableConcept `json:"pediatricuseindicator,omitempty"`
		Classification []*CodeableConcept `json:"classification,omitempty"`
		MarketingStatus []*MarketingStatus `json:"marketingstatus,omitempty"`
		PackagedMedicinalProduct []*CodeableConcept `json:"packagedmedicinalproduct,omitempty"`
		Ingredient []*CodeableConcept `json:"ingredient,omitempty"`
		Impurity []*CodeableReference `json:"impurity,omitempty"`
		AttachedDocument []*Reference `json:"attacheddocument,omitempty"`
		MasterFile []*Reference `json:"masterfile,omitempty"`
		Contact []*MedicinalProductDefinitionContact `json:"contact,omitempty"`
		ClinicalTrial []*Reference `json:"clinicaltrial,omitempty"`
		Code []*Coding `json:"code,omitempty"`
		Name []*MedicinalProductDefinitionName `json:"name,omitempty"`
		CrossReference []*MedicinalProductDefinitionCrossReference `json:"crossreference,omitempty"`
		Operation []*MedicinalProductDefinitionOperation `json:"operation,omitempty"`
		Characteristic []*MedicinalProductDefinitionCharacteristic `json:"characteristic,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Type = temp.Type
	m.Domain = temp.Domain
	m.Version = temp.Version
	m.Status = temp.Status
	m.StatusDate = temp.StatusDate
	m.Description = temp.Description
	m.CombinedPharmaceuticalDoseForm = temp.CombinedPharmaceuticalDoseForm
	m.Route = temp.Route
	m.Indication = temp.Indication
	m.LegalStatusOfSupply = temp.LegalStatusOfSupply
	m.AdditionalMonitoringIndicator = temp.AdditionalMonitoringIndicator
	m.SpecialMeasures = temp.SpecialMeasures
	m.PediatricUseIndicator = temp.PediatricUseIndicator
	m.Classification = temp.Classification
	m.MarketingStatus = temp.MarketingStatus
	m.PackagedMedicinalProduct = temp.PackagedMedicinalProduct
	m.Ingredient = temp.Ingredient
	m.Impurity = temp.Impurity
	m.AttachedDocument = temp.AttachedDocument
	m.MasterFile = temp.MasterFile
	m.Contact = temp.Contact
	m.ClinicalTrial = temp.ClinicalTrial
	m.Code = temp.Code
	m.Name = temp.Name
	m.CrossReference = temp.CrossReference
	m.Operation = temp.Operation
	m.Characteristic = temp.Characteristic
	return nil
}

// MarshalJSON converts MedicinalProductDefinition to JSON data.
func (m *MedicinalProductDefinition) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Domain *CodeableConcept `json:"domain,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		StatusDate interface{} `json:"statusdate,omitempty"`
		StatusDateElement map[string]interface{} `json:"_statusdate,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		CombinedPharmaceuticalDoseForm *CodeableConcept `json:"combinedpharmaceuticaldoseform,omitempty"`
		Route []*CodeableConcept `json:"route,omitempty"`
		Indication interface{} `json:"indication,omitempty"`
		IndicationElement map[string]interface{} `json:"_indication,omitempty"`
		LegalStatusOfSupply *CodeableConcept `json:"legalstatusofsupply,omitempty"`
		AdditionalMonitoringIndicator *CodeableConcept `json:"additionalmonitoringindicator,omitempty"`
		SpecialMeasures []*CodeableConcept `json:"specialmeasures,omitempty"`
		PediatricUseIndicator *CodeableConcept `json:"pediatricuseindicator,omitempty"`
		Classification []*CodeableConcept `json:"classification,omitempty"`
		MarketingStatus []*MarketingStatus `json:"marketingstatus,omitempty"`
		PackagedMedicinalProduct []*CodeableConcept `json:"packagedmedicinalproduct,omitempty"`
		Ingredient []*CodeableConcept `json:"ingredient,omitempty"`
		Impurity []*CodeableReference `json:"impurity,omitempty"`
		AttachedDocument []*Reference `json:"attacheddocument,omitempty"`
		MasterFile []*Reference `json:"masterfile,omitempty"`
		Contact []*MedicinalProductDefinitionContact `json:"contact,omitempty"`
		ClinicalTrial []*Reference `json:"clinicaltrial,omitempty"`
		Code []*Coding `json:"code,omitempty"`
		Name []*MedicinalProductDefinitionName `json:"name,omitempty"`
		CrossReference []*MedicinalProductDefinitionCrossReference `json:"crossreference,omitempty"`
		Operation []*MedicinalProductDefinitionOperation `json:"operation,omitempty"`
		Characteristic []*MedicinalProductDefinitionCharacteristic `json:"characteristic,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Type = m.Type
	output.Domain = m.Domain
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.MarshalJSON())
		}
	}
	output.Status = m.Status
	if m.StatusDate != nil && m.StatusDate.Value != nil {
		output.StatusDate = m.StatusDate.Value
		if m.StatusDate.Element != nil {
			output.StatusDateElement = toMapOrNil(m.StatusDate.Element.MarshalJSON())
		}
	}
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.CombinedPharmaceuticalDoseForm = m.CombinedPharmaceuticalDoseForm
	output.Route = m.Route
	if m.Indication != nil && m.Indication.Value != nil {
		output.Indication = m.Indication.Value
		if m.Indication.Element != nil {
			output.IndicationElement = toMapOrNil(m.Indication.Element.MarshalJSON())
		}
	}
	output.LegalStatusOfSupply = m.LegalStatusOfSupply
	output.AdditionalMonitoringIndicator = m.AdditionalMonitoringIndicator
	output.SpecialMeasures = m.SpecialMeasures
	output.PediatricUseIndicator = m.PediatricUseIndicator
	output.Classification = m.Classification
	output.MarketingStatus = m.MarketingStatus
	output.PackagedMedicinalProduct = m.PackagedMedicinalProduct
	output.Ingredient = m.Ingredient
	output.Impurity = m.Impurity
	output.AttachedDocument = m.AttachedDocument
	output.MasterFile = m.MasterFile
	output.Contact = m.Contact
	output.ClinicalTrial = m.ClinicalTrial
	output.Code = m.Code
	output.Name = m.Name
	output.CrossReference = m.CrossReference
	output.Operation = m.Operation
	output.Characteristic = m.Characteristic
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinition.
func (m *MedicinalProductDefinition) Clone() *MedicinalProductDefinition {
	if m == nil { return nil }
	return &MedicinalProductDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Type: m.Type.Clone(),
		Domain: m.Domain.Clone(),
		Version: m.Version.Clone(),
		Status: m.Status.Clone(),
		StatusDate: m.StatusDate.Clone(),
		Description: m.Description.Clone(),
		CombinedPharmaceuticalDoseForm: m.CombinedPharmaceuticalDoseForm.Clone(),
		Route: cloneSlices(m.Route),
		Indication: m.Indication.Clone(),
		LegalStatusOfSupply: m.LegalStatusOfSupply.Clone(),
		AdditionalMonitoringIndicator: m.AdditionalMonitoringIndicator.Clone(),
		SpecialMeasures: cloneSlices(m.SpecialMeasures),
		PediatricUseIndicator: m.PediatricUseIndicator.Clone(),
		Classification: cloneSlices(m.Classification),
		MarketingStatus: cloneSlices(m.MarketingStatus),
		PackagedMedicinalProduct: cloneSlices(m.PackagedMedicinalProduct),
		Ingredient: cloneSlices(m.Ingredient),
		Impurity: cloneSlices(m.Impurity),
		AttachedDocument: cloneSlices(m.AttachedDocument),
		MasterFile: cloneSlices(m.MasterFile),
		Contact: cloneSlices(m.Contact),
		ClinicalTrial: cloneSlices(m.ClinicalTrial),
		Code: cloneSlices(m.Code),
		Name: cloneSlices(m.Name),
		CrossReference: cloneSlices(m.CrossReference),
		Operation: cloneSlices(m.Operation),
		Characteristic: cloneSlices(m.Characteristic),
	}
}

// Equals checks equality between two MedicinalProductDefinition instances.
func (m *MedicinalProductDefinition) Equals(other *MedicinalProductDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Domain.Equals(other.Domain) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.CombinedPharmaceuticalDoseForm.Equals(other.CombinedPharmaceuticalDoseForm) { return false }
	if !compareSlices(m.Route, other.Route) { return false }
	if !m.Indication.Equals(other.Indication) { return false }
	if !m.LegalStatusOfSupply.Equals(other.LegalStatusOfSupply) { return false }
	if !m.AdditionalMonitoringIndicator.Equals(other.AdditionalMonitoringIndicator) { return false }
	if !compareSlices(m.SpecialMeasures, other.SpecialMeasures) { return false }
	if !m.PediatricUseIndicator.Equals(other.PediatricUseIndicator) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	if !compareSlices(m.MarketingStatus, other.MarketingStatus) { return false }
	if !compareSlices(m.PackagedMedicinalProduct, other.PackagedMedicinalProduct) { return false }
	if !compareSlices(m.Ingredient, other.Ingredient) { return false }
	if !compareSlices(m.Impurity, other.Impurity) { return false }
	if !compareSlices(m.AttachedDocument, other.AttachedDocument) { return false }
	if !compareSlices(m.MasterFile, other.MasterFile) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !compareSlices(m.ClinicalTrial, other.ClinicalTrial) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Name, other.Name) { return false }
	if !compareSlices(m.CrossReference, other.CrossReference) { return false }
	if !compareSlices(m.Operation, other.Operation) { return false }
	if !compareSlices(m.Characteristic, other.Characteristic) { return false }
	return true
}

// MedicinalProductDefinitionContact
// A product specific contact, person (in a role), or an organization.
type MedicinalProductDefinitionContact struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Contact *Reference `json:"contact,omitempty"`
}

// NewMedicinalProductDefinitionContact creates a new MedicinalProductDefinitionContact instance.
func NewMedicinalProductDefinitionContact() *MedicinalProductDefinitionContact {
	return &MedicinalProductDefinitionContact{}
}

// UnmarshalJSON populates MedicinalProductDefinitionContact from JSON data.
func (m *MedicinalProductDefinitionContact) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Contact *Reference `json:"contact,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Contact = temp.Contact
	return nil
}

// MarshalJSON converts MedicinalProductDefinitionContact to JSON data.
func (m *MedicinalProductDefinitionContact) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Contact *Reference `json:"contact,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Contact = m.Contact
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinitionContact.
func (m *MedicinalProductDefinitionContact) Clone() *MedicinalProductDefinitionContact {
	if m == nil { return nil }
	return &MedicinalProductDefinitionContact{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Contact: m.Contact.Clone(),
	}
}

// Equals checks equality between two MedicinalProductDefinitionContact instances.
func (m *MedicinalProductDefinitionContact) Equals(other *MedicinalProductDefinitionContact) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Contact.Equals(other.Contact) { return false }
	return true
}

// MedicinalProductDefinitionName
// The product's name, including full name and possibly coded parts.
type MedicinalProductDefinitionName struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductName *FhirString `json:"productname,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	NamePart []*MedicinalProductDefinitionNamePart `json:"namepart,omitempty"`
	CountryLanguage []*MedicinalProductDefinitionCountryLanguage `json:"countrylanguage,omitempty"`
}

// NewMedicinalProductDefinitionName creates a new MedicinalProductDefinitionName instance.
func NewMedicinalProductDefinitionName() *MedicinalProductDefinitionName {
	return &MedicinalProductDefinitionName{}
}

// UnmarshalJSON populates MedicinalProductDefinitionName from JSON data.
func (m *MedicinalProductDefinitionName) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ProductName *FhirString `json:"productname,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		NamePart []*MedicinalProductDefinitionNamePart `json:"namepart,omitempty"`
		CountryLanguage []*MedicinalProductDefinitionCountryLanguage `json:"countrylanguage,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.ProductName = temp.ProductName
	m.Type = temp.Type
	m.NamePart = temp.NamePart
	m.CountryLanguage = temp.CountryLanguage
	return nil
}

// MarshalJSON converts MedicinalProductDefinitionName to JSON data.
func (m *MedicinalProductDefinitionName) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		ProductName interface{} `json:"productname,omitempty"`
		ProductNameElement map[string]interface{} `json:"_productname,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		NamePart []*MedicinalProductDefinitionNamePart `json:"namepart,omitempty"`
		CountryLanguage []*MedicinalProductDefinitionCountryLanguage `json:"countrylanguage,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.ProductName != nil && m.ProductName.Value != nil {
		output.ProductName = m.ProductName.Value
		if m.ProductName.Element != nil {
			output.ProductNameElement = toMapOrNil(m.ProductName.Element.MarshalJSON())
		}
	}
	output.Type = m.Type
	output.NamePart = m.NamePart
	output.CountryLanguage = m.CountryLanguage
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinitionName.
func (m *MedicinalProductDefinitionName) Clone() *MedicinalProductDefinitionName {
	if m == nil { return nil }
	return &MedicinalProductDefinitionName{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductName: m.ProductName.Clone(),
		Type: m.Type.Clone(),
		NamePart: cloneSlices(m.NamePart),
		CountryLanguage: cloneSlices(m.CountryLanguage),
	}
}

// Equals checks equality between two MedicinalProductDefinitionName instances.
func (m *MedicinalProductDefinitionName) Equals(other *MedicinalProductDefinitionName) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductName.Equals(other.ProductName) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.NamePart, other.NamePart) { return false }
	if !compareSlices(m.CountryLanguage, other.CountryLanguage) { return false }
	return true
}

// MedicinalProductDefinitionNamePart
// Coding words or phrases of the name.
type MedicinalProductDefinitionNamePart struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Part_ *FhirString `json:"part,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
}

// NewMedicinalProductDefinitionNamePart creates a new MedicinalProductDefinitionNamePart instance.
func NewMedicinalProductDefinitionNamePart() *MedicinalProductDefinitionNamePart {
	return &MedicinalProductDefinitionNamePart{}
}

// UnmarshalJSON populates MedicinalProductDefinitionNamePart from JSON data.
func (m *MedicinalProductDefinitionNamePart) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Part_ *FhirString `json:"part,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Part_ = temp.Part_
	m.Type = temp.Type
	return nil
}

// MarshalJSON converts MedicinalProductDefinitionNamePart to JSON data.
func (m *MedicinalProductDefinitionNamePart) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Part_ interface{} `json:"part,omitempty"`
		Part_Element map[string]interface{} `json:"_part,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Part_ != nil && m.Part_.Value != nil {
		output.Part_ = m.Part_.Value
		if m.Part_.Element != nil {
			output.Part_Element = toMapOrNil(m.Part_.Element.MarshalJSON())
		}
	}
	output.Type = m.Type
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinitionNamePart.
func (m *MedicinalProductDefinitionNamePart) Clone() *MedicinalProductDefinitionNamePart {
	if m == nil { return nil }
	return &MedicinalProductDefinitionNamePart{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Part_: m.Part_.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks equality between two MedicinalProductDefinitionNamePart instances.
func (m *MedicinalProductDefinitionNamePart) Equals(other *MedicinalProductDefinitionNamePart) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Part_.Equals(other.Part_) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// MedicinalProductDefinitionCountryLanguage
// Country and jurisdiction where the name applies, and associated language.
type MedicinalProductDefinitionCountryLanguage struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Country *CodeableConcept `json:"country,omitempty"`
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`
	Language *CodeableConcept `json:"language,omitempty"`
}

// NewMedicinalProductDefinitionCountryLanguage creates a new MedicinalProductDefinitionCountryLanguage instance.
func NewMedicinalProductDefinitionCountryLanguage() *MedicinalProductDefinitionCountryLanguage {
	return &MedicinalProductDefinitionCountryLanguage{}
}

// UnmarshalJSON populates MedicinalProductDefinitionCountryLanguage from JSON data.
func (m *MedicinalProductDefinitionCountryLanguage) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Country *CodeableConcept `json:"country,omitempty"`
		Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`
		Language *CodeableConcept `json:"language,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Country = temp.Country
	m.Jurisdiction = temp.Jurisdiction
	m.Language = temp.Language
	return nil
}

// MarshalJSON converts MedicinalProductDefinitionCountryLanguage to JSON data.
func (m *MedicinalProductDefinitionCountryLanguage) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Country *CodeableConcept `json:"country,omitempty"`
		Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`
		Language *CodeableConcept `json:"language,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Country = m.Country
	output.Jurisdiction = m.Jurisdiction
	output.Language = m.Language
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinitionCountryLanguage.
func (m *MedicinalProductDefinitionCountryLanguage) Clone() *MedicinalProductDefinitionCountryLanguage {
	if m == nil { return nil }
	return &MedicinalProductDefinitionCountryLanguage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Country: m.Country.Clone(),
		Jurisdiction: m.Jurisdiction.Clone(),
		Language: m.Language.Clone(),
	}
}

// Equals checks equality between two MedicinalProductDefinitionCountryLanguage instances.
func (m *MedicinalProductDefinitionCountryLanguage) Equals(other *MedicinalProductDefinitionCountryLanguage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Country.Equals(other.Country) { return false }
	if !m.Jurisdiction.Equals(other.Jurisdiction) { return false }
	if !m.Language.Equals(other.Language) { return false }
	return true
}

// MedicinalProductDefinitionCrossReference
// Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
type MedicinalProductDefinitionCrossReference struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Product *CodeableReference `json:"product,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
}

// NewMedicinalProductDefinitionCrossReference creates a new MedicinalProductDefinitionCrossReference instance.
func NewMedicinalProductDefinitionCrossReference() *MedicinalProductDefinitionCrossReference {
	return &MedicinalProductDefinitionCrossReference{}
}

// UnmarshalJSON populates MedicinalProductDefinitionCrossReference from JSON data.
func (m *MedicinalProductDefinitionCrossReference) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Product *CodeableReference `json:"product,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Product = temp.Product
	m.Type = temp.Type
	return nil
}

// MarshalJSON converts MedicinalProductDefinitionCrossReference to JSON data.
func (m *MedicinalProductDefinitionCrossReference) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Product *CodeableReference `json:"product,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Product = m.Product
	output.Type = m.Type
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinitionCrossReference.
func (m *MedicinalProductDefinitionCrossReference) Clone() *MedicinalProductDefinitionCrossReference {
	if m == nil { return nil }
	return &MedicinalProductDefinitionCrossReference{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Product: m.Product.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks equality between two MedicinalProductDefinitionCrossReference instances.
func (m *MedicinalProductDefinitionCrossReference) Equals(other *MedicinalProductDefinitionCrossReference) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Product.Equals(other.Product) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// MedicinalProductDefinitionOperation
// A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
type MedicinalProductDefinitionOperation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableReference `json:"type,omitempty"`
	EffectiveDate *Period `json:"effectivedate,omitempty"`
	Organization []*Reference `json:"organization,omitempty"`
	ConfidentialityIndicator *CodeableConcept `json:"confidentialityindicator,omitempty"`
}

// NewMedicinalProductDefinitionOperation creates a new MedicinalProductDefinitionOperation instance.
func NewMedicinalProductDefinitionOperation() *MedicinalProductDefinitionOperation {
	return &MedicinalProductDefinitionOperation{}
}

// UnmarshalJSON populates MedicinalProductDefinitionOperation from JSON data.
func (m *MedicinalProductDefinitionOperation) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableReference `json:"type,omitempty"`
		EffectiveDate *Period `json:"effectivedate,omitempty"`
		Organization []*Reference `json:"organization,omitempty"`
		ConfidentialityIndicator *CodeableConcept `json:"confidentialityindicator,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.EffectiveDate = temp.EffectiveDate
	m.Organization = temp.Organization
	m.ConfidentialityIndicator = temp.ConfidentialityIndicator
	return nil
}

// MarshalJSON converts MedicinalProductDefinitionOperation to JSON data.
func (m *MedicinalProductDefinitionOperation) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableReference `json:"type,omitempty"`
		EffectiveDate *Period `json:"effectivedate,omitempty"`
		Organization []*Reference `json:"organization,omitempty"`
		ConfidentialityIndicator *CodeableConcept `json:"confidentialityindicator,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.EffectiveDate = m.EffectiveDate
	output.Organization = m.Organization
	output.ConfidentialityIndicator = m.ConfidentialityIndicator
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinitionOperation.
func (m *MedicinalProductDefinitionOperation) Clone() *MedicinalProductDefinitionOperation {
	if m == nil { return nil }
	return &MedicinalProductDefinitionOperation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		EffectiveDate: m.EffectiveDate.Clone(),
		Organization: cloneSlices(m.Organization),
		ConfidentialityIndicator: m.ConfidentialityIndicator.Clone(),
	}
}

// Equals checks equality between two MedicinalProductDefinitionOperation instances.
func (m *MedicinalProductDefinitionOperation) Equals(other *MedicinalProductDefinitionOperation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.EffectiveDate.Equals(other.EffectiveDate) { return false }
	if !compareSlices(m.Organization, other.Organization) { return false }
	if !m.ConfidentialityIndicator.Equals(other.ConfidentialityIndicator) { return false }
	return true
}

// MedicinalProductDefinitionCharacteristic
// Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
type MedicinalProductDefinitionCharacteristic struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
}

// NewMedicinalProductDefinitionCharacteristic creates a new MedicinalProductDefinitionCharacteristic instance.
func NewMedicinalProductDefinitionCharacteristic() *MedicinalProductDefinitionCharacteristic {
	return &MedicinalProductDefinitionCharacteristic{}
}

// UnmarshalJSON populates MedicinalProductDefinitionCharacteristic from JSON data.
func (m *MedicinalProductDefinitionCharacteristic) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueDate *FhirDate `json:"valuedate,omitempty"`
		ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.ValueCodeableConcept = temp.ValueCodeableConcept
	m.ValueQuantity = temp.ValueQuantity
	m.ValueDate = temp.ValueDate
	m.ValueBoolean = temp.ValueBoolean
	m.ValueAttachment = temp.ValueAttachment
	return nil
}

// MarshalJSON converts MedicinalProductDefinitionCharacteristic to JSON data.
func (m *MedicinalProductDefinitionCharacteristic) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueDate interface{} `json:"valuedate,omitempty"`
		ValueDateElement map[string]interface{} `json:"_valuedate,omitempty"`
		ValueBoolean interface{} `json:"valueboolean,omitempty"`
		ValueBooleanElement map[string]interface{} `json:"_valueboolean,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.ValueCodeableConcept = m.ValueCodeableConcept
	output.ValueQuantity = m.ValueQuantity
	if m.ValueDate != nil && m.ValueDate.Value != nil {
		output.ValueDate = m.ValueDate.Value
		if m.ValueDate.Element != nil {
			output.ValueDateElement = toMapOrNil(m.ValueDate.Element.MarshalJSON())
		}
	}
	if m.ValueBoolean != nil && m.ValueBoolean.Value != nil {
		output.ValueBoolean = m.ValueBoolean.Value
		if m.ValueBoolean.Element != nil {
			output.ValueBooleanElement = toMapOrNil(m.ValueBoolean.Element.MarshalJSON())
		}
	}
	output.ValueAttachment = m.ValueAttachment
	return json.Marshal(output)
}

// Clone creates a deep copy of MedicinalProductDefinitionCharacteristic.
func (m *MedicinalProductDefinitionCharacteristic) Clone() *MedicinalProductDefinitionCharacteristic {
	if m == nil { return nil }
	return &MedicinalProductDefinitionCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
	}
}

// Equals checks equality between two MedicinalProductDefinitionCharacteristic instances.
func (m *MedicinalProductDefinitionCharacteristic) Equals(other *MedicinalProductDefinitionCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	return true
}

