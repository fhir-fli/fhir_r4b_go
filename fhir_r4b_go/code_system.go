// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// CodeSystem
// The CodeSystem resource is used to declare the existence of and describe a code system or code system supplement and its key properties, and optionally define a part or all of its content.
type CodeSystem struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	CaseSensitive *FhirBoolean `json:"casesensitive,omitempty"`
	ValueSet *FhirCanonical `json:"valueset,omitempty"`
	HierarchyMeaning *CodeSystemHierarchyMeaning `json:"hierarchymeaning,omitempty"`
	Compositional *FhirBoolean `json:"compositional,omitempty"`
	VersionNeeded *FhirBoolean `json:"versionneeded,omitempty"`
	Content *CodeSystemContentMode `json:"content,omitempty"`
	Supplements *FhirCanonical `json:"supplements,omitempty"`
	Count *FhirUnsignedInt `json:"count,omitempty"`
	Filter []*CodeSystemFilter `json:"filter,omitempty"`
	Property []*CodeSystemProperty `json:"property,omitempty"`
	Concept []*CodeSystemConcept `json:"concept,omitempty"`
}

// NewCodeSystem creates a new CodeSystem instance
func NewCodeSystem() *CodeSystem {
	return &CodeSystem{}
}

// FromJSON populates CodeSystem from JSON data
func (m *CodeSystem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CodeSystem to JSON data
func (m *CodeSystem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CodeSystem
func (m *CodeSystem) Clone() *CodeSystem {
	if m == nil { return nil }
	return &CodeSystem{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		CaseSensitive: m.CaseSensitive.Clone(),
		ValueSet: m.ValueSet.Clone(),
		HierarchyMeaning: m.HierarchyMeaning.Clone(),
		Compositional: m.Compositional.Clone(),
		VersionNeeded: m.VersionNeeded.Clone(),
		Content: m.Content.Clone(),
		Supplements: m.Supplements.Clone(),
		Count: m.Count.Clone(),
		Filter: cloneSlices(m.Filter),
		Property: cloneSlices(m.Property),
		Concept: cloneSlices(m.Concept),
	}
}

// Equals checks for equality with another CodeSystem instance
func (m *CodeSystem) Equals(other *CodeSystem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.CaseSensitive.Equals(other.CaseSensitive) { return false }
	if !m.ValueSet.Equals(other.ValueSet) { return false }
	if !m.HierarchyMeaning.Equals(other.HierarchyMeaning) { return false }
	if !m.Compositional.Equals(other.Compositional) { return false }
	if !m.VersionNeeded.Equals(other.VersionNeeded) { return false }
	if !m.Content.Equals(other.Content) { return false }
	if !m.Supplements.Equals(other.Supplements) { return false }
	if !m.Count.Equals(other.Count) { return false }
	if !compareSlices(m.Filter, other.Filter) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !compareSlices(m.Concept, other.Concept) { return false }
	return true
}

// CodeSystemFilter
// A filter that can be used in a value set compose statement when selecting concepts using a filter.
type CodeSystemFilter struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Operator_ []*FilterOperator `json:"operator,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewCodeSystemFilter creates a new CodeSystemFilter instance
func NewCodeSystemFilter() *CodeSystemFilter {
	return &CodeSystemFilter{}
}

// FromJSON populates CodeSystemFilter from JSON data
func (m *CodeSystemFilter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CodeSystemFilter to JSON data
func (m *CodeSystemFilter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CodeSystemFilter
func (m *CodeSystemFilter) Clone() *CodeSystemFilter {
	if m == nil { return nil }
	return &CodeSystemFilter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Description: m.Description.Clone(),
		Operator_: cloneSlices(m.Operator_),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another CodeSystemFilter instance
func (m *CodeSystemFilter) Equals(other *CodeSystemFilter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Operator_, other.Operator_) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// CodeSystemProperty
// A property defines an additional slot through which additional information can be provided about a concept.
type CodeSystemProperty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Uri *FhirUri `json:"uri,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Type *PropertyType `json:"type,omitempty"`
}

// NewCodeSystemProperty creates a new CodeSystemProperty instance
func NewCodeSystemProperty() *CodeSystemProperty {
	return &CodeSystemProperty{}
}

// FromJSON populates CodeSystemProperty from JSON data
func (m *CodeSystemProperty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CodeSystemProperty to JSON data
func (m *CodeSystemProperty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CodeSystemProperty
func (m *CodeSystemProperty) Clone() *CodeSystemProperty {
	if m == nil { return nil }
	return &CodeSystemProperty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Uri: m.Uri.Clone(),
		Description: m.Description.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks for equality with another CodeSystemProperty instance
func (m *CodeSystemProperty) Equals(other *CodeSystemProperty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Uri.Equals(other.Uri) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// CodeSystemConcept
// Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meanings of the hierarchical relationships are.
type CodeSystemConcept struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	Display *FhirString `json:"display,omitempty"`
	Definition *FhirString `json:"definition,omitempty"`
	Designation []*CodeSystemDesignation `json:"designation,omitempty"`
	Property []*CodeSystemProperty1 `json:"property,omitempty"`
	Concept []*CodeSystemConcept `json:"concept,omitempty"`
}

// NewCodeSystemConcept creates a new CodeSystemConcept instance
func NewCodeSystemConcept() *CodeSystemConcept {
	return &CodeSystemConcept{}
}

// FromJSON populates CodeSystemConcept from JSON data
func (m *CodeSystemConcept) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CodeSystemConcept to JSON data
func (m *CodeSystemConcept) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CodeSystemConcept
func (m *CodeSystemConcept) Clone() *CodeSystemConcept {
	if m == nil { return nil }
	return &CodeSystemConcept{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Display: m.Display.Clone(),
		Definition: m.Definition.Clone(),
		Designation: cloneSlices(m.Designation),
		Property: cloneSlices(m.Property),
		Concept: cloneSlices(m.Concept),
	}
}

// Equals checks for equality with another CodeSystemConcept instance
func (m *CodeSystemConcept) Equals(other *CodeSystemConcept) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Display.Equals(other.Display) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	if !compareSlices(m.Designation, other.Designation) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !compareSlices(m.Concept, other.Concept) { return false }
	return true
}

// CodeSystemDesignation
// Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
type CodeSystemDesignation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Use *Coding `json:"use,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewCodeSystemDesignation creates a new CodeSystemDesignation instance
func NewCodeSystemDesignation() *CodeSystemDesignation {
	return &CodeSystemDesignation{}
}

// FromJSON populates CodeSystemDesignation from JSON data
func (m *CodeSystemDesignation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CodeSystemDesignation to JSON data
func (m *CodeSystemDesignation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CodeSystemDesignation
func (m *CodeSystemDesignation) Clone() *CodeSystemDesignation {
	if m == nil { return nil }
	return &CodeSystemDesignation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Language: m.Language.Clone(),
		Use: m.Use.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another CodeSystemDesignation instance
func (m *CodeSystemDesignation) Equals(other *CodeSystemDesignation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// CodeSystemProperty1
// A property value for this concept.
type CodeSystemProperty1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
	ValueCode *FhirCode `json:"valuecode,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
}

// NewCodeSystemProperty1 creates a new CodeSystemProperty1 instance
func NewCodeSystemProperty1() *CodeSystemProperty1 {
	return &CodeSystemProperty1{}
}

// FromJSON populates CodeSystemProperty1 from JSON data
func (m *CodeSystemProperty1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CodeSystemProperty1 to JSON data
func (m *CodeSystemProperty1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CodeSystemProperty1
func (m *CodeSystemProperty1) Clone() *CodeSystemProperty1 {
	if m == nil { return nil }
	return &CodeSystemProperty1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		ValueCode: m.ValueCode.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
	}
}

// Equals checks for equality with another CodeSystemProperty1 instance
func (m *CodeSystemProperty1) Equals(other *CodeSystemProperty1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.ValueCode.Equals(other.ValueCode) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	return true
}

