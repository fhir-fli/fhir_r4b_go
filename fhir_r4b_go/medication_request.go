// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// MedicationRequest
// An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.
type MedicationRequest struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *MedicationrequestStatus `json:"status,omitempty"`
	StatusReason *CodeableConcept `json:"statusreason,omitempty"`
	Intent *MedicationRequestIntent `json:"intent,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Priority *RequestPriority `json:"priority,omitempty"`
	DoNotPerform *FhirBoolean `json:"donotperform,omitempty"`
	ReportedBoolean *FhirBoolean `json:"reportedboolean,omitempty"`
	ReportedReference *Reference `json:"reportedreference,omitempty"`
	MedicationCodeableConcept *CodeableConcept `json:"medicationcodeableconcept,omitempty"`
	MedicationReference *Reference `json:"medicationreference,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
	AuthoredOn *FhirDateTime `json:"authoredon,omitempty"`
	Requester *Reference `json:"requester,omitempty"`
	Performer *Reference `json:"performer,omitempty"`
	PerformerType *CodeableConcept `json:"performertype,omitempty"`
	Recorder *Reference `json:"recorder,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	InstantiatesCanonical []*FhirCanonical `json:"instantiatescanonical,omitempty"`
	InstantiatesUri []*FhirUri `json:"instantiatesuri,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	GroupIdentifier *Identifier `json:"groupidentifier,omitempty"`
	CourseOfTherapyType *CodeableConcept `json:"courseoftherapytype,omitempty"`
	Insurance []*Reference `json:"insurance,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	DosageInstruction []*Dosage `json:"dosageinstruction,omitempty"`
	DispenseRequest *MedicationRequestDispenseRequest `json:"dispenserequest,omitempty"`
	Substitution *MedicationRequestSubstitution `json:"substitution,omitempty"`
	PriorPrescription *Reference `json:"priorprescription,omitempty"`
	DetectedIssue []*Reference `json:"detectedissue,omitempty"`
	EventHistory []*Reference `json:"eventhistory,omitempty"`
}

// NewMedicationRequest creates a new MedicationRequest instance
func NewMedicationRequest() *MedicationRequest {
	return &MedicationRequest{}
}

// FromJSON populates MedicationRequest from JSON data
func (m *MedicationRequest) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationRequest to JSON data
func (m *MedicationRequest) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationRequest
func (m *MedicationRequest) Clone() *MedicationRequest {
	if m == nil { return nil }
	return &MedicationRequest{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		StatusReason: m.StatusReason.Clone(),
		Intent: m.Intent.Clone(),
		Category: cloneSlices(m.Category),
		Priority: m.Priority.Clone(),
		DoNotPerform: m.DoNotPerform.Clone(),
		ReportedBoolean: m.ReportedBoolean.Clone(),
		ReportedReference: m.ReportedReference.Clone(),
		MedicationCodeableConcept: m.MedicationCodeableConcept.Clone(),
		MedicationReference: m.MedicationReference.Clone(),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		SupportingInformation: cloneSlices(m.SupportingInformation),
		AuthoredOn: m.AuthoredOn.Clone(),
		Requester: m.Requester.Clone(),
		Performer: m.Performer.Clone(),
		PerformerType: m.PerformerType.Clone(),
		Recorder: m.Recorder.Clone(),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		InstantiatesCanonical: cloneSlices(m.InstantiatesCanonical),
		InstantiatesUri: cloneSlices(m.InstantiatesUri),
		BasedOn: cloneSlices(m.BasedOn),
		GroupIdentifier: m.GroupIdentifier.Clone(),
		CourseOfTherapyType: m.CourseOfTherapyType.Clone(),
		Insurance: cloneSlices(m.Insurance),
		Note: cloneSlices(m.Note),
		DosageInstruction: cloneSlices(m.DosageInstruction),
		DispenseRequest: m.DispenseRequest.Clone(),
		Substitution: m.Substitution.Clone(),
		PriorPrescription: m.PriorPrescription.Clone(),
		DetectedIssue: cloneSlices(m.DetectedIssue),
		EventHistory: cloneSlices(m.EventHistory),
	}
}

// Equals checks for equality with another MedicationRequest instance
func (m *MedicationRequest) Equals(other *MedicationRequest) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusReason.Equals(other.StatusReason) { return false }
	if !m.Intent.Equals(other.Intent) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.DoNotPerform.Equals(other.DoNotPerform) { return false }
	if !m.ReportedBoolean.Equals(other.ReportedBoolean) { return false }
	if !m.ReportedReference.Equals(other.ReportedReference) { return false }
	if !m.MedicationCodeableConcept.Equals(other.MedicationCodeableConcept) { return false }
	if !m.MedicationReference.Equals(other.MedicationReference) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !compareSlices(m.SupportingInformation, other.SupportingInformation) { return false }
	if !m.AuthoredOn.Equals(other.AuthoredOn) { return false }
	if !m.Requester.Equals(other.Requester) { return false }
	if !m.Performer.Equals(other.Performer) { return false }
	if !m.PerformerType.Equals(other.PerformerType) { return false }
	if !m.Recorder.Equals(other.Recorder) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !compareSlices(m.InstantiatesCanonical, other.InstantiatesCanonical) { return false }
	if !compareSlices(m.InstantiatesUri, other.InstantiatesUri) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !m.GroupIdentifier.Equals(other.GroupIdentifier) { return false }
	if !m.CourseOfTherapyType.Equals(other.CourseOfTherapyType) { return false }
	if !compareSlices(m.Insurance, other.Insurance) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.DosageInstruction, other.DosageInstruction) { return false }
	if !m.DispenseRequest.Equals(other.DispenseRequest) { return false }
	if !m.Substitution.Equals(other.Substitution) { return false }
	if !m.PriorPrescription.Equals(other.PriorPrescription) { return false }
	if !compareSlices(m.DetectedIssue, other.DetectedIssue) { return false }
	if !compareSlices(m.EventHistory, other.EventHistory) { return false }
	return true
}

// MedicationRequestDispenseRequest
// Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
type MedicationRequestDispenseRequest struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	InitialFill *MedicationRequestInitialFill `json:"initialfill,omitempty"`
	DispenseInterval *FhirDuration `json:"dispenseinterval,omitempty"`
	ValidityPeriod *Period `json:"validityperiod,omitempty"`
	NumberOfRepeatsAllowed *FhirUnsignedInt `json:"numberofrepeatsallowed,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	ExpectedSupplyDuration *FhirDuration `json:"expectedsupplyduration,omitempty"`
	Performer *Reference `json:"performer,omitempty"`
}

// NewMedicationRequestDispenseRequest creates a new MedicationRequestDispenseRequest instance
func NewMedicationRequestDispenseRequest() *MedicationRequestDispenseRequest {
	return &MedicationRequestDispenseRequest{}
}

// FromJSON populates MedicationRequestDispenseRequest from JSON data
func (m *MedicationRequestDispenseRequest) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationRequestDispenseRequest to JSON data
func (m *MedicationRequestDispenseRequest) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationRequestDispenseRequest
func (m *MedicationRequestDispenseRequest) Clone() *MedicationRequestDispenseRequest {
	if m == nil { return nil }
	return &MedicationRequestDispenseRequest{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		InitialFill: m.InitialFill.Clone(),
		DispenseInterval: m.DispenseInterval.Clone(),
		ValidityPeriod: m.ValidityPeriod.Clone(),
		NumberOfRepeatsAllowed: m.NumberOfRepeatsAllowed.Clone(),
		Quantity: m.Quantity.Clone(),
		ExpectedSupplyDuration: m.ExpectedSupplyDuration.Clone(),
		Performer: m.Performer.Clone(),
	}
}

// Equals checks for equality with another MedicationRequestDispenseRequest instance
func (m *MedicationRequestDispenseRequest) Equals(other *MedicationRequestDispenseRequest) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.InitialFill.Equals(other.InitialFill) { return false }
	if !m.DispenseInterval.Equals(other.DispenseInterval) { return false }
	if !m.ValidityPeriod.Equals(other.ValidityPeriod) { return false }
	if !m.NumberOfRepeatsAllowed.Equals(other.NumberOfRepeatsAllowed) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.ExpectedSupplyDuration.Equals(other.ExpectedSupplyDuration) { return false }
	if !m.Performer.Equals(other.Performer) { return false }
	return true
}

// MedicationRequestInitialFill
// Indicates the quantity or duration for the first dispense of the medication.
type MedicationRequestInitialFill struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Duration *FhirDuration `json:"duration,omitempty"`
}

// NewMedicationRequestInitialFill creates a new MedicationRequestInitialFill instance
func NewMedicationRequestInitialFill() *MedicationRequestInitialFill {
	return &MedicationRequestInitialFill{}
}

// FromJSON populates MedicationRequestInitialFill from JSON data
func (m *MedicationRequestInitialFill) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationRequestInitialFill to JSON data
func (m *MedicationRequestInitialFill) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationRequestInitialFill
func (m *MedicationRequestInitialFill) Clone() *MedicationRequestInitialFill {
	if m == nil { return nil }
	return &MedicationRequestInitialFill{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Quantity: m.Quantity.Clone(),
		Duration: m.Duration.Clone(),
	}
}

// Equals checks for equality with another MedicationRequestInitialFill instance
func (m *MedicationRequestInitialFill) Equals(other *MedicationRequestInitialFill) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.Duration.Equals(other.Duration) { return false }
	return true
}

// MedicationRequestSubstitution
// Indicates whether or not substitution can or should be part of the dispense. In some cases, substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done.
type MedicationRequestSubstitution struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	AllowedBoolean *FhirBoolean `json:"allowedboolean,omitempty"`
	AllowedCodeableConcept *CodeableConcept `json:"allowedcodeableconcept,omitempty"`
	Reason *CodeableConcept `json:"reason,omitempty"`
}

// NewMedicationRequestSubstitution creates a new MedicationRequestSubstitution instance
func NewMedicationRequestSubstitution() *MedicationRequestSubstitution {
	return &MedicationRequestSubstitution{}
}

// FromJSON populates MedicationRequestSubstitution from JSON data
func (m *MedicationRequestSubstitution) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationRequestSubstitution to JSON data
func (m *MedicationRequestSubstitution) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationRequestSubstitution
func (m *MedicationRequestSubstitution) Clone() *MedicationRequestSubstitution {
	if m == nil { return nil }
	return &MedicationRequestSubstitution{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		AllowedBoolean: m.AllowedBoolean.Clone(),
		AllowedCodeableConcept: m.AllowedCodeableConcept.Clone(),
		Reason: m.Reason.Clone(),
	}
}

// Equals checks for equality with another MedicationRequestSubstitution instance
func (m *MedicationRequestSubstitution) Equals(other *MedicationRequestSubstitution) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.AllowedBoolean.Equals(other.AllowedBoolean) { return false }
	if !m.AllowedCodeableConcept.Equals(other.AllowedCodeableConcept) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	return true
}

