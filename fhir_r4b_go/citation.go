// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Citation
// The Citation Resource enables reference to any knowledge artifact for purposes of identification and attribution. The Citation Resource supports existing reference structures and developing publication practices such as versioning, expressing complex contributorship roles, and referencing computable resources.
type Citation struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	Author []*ContactDetail `json:"author,omitempty"`
	Editor []*ContactDetail `json:"editor,omitempty"`
	Reviewer []*ContactDetail `json:"reviewer,omitempty"`
	Endorser []*ContactDetail `json:"endorser,omitempty"`
	Summary []*CitationSummary `json:"summary,omitempty"`
	Classification []*CitationClassification `json:"classification,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	CurrentState []*CodeableConcept `json:"currentstate,omitempty"`
	StatusDate []*CitationStatusDate `json:"statusdate,omitempty"`
	RelatesTo []*CitationRelatesTo `json:"relatesto,omitempty"`
	CitedArtifact *CitationCitedArtifact `json:"citedartifact,omitempty"`
}

// NewCitation creates a new Citation instance
func NewCitation() *Citation {
	return &Citation{}
}

// FromJSON populates Citation from JSON data
func (m *Citation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Citation to JSON data
func (m *Citation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Citation
func (m *Citation) Clone() *Citation {
	if m == nil { return nil }
	return &Citation{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		Author: cloneSlices(m.Author),
		Editor: cloneSlices(m.Editor),
		Reviewer: cloneSlices(m.Reviewer),
		Endorser: cloneSlices(m.Endorser),
		Summary: cloneSlices(m.Summary),
		Classification: cloneSlices(m.Classification),
		Note: cloneSlices(m.Note),
		CurrentState: cloneSlices(m.CurrentState),
		StatusDate: cloneSlices(m.StatusDate),
		RelatesTo: cloneSlices(m.RelatesTo),
		CitedArtifact: m.CitedArtifact.Clone(),
	}
}

// Equals checks for equality with another Citation instance
func (m *Citation) Equals(other *Citation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !compareSlices(m.Author, other.Author) { return false }
	if !compareSlices(m.Editor, other.Editor) { return false }
	if !compareSlices(m.Reviewer, other.Reviewer) { return false }
	if !compareSlices(m.Endorser, other.Endorser) { return false }
	if !compareSlices(m.Summary, other.Summary) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.CurrentState, other.CurrentState) { return false }
	if !compareSlices(m.StatusDate, other.StatusDate) { return false }
	if !compareSlices(m.RelatesTo, other.RelatesTo) { return false }
	if !m.CitedArtifact.Equals(other.CitedArtifact) { return false }
	return true
}

// CitationSummary
// A human-readable display of the citation.
type CitationSummary struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Style *CodeableConcept `json:"style,omitempty"`
	Text *FhirMarkdown `json:"text,omitempty"`
}

// NewCitationSummary creates a new CitationSummary instance
func NewCitationSummary() *CitationSummary {
	return &CitationSummary{}
}

// FromJSON populates CitationSummary from JSON data
func (m *CitationSummary) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationSummary to JSON data
func (m *CitationSummary) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationSummary
func (m *CitationSummary) Clone() *CitationSummary {
	if m == nil { return nil }
	return &CitationSummary{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Style: m.Style.Clone(),
		Text: m.Text.Clone(),
	}
}

// Equals checks for equality with another CitationSummary instance
func (m *CitationSummary) Equals(other *CitationSummary) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Style.Equals(other.Style) { return false }
	if !m.Text.Equals(other.Text) { return false }
	return true
}

// CitationClassification
// The assignment to an organizing scheme.
type CitationClassification struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Classifier []*CodeableConcept `json:"classifier,omitempty"`
}

// NewCitationClassification creates a new CitationClassification instance
func NewCitationClassification() *CitationClassification {
	return &CitationClassification{}
}

// FromJSON populates CitationClassification from JSON data
func (m *CitationClassification) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationClassification to JSON data
func (m *CitationClassification) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationClassification
func (m *CitationClassification) Clone() *CitationClassification {
	if m == nil { return nil }
	return &CitationClassification{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Classifier: cloneSlices(m.Classifier),
	}
}

// Equals checks for equality with another CitationClassification instance
func (m *CitationClassification) Equals(other *CitationClassification) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Classifier, other.Classifier) { return false }
	return true
}

// CitationStatusDate
// An effective date or period for a status of the citation.
type CitationStatusDate struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Activity *CodeableConcept `json:"activity,omitempty"`
	Actual *FhirBoolean `json:"actual,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewCitationStatusDate creates a new CitationStatusDate instance
func NewCitationStatusDate() *CitationStatusDate {
	return &CitationStatusDate{}
}

// FromJSON populates CitationStatusDate from JSON data
func (m *CitationStatusDate) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationStatusDate to JSON data
func (m *CitationStatusDate) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationStatusDate
func (m *CitationStatusDate) Clone() *CitationStatusDate {
	if m == nil { return nil }
	return &CitationStatusDate{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Activity: m.Activity.Clone(),
		Actual: m.Actual.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks for equality with another CitationStatusDate instance
func (m *CitationStatusDate) Equals(other *CitationStatusDate) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Activity.Equals(other.Activity) { return false }
	if !m.Actual.Equals(other.Actual) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// CitationRelatesTo
// Artifact related to the Citation Resource.
type CitationRelatesTo struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	RelationshipType *CodeableConcept `json:"relationshiptype,omitempty"`
	TargetClassifier []*CodeableConcept `json:"targetclassifier,omitempty"`
	TargetUri *FhirUri `json:"targeturi,omitempty"`
	TargetIdentifier *Identifier `json:"targetidentifier,omitempty"`
	TargetReference *Reference `json:"targetreference,omitempty"`
	TargetAttachment *Attachment `json:"targetattachment,omitempty"`
}

// NewCitationRelatesTo creates a new CitationRelatesTo instance
func NewCitationRelatesTo() *CitationRelatesTo {
	return &CitationRelatesTo{}
}

// FromJSON populates CitationRelatesTo from JSON data
func (m *CitationRelatesTo) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationRelatesTo to JSON data
func (m *CitationRelatesTo) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationRelatesTo
func (m *CitationRelatesTo) Clone() *CitationRelatesTo {
	if m == nil { return nil }
	return &CitationRelatesTo{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		RelationshipType: m.RelationshipType.Clone(),
		TargetClassifier: cloneSlices(m.TargetClassifier),
		TargetUri: m.TargetUri.Clone(),
		TargetIdentifier: m.TargetIdentifier.Clone(),
		TargetReference: m.TargetReference.Clone(),
		TargetAttachment: m.TargetAttachment.Clone(),
	}
}

// Equals checks for equality with another CitationRelatesTo instance
func (m *CitationRelatesTo) Equals(other *CitationRelatesTo) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.RelationshipType.Equals(other.RelationshipType) { return false }
	if !compareSlices(m.TargetClassifier, other.TargetClassifier) { return false }
	if !m.TargetUri.Equals(other.TargetUri) { return false }
	if !m.TargetIdentifier.Equals(other.TargetIdentifier) { return false }
	if !m.TargetReference.Equals(other.TargetReference) { return false }
	if !m.TargetAttachment.Equals(other.TargetAttachment) { return false }
	return true
}

// CitationCitedArtifact
// The article or artifact being described.
type CitationCitedArtifact struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	RelatedIdentifier []*Identifier `json:"relatedidentifier,omitempty"`
	DateAccessed *FhirDateTime `json:"dateaccessed,omitempty"`
	Version *CitationVersion `json:"version,omitempty"`
	CurrentState []*CodeableConcept `json:"currentstate,omitempty"`
	StatusDate []*CitationStatusDate `json:"statusdate,omitempty"`
	Title []*CitationTitle `json:"title,omitempty"`
	Abstract_ []*CitationAbstract `json:"abstract,omitempty"`
	Part_ *CitationPart `json:"part,omitempty"`
	RelatesTo []*CitationRelatesTo `json:"relatesto,omitempty"`
	PublicationForm []*CitationPublicationForm `json:"publicationform,omitempty"`
	WebLocation []*CitationWebLocation `json:"weblocation,omitempty"`
	Classification []*CitationClassification `json:"classification,omitempty"`
	Contributorship *CitationContributorship `json:"contributorship,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewCitationCitedArtifact creates a new CitationCitedArtifact instance
func NewCitationCitedArtifact() *CitationCitedArtifact {
	return &CitationCitedArtifact{}
}

// FromJSON populates CitationCitedArtifact from JSON data
func (m *CitationCitedArtifact) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationCitedArtifact to JSON data
func (m *CitationCitedArtifact) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationCitedArtifact
func (m *CitationCitedArtifact) Clone() *CitationCitedArtifact {
	if m == nil { return nil }
	return &CitationCitedArtifact{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		RelatedIdentifier: cloneSlices(m.RelatedIdentifier),
		DateAccessed: m.DateAccessed.Clone(),
		Version: m.Version.Clone(),
		CurrentState: cloneSlices(m.CurrentState),
		StatusDate: cloneSlices(m.StatusDate),
		Title: cloneSlices(m.Title),
		Abstract_: cloneSlices(m.Abstract_),
		Part_: m.Part_.Clone(),
		RelatesTo: cloneSlices(m.RelatesTo),
		PublicationForm: cloneSlices(m.PublicationForm),
		WebLocation: cloneSlices(m.WebLocation),
		Classification: cloneSlices(m.Classification),
		Contributorship: m.Contributorship.Clone(),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks for equality with another CitationCitedArtifact instance
func (m *CitationCitedArtifact) Equals(other *CitationCitedArtifact) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.RelatedIdentifier, other.RelatedIdentifier) { return false }
	if !m.DateAccessed.Equals(other.DateAccessed) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !compareSlices(m.CurrentState, other.CurrentState) { return false }
	if !compareSlices(m.StatusDate, other.StatusDate) { return false }
	if !compareSlices(m.Title, other.Title) { return false }
	if !compareSlices(m.Abstract_, other.Abstract_) { return false }
	if !m.Part_.Equals(other.Part_) { return false }
	if !compareSlices(m.RelatesTo, other.RelatesTo) { return false }
	if !compareSlices(m.PublicationForm, other.PublicationForm) { return false }
	if !compareSlices(m.WebLocation, other.WebLocation) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	if !m.Contributorship.Equals(other.Contributorship) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// CitationVersion
// The defined version of the cited artifact.
type CitationVersion struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Value *FhirString `json:"value,omitempty"`
	BaseCitation *Reference `json:"basecitation,omitempty"`
}

// NewCitationVersion creates a new CitationVersion instance
func NewCitationVersion() *CitationVersion {
	return &CitationVersion{}
}

// FromJSON populates CitationVersion from JSON data
func (m *CitationVersion) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationVersion to JSON data
func (m *CitationVersion) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationVersion
func (m *CitationVersion) Clone() *CitationVersion {
	if m == nil { return nil }
	return &CitationVersion{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Value: m.Value.Clone(),
		BaseCitation: m.BaseCitation.Clone(),
	}
}

// Equals checks for equality with another CitationVersion instance
func (m *CitationVersion) Equals(other *CitationVersion) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !m.BaseCitation.Equals(other.BaseCitation) { return false }
	return true
}

// CitationStatusDate1
// An effective date or period for a status of the cited artifact.
type CitationStatusDate1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Activity *CodeableConcept `json:"activity,omitempty"`
	Actual *FhirBoolean `json:"actual,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewCitationStatusDate1 creates a new CitationStatusDate1 instance
func NewCitationStatusDate1() *CitationStatusDate1 {
	return &CitationStatusDate1{}
}

// FromJSON populates CitationStatusDate1 from JSON data
func (m *CitationStatusDate1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationStatusDate1 to JSON data
func (m *CitationStatusDate1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationStatusDate1
func (m *CitationStatusDate1) Clone() *CitationStatusDate1 {
	if m == nil { return nil }
	return &CitationStatusDate1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Activity: m.Activity.Clone(),
		Actual: m.Actual.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks for equality with another CitationStatusDate1 instance
func (m *CitationStatusDate1) Equals(other *CitationStatusDate1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Activity.Equals(other.Activity) { return false }
	if !m.Actual.Equals(other.Actual) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// CitationTitle
// The title details of the article or artifact.
type CitationTitle struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	Language *CodeableConcept `json:"language,omitempty"`
	Text *FhirMarkdown `json:"text,omitempty"`
}

// NewCitationTitle creates a new CitationTitle instance
func NewCitationTitle() *CitationTitle {
	return &CitationTitle{}
}

// FromJSON populates CitationTitle from JSON data
func (m *CitationTitle) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationTitle to JSON data
func (m *CitationTitle) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationTitle
func (m *CitationTitle) Clone() *CitationTitle {
	if m == nil { return nil }
	return &CitationTitle{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: cloneSlices(m.Type),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
	}
}

// Equals checks for equality with another CitationTitle instance
func (m *CitationTitle) Equals(other *CitationTitle) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	return true
}

// CitationAbstract
// Summary of the article or artifact.
type CitationAbstract struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Language *CodeableConcept `json:"language,omitempty"`
	Text *FhirMarkdown `json:"text,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
}

// NewCitationAbstract creates a new CitationAbstract instance
func NewCitationAbstract() *CitationAbstract {
	return &CitationAbstract{}
}

// FromJSON populates CitationAbstract from JSON data
func (m *CitationAbstract) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationAbstract to JSON data
func (m *CitationAbstract) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationAbstract
func (m *CitationAbstract) Clone() *CitationAbstract {
	if m == nil { return nil }
	return &CitationAbstract{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Copyright: m.Copyright.Clone(),
	}
}

// Equals checks for equality with another CitationAbstract instance
func (m *CitationAbstract) Equals(other *CitationAbstract) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	return true
}

// CitationPart
// The component of the article or artifact.
type CitationPart struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Value *FhirString `json:"value,omitempty"`
	BaseCitation *Reference `json:"basecitation,omitempty"`
}

// NewCitationPart creates a new CitationPart instance
func NewCitationPart() *CitationPart {
	return &CitationPart{}
}

// FromJSON populates CitationPart from JSON data
func (m *CitationPart) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationPart to JSON data
func (m *CitationPart) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationPart
func (m *CitationPart) Clone() *CitationPart {
	if m == nil { return nil }
	return &CitationPart{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Value: m.Value.Clone(),
		BaseCitation: m.BaseCitation.Clone(),
	}
}

// Equals checks for equality with another CitationPart instance
func (m *CitationPart) Equals(other *CitationPart) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !m.BaseCitation.Equals(other.BaseCitation) { return false }
	return true
}

// CitationRelatesTo1
// The artifact related to the cited artifact.
type CitationRelatesTo1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	RelationshipType *CodeableConcept `json:"relationshiptype,omitempty"`
	TargetClassifier []*CodeableConcept `json:"targetclassifier,omitempty"`
	TargetUri *FhirUri `json:"targeturi,omitempty"`
	TargetIdentifier *Identifier `json:"targetidentifier,omitempty"`
	TargetReference *Reference `json:"targetreference,omitempty"`
	TargetAttachment *Attachment `json:"targetattachment,omitempty"`
}

// NewCitationRelatesTo1 creates a new CitationRelatesTo1 instance
func NewCitationRelatesTo1() *CitationRelatesTo1 {
	return &CitationRelatesTo1{}
}

// FromJSON populates CitationRelatesTo1 from JSON data
func (m *CitationRelatesTo1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationRelatesTo1 to JSON data
func (m *CitationRelatesTo1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationRelatesTo1
func (m *CitationRelatesTo1) Clone() *CitationRelatesTo1 {
	if m == nil { return nil }
	return &CitationRelatesTo1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		RelationshipType: m.RelationshipType.Clone(),
		TargetClassifier: cloneSlices(m.TargetClassifier),
		TargetUri: m.TargetUri.Clone(),
		TargetIdentifier: m.TargetIdentifier.Clone(),
		TargetReference: m.TargetReference.Clone(),
		TargetAttachment: m.TargetAttachment.Clone(),
	}
}

// Equals checks for equality with another CitationRelatesTo1 instance
func (m *CitationRelatesTo1) Equals(other *CitationRelatesTo1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.RelationshipType.Equals(other.RelationshipType) { return false }
	if !compareSlices(m.TargetClassifier, other.TargetClassifier) { return false }
	if !m.TargetUri.Equals(other.TargetUri) { return false }
	if !m.TargetIdentifier.Equals(other.TargetIdentifier) { return false }
	if !m.TargetReference.Equals(other.TargetReference) { return false }
	if !m.TargetAttachment.Equals(other.TargetAttachment) { return false }
	return true
}

// CitationPublicationForm
// If multiple, used to represent alternative forms of the article that are not separate citations.
type CitationPublicationForm struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	PublishedIn *CitationPublishedIn `json:"publishedin,omitempty"`
	PeriodicRelease *CitationPeriodicRelease `json:"periodicrelease,omitempty"`
	ArticleDate *FhirDateTime `json:"articledate,omitempty"`
	LastRevisionDate *FhirDateTime `json:"lastrevisiondate,omitempty"`
	Language []*CodeableConcept `json:"language,omitempty"`
	AccessionNumber *FhirString `json:"accessionnumber,omitempty"`
	PageString *FhirString `json:"pagestring,omitempty"`
	FirstPage *FhirString `json:"firstpage,omitempty"`
	LastPage *FhirString `json:"lastpage,omitempty"`
	PageCount *FhirString `json:"pagecount,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
}

// NewCitationPublicationForm creates a new CitationPublicationForm instance
func NewCitationPublicationForm() *CitationPublicationForm {
	return &CitationPublicationForm{}
}

// FromJSON populates CitationPublicationForm from JSON data
func (m *CitationPublicationForm) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationPublicationForm to JSON data
func (m *CitationPublicationForm) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationPublicationForm
func (m *CitationPublicationForm) Clone() *CitationPublicationForm {
	if m == nil { return nil }
	return &CitationPublicationForm{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		PublishedIn: m.PublishedIn.Clone(),
		PeriodicRelease: m.PeriodicRelease.Clone(),
		ArticleDate: m.ArticleDate.Clone(),
		LastRevisionDate: m.LastRevisionDate.Clone(),
		Language: cloneSlices(m.Language),
		AccessionNumber: m.AccessionNumber.Clone(),
		PageString: m.PageString.Clone(),
		FirstPage: m.FirstPage.Clone(),
		LastPage: m.LastPage.Clone(),
		PageCount: m.PageCount.Clone(),
		Copyright: m.Copyright.Clone(),
	}
}

// Equals checks for equality with another CitationPublicationForm instance
func (m *CitationPublicationForm) Equals(other *CitationPublicationForm) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.PublishedIn.Equals(other.PublishedIn) { return false }
	if !m.PeriodicRelease.Equals(other.PeriodicRelease) { return false }
	if !m.ArticleDate.Equals(other.ArticleDate) { return false }
	if !m.LastRevisionDate.Equals(other.LastRevisionDate) { return false }
	if !compareSlices(m.Language, other.Language) { return false }
	if !m.AccessionNumber.Equals(other.AccessionNumber) { return false }
	if !m.PageString.Equals(other.PageString) { return false }
	if !m.FirstPage.Equals(other.FirstPage) { return false }
	if !m.LastPage.Equals(other.LastPage) { return false }
	if !m.PageCount.Equals(other.PageCount) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	return true
}

// CitationPublishedIn
// The collection the cited article or artifact is published in.
type CitationPublishedIn struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Publisher *Reference `json:"publisher,omitempty"`
	PublisherLocation *FhirString `json:"publisherlocation,omitempty"`
}

// NewCitationPublishedIn creates a new CitationPublishedIn instance
func NewCitationPublishedIn() *CitationPublishedIn {
	return &CitationPublishedIn{}
}

// FromJSON populates CitationPublishedIn from JSON data
func (m *CitationPublishedIn) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationPublishedIn to JSON data
func (m *CitationPublishedIn) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationPublishedIn
func (m *CitationPublishedIn) Clone() *CitationPublishedIn {
	if m == nil { return nil }
	return &CitationPublishedIn{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Title: m.Title.Clone(),
		Publisher: m.Publisher.Clone(),
		PublisherLocation: m.PublisherLocation.Clone(),
	}
}

// Equals checks for equality with another CitationPublishedIn instance
func (m *CitationPublishedIn) Equals(other *CitationPublishedIn) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !m.PublisherLocation.Equals(other.PublisherLocation) { return false }
	return true
}

// CitationPeriodicRelease
// The specific issue in which the cited article resides.
type CitationPeriodicRelease struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	CitedMedium *CodeableConcept `json:"citedmedium,omitempty"`
	Volume *FhirString `json:"volume,omitempty"`
	Issue *FhirString `json:"issue,omitempty"`
	DateOfPublication *CitationDateOfPublication `json:"dateofpublication,omitempty"`
}

// NewCitationPeriodicRelease creates a new CitationPeriodicRelease instance
func NewCitationPeriodicRelease() *CitationPeriodicRelease {
	return &CitationPeriodicRelease{}
}

// FromJSON populates CitationPeriodicRelease from JSON data
func (m *CitationPeriodicRelease) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationPeriodicRelease to JSON data
func (m *CitationPeriodicRelease) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationPeriodicRelease
func (m *CitationPeriodicRelease) Clone() *CitationPeriodicRelease {
	if m == nil { return nil }
	return &CitationPeriodicRelease{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		CitedMedium: m.CitedMedium.Clone(),
		Volume: m.Volume.Clone(),
		Issue: m.Issue.Clone(),
		DateOfPublication: m.DateOfPublication.Clone(),
	}
}

// Equals checks for equality with another CitationPeriodicRelease instance
func (m *CitationPeriodicRelease) Equals(other *CitationPeriodicRelease) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.CitedMedium.Equals(other.CitedMedium) { return false }
	if !m.Volume.Equals(other.Volume) { return false }
	if !m.Issue.Equals(other.Issue) { return false }
	if !m.DateOfPublication.Equals(other.DateOfPublication) { return false }
	return true
}

// CitationDateOfPublication
// Defining the date on which the issue of the journal was published.
type CitationDateOfPublication struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Date *FhirDate `json:"date,omitempty"`
	Year *FhirString `json:"year,omitempty"`
	Month *FhirString `json:"month,omitempty"`
	Day *FhirString `json:"day,omitempty"`
	Season *FhirString `json:"season,omitempty"`
	Text *FhirString `json:"text,omitempty"`
}

// NewCitationDateOfPublication creates a new CitationDateOfPublication instance
func NewCitationDateOfPublication() *CitationDateOfPublication {
	return &CitationDateOfPublication{}
}

// FromJSON populates CitationDateOfPublication from JSON data
func (m *CitationDateOfPublication) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationDateOfPublication to JSON data
func (m *CitationDateOfPublication) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationDateOfPublication
func (m *CitationDateOfPublication) Clone() *CitationDateOfPublication {
	if m == nil { return nil }
	return &CitationDateOfPublication{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Date: m.Date.Clone(),
		Year: m.Year.Clone(),
		Month: m.Month.Clone(),
		Day: m.Day.Clone(),
		Season: m.Season.Clone(),
		Text: m.Text.Clone(),
	}
}

// Equals checks for equality with another CitationDateOfPublication instance
func (m *CitationDateOfPublication) Equals(other *CitationDateOfPublication) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Year.Equals(other.Year) { return false }
	if !m.Month.Equals(other.Month) { return false }
	if !m.Day.Equals(other.Day) { return false }
	if !m.Season.Equals(other.Season) { return false }
	if !m.Text.Equals(other.Text) { return false }
	return true
}

// CitationWebLocation
// Used for any URL for the article or artifact cited.
type CitationWebLocation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
}

// NewCitationWebLocation creates a new CitationWebLocation instance
func NewCitationWebLocation() *CitationWebLocation {
	return &CitationWebLocation{}
}

// FromJSON populates CitationWebLocation from JSON data
func (m *CitationWebLocation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationWebLocation to JSON data
func (m *CitationWebLocation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationWebLocation
func (m *CitationWebLocation) Clone() *CitationWebLocation {
	if m == nil { return nil }
	return &CitationWebLocation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Url: m.Url.Clone(),
	}
}

// Equals checks for equality with another CitationWebLocation instance
func (m *CitationWebLocation) Equals(other *CitationWebLocation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Url.Equals(other.Url) { return false }
	return true
}

// CitationClassification1
// The assignment to an organizing scheme.
type CitationClassification1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Classifier []*CodeableConcept `json:"classifier,omitempty"`
	WhoClassified *CitationWhoClassified `json:"whoclassified,omitempty"`
}

// NewCitationClassification1 creates a new CitationClassification1 instance
func NewCitationClassification1() *CitationClassification1 {
	return &CitationClassification1{}
}

// FromJSON populates CitationClassification1 from JSON data
func (m *CitationClassification1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationClassification1 to JSON data
func (m *CitationClassification1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationClassification1
func (m *CitationClassification1) Clone() *CitationClassification1 {
	if m == nil { return nil }
	return &CitationClassification1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Classifier: cloneSlices(m.Classifier),
		WhoClassified: m.WhoClassified.Clone(),
	}
}

// Equals checks for equality with another CitationClassification1 instance
func (m *CitationClassification1) Equals(other *CitationClassification1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Classifier, other.Classifier) { return false }
	if !m.WhoClassified.Equals(other.WhoClassified) { return false }
	return true
}

// CitationWhoClassified
// Provenance and copyright of classification.
type CitationWhoClassified struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Person *Reference `json:"person,omitempty"`
	Organization *Reference `json:"organization,omitempty"`
	Publisher *Reference `json:"publisher,omitempty"`
	ClassifierCopyright *FhirString `json:"classifiercopyright,omitempty"`
	FreeToShare *FhirBoolean `json:"freetoshare,omitempty"`
}

// NewCitationWhoClassified creates a new CitationWhoClassified instance
func NewCitationWhoClassified() *CitationWhoClassified {
	return &CitationWhoClassified{}
}

// FromJSON populates CitationWhoClassified from JSON data
func (m *CitationWhoClassified) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationWhoClassified to JSON data
func (m *CitationWhoClassified) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationWhoClassified
func (m *CitationWhoClassified) Clone() *CitationWhoClassified {
	if m == nil { return nil }
	return &CitationWhoClassified{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Person: m.Person.Clone(),
		Organization: m.Organization.Clone(),
		Publisher: m.Publisher.Clone(),
		ClassifierCopyright: m.ClassifierCopyright.Clone(),
		FreeToShare: m.FreeToShare.Clone(),
	}
}

// Equals checks for equality with another CitationWhoClassified instance
func (m *CitationWhoClassified) Equals(other *CitationWhoClassified) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Person.Equals(other.Person) { return false }
	if !m.Organization.Equals(other.Organization) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !m.ClassifierCopyright.Equals(other.ClassifierCopyright) { return false }
	if !m.FreeToShare.Equals(other.FreeToShare) { return false }
	return true
}

// CitationContributorship
// This element is used to list authors and other contributors, their contact information, specific contributions, and summary statements.
type CitationContributorship struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Complete *FhirBoolean `json:"complete,omitempty"`
	Entry []*CitationEntry `json:"entry,omitempty"`
	Summary []*CitationSummary `json:"summary,omitempty"`
}

// NewCitationContributorship creates a new CitationContributorship instance
func NewCitationContributorship() *CitationContributorship {
	return &CitationContributorship{}
}

// FromJSON populates CitationContributorship from JSON data
func (m *CitationContributorship) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationContributorship to JSON data
func (m *CitationContributorship) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationContributorship
func (m *CitationContributorship) Clone() *CitationContributorship {
	if m == nil { return nil }
	return &CitationContributorship{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Complete: m.Complete.Clone(),
		Entry: cloneSlices(m.Entry),
		Summary: cloneSlices(m.Summary),
	}
}

// Equals checks for equality with another CitationContributorship instance
func (m *CitationContributorship) Equals(other *CitationContributorship) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Complete.Equals(other.Complete) { return false }
	if !compareSlices(m.Entry, other.Entry) { return false }
	if !compareSlices(m.Summary, other.Summary) { return false }
	return true
}

// CitationEntry
// An individual entity named in the author list or contributor list.
type CitationEntry struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *HumanName `json:"name,omitempty"`
	Initials *FhirString `json:"initials,omitempty"`
	CollectiveName *FhirString `json:"collectivename,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	AffiliationInfo []*CitationAffiliationInfo `json:"affiliationinfo,omitempty"`
	Address []*Address `json:"address,omitempty"`
	Telecom []*ContactPoint `json:"telecom,omitempty"`
	ContributionType []*CodeableConcept `json:"contributiontype,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	ContributionInstance []*CitationContributionInstance `json:"contributioninstance,omitempty"`
	CorrespondingContact *FhirBoolean `json:"correspondingcontact,omitempty"`
	ListOrder *FhirPositiveInt `json:"listorder,omitempty"`
}

// NewCitationEntry creates a new CitationEntry instance
func NewCitationEntry() *CitationEntry {
	return &CitationEntry{}
}

// FromJSON populates CitationEntry from JSON data
func (m *CitationEntry) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationEntry to JSON data
func (m *CitationEntry) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationEntry
func (m *CitationEntry) Clone() *CitationEntry {
	if m == nil { return nil }
	return &CitationEntry{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Initials: m.Initials.Clone(),
		CollectiveName: m.CollectiveName.Clone(),
		Identifier: cloneSlices(m.Identifier),
		AffiliationInfo: cloneSlices(m.AffiliationInfo),
		Address: cloneSlices(m.Address),
		Telecom: cloneSlices(m.Telecom),
		ContributionType: cloneSlices(m.ContributionType),
		Role: m.Role.Clone(),
		ContributionInstance: cloneSlices(m.ContributionInstance),
		CorrespondingContact: m.CorrespondingContact.Clone(),
		ListOrder: m.ListOrder.Clone(),
	}
}

// Equals checks for equality with another CitationEntry instance
func (m *CitationEntry) Equals(other *CitationEntry) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Initials.Equals(other.Initials) { return false }
	if !m.CollectiveName.Equals(other.CollectiveName) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.AffiliationInfo, other.AffiliationInfo) { return false }
	if !compareSlices(m.Address, other.Address) { return false }
	if !compareSlices(m.Telecom, other.Telecom) { return false }
	if !compareSlices(m.ContributionType, other.ContributionType) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !compareSlices(m.ContributionInstance, other.ContributionInstance) { return false }
	if !m.CorrespondingContact.Equals(other.CorrespondingContact) { return false }
	if !m.ListOrder.Equals(other.ListOrder) { return false }
	return true
}

// CitationAffiliationInfo
// Organization affiliated with the entity.
type CitationAffiliationInfo struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Affiliation *FhirString `json:"affiliation,omitempty"`
	Role *FhirString `json:"role,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
}

// NewCitationAffiliationInfo creates a new CitationAffiliationInfo instance
func NewCitationAffiliationInfo() *CitationAffiliationInfo {
	return &CitationAffiliationInfo{}
}

// FromJSON populates CitationAffiliationInfo from JSON data
func (m *CitationAffiliationInfo) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationAffiliationInfo to JSON data
func (m *CitationAffiliationInfo) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationAffiliationInfo
func (m *CitationAffiliationInfo) Clone() *CitationAffiliationInfo {
	if m == nil { return nil }
	return &CitationAffiliationInfo{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Affiliation: m.Affiliation.Clone(),
		Role: m.Role.Clone(),
		Identifier: cloneSlices(m.Identifier),
	}
}

// Equals checks for equality with another CitationAffiliationInfo instance
func (m *CitationAffiliationInfo) Equals(other *CitationAffiliationInfo) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Affiliation.Equals(other.Affiliation) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	return true
}

// CitationContributionInstance
// Contributions with accounting for time or number.
type CitationContributionInstance struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Time *FhirDateTime `json:"time,omitempty"`
}

// NewCitationContributionInstance creates a new CitationContributionInstance instance
func NewCitationContributionInstance() *CitationContributionInstance {
	return &CitationContributionInstance{}
}

// FromJSON populates CitationContributionInstance from JSON data
func (m *CitationContributionInstance) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationContributionInstance to JSON data
func (m *CitationContributionInstance) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationContributionInstance
func (m *CitationContributionInstance) Clone() *CitationContributionInstance {
	if m == nil { return nil }
	return &CitationContributionInstance{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Time: m.Time.Clone(),
	}
}

// Equals checks for equality with another CitationContributionInstance instance
func (m *CitationContributionInstance) Equals(other *CitationContributionInstance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Time.Equals(other.Time) { return false }
	return true
}

// CitationSummary1
// Used to record a display of the author/contributor list without separate coding for each list member.
type CitationSummary1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Style *CodeableConcept `json:"style,omitempty"`
	Source *CodeableConcept `json:"source,omitempty"`
	Value *FhirMarkdown `json:"value,omitempty"`
}

// NewCitationSummary1 creates a new CitationSummary1 instance
func NewCitationSummary1() *CitationSummary1 {
	return &CitationSummary1{}
}

// FromJSON populates CitationSummary1 from JSON data
func (m *CitationSummary1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CitationSummary1 to JSON data
func (m *CitationSummary1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CitationSummary1
func (m *CitationSummary1) Clone() *CitationSummary1 {
	if m == nil { return nil }
	return &CitationSummary1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Style: m.Style.Clone(),
		Source: m.Source.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another CitationSummary1 instance
func (m *CitationSummary1) Equals(other *CitationSummary1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Style.Equals(other.Style) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

