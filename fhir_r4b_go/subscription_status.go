// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// SubscriptionStatus
// The SubscriptionStatus resource describes the state of a Subscription during notifications.
type SubscriptionStatus struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Status *SubscriptionStatusCodes `json:"status,omitempty"`
	Type *SubscriptionNotificationType `json:"type,omitempty"`
	EventsSinceSubscriptionStart *FhirString `json:"eventssincesubscriptionstart,omitempty"`
	NotificationEvent []*SubscriptionStatusNotificationEvent `json:"notificationevent,omitempty"`
	Subscription *Reference `json:"subscription,omitempty"`
	Topic *FhirCanonical `json:"topic,omitempty"`
	Error []*CodeableConcept `json:"error,omitempty"`
}

// NewSubscriptionStatus creates a new SubscriptionStatus instance
func NewSubscriptionStatus() *SubscriptionStatus {
	return &SubscriptionStatus{}
}

// FromJSON populates SubscriptionStatus from JSON data
func (m *SubscriptionStatus) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionStatus to JSON data
func (m *SubscriptionStatus) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionStatus
func (m *SubscriptionStatus) Clone() *SubscriptionStatus {
	if m == nil { return nil }
	return &SubscriptionStatus{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Status: m.Status.Clone(),
		Type: m.Type.Clone(),
		EventsSinceSubscriptionStart: m.EventsSinceSubscriptionStart.Clone(),
		NotificationEvent: cloneSlices(m.NotificationEvent),
		Subscription: m.Subscription.Clone(),
		Topic: m.Topic.Clone(),
		Error: cloneSlices(m.Error),
	}
}

// Equals checks for equality with another SubscriptionStatus instance
func (m *SubscriptionStatus) Equals(other *SubscriptionStatus) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.EventsSinceSubscriptionStart.Equals(other.EventsSinceSubscriptionStart) { return false }
	if !compareSlices(m.NotificationEvent, other.NotificationEvent) { return false }
	if !m.Subscription.Equals(other.Subscription) { return false }
	if !m.Topic.Equals(other.Topic) { return false }
	if !compareSlices(m.Error, other.Error) { return false }
	return true
}

// SubscriptionStatusNotificationEvent
// Detailed information about events relevant to this subscription notification.
type SubscriptionStatusNotificationEvent struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	EventNumber *FhirString `json:"eventnumber,omitempty"`
	Timestamp *FhirInstant `json:"timestamp,omitempty"`
	Focus *Reference `json:"focus,omitempty"`
	AdditionalContext []*Reference `json:"additionalcontext,omitempty"`
}

// NewSubscriptionStatusNotificationEvent creates a new SubscriptionStatusNotificationEvent instance
func NewSubscriptionStatusNotificationEvent() *SubscriptionStatusNotificationEvent {
	return &SubscriptionStatusNotificationEvent{}
}

// FromJSON populates SubscriptionStatusNotificationEvent from JSON data
func (m *SubscriptionStatusNotificationEvent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubscriptionStatusNotificationEvent to JSON data
func (m *SubscriptionStatusNotificationEvent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubscriptionStatusNotificationEvent
func (m *SubscriptionStatusNotificationEvent) Clone() *SubscriptionStatusNotificationEvent {
	if m == nil { return nil }
	return &SubscriptionStatusNotificationEvent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		EventNumber: m.EventNumber.Clone(),
		Timestamp: m.Timestamp.Clone(),
		Focus: m.Focus.Clone(),
		AdditionalContext: cloneSlices(m.AdditionalContext),
	}
}

// Equals checks for equality with another SubscriptionStatusNotificationEvent instance
func (m *SubscriptionStatusNotificationEvent) Equals(other *SubscriptionStatusNotificationEvent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.EventNumber.Equals(other.EventNumber) { return false }
	if !m.Timestamp.Equals(other.Timestamp) { return false }
	if !m.Focus.Equals(other.Focus) { return false }
	if !compareSlices(m.AdditionalContext, other.AdditionalContext) { return false }
	return true
}

