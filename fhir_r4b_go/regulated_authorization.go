// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// RegulatedAuthorization
// Regulatory approval, clearance or licencing related to a regulated product, treatment, facility or activity that is cited in a guidance, regulation, rule or legislative act. An example is Market Authorization relating to a Medicinal Product.
type RegulatedAuthorization struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Subject []*Reference `json:"subject,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Region []*CodeableConcept `json:"region,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	StatusDate *FhirDateTime `json:"statusdate,omitempty"`
	ValidityPeriod *Period `json:"validityperiod,omitempty"`
	Indication *CodeableReference `json:"indication,omitempty"`
	IntendedUse *CodeableConcept `json:"intendeduse,omitempty"`
	Basis []*CodeableConcept `json:"basis,omitempty"`
	Holder *Reference `json:"holder,omitempty"`
	Regulator *Reference `json:"regulator,omitempty"`
	Case_ *RegulatedAuthorizationCase `json:"case,omitempty"`
}

// NewRegulatedAuthorization creates a new RegulatedAuthorization instance.
func NewRegulatedAuthorization() *RegulatedAuthorization {
	return &RegulatedAuthorization{}
}

// UnmarshalJSON populates RegulatedAuthorization from JSON data.
func (m *RegulatedAuthorization) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Subject []*Reference `json:"subject,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		Region []*CodeableConcept `json:"region,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		StatusDate *FhirDateTime `json:"statusdate,omitempty"`
		ValidityPeriod *Period `json:"validityperiod,omitempty"`
		Indication *CodeableReference `json:"indication,omitempty"`
		IntendedUse *CodeableConcept `json:"intendeduse,omitempty"`
		Basis []*CodeableConcept `json:"basis,omitempty"`
		Holder *Reference `json:"holder,omitempty"`
		Regulator *Reference `json:"regulator,omitempty"`
		Case_ *RegulatedAuthorizationCase `json:"case,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Subject = temp.Subject
	m.Type = temp.Type
	m.Description = temp.Description
	m.Region = temp.Region
	m.Status = temp.Status
	m.StatusDate = temp.StatusDate
	m.ValidityPeriod = temp.ValidityPeriod
	m.Indication = temp.Indication
	m.IntendedUse = temp.IntendedUse
	m.Basis = temp.Basis
	m.Holder = temp.Holder
	m.Regulator = temp.Regulator
	m.Case_ = temp.Case_
	return nil
}

// MarshalJSON converts RegulatedAuthorization to JSON data.
func (m *RegulatedAuthorization) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Subject []*Reference `json:"subject,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		Region []*CodeableConcept `json:"region,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		StatusDate interface{} `json:"statusdate,omitempty"`
		StatusDateElement map[string]interface{} `json:"_statusdate,omitempty"`
		ValidityPeriod *Period `json:"validityperiod,omitempty"`
		Indication *CodeableReference `json:"indication,omitempty"`
		IntendedUse *CodeableConcept `json:"intendeduse,omitempty"`
		Basis []*CodeableConcept `json:"basis,omitempty"`
		Holder *Reference `json:"holder,omitempty"`
		Regulator *Reference `json:"regulator,omitempty"`
		Case_ *RegulatedAuthorizationCase `json:"case,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Subject = m.Subject
	output.Type = m.Type
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.MarshalJSON())
		}
	}
	output.Region = m.Region
	output.Status = m.Status
	if m.StatusDate != nil && m.StatusDate.Value != nil {
		output.StatusDate = m.StatusDate.Value
		if m.StatusDate.Element != nil {
			output.StatusDateElement = toMapOrNil(m.StatusDate.Element.MarshalJSON())
		}
	}
	output.ValidityPeriod = m.ValidityPeriod
	output.Indication = m.Indication
	output.IntendedUse = m.IntendedUse
	output.Basis = m.Basis
	output.Holder = m.Holder
	output.Regulator = m.Regulator
	output.Case_ = m.Case_
	return json.Marshal(output)
}

// Clone creates a deep copy of RegulatedAuthorization.
func (m *RegulatedAuthorization) Clone() *RegulatedAuthorization {
	if m == nil { return nil }
	return &RegulatedAuthorization{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Subject: cloneSlices(m.Subject),
		Type: m.Type.Clone(),
		Description: m.Description.Clone(),
		Region: cloneSlices(m.Region),
		Status: m.Status.Clone(),
		StatusDate: m.StatusDate.Clone(),
		ValidityPeriod: m.ValidityPeriod.Clone(),
		Indication: m.Indication.Clone(),
		IntendedUse: m.IntendedUse.Clone(),
		Basis: cloneSlices(m.Basis),
		Holder: m.Holder.Clone(),
		Regulator: m.Regulator.Clone(),
		Case_: m.Case_.Clone(),
	}
}

// Equals checks equality between two RegulatedAuthorization instances.
func (m *RegulatedAuthorization) Equals(other *RegulatedAuthorization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.Subject, other.Subject) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Region, other.Region) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !m.ValidityPeriod.Equals(other.ValidityPeriod) { return false }
	if !m.Indication.Equals(other.Indication) { return false }
	if !m.IntendedUse.Equals(other.IntendedUse) { return false }
	if !compareSlices(m.Basis, other.Basis) { return false }
	if !m.Holder.Equals(other.Holder) { return false }
	if !m.Regulator.Equals(other.Regulator) { return false }
	if !m.Case_.Equals(other.Case_) { return false }
	return true
}

// RegulatedAuthorizationCase
// The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
type RegulatedAuthorizationCase struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	DatePeriod *Period `json:"dateperiod,omitempty"`
	DateDateTime *FhirDateTime `json:"datedatetime,omitempty"`
	Application []*RegulatedAuthorizationCase `json:"application,omitempty"`
}

// NewRegulatedAuthorizationCase creates a new RegulatedAuthorizationCase instance.
func NewRegulatedAuthorizationCase() *RegulatedAuthorizationCase {
	return &RegulatedAuthorizationCase{}
}

// UnmarshalJSON populates RegulatedAuthorizationCase from JSON data.
func (m *RegulatedAuthorizationCase) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		DatePeriod *Period `json:"dateperiod,omitempty"`
		DateDateTime *FhirDateTime `json:"datedatetime,omitempty"`
		Application []*RegulatedAuthorizationCase `json:"application,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Type = temp.Type
	m.Status = temp.Status
	m.DatePeriod = temp.DatePeriod
	m.DateDateTime = temp.DateDateTime
	m.Application = temp.Application
	return nil
}

// MarshalJSON converts RegulatedAuthorizationCase to JSON data.
func (m *RegulatedAuthorizationCase) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		DatePeriod *Period `json:"dateperiod,omitempty"`
		DateDateTime interface{} `json:"datedatetime,omitempty"`
		DateDateTimeElement map[string]interface{} `json:"_datedatetime,omitempty"`
		Application []*RegulatedAuthorizationCase `json:"application,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Type = m.Type
	output.Status = m.Status
	output.DatePeriod = m.DatePeriod
	if m.DateDateTime != nil && m.DateDateTime.Value != nil {
		output.DateDateTime = m.DateDateTime.Value
		if m.DateDateTime.Element != nil {
			output.DateDateTimeElement = toMapOrNil(m.DateDateTime.Element.MarshalJSON())
		}
	}
	output.Application = m.Application
	return json.Marshal(output)
}

// Clone creates a deep copy of RegulatedAuthorizationCase.
func (m *RegulatedAuthorizationCase) Clone() *RegulatedAuthorizationCase {
	if m == nil { return nil }
	return &RegulatedAuthorizationCase{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Type: m.Type.Clone(),
		Status: m.Status.Clone(),
		DatePeriod: m.DatePeriod.Clone(),
		DateDateTime: m.DateDateTime.Clone(),
		Application: cloneSlices(m.Application),
	}
}

// Equals checks equality between two RegulatedAuthorizationCase instances.
func (m *RegulatedAuthorizationCase) Equals(other *RegulatedAuthorizationCase) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.DatePeriod.Equals(other.DatePeriod) { return false }
	if !m.DateDateTime.Equals(other.DateDateTime) { return false }
	if !compareSlices(m.Application, other.Application) { return false }
	return true
}

