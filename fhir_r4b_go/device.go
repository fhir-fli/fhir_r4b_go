// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Device
// A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
type Device struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Definition *Reference `json:"definition,omitempty"`
	UdiCarrier []*DeviceUdiCarrier `json:"udicarrier,omitempty"`
	Status *FHIRDeviceStatus `json:"status,omitempty"`
	StatusReason []*CodeableConcept `json:"statusreason,omitempty"`
	DistinctIdentifier *FhirString `json:"distinctidentifier,omitempty"`
	Manufacturer *FhirString `json:"manufacturer,omitempty"`
	ManufactureDate *FhirDateTime `json:"manufacturedate,omitempty"`
	ExpirationDate *FhirDateTime `json:"expirationdate,omitempty"`
	LotNumber *FhirString `json:"lotnumber,omitempty"`
	SerialNumber *FhirString `json:"serialnumber,omitempty"`
	DeviceName []*DeviceDeviceName `json:"devicename,omitempty"`
	ModelNumber *FhirString `json:"modelnumber,omitempty"`
	PartNumber *FhirString `json:"partnumber,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Specialization []*DeviceSpecialization `json:"specialization,omitempty"`
	Version []*DeviceVersion `json:"version,omitempty"`
	Property []*DeviceProperty `json:"property,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	Owner *Reference `json:"owner,omitempty"`
	Contact []*ContactPoint `json:"contact,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Safety []*CodeableConcept `json:"safety,omitempty"`
	Parent *Reference `json:"parent,omitempty"`
}

// NewDevice creates a new Device instance
func NewDevice() *Device {
	return &Device{}
}

// FromJSON populates Device from JSON data
func (m *Device) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Device to JSON data
func (m *Device) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Device
func (m *Device) Clone() *Device {
	if m == nil { return nil }
	return &Device{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Definition: m.Definition.Clone(),
		UdiCarrier: cloneSlices(m.UdiCarrier),
		Status: m.Status.Clone(),
		StatusReason: cloneSlices(m.StatusReason),
		DistinctIdentifier: m.DistinctIdentifier.Clone(),
		Manufacturer: m.Manufacturer.Clone(),
		ManufactureDate: m.ManufactureDate.Clone(),
		ExpirationDate: m.ExpirationDate.Clone(),
		LotNumber: m.LotNumber.Clone(),
		SerialNumber: m.SerialNumber.Clone(),
		DeviceName: cloneSlices(m.DeviceName),
		ModelNumber: m.ModelNumber.Clone(),
		PartNumber: m.PartNumber.Clone(),
		Type: m.Type.Clone(),
		Specialization: cloneSlices(m.Specialization),
		Version: cloneSlices(m.Version),
		Property: cloneSlices(m.Property),
		Patient: m.Patient.Clone(),
		Owner: m.Owner.Clone(),
		Contact: cloneSlices(m.Contact),
		Location: m.Location.Clone(),
		Url: m.Url.Clone(),
		Note: cloneSlices(m.Note),
		Safety: cloneSlices(m.Safety),
		Parent: m.Parent.Clone(),
	}
}

// Equals checks for equality with another Device instance
func (m *Device) Equals(other *Device) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	if !compareSlices(m.UdiCarrier, other.UdiCarrier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.StatusReason, other.StatusReason) { return false }
	if !m.DistinctIdentifier.Equals(other.DistinctIdentifier) { return false }
	if !m.Manufacturer.Equals(other.Manufacturer) { return false }
	if !m.ManufactureDate.Equals(other.ManufactureDate) { return false }
	if !m.ExpirationDate.Equals(other.ExpirationDate) { return false }
	if !m.LotNumber.Equals(other.LotNumber) { return false }
	if !m.SerialNumber.Equals(other.SerialNumber) { return false }
	if !compareSlices(m.DeviceName, other.DeviceName) { return false }
	if !m.ModelNumber.Equals(other.ModelNumber) { return false }
	if !m.PartNumber.Equals(other.PartNumber) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Specialization, other.Specialization) { return false }
	if !compareSlices(m.Version, other.Version) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.Owner.Equals(other.Owner) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.Safety, other.Safety) { return false }
	if !m.Parent.Equals(other.Parent) { return false }
	return true
}

// DeviceUdiCarrier
// Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
type DeviceUdiCarrier struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DeviceIdentifier *FhirString `json:"deviceidentifier,omitempty"`
	Issuer *FhirUri `json:"issuer,omitempty"`
	Jurisdiction *FhirUri `json:"jurisdiction,omitempty"`
	CarrierAIDC *FhirBase64Binary `json:"carrieraidc,omitempty"`
	CarrierHRF *FhirString `json:"carrierhrf,omitempty"`
	EntryType *UDIEntryType `json:"entrytype,omitempty"`
}

// NewDeviceUdiCarrier creates a new DeviceUdiCarrier instance
func NewDeviceUdiCarrier() *DeviceUdiCarrier {
	return &DeviceUdiCarrier{}
}

// FromJSON populates DeviceUdiCarrier from JSON data
func (m *DeviceUdiCarrier) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceUdiCarrier to JSON data
func (m *DeviceUdiCarrier) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceUdiCarrier
func (m *DeviceUdiCarrier) Clone() *DeviceUdiCarrier {
	if m == nil { return nil }
	return &DeviceUdiCarrier{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DeviceIdentifier: m.DeviceIdentifier.Clone(),
		Issuer: m.Issuer.Clone(),
		Jurisdiction: m.Jurisdiction.Clone(),
		CarrierAIDC: m.CarrierAIDC.Clone(),
		CarrierHRF: m.CarrierHRF.Clone(),
		EntryType: m.EntryType.Clone(),
	}
}

// Equals checks for equality with another DeviceUdiCarrier instance
func (m *DeviceUdiCarrier) Equals(other *DeviceUdiCarrier) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.DeviceIdentifier.Equals(other.DeviceIdentifier) { return false }
	if !m.Issuer.Equals(other.Issuer) { return false }
	if !m.Jurisdiction.Equals(other.Jurisdiction) { return false }
	if !m.CarrierAIDC.Equals(other.CarrierAIDC) { return false }
	if !m.CarrierHRF.Equals(other.CarrierHRF) { return false }
	if !m.EntryType.Equals(other.EntryType) { return false }
	return true
}

// DeviceDeviceName
// This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
type DeviceDeviceName struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Type *DeviceNameType `json:"type,omitempty"`
}

// NewDeviceDeviceName creates a new DeviceDeviceName instance
func NewDeviceDeviceName() *DeviceDeviceName {
	return &DeviceDeviceName{}
}

// FromJSON populates DeviceDeviceName from JSON data
func (m *DeviceDeviceName) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDeviceName to JSON data
func (m *DeviceDeviceName) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDeviceName
func (m *DeviceDeviceName) Clone() *DeviceDeviceName {
	if m == nil { return nil }
	return &DeviceDeviceName{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks for equality with another DeviceDeviceName instance
func (m *DeviceDeviceName) Equals(other *DeviceDeviceName) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// DeviceSpecialization
// The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
type DeviceSpecialization struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	SystemType *CodeableConcept `json:"systemtype,omitempty"`
	Version *FhirString `json:"version,omitempty"`
}

// NewDeviceSpecialization creates a new DeviceSpecialization instance
func NewDeviceSpecialization() *DeviceSpecialization {
	return &DeviceSpecialization{}
}

// FromJSON populates DeviceSpecialization from JSON data
func (m *DeviceSpecialization) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceSpecialization to JSON data
func (m *DeviceSpecialization) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceSpecialization
func (m *DeviceSpecialization) Clone() *DeviceSpecialization {
	if m == nil { return nil }
	return &DeviceSpecialization{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		SystemType: m.SystemType.Clone(),
		Version: m.Version.Clone(),
	}
}

// Equals checks for equality with another DeviceSpecialization instance
func (m *DeviceSpecialization) Equals(other *DeviceSpecialization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.SystemType.Equals(other.SystemType) { return false }
	if !m.Version.Equals(other.Version) { return false }
	return true
}

// DeviceVersion
// The actual design of the device or software version running on the device.
type DeviceVersion struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Component *Identifier `json:"component,omitempty"`
	Value *FhirString `json:"value,omitempty"`
}

// NewDeviceVersion creates a new DeviceVersion instance
func NewDeviceVersion() *DeviceVersion {
	return &DeviceVersion{}
}

// FromJSON populates DeviceVersion from JSON data
func (m *DeviceVersion) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceVersion to JSON data
func (m *DeviceVersion) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceVersion
func (m *DeviceVersion) Clone() *DeviceVersion {
	if m == nil { return nil }
	return &DeviceVersion{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Component: m.Component.Clone(),
		Value: m.Value.Clone(),
	}
}

// Equals checks for equality with another DeviceVersion instance
func (m *DeviceVersion) Equals(other *DeviceVersion) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Component.Equals(other.Component) { return false }
	if !m.Value.Equals(other.Value) { return false }
	return true
}

// DeviceProperty
// The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
type DeviceProperty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueQuantity []*Quantity `json:"valuequantity,omitempty"`
	ValueCode []*CodeableConcept `json:"valuecode,omitempty"`
}

// NewDeviceProperty creates a new DeviceProperty instance
func NewDeviceProperty() *DeviceProperty {
	return &DeviceProperty{}
}

// FromJSON populates DeviceProperty from JSON data
func (m *DeviceProperty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceProperty to JSON data
func (m *DeviceProperty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceProperty
func (m *DeviceProperty) Clone() *DeviceProperty {
	if m == nil { return nil }
	return &DeviceProperty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueQuantity: cloneSlices(m.ValueQuantity),
		ValueCode: cloneSlices(m.ValueCode),
	}
}

// Equals checks for equality with another DeviceProperty instance
func (m *DeviceProperty) Equals(other *DeviceProperty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.ValueQuantity, other.ValueQuantity) { return false }
	if !compareSlices(m.ValueCode, other.ValueCode) { return false }
	return true
}

