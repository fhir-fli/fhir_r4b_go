// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// MedicationDispense
// Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.
type MedicationDispense struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	PartOf []*Reference `json:"partof,omitempty"`
	Status *MedicationDispenseStatusCodes `json:"status,omitempty"`
	StatusReasonCodeableConcept *CodeableConcept `json:"statusreasoncodeableconcept,omitempty"`
	StatusReasonReference *Reference `json:"statusreasonreference,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	MedicationCodeableConcept *CodeableConcept `json:"medicationcodeableconcept,omitempty"`
	MedicationReference *Reference `json:"medicationreference,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Context *Reference `json:"context,omitempty"`
	SupportingInformation []*Reference `json:"supportinginformation,omitempty"`
	Performer []*MedicationDispensePerformer `json:"performer,omitempty"`
	Location *Reference `json:"location,omitempty"`
	AuthorizingPrescription []*Reference `json:"authorizingprescription,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	DaysSupply *Quantity `json:"dayssupply,omitempty"`
	WhenPrepared *FhirDateTime `json:"whenprepared,omitempty"`
	WhenHandedOver *FhirDateTime `json:"whenhandedover,omitempty"`
	Destination *Reference `json:"destination,omitempty"`
	Receiver []*Reference `json:"receiver,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	DosageInstruction []*Dosage `json:"dosageinstruction,omitempty"`
	Substitution *MedicationDispenseSubstitution `json:"substitution,omitempty"`
	DetectedIssue []*Reference `json:"detectedissue,omitempty"`
	EventHistory []*Reference `json:"eventhistory,omitempty"`
}

// NewMedicationDispense creates a new MedicationDispense instance
func NewMedicationDispense() *MedicationDispense {
	return &MedicationDispense{}
}

// FromJSON populates MedicationDispense from JSON data
func (m *MedicationDispense) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationDispense to JSON data
func (m *MedicationDispense) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationDispense
func (m *MedicationDispense) Clone() *MedicationDispense {
	if m == nil { return nil }
	return &MedicationDispense{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		PartOf: cloneSlices(m.PartOf),
		Status: m.Status.Clone(),
		StatusReasonCodeableConcept: m.StatusReasonCodeableConcept.Clone(),
		StatusReasonReference: m.StatusReasonReference.Clone(),
		Category: m.Category.Clone(),
		MedicationCodeableConcept: m.MedicationCodeableConcept.Clone(),
		MedicationReference: m.MedicationReference.Clone(),
		Subject: m.Subject.Clone(),
		Context: m.Context.Clone(),
		SupportingInformation: cloneSlices(m.SupportingInformation),
		Performer: cloneSlices(m.Performer),
		Location: m.Location.Clone(),
		AuthorizingPrescription: cloneSlices(m.AuthorizingPrescription),
		Type: m.Type.Clone(),
		Quantity: m.Quantity.Clone(),
		DaysSupply: m.DaysSupply.Clone(),
		WhenPrepared: m.WhenPrepared.Clone(),
		WhenHandedOver: m.WhenHandedOver.Clone(),
		Destination: m.Destination.Clone(),
		Receiver: cloneSlices(m.Receiver),
		Note: cloneSlices(m.Note),
		DosageInstruction: cloneSlices(m.DosageInstruction),
		Substitution: m.Substitution.Clone(),
		DetectedIssue: cloneSlices(m.DetectedIssue),
		EventHistory: cloneSlices(m.EventHistory),
	}
}

// Equals checks for equality with another MedicationDispense instance
func (m *MedicationDispense) Equals(other *MedicationDispense) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusReasonCodeableConcept.Equals(other.StatusReasonCodeableConcept) { return false }
	if !m.StatusReasonReference.Equals(other.StatusReasonReference) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.MedicationCodeableConcept.Equals(other.MedicationCodeableConcept) { return false }
	if !m.MedicationReference.Equals(other.MedicationReference) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Context.Equals(other.Context) { return false }
	if !compareSlices(m.SupportingInformation, other.SupportingInformation) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !compareSlices(m.AuthorizingPrescription, other.AuthorizingPrescription) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.DaysSupply.Equals(other.DaysSupply) { return false }
	if !m.WhenPrepared.Equals(other.WhenPrepared) { return false }
	if !m.WhenHandedOver.Equals(other.WhenHandedOver) { return false }
	if !m.Destination.Equals(other.Destination) { return false }
	if !compareSlices(m.Receiver, other.Receiver) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.DosageInstruction, other.DosageInstruction) { return false }
	if !m.Substitution.Equals(other.Substitution) { return false }
	if !compareSlices(m.DetectedIssue, other.DetectedIssue) { return false }
	if !compareSlices(m.EventHistory, other.EventHistory) { return false }
	return true
}

// MedicationDispensePerformer
// Indicates who or what performed the event.
type MedicationDispensePerformer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Function_ *CodeableConcept `json:"function,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewMedicationDispensePerformer creates a new MedicationDispensePerformer instance
func NewMedicationDispensePerformer() *MedicationDispensePerformer {
	return &MedicationDispensePerformer{}
}

// FromJSON populates MedicationDispensePerformer from JSON data
func (m *MedicationDispensePerformer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationDispensePerformer to JSON data
func (m *MedicationDispensePerformer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationDispensePerformer
func (m *MedicationDispensePerformer) Clone() *MedicationDispensePerformer {
	if m == nil { return nil }
	return &MedicationDispensePerformer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Function_: m.Function_.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks for equality with another MedicationDispensePerformer instance
func (m *MedicationDispensePerformer) Equals(other *MedicationDispensePerformer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Function_.Equals(other.Function_) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

// MedicationDispenseSubstitution
// Indicates whether or not substitution was made as part of the dispense.  In some cases, substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done.
type MedicationDispenseSubstitution struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	WasSubstituted *FhirBoolean `json:"wassubstituted,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Reason []*CodeableConcept `json:"reason,omitempty"`
	ResponsibleParty []*Reference `json:"responsibleparty,omitempty"`
}

// NewMedicationDispenseSubstitution creates a new MedicationDispenseSubstitution instance
func NewMedicationDispenseSubstitution() *MedicationDispenseSubstitution {
	return &MedicationDispenseSubstitution{}
}

// FromJSON populates MedicationDispenseSubstitution from JSON data
func (m *MedicationDispenseSubstitution) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicationDispenseSubstitution to JSON data
func (m *MedicationDispenseSubstitution) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicationDispenseSubstitution
func (m *MedicationDispenseSubstitution) Clone() *MedicationDispenseSubstitution {
	if m == nil { return nil }
	return &MedicationDispenseSubstitution{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		WasSubstituted: m.WasSubstituted.Clone(),
		Type: m.Type.Clone(),
		Reason: cloneSlices(m.Reason),
		ResponsibleParty: cloneSlices(m.ResponsibleParty),
	}
}

// Equals checks for equality with another MedicationDispenseSubstitution instance
func (m *MedicationDispenseSubstitution) Equals(other *MedicationDispenseSubstitution) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.WasSubstituted.Equals(other.WasSubstituted) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Reason, other.Reason) { return false }
	if !compareSlices(m.ResponsibleParty, other.ResponsibleParty) { return false }
	return true
}

