// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// SubstanceDefinition
// The detailed description of a substance, typically at a level beyond what is used for prescribing.
type SubstanceDefinition struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Classification []*CodeableConcept `json:"classification,omitempty"`
	Domain *CodeableConcept `json:"domain,omitempty"`
	Grade []*CodeableConcept `json:"grade,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	InformationSource []*Reference `json:"informationsource,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Manufacturer []*Reference `json:"manufacturer,omitempty"`
	Supplier []*Reference `json:"supplier,omitempty"`
	Moiety []*SubstanceDefinitionMoiety `json:"moiety,omitempty"`
	Property []*SubstanceDefinitionProperty `json:"property,omitempty"`
	MolecularWeight []*SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
	Structure *SubstanceDefinitionStructure `json:"structure,omitempty"`
	Code []*SubstanceDefinitionCode `json:"code,omitempty"`
	Name []*SubstanceDefinitionName `json:"name,omitempty"`
	Relationship []*SubstanceDefinitionRelationship `json:"relationship,omitempty"`
	SourceMaterial *SubstanceDefinitionSourceMaterial `json:"sourcematerial,omitempty"`
}

// NewSubstanceDefinition creates a new SubstanceDefinition instance.
func NewSubstanceDefinition() *SubstanceDefinition {
	return &SubstanceDefinition{}
}

// FromJSON populates SubstanceDefinition from JSON data.
func (m *SubstanceDefinition) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version *FhirString `json:"version,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		Classification []*CodeableConcept `json:"classification,omitempty"`
		Domain *CodeableConcept `json:"domain,omitempty"`
		Grade []*CodeableConcept `json:"grade,omitempty"`
		Description *FhirMarkdown `json:"description,omitempty"`
		InformationSource []*Reference `json:"informationsource,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Manufacturer []*Reference `json:"manufacturer,omitempty"`
		Supplier []*Reference `json:"supplier,omitempty"`
		Moiety []*SubstanceDefinitionMoiety `json:"moiety,omitempty"`
		Property []*SubstanceDefinitionProperty `json:"property,omitempty"`
		MolecularWeight []*SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
		Structure *SubstanceDefinitionStructure `json:"structure,omitempty"`
		Code []*SubstanceDefinitionCode `json:"code,omitempty"`
		Name []*SubstanceDefinitionName `json:"name,omitempty"`
		Relationship []*SubstanceDefinitionRelationship `json:"relationship,omitempty"`
		SourceMaterial *SubstanceDefinitionSourceMaterial `json:"sourcematerial,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Version = temp.Version
	m.Status = temp.Status
	m.Classification = temp.Classification
	m.Domain = temp.Domain
	m.Grade = temp.Grade
	m.Description = temp.Description
	m.InformationSource = temp.InformationSource
	m.Note = temp.Note
	m.Manufacturer = temp.Manufacturer
	m.Supplier = temp.Supplier
	m.Moiety = temp.Moiety
	m.Property = temp.Property
	m.MolecularWeight = temp.MolecularWeight
	m.Structure = temp.Structure
	m.Code = temp.Code
	m.Name = temp.Name
	m.Relationship = temp.Relationship
	m.SourceMaterial = temp.SourceMaterial
	return nil
}

// ToJSON converts SubstanceDefinition to JSON data.
func (m *SubstanceDefinition) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Version interface{} `json:"version,omitempty"`
		VersionElement map[string]interface{} `json:"_version,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		Classification []*CodeableConcept `json:"classification,omitempty"`
		Domain *CodeableConcept `json:"domain,omitempty"`
		Grade []*CodeableConcept `json:"grade,omitempty"`
		Description interface{} `json:"description,omitempty"`
		DescriptionElement map[string]interface{} `json:"_description,omitempty"`
		InformationSource []*Reference `json:"informationsource,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Manufacturer []*Reference `json:"manufacturer,omitempty"`
		Supplier []*Reference `json:"supplier,omitempty"`
		Moiety []*SubstanceDefinitionMoiety `json:"moiety,omitempty"`
		Property []*SubstanceDefinitionProperty `json:"property,omitempty"`
		MolecularWeight []*SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
		Structure *SubstanceDefinitionStructure `json:"structure,omitempty"`
		Code []*SubstanceDefinitionCode `json:"code,omitempty"`
		Name []*SubstanceDefinitionName `json:"name,omitempty"`
		Relationship []*SubstanceDefinitionRelationship `json:"relationship,omitempty"`
		SourceMaterial *SubstanceDefinitionSourceMaterial `json:"sourcematerial,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.ToJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	if m.Version != nil && m.Version.Value != nil {
		output.Version = m.Version.Value
		if m.Version.Element != nil {
			output.VersionElement = toMapOrNil(m.Version.Element.ToJSON())
		}
	}
	output.Status = m.Status
	output.Classification = m.Classification
	output.Domain = m.Domain
	output.Grade = m.Grade
	if m.Description != nil && m.Description.Value != nil {
		output.Description = m.Description.Value
		if m.Description.Element != nil {
			output.DescriptionElement = toMapOrNil(m.Description.Element.ToJSON())
		}
	}
	output.InformationSource = m.InformationSource
	output.Note = m.Note
	output.Manufacturer = m.Manufacturer
	output.Supplier = m.Supplier
	output.Moiety = m.Moiety
	output.Property = m.Property
	output.MolecularWeight = m.MolecularWeight
	output.Structure = m.Structure
	output.Code = m.Code
	output.Name = m.Name
	output.Relationship = m.Relationship
	output.SourceMaterial = m.SourceMaterial
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinition.
func (m *SubstanceDefinition) Clone() *SubstanceDefinition {
	if m == nil { return nil }
	return &SubstanceDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Status: m.Status.Clone(),
		Classification: cloneSlices(m.Classification),
		Domain: m.Domain.Clone(),
		Grade: cloneSlices(m.Grade),
		Description: m.Description.Clone(),
		InformationSource: cloneSlices(m.InformationSource),
		Note: cloneSlices(m.Note),
		Manufacturer: cloneSlices(m.Manufacturer),
		Supplier: cloneSlices(m.Supplier),
		Moiety: cloneSlices(m.Moiety),
		Property: cloneSlices(m.Property),
		MolecularWeight: cloneSlices(m.MolecularWeight),
		Structure: m.Structure.Clone(),
		Code: cloneSlices(m.Code),
		Name: cloneSlices(m.Name),
		Relationship: cloneSlices(m.Relationship),
		SourceMaterial: m.SourceMaterial.Clone(),
	}
}

// Equals checks equality between two SubstanceDefinition instances.
func (m *SubstanceDefinition) Equals(other *SubstanceDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	if !m.Domain.Equals(other.Domain) { return false }
	if !compareSlices(m.Grade, other.Grade) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.InformationSource, other.InformationSource) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.Manufacturer, other.Manufacturer) { return false }
	if !compareSlices(m.Supplier, other.Supplier) { return false }
	if !compareSlices(m.Moiety, other.Moiety) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !compareSlices(m.MolecularWeight, other.MolecularWeight) { return false }
	if !m.Structure.Equals(other.Structure) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Name, other.Name) { return false }
	if !compareSlices(m.Relationship, other.Relationship) { return false }
	if !m.SourceMaterial.Equals(other.SourceMaterial) { return false }
	return true
}

// SubstanceDefinitionMoiety
// Moiety, for structural modifications.
type SubstanceDefinitionMoiety struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
	MolecularFormula *FhirString `json:"molecularformula,omitempty"`
	AmountQuantity *Quantity `json:"amountquantity,omitempty"`
	AmountString *FhirString `json:"amountstring,omitempty"`
	MeasurementType *CodeableConcept `json:"measurementtype,omitempty"`
}

// NewSubstanceDefinitionMoiety creates a new SubstanceDefinitionMoiety instance.
func NewSubstanceDefinitionMoiety() *SubstanceDefinitionMoiety {
	return &SubstanceDefinitionMoiety{}
}

// FromJSON populates SubstanceDefinitionMoiety from JSON data.
func (m *SubstanceDefinitionMoiety) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Role *CodeableConcept `json:"role,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
		OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
		MolecularFormula *FhirString `json:"molecularformula,omitempty"`
		AmountQuantity *Quantity `json:"amountquantity,omitempty"`
		AmountString *FhirString `json:"amountstring,omitempty"`
		MeasurementType *CodeableConcept `json:"measurementtype,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Role = temp.Role
	m.Identifier = temp.Identifier
	m.Name = temp.Name
	m.Stereochemistry = temp.Stereochemistry
	m.OpticalActivity = temp.OpticalActivity
	m.MolecularFormula = temp.MolecularFormula
	m.AmountQuantity = temp.AmountQuantity
	m.AmountString = temp.AmountString
	m.MeasurementType = temp.MeasurementType
	return nil
}

// ToJSON converts SubstanceDefinitionMoiety to JSON data.
func (m *SubstanceDefinitionMoiety) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Role *CodeableConcept `json:"role,omitempty"`
		Identifier *Identifier `json:"identifier,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
		OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
		MolecularFormula interface{} `json:"molecularformula,omitempty"`
		MolecularFormulaElement map[string]interface{} `json:"_molecularformula,omitempty"`
		AmountQuantity *Quantity `json:"amountquantity,omitempty"`
		AmountString interface{} `json:"amountstring,omitempty"`
		AmountStringElement map[string]interface{} `json:"_amountstring,omitempty"`
		MeasurementType *CodeableConcept `json:"measurementtype,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Role = m.Role
	output.Identifier = m.Identifier
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.ToJSON())
		}
	}
	output.Stereochemistry = m.Stereochemistry
	output.OpticalActivity = m.OpticalActivity
	if m.MolecularFormula != nil && m.MolecularFormula.Value != nil {
		output.MolecularFormula = m.MolecularFormula.Value
		if m.MolecularFormula.Element != nil {
			output.MolecularFormulaElement = toMapOrNil(m.MolecularFormula.Element.ToJSON())
		}
	}
	output.AmountQuantity = m.AmountQuantity
	if m.AmountString != nil && m.AmountString.Value != nil {
		output.AmountString = m.AmountString.Value
		if m.AmountString.Element != nil {
			output.AmountStringElement = toMapOrNil(m.AmountString.Element.ToJSON())
		}
	}
	output.MeasurementType = m.MeasurementType
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionMoiety.
func (m *SubstanceDefinitionMoiety) Clone() *SubstanceDefinitionMoiety {
	if m == nil { return nil }
	return &SubstanceDefinitionMoiety{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Role: m.Role.Clone(),
		Identifier: m.Identifier.Clone(),
		Name: m.Name.Clone(),
		Stereochemistry: m.Stereochemistry.Clone(),
		OpticalActivity: m.OpticalActivity.Clone(),
		MolecularFormula: m.MolecularFormula.Clone(),
		AmountQuantity: m.AmountQuantity.Clone(),
		AmountString: m.AmountString.Clone(),
		MeasurementType: m.MeasurementType.Clone(),
	}
}

// Equals checks equality between two SubstanceDefinitionMoiety instances.
func (m *SubstanceDefinitionMoiety) Equals(other *SubstanceDefinitionMoiety) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Stereochemistry.Equals(other.Stereochemistry) { return false }
	if !m.OpticalActivity.Equals(other.OpticalActivity) { return false }
	if !m.MolecularFormula.Equals(other.MolecularFormula) { return false }
	if !m.AmountQuantity.Equals(other.AmountQuantity) { return false }
	if !m.AmountString.Equals(other.AmountString) { return false }
	if !m.MeasurementType.Equals(other.MeasurementType) { return false }
	return true
}

// SubstanceDefinitionProperty
// General specifications for this substance.
type SubstanceDefinitionProperty struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
}

// NewSubstanceDefinitionProperty creates a new SubstanceDefinitionProperty instance.
func NewSubstanceDefinitionProperty() *SubstanceDefinitionProperty {
	return &SubstanceDefinitionProperty{}
}

// FromJSON populates SubstanceDefinitionProperty from JSON data.
func (m *SubstanceDefinitionProperty) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueDate *FhirDate `json:"valuedate,omitempty"`
		ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.ValueCodeableConcept = temp.ValueCodeableConcept
	m.ValueQuantity = temp.ValueQuantity
	m.ValueDate = temp.ValueDate
	m.ValueBoolean = temp.ValueBoolean
	m.ValueAttachment = temp.ValueAttachment
	return nil
}

// ToJSON converts SubstanceDefinitionProperty to JSON data.
func (m *SubstanceDefinitionProperty) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
		ValueQuantity *Quantity `json:"valuequantity,omitempty"`
		ValueDate interface{} `json:"valuedate,omitempty"`
		ValueDateElement map[string]interface{} `json:"_valuedate,omitempty"`
		ValueBoolean interface{} `json:"valueboolean,omitempty"`
		ValueBooleanElement map[string]interface{} `json:"_valueboolean,omitempty"`
		ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.ValueCodeableConcept = m.ValueCodeableConcept
	output.ValueQuantity = m.ValueQuantity
	if m.ValueDate != nil && m.ValueDate.Value != nil {
		output.ValueDate = m.ValueDate.Value
		if m.ValueDate.Element != nil {
			output.ValueDateElement = toMapOrNil(m.ValueDate.Element.ToJSON())
		}
	}
	if m.ValueBoolean != nil && m.ValueBoolean.Value != nil {
		output.ValueBoolean = m.ValueBoolean.Value
		if m.ValueBoolean.Element != nil {
			output.ValueBooleanElement = toMapOrNil(m.ValueBoolean.Element.ToJSON())
		}
	}
	output.ValueAttachment = m.ValueAttachment
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionProperty.
func (m *SubstanceDefinitionProperty) Clone() *SubstanceDefinitionProperty {
	if m == nil { return nil }
	return &SubstanceDefinitionProperty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
	}
}

// Equals checks equality between two SubstanceDefinitionProperty instances.
func (m *SubstanceDefinitionProperty) Equals(other *SubstanceDefinitionProperty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	return true
}

// SubstanceDefinitionMolecularWeight
// The molecular weight or weight range (for proteins, polymers or nucleic acids).
type SubstanceDefinitionMolecularWeight struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Amount *Quantity `json:"amount,omitempty"`
}

// NewSubstanceDefinitionMolecularWeight creates a new SubstanceDefinitionMolecularWeight instance.
func NewSubstanceDefinitionMolecularWeight() *SubstanceDefinitionMolecularWeight {
	return &SubstanceDefinitionMolecularWeight{}
}

// FromJSON populates SubstanceDefinitionMolecularWeight from JSON data.
func (m *SubstanceDefinitionMolecularWeight) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Method *CodeableConcept `json:"method,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Amount *Quantity `json:"amount,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Method = temp.Method
	m.Type = temp.Type
	m.Amount = temp.Amount
	return nil
}

// ToJSON converts SubstanceDefinitionMolecularWeight to JSON data.
func (m *SubstanceDefinitionMolecularWeight) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Method *CodeableConcept `json:"method,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Amount *Quantity `json:"amount,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Method = m.Method
	output.Type = m.Type
	output.Amount = m.Amount
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionMolecularWeight.
func (m *SubstanceDefinitionMolecularWeight) Clone() *SubstanceDefinitionMolecularWeight {
	if m == nil { return nil }
	return &SubstanceDefinitionMolecularWeight{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Method: m.Method.Clone(),
		Type: m.Type.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks equality between two SubstanceDefinitionMolecularWeight instances.
func (m *SubstanceDefinitionMolecularWeight) Equals(other *SubstanceDefinitionMolecularWeight) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

// SubstanceDefinitionStructure
// Structural information.
type SubstanceDefinitionStructure struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
	MolecularFormula *FhirString `json:"molecularformula,omitempty"`
	MolecularFormulaByMoiety *FhirString `json:"molecularformulabymoiety,omitempty"`
	MolecularWeight *SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
	Technique []*CodeableConcept `json:"technique,omitempty"`
	SourceDocument []*Reference `json:"sourcedocument,omitempty"`
	Representation []*SubstanceDefinitionRepresentation `json:"representation,omitempty"`
}

// NewSubstanceDefinitionStructure creates a new SubstanceDefinitionStructure instance.
func NewSubstanceDefinitionStructure() *SubstanceDefinitionStructure {
	return &SubstanceDefinitionStructure{}
}

// FromJSON populates SubstanceDefinitionStructure from JSON data.
func (m *SubstanceDefinitionStructure) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
		OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
		MolecularFormula *FhirString `json:"molecularformula,omitempty"`
		MolecularFormulaByMoiety *FhirString `json:"molecularformulabymoiety,omitempty"`
		MolecularWeight *SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
		Technique []*CodeableConcept `json:"technique,omitempty"`
		SourceDocument []*Reference `json:"sourcedocument,omitempty"`
		Representation []*SubstanceDefinitionRepresentation `json:"representation,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Stereochemistry = temp.Stereochemistry
	m.OpticalActivity = temp.OpticalActivity
	m.MolecularFormula = temp.MolecularFormula
	m.MolecularFormulaByMoiety = temp.MolecularFormulaByMoiety
	m.MolecularWeight = temp.MolecularWeight
	m.Technique = temp.Technique
	m.SourceDocument = temp.SourceDocument
	m.Representation = temp.Representation
	return nil
}

// ToJSON converts SubstanceDefinitionStructure to JSON data.
func (m *SubstanceDefinitionStructure) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
		OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
		MolecularFormula interface{} `json:"molecularformula,omitempty"`
		MolecularFormulaElement map[string]interface{} `json:"_molecularformula,omitempty"`
		MolecularFormulaByMoiety interface{} `json:"molecularformulabymoiety,omitempty"`
		MolecularFormulaByMoietyElement map[string]interface{} `json:"_molecularformulabymoiety,omitempty"`
		MolecularWeight *SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
		Technique []*CodeableConcept `json:"technique,omitempty"`
		SourceDocument []*Reference `json:"sourcedocument,omitempty"`
		Representation []*SubstanceDefinitionRepresentation `json:"representation,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Stereochemistry = m.Stereochemistry
	output.OpticalActivity = m.OpticalActivity
	if m.MolecularFormula != nil && m.MolecularFormula.Value != nil {
		output.MolecularFormula = m.MolecularFormula.Value
		if m.MolecularFormula.Element != nil {
			output.MolecularFormulaElement = toMapOrNil(m.MolecularFormula.Element.ToJSON())
		}
	}
	if m.MolecularFormulaByMoiety != nil && m.MolecularFormulaByMoiety.Value != nil {
		output.MolecularFormulaByMoiety = m.MolecularFormulaByMoiety.Value
		if m.MolecularFormulaByMoiety.Element != nil {
			output.MolecularFormulaByMoietyElement = toMapOrNil(m.MolecularFormulaByMoiety.Element.ToJSON())
		}
	}
	output.MolecularWeight = m.MolecularWeight
	output.Technique = m.Technique
	output.SourceDocument = m.SourceDocument
	output.Representation = m.Representation
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionStructure.
func (m *SubstanceDefinitionStructure) Clone() *SubstanceDefinitionStructure {
	if m == nil { return nil }
	return &SubstanceDefinitionStructure{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Stereochemistry: m.Stereochemistry.Clone(),
		OpticalActivity: m.OpticalActivity.Clone(),
		MolecularFormula: m.MolecularFormula.Clone(),
		MolecularFormulaByMoiety: m.MolecularFormulaByMoiety.Clone(),
		MolecularWeight: m.MolecularWeight.Clone(),
		Technique: cloneSlices(m.Technique),
		SourceDocument: cloneSlices(m.SourceDocument),
		Representation: cloneSlices(m.Representation),
	}
}

// Equals checks equality between two SubstanceDefinitionStructure instances.
func (m *SubstanceDefinitionStructure) Equals(other *SubstanceDefinitionStructure) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Stereochemistry.Equals(other.Stereochemistry) { return false }
	if !m.OpticalActivity.Equals(other.OpticalActivity) { return false }
	if !m.MolecularFormula.Equals(other.MolecularFormula) { return false }
	if !m.MolecularFormulaByMoiety.Equals(other.MolecularFormulaByMoiety) { return false }
	if !m.MolecularWeight.Equals(other.MolecularWeight) { return false }
	if !compareSlices(m.Technique, other.Technique) { return false }
	if !compareSlices(m.SourceDocument, other.SourceDocument) { return false }
	if !compareSlices(m.Representation, other.Representation) { return false }
	return true
}

// SubstanceDefinitionRepresentation
// A depiction of the structure or characterization of the substance.
type SubstanceDefinitionRepresentation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Representation *FhirString `json:"representation,omitempty"`
	Format *CodeableConcept `json:"format,omitempty"`
	Document *Reference `json:"document,omitempty"`
}

// NewSubstanceDefinitionRepresentation creates a new SubstanceDefinitionRepresentation instance.
func NewSubstanceDefinitionRepresentation() *SubstanceDefinitionRepresentation {
	return &SubstanceDefinitionRepresentation{}
}

// FromJSON populates SubstanceDefinitionRepresentation from JSON data.
func (m *SubstanceDefinitionRepresentation) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Representation *FhirString `json:"representation,omitempty"`
		Format *CodeableConcept `json:"format,omitempty"`
		Document *Reference `json:"document,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Representation = temp.Representation
	m.Format = temp.Format
	m.Document = temp.Document
	return nil
}

// ToJSON converts SubstanceDefinitionRepresentation to JSON data.
func (m *SubstanceDefinitionRepresentation) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Representation interface{} `json:"representation,omitempty"`
		RepresentationElement map[string]interface{} `json:"_representation,omitempty"`
		Format *CodeableConcept `json:"format,omitempty"`
		Document *Reference `json:"document,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	if m.Representation != nil && m.Representation.Value != nil {
		output.Representation = m.Representation.Value
		if m.Representation.Element != nil {
			output.RepresentationElement = toMapOrNil(m.Representation.Element.ToJSON())
		}
	}
	output.Format = m.Format
	output.Document = m.Document
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionRepresentation.
func (m *SubstanceDefinitionRepresentation) Clone() *SubstanceDefinitionRepresentation {
	if m == nil { return nil }
	return &SubstanceDefinitionRepresentation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Representation: m.Representation.Clone(),
		Format: m.Format.Clone(),
		Document: m.Document.Clone(),
	}
}

// Equals checks equality between two SubstanceDefinitionRepresentation instances.
func (m *SubstanceDefinitionRepresentation) Equals(other *SubstanceDefinitionRepresentation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Representation.Equals(other.Representation) { return false }
	if !m.Format.Equals(other.Format) { return false }
	if !m.Document.Equals(other.Document) { return false }
	return true
}

// SubstanceDefinitionCode
// Codes associated with the substance.
type SubstanceDefinitionCode struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	StatusDate *FhirDateTime `json:"statusdate,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Source []*Reference `json:"source,omitempty"`
}

// NewSubstanceDefinitionCode creates a new SubstanceDefinitionCode instance.
func NewSubstanceDefinitionCode() *SubstanceDefinitionCode {
	return &SubstanceDefinitionCode{}
}

// FromJSON populates SubstanceDefinitionCode from JSON data.
func (m *SubstanceDefinitionCode) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		StatusDate *FhirDateTime `json:"statusdate,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Source []*Reference `json:"source,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Code = temp.Code
	m.Status = temp.Status
	m.StatusDate = temp.StatusDate
	m.Note = temp.Note
	m.Source = temp.Source
	return nil
}

// ToJSON converts SubstanceDefinitionCode to JSON data.
func (m *SubstanceDefinitionCode) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Code *CodeableConcept `json:"code,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		StatusDate interface{} `json:"statusdate,omitempty"`
		StatusDateElement map[string]interface{} `json:"_statusdate,omitempty"`
		Note []*Annotation `json:"note,omitempty"`
		Source []*Reference `json:"source,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Code = m.Code
	output.Status = m.Status
	if m.StatusDate != nil && m.StatusDate.Value != nil {
		output.StatusDate = m.StatusDate.Value
		if m.StatusDate.Element != nil {
			output.StatusDateElement = toMapOrNil(m.StatusDate.Element.ToJSON())
		}
	}
	output.Note = m.Note
	output.Source = m.Source
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionCode.
func (m *SubstanceDefinitionCode) Clone() *SubstanceDefinitionCode {
	if m == nil { return nil }
	return &SubstanceDefinitionCode{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Status: m.Status.Clone(),
		StatusDate: m.StatusDate.Clone(),
		Note: cloneSlices(m.Note),
		Source: cloneSlices(m.Source),
	}
}

// Equals checks equality between two SubstanceDefinitionCode instances.
func (m *SubstanceDefinitionCode) Equals(other *SubstanceDefinitionCode) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.Source, other.Source) { return false }
	return true
}

// SubstanceDefinitionName
// Names applicable to this substance.
type SubstanceDefinitionName struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Preferred *FhirBoolean `json:"preferred,omitempty"`
	Language []*CodeableConcept `json:"language,omitempty"`
	Domain []*CodeableConcept `json:"domain,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Synonym []*SubstanceDefinitionName `json:"synonym,omitempty"`
	Translation []*SubstanceDefinitionName `json:"translation,omitempty"`
	Official []*SubstanceDefinitionOfficial `json:"official,omitempty"`
	Source []*Reference `json:"source,omitempty"`
}

// NewSubstanceDefinitionName creates a new SubstanceDefinitionName instance.
func NewSubstanceDefinitionName() *SubstanceDefinitionName {
	return &SubstanceDefinitionName{}
}

// FromJSON populates SubstanceDefinitionName from JSON data.
func (m *SubstanceDefinitionName) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name *FhirString `json:"name,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		Preferred *FhirBoolean `json:"preferred,omitempty"`
		Language []*CodeableConcept `json:"language,omitempty"`
		Domain []*CodeableConcept `json:"domain,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Synonym []*SubstanceDefinitionName `json:"synonym,omitempty"`
		Translation []*SubstanceDefinitionName `json:"translation,omitempty"`
		Official []*SubstanceDefinitionOfficial `json:"official,omitempty"`
		Source []*Reference `json:"source,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Name = temp.Name
	m.Type = temp.Type
	m.Status = temp.Status
	m.Preferred = temp.Preferred
	m.Language = temp.Language
	m.Domain = temp.Domain
	m.Jurisdiction = temp.Jurisdiction
	m.Synonym = temp.Synonym
	m.Translation = temp.Translation
	m.Official = temp.Official
	m.Source = temp.Source
	return nil
}

// ToJSON converts SubstanceDefinitionName to JSON data.
func (m *SubstanceDefinitionName) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Name interface{} `json:"name,omitempty"`
		NameElement map[string]interface{} `json:"_name,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		Preferred interface{} `json:"preferred,omitempty"`
		PreferredElement map[string]interface{} `json:"_preferred,omitempty"`
		Language []*CodeableConcept `json:"language,omitempty"`
		Domain []*CodeableConcept `json:"domain,omitempty"`
		Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
		Synonym []*SubstanceDefinitionName `json:"synonym,omitempty"`
		Translation []*SubstanceDefinitionName `json:"translation,omitempty"`
		Official []*SubstanceDefinitionOfficial `json:"official,omitempty"`
		Source []*Reference `json:"source,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	if m.Name != nil && m.Name.Value != nil {
		output.Name = m.Name.Value
		if m.Name.Element != nil {
			output.NameElement = toMapOrNil(m.Name.Element.ToJSON())
		}
	}
	output.Type = m.Type
	output.Status = m.Status
	if m.Preferred != nil && m.Preferred.Value != nil {
		output.Preferred = m.Preferred.Value
		if m.Preferred.Element != nil {
			output.PreferredElement = toMapOrNil(m.Preferred.Element.ToJSON())
		}
	}
	output.Language = m.Language
	output.Domain = m.Domain
	output.Jurisdiction = m.Jurisdiction
	output.Synonym = m.Synonym
	output.Translation = m.Translation
	output.Official = m.Official
	output.Source = m.Source
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionName.
func (m *SubstanceDefinitionName) Clone() *SubstanceDefinitionName {
	if m == nil { return nil }
	return &SubstanceDefinitionName{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
		Status: m.Status.Clone(),
		Preferred: m.Preferred.Clone(),
		Language: cloneSlices(m.Language),
		Domain: cloneSlices(m.Domain),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Synonym: cloneSlices(m.Synonym),
		Translation: cloneSlices(m.Translation),
		Official: cloneSlices(m.Official),
		Source: cloneSlices(m.Source),
	}
}

// Equals checks equality between two SubstanceDefinitionName instances.
func (m *SubstanceDefinitionName) Equals(other *SubstanceDefinitionName) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Preferred.Equals(other.Preferred) { return false }
	if !compareSlices(m.Language, other.Language) { return false }
	if !compareSlices(m.Domain, other.Domain) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !compareSlices(m.Synonym, other.Synonym) { return false }
	if !compareSlices(m.Translation, other.Translation) { return false }
	if !compareSlices(m.Official, other.Official) { return false }
	if !compareSlices(m.Source, other.Source) { return false }
	return true
}

// SubstanceDefinitionOfficial
// Details of the official nature of this name.
type SubstanceDefinitionOfficial struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Authority *CodeableConcept `json:"authority,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
}

// NewSubstanceDefinitionOfficial creates a new SubstanceDefinitionOfficial instance.
func NewSubstanceDefinitionOfficial() *SubstanceDefinitionOfficial {
	return &SubstanceDefinitionOfficial{}
}

// FromJSON populates SubstanceDefinitionOfficial from JSON data.
func (m *SubstanceDefinitionOfficial) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Authority *CodeableConcept `json:"authority,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		Date *FhirDateTime `json:"date,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Authority = temp.Authority
	m.Status = temp.Status
	m.Date = temp.Date
	return nil
}

// ToJSON converts SubstanceDefinitionOfficial to JSON data.
func (m *SubstanceDefinitionOfficial) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Authority *CodeableConcept `json:"authority,omitempty"`
		Status *CodeableConcept `json:"status,omitempty"`
		Date interface{} `json:"date,omitempty"`
		DateElement map[string]interface{} `json:"_date,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Authority = m.Authority
	output.Status = m.Status
	if m.Date != nil && m.Date.Value != nil {
		output.Date = m.Date.Value
		if m.Date.Element != nil {
			output.DateElement = toMapOrNil(m.Date.Element.ToJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionOfficial.
func (m *SubstanceDefinitionOfficial) Clone() *SubstanceDefinitionOfficial {
	if m == nil { return nil }
	return &SubstanceDefinitionOfficial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Authority: m.Authority.Clone(),
		Status: m.Status.Clone(),
		Date: m.Date.Clone(),
	}
}

// Equals checks equality between two SubstanceDefinitionOfficial instances.
func (m *SubstanceDefinitionOfficial) Equals(other *SubstanceDefinitionOfficial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Authority.Equals(other.Authority) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Date.Equals(other.Date) { return false }
	return true
}

// SubstanceDefinitionRelationship
// A link between this substance and another, with details of the relationship.
type SubstanceDefinitionRelationship struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	SubstanceDefinitionReference *Reference `json:"substancedefinitionreference,omitempty"`
	SubstanceDefinitionCodeableConcept *CodeableConcept `json:"substancedefinitioncodeableconcept,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	IsDefining *FhirBoolean `json:"isdefining,omitempty"`
	AmountQuantity *Quantity `json:"amountquantity,omitempty"`
	AmountRatio *Ratio `json:"amountratio,omitempty"`
	AmountString *FhirString `json:"amountstring,omitempty"`
	RatioHighLimitAmount *Ratio `json:"ratiohighlimitamount,omitempty"`
	Comparator *CodeableConcept `json:"comparator,omitempty"`
	Source []*Reference `json:"source,omitempty"`
}

// NewSubstanceDefinitionRelationship creates a new SubstanceDefinitionRelationship instance.
func NewSubstanceDefinitionRelationship() *SubstanceDefinitionRelationship {
	return &SubstanceDefinitionRelationship{}
}

// FromJSON populates SubstanceDefinitionRelationship from JSON data.
func (m *SubstanceDefinitionRelationship) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		SubstanceDefinitionReference *Reference `json:"substancedefinitionreference,omitempty"`
		SubstanceDefinitionCodeableConcept *CodeableConcept `json:"substancedefinitioncodeableconcept,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		IsDefining *FhirBoolean `json:"isdefining,omitempty"`
		AmountQuantity *Quantity `json:"amountquantity,omitempty"`
		AmountRatio *Ratio `json:"amountratio,omitempty"`
		AmountString *FhirString `json:"amountstring,omitempty"`
		RatioHighLimitAmount *Ratio `json:"ratiohighlimitamount,omitempty"`
		Comparator *CodeableConcept `json:"comparator,omitempty"`
		Source []*Reference `json:"source,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.SubstanceDefinitionReference = temp.SubstanceDefinitionReference
	m.SubstanceDefinitionCodeableConcept = temp.SubstanceDefinitionCodeableConcept
	m.Type = temp.Type
	m.IsDefining = temp.IsDefining
	m.AmountQuantity = temp.AmountQuantity
	m.AmountRatio = temp.AmountRatio
	m.AmountString = temp.AmountString
	m.RatioHighLimitAmount = temp.RatioHighLimitAmount
	m.Comparator = temp.Comparator
	m.Source = temp.Source
	return nil
}

// ToJSON converts SubstanceDefinitionRelationship to JSON data.
func (m *SubstanceDefinitionRelationship) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		SubstanceDefinitionReference *Reference `json:"substancedefinitionreference,omitempty"`
		SubstanceDefinitionCodeableConcept *CodeableConcept `json:"substancedefinitioncodeableconcept,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		IsDefining interface{} `json:"isdefining,omitempty"`
		IsDefiningElement map[string]interface{} `json:"_isdefining,omitempty"`
		AmountQuantity *Quantity `json:"amountquantity,omitempty"`
		AmountRatio *Ratio `json:"amountratio,omitempty"`
		AmountString interface{} `json:"amountstring,omitempty"`
		AmountStringElement map[string]interface{} `json:"_amountstring,omitempty"`
		RatioHighLimitAmount *Ratio `json:"ratiohighlimitamount,omitempty"`
		Comparator *CodeableConcept `json:"comparator,omitempty"`
		Source []*Reference `json:"source,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.SubstanceDefinitionReference = m.SubstanceDefinitionReference
	output.SubstanceDefinitionCodeableConcept = m.SubstanceDefinitionCodeableConcept
	output.Type = m.Type
	if m.IsDefining != nil && m.IsDefining.Value != nil {
		output.IsDefining = m.IsDefining.Value
		if m.IsDefining.Element != nil {
			output.IsDefiningElement = toMapOrNil(m.IsDefining.Element.ToJSON())
		}
	}
	output.AmountQuantity = m.AmountQuantity
	output.AmountRatio = m.AmountRatio
	if m.AmountString != nil && m.AmountString.Value != nil {
		output.AmountString = m.AmountString.Value
		if m.AmountString.Element != nil {
			output.AmountStringElement = toMapOrNil(m.AmountString.Element.ToJSON())
		}
	}
	output.RatioHighLimitAmount = m.RatioHighLimitAmount
	output.Comparator = m.Comparator
	output.Source = m.Source
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionRelationship.
func (m *SubstanceDefinitionRelationship) Clone() *SubstanceDefinitionRelationship {
	if m == nil { return nil }
	return &SubstanceDefinitionRelationship{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		SubstanceDefinitionReference: m.SubstanceDefinitionReference.Clone(),
		SubstanceDefinitionCodeableConcept: m.SubstanceDefinitionCodeableConcept.Clone(),
		Type: m.Type.Clone(),
		IsDefining: m.IsDefining.Clone(),
		AmountQuantity: m.AmountQuantity.Clone(),
		AmountRatio: m.AmountRatio.Clone(),
		AmountString: m.AmountString.Clone(),
		RatioHighLimitAmount: m.RatioHighLimitAmount.Clone(),
		Comparator: m.Comparator.Clone(),
		Source: cloneSlices(m.Source),
	}
}

// Equals checks equality between two SubstanceDefinitionRelationship instances.
func (m *SubstanceDefinitionRelationship) Equals(other *SubstanceDefinitionRelationship) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.SubstanceDefinitionReference.Equals(other.SubstanceDefinitionReference) { return false }
	if !m.SubstanceDefinitionCodeableConcept.Equals(other.SubstanceDefinitionCodeableConcept) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.IsDefining.Equals(other.IsDefining) { return false }
	if !m.AmountQuantity.Equals(other.AmountQuantity) { return false }
	if !m.AmountRatio.Equals(other.AmountRatio) { return false }
	if !m.AmountString.Equals(other.AmountString) { return false }
	if !m.RatioHighLimitAmount.Equals(other.RatioHighLimitAmount) { return false }
	if !m.Comparator.Equals(other.Comparator) { return false }
	if !compareSlices(m.Source, other.Source) { return false }
	return true
}

// SubstanceDefinitionSourceMaterial
// Material or taxonomic/anatomical source for the substance.
type SubstanceDefinitionSourceMaterial struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Genus *CodeableConcept `json:"genus,omitempty"`
	Species *CodeableConcept `json:"species,omitempty"`
	Part_ *CodeableConcept `json:"part,omitempty"`
	CountryOfOrigin []*CodeableConcept `json:"countryoforigin,omitempty"`
}

// NewSubstanceDefinitionSourceMaterial creates a new SubstanceDefinitionSourceMaterial instance.
func NewSubstanceDefinitionSourceMaterial() *SubstanceDefinitionSourceMaterial {
	return &SubstanceDefinitionSourceMaterial{}
}

// FromJSON populates SubstanceDefinitionSourceMaterial from JSON data.
func (m *SubstanceDefinitionSourceMaterial) FromJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Genus *CodeableConcept `json:"genus,omitempty"`
		Species *CodeableConcept `json:"species,omitempty"`
		Part_ *CodeableConcept `json:"part,omitempty"`
		CountryOfOrigin []*CodeableConcept `json:"countryoforigin,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Genus = temp.Genus
	m.Species = temp.Species
	m.Part_ = temp.Part_
	m.CountryOfOrigin = temp.CountryOfOrigin
	return nil
}

// ToJSON converts SubstanceDefinitionSourceMaterial to JSON data.
func (m *SubstanceDefinitionSourceMaterial) ToJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type *CodeableConcept `json:"type,omitempty"`
		Genus *CodeableConcept `json:"genus,omitempty"`
		Species *CodeableConcept `json:"species,omitempty"`
		Part_ *CodeableConcept `json:"part,omitempty"`
		CountryOfOrigin []*CodeableConcept `json:"countryoforigin,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.ToJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Genus = m.Genus
	output.Species = m.Species
	output.Part_ = m.Part_
	output.CountryOfOrigin = m.CountryOfOrigin
	return json.Marshal(output)
}

// Clone creates a deep copy of SubstanceDefinitionSourceMaterial.
func (m *SubstanceDefinitionSourceMaterial) Clone() *SubstanceDefinitionSourceMaterial {
	if m == nil { return nil }
	return &SubstanceDefinitionSourceMaterial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Genus: m.Genus.Clone(),
		Species: m.Species.Clone(),
		Part_: m.Part_.Clone(),
		CountryOfOrigin: cloneSlices(m.CountryOfOrigin),
	}
}

// Equals checks equality between two SubstanceDefinitionSourceMaterial instances.
func (m *SubstanceDefinitionSourceMaterial) Equals(other *SubstanceDefinitionSourceMaterial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Genus.Equals(other.Genus) { return false }
	if !m.Species.Equals(other.Species) { return false }
	if !m.Part_.Equals(other.Part_) { return false }
	if !compareSlices(m.CountryOfOrigin, other.CountryOfOrigin) { return false }
	return true
}

