// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// SubstanceDefinition
// The detailed description of a substance, typically at a level beyond what is used for prescribing.
type SubstanceDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Classification []*CodeableConcept `json:"classification,omitempty"`
	Domain *CodeableConcept `json:"domain,omitempty"`
	Grade []*CodeableConcept `json:"grade,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	InformationSource []*Reference `json:"informationsource,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Manufacturer []*Reference `json:"manufacturer,omitempty"`
	Supplier []*Reference `json:"supplier,omitempty"`
	Moiety []*SubstanceDefinitionMoiety `json:"moiety,omitempty"`
	Property []*SubstanceDefinitionProperty `json:"property,omitempty"`
	MolecularWeight []*SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
	Structure *SubstanceDefinitionStructure `json:"structure,omitempty"`
	Code []*SubstanceDefinitionCode `json:"code,omitempty"`
	Name []*SubstanceDefinitionName `json:"name,omitempty"`
	Relationship []*SubstanceDefinitionRelationship `json:"relationship,omitempty"`
	SourceMaterial *SubstanceDefinitionSourceMaterial `json:"sourcematerial,omitempty"`
}

// NewSubstanceDefinition creates a new SubstanceDefinition instance
func NewSubstanceDefinition() *SubstanceDefinition {
	return &SubstanceDefinition{}
}

// FromJSON populates SubstanceDefinition from JSON data
func (m *SubstanceDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinition to JSON data
func (m *SubstanceDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinition
func (m *SubstanceDefinition) Clone() *SubstanceDefinition {
	if m == nil { return nil }
	return &SubstanceDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Status: m.Status.Clone(),
		Classification: cloneSlices(m.Classification),
		Domain: m.Domain.Clone(),
		Grade: cloneSlices(m.Grade),
		Description: m.Description.Clone(),
		InformationSource: cloneSlices(m.InformationSource),
		Note: cloneSlices(m.Note),
		Manufacturer: cloneSlices(m.Manufacturer),
		Supplier: cloneSlices(m.Supplier),
		Moiety: cloneSlices(m.Moiety),
		Property: cloneSlices(m.Property),
		MolecularWeight: cloneSlices(m.MolecularWeight),
		Structure: m.Structure.Clone(),
		Code: cloneSlices(m.Code),
		Name: cloneSlices(m.Name),
		Relationship: cloneSlices(m.Relationship),
		SourceMaterial: m.SourceMaterial.Clone(),
	}
}

// Equals checks for equality with another SubstanceDefinition instance
func (m *SubstanceDefinition) Equals(other *SubstanceDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	if !m.Domain.Equals(other.Domain) { return false }
	if !compareSlices(m.Grade, other.Grade) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.InformationSource, other.InformationSource) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.Manufacturer, other.Manufacturer) { return false }
	if !compareSlices(m.Supplier, other.Supplier) { return false }
	if !compareSlices(m.Moiety, other.Moiety) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !compareSlices(m.MolecularWeight, other.MolecularWeight) { return false }
	if !m.Structure.Equals(other.Structure) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Name, other.Name) { return false }
	if !compareSlices(m.Relationship, other.Relationship) { return false }
	if !m.SourceMaterial.Equals(other.SourceMaterial) { return false }
	return true
}

// SubstanceDefinitionMoiety
// Moiety, for structural modifications.
type SubstanceDefinitionMoiety struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
	MolecularFormula *FhirString `json:"molecularformula,omitempty"`
	AmountQuantity *Quantity `json:"amountquantity,omitempty"`
	AmountString *FhirString `json:"amountstring,omitempty"`
	MeasurementType *CodeableConcept `json:"measurementtype,omitempty"`
}

// NewSubstanceDefinitionMoiety creates a new SubstanceDefinitionMoiety instance
func NewSubstanceDefinitionMoiety() *SubstanceDefinitionMoiety {
	return &SubstanceDefinitionMoiety{}
}

// FromJSON populates SubstanceDefinitionMoiety from JSON data
func (m *SubstanceDefinitionMoiety) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionMoiety to JSON data
func (m *SubstanceDefinitionMoiety) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionMoiety
func (m *SubstanceDefinitionMoiety) Clone() *SubstanceDefinitionMoiety {
	if m == nil { return nil }
	return &SubstanceDefinitionMoiety{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Role: m.Role.Clone(),
		Identifier: m.Identifier.Clone(),
		Name: m.Name.Clone(),
		Stereochemistry: m.Stereochemistry.Clone(),
		OpticalActivity: m.OpticalActivity.Clone(),
		MolecularFormula: m.MolecularFormula.Clone(),
		AmountQuantity: m.AmountQuantity.Clone(),
		AmountString: m.AmountString.Clone(),
		MeasurementType: m.MeasurementType.Clone(),
	}
}

// Equals checks for equality with another SubstanceDefinitionMoiety instance
func (m *SubstanceDefinitionMoiety) Equals(other *SubstanceDefinitionMoiety) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Stereochemistry.Equals(other.Stereochemistry) { return false }
	if !m.OpticalActivity.Equals(other.OpticalActivity) { return false }
	if !m.MolecularFormula.Equals(other.MolecularFormula) { return false }
	if !m.AmountQuantity.Equals(other.AmountQuantity) { return false }
	if !m.AmountString.Equals(other.AmountString) { return false }
	if !m.MeasurementType.Equals(other.MeasurementType) { return false }
	return true
}

// SubstanceDefinitionProperty
// General specifications for this substance.
type SubstanceDefinitionProperty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
}

// NewSubstanceDefinitionProperty creates a new SubstanceDefinitionProperty instance
func NewSubstanceDefinitionProperty() *SubstanceDefinitionProperty {
	return &SubstanceDefinitionProperty{}
}

// FromJSON populates SubstanceDefinitionProperty from JSON data
func (m *SubstanceDefinitionProperty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionProperty to JSON data
func (m *SubstanceDefinitionProperty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionProperty
func (m *SubstanceDefinitionProperty) Clone() *SubstanceDefinitionProperty {
	if m == nil { return nil }
	return &SubstanceDefinitionProperty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
	}
}

// Equals checks for equality with another SubstanceDefinitionProperty instance
func (m *SubstanceDefinitionProperty) Equals(other *SubstanceDefinitionProperty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	return true
}

// SubstanceDefinitionMolecularWeight
// The molecular weight or weight range (for proteins, polymers or nucleic acids).
type SubstanceDefinitionMolecularWeight struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Amount *Quantity `json:"amount,omitempty"`
}

// NewSubstanceDefinitionMolecularWeight creates a new SubstanceDefinitionMolecularWeight instance
func NewSubstanceDefinitionMolecularWeight() *SubstanceDefinitionMolecularWeight {
	return &SubstanceDefinitionMolecularWeight{}
}

// FromJSON populates SubstanceDefinitionMolecularWeight from JSON data
func (m *SubstanceDefinitionMolecularWeight) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionMolecularWeight to JSON data
func (m *SubstanceDefinitionMolecularWeight) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionMolecularWeight
func (m *SubstanceDefinitionMolecularWeight) Clone() *SubstanceDefinitionMolecularWeight {
	if m == nil { return nil }
	return &SubstanceDefinitionMolecularWeight{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Method: m.Method.Clone(),
		Type: m.Type.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks for equality with another SubstanceDefinitionMolecularWeight instance
func (m *SubstanceDefinitionMolecularWeight) Equals(other *SubstanceDefinitionMolecularWeight) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

// SubstanceDefinitionStructure
// Structural information.
type SubstanceDefinitionStructure struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	OpticalActivity *CodeableConcept `json:"opticalactivity,omitempty"`
	MolecularFormula *FhirString `json:"molecularformula,omitempty"`
	MolecularFormulaByMoiety *FhirString `json:"molecularformulabymoiety,omitempty"`
	MolecularWeight *SubstanceDefinitionMolecularWeight `json:"molecularweight,omitempty"`
	Technique []*CodeableConcept `json:"technique,omitempty"`
	SourceDocument []*Reference `json:"sourcedocument,omitempty"`
	Representation []*SubstanceDefinitionRepresentation `json:"representation,omitempty"`
}

// NewSubstanceDefinitionStructure creates a new SubstanceDefinitionStructure instance
func NewSubstanceDefinitionStructure() *SubstanceDefinitionStructure {
	return &SubstanceDefinitionStructure{}
}

// FromJSON populates SubstanceDefinitionStructure from JSON data
func (m *SubstanceDefinitionStructure) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionStructure to JSON data
func (m *SubstanceDefinitionStructure) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionStructure
func (m *SubstanceDefinitionStructure) Clone() *SubstanceDefinitionStructure {
	if m == nil { return nil }
	return &SubstanceDefinitionStructure{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Stereochemistry: m.Stereochemistry.Clone(),
		OpticalActivity: m.OpticalActivity.Clone(),
		MolecularFormula: m.MolecularFormula.Clone(),
		MolecularFormulaByMoiety: m.MolecularFormulaByMoiety.Clone(),
		MolecularWeight: m.MolecularWeight.Clone(),
		Technique: cloneSlices(m.Technique),
		SourceDocument: cloneSlices(m.SourceDocument),
		Representation: cloneSlices(m.Representation),
	}
}

// Equals checks for equality with another SubstanceDefinitionStructure instance
func (m *SubstanceDefinitionStructure) Equals(other *SubstanceDefinitionStructure) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Stereochemistry.Equals(other.Stereochemistry) { return false }
	if !m.OpticalActivity.Equals(other.OpticalActivity) { return false }
	if !m.MolecularFormula.Equals(other.MolecularFormula) { return false }
	if !m.MolecularFormulaByMoiety.Equals(other.MolecularFormulaByMoiety) { return false }
	if !m.MolecularWeight.Equals(other.MolecularWeight) { return false }
	if !compareSlices(m.Technique, other.Technique) { return false }
	if !compareSlices(m.SourceDocument, other.SourceDocument) { return false }
	if !compareSlices(m.Representation, other.Representation) { return false }
	return true
}

// SubstanceDefinitionRepresentation
// A depiction of the structure or characterization of the substance.
type SubstanceDefinitionRepresentation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Representation *FhirString `json:"representation,omitempty"`
	Format *CodeableConcept `json:"format,omitempty"`
	Document *Reference `json:"document,omitempty"`
}

// NewSubstanceDefinitionRepresentation creates a new SubstanceDefinitionRepresentation instance
func NewSubstanceDefinitionRepresentation() *SubstanceDefinitionRepresentation {
	return &SubstanceDefinitionRepresentation{}
}

// FromJSON populates SubstanceDefinitionRepresentation from JSON data
func (m *SubstanceDefinitionRepresentation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionRepresentation to JSON data
func (m *SubstanceDefinitionRepresentation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionRepresentation
func (m *SubstanceDefinitionRepresentation) Clone() *SubstanceDefinitionRepresentation {
	if m == nil { return nil }
	return &SubstanceDefinitionRepresentation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Representation: m.Representation.Clone(),
		Format: m.Format.Clone(),
		Document: m.Document.Clone(),
	}
}

// Equals checks for equality with another SubstanceDefinitionRepresentation instance
func (m *SubstanceDefinitionRepresentation) Equals(other *SubstanceDefinitionRepresentation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Representation.Equals(other.Representation) { return false }
	if !m.Format.Equals(other.Format) { return false }
	if !m.Document.Equals(other.Document) { return false }
	return true
}

// SubstanceDefinitionCode
// Codes associated with the substance.
type SubstanceDefinitionCode struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	StatusDate *FhirDateTime `json:"statusdate,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Source []*Reference `json:"source,omitempty"`
}

// NewSubstanceDefinitionCode creates a new SubstanceDefinitionCode instance
func NewSubstanceDefinitionCode() *SubstanceDefinitionCode {
	return &SubstanceDefinitionCode{}
}

// FromJSON populates SubstanceDefinitionCode from JSON data
func (m *SubstanceDefinitionCode) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionCode to JSON data
func (m *SubstanceDefinitionCode) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionCode
func (m *SubstanceDefinitionCode) Clone() *SubstanceDefinitionCode {
	if m == nil { return nil }
	return &SubstanceDefinitionCode{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Status: m.Status.Clone(),
		StatusDate: m.StatusDate.Clone(),
		Note: cloneSlices(m.Note),
		Source: cloneSlices(m.Source),
	}
}

// Equals checks for equality with another SubstanceDefinitionCode instance
func (m *SubstanceDefinitionCode) Equals(other *SubstanceDefinitionCode) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.Source, other.Source) { return false }
	return true
}

// SubstanceDefinitionName
// Names applicable to this substance.
type SubstanceDefinitionName struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Preferred *FhirBoolean `json:"preferred,omitempty"`
	Language []*CodeableConcept `json:"language,omitempty"`
	Domain []*CodeableConcept `json:"domain,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Synonym []*SubstanceDefinitionName `json:"synonym,omitempty"`
	Translation []*SubstanceDefinitionName `json:"translation,omitempty"`
	Official []*SubstanceDefinitionOfficial `json:"official,omitempty"`
	Source []*Reference `json:"source,omitempty"`
}

// NewSubstanceDefinitionName creates a new SubstanceDefinitionName instance
func NewSubstanceDefinitionName() *SubstanceDefinitionName {
	return &SubstanceDefinitionName{}
}

// FromJSON populates SubstanceDefinitionName from JSON data
func (m *SubstanceDefinitionName) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionName to JSON data
func (m *SubstanceDefinitionName) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionName
func (m *SubstanceDefinitionName) Clone() *SubstanceDefinitionName {
	if m == nil { return nil }
	return &SubstanceDefinitionName{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
		Status: m.Status.Clone(),
		Preferred: m.Preferred.Clone(),
		Language: cloneSlices(m.Language),
		Domain: cloneSlices(m.Domain),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Synonym: cloneSlices(m.Synonym),
		Translation: cloneSlices(m.Translation),
		Official: cloneSlices(m.Official),
		Source: cloneSlices(m.Source),
	}
}

// Equals checks for equality with another SubstanceDefinitionName instance
func (m *SubstanceDefinitionName) Equals(other *SubstanceDefinitionName) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Preferred.Equals(other.Preferred) { return false }
	if !compareSlices(m.Language, other.Language) { return false }
	if !compareSlices(m.Domain, other.Domain) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !compareSlices(m.Synonym, other.Synonym) { return false }
	if !compareSlices(m.Translation, other.Translation) { return false }
	if !compareSlices(m.Official, other.Official) { return false }
	if !compareSlices(m.Source, other.Source) { return false }
	return true
}

// SubstanceDefinitionOfficial
// Details of the official nature of this name.
type SubstanceDefinitionOfficial struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Authority *CodeableConcept `json:"authority,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
}

// NewSubstanceDefinitionOfficial creates a new SubstanceDefinitionOfficial instance
func NewSubstanceDefinitionOfficial() *SubstanceDefinitionOfficial {
	return &SubstanceDefinitionOfficial{}
}

// FromJSON populates SubstanceDefinitionOfficial from JSON data
func (m *SubstanceDefinitionOfficial) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionOfficial to JSON data
func (m *SubstanceDefinitionOfficial) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionOfficial
func (m *SubstanceDefinitionOfficial) Clone() *SubstanceDefinitionOfficial {
	if m == nil { return nil }
	return &SubstanceDefinitionOfficial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Authority: m.Authority.Clone(),
		Status: m.Status.Clone(),
		Date: m.Date.Clone(),
	}
}

// Equals checks for equality with another SubstanceDefinitionOfficial instance
func (m *SubstanceDefinitionOfficial) Equals(other *SubstanceDefinitionOfficial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Authority.Equals(other.Authority) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Date.Equals(other.Date) { return false }
	return true
}

// SubstanceDefinitionRelationship
// A link between this substance and another, with details of the relationship.
type SubstanceDefinitionRelationship struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	SubstanceDefinitionReference *Reference `json:"substancedefinitionreference,omitempty"`
	SubstanceDefinitionCodeableConcept *CodeableConcept `json:"substancedefinitioncodeableconcept,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	IsDefining *FhirBoolean `json:"isdefining,omitempty"`
	AmountQuantity *Quantity `json:"amountquantity,omitempty"`
	AmountRatio *Ratio `json:"amountratio,omitempty"`
	AmountString *FhirString `json:"amountstring,omitempty"`
	RatioHighLimitAmount *Ratio `json:"ratiohighlimitamount,omitempty"`
	Comparator *CodeableConcept `json:"comparator,omitempty"`
	Source []*Reference `json:"source,omitempty"`
}

// NewSubstanceDefinitionRelationship creates a new SubstanceDefinitionRelationship instance
func NewSubstanceDefinitionRelationship() *SubstanceDefinitionRelationship {
	return &SubstanceDefinitionRelationship{}
}

// FromJSON populates SubstanceDefinitionRelationship from JSON data
func (m *SubstanceDefinitionRelationship) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionRelationship to JSON data
func (m *SubstanceDefinitionRelationship) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionRelationship
func (m *SubstanceDefinitionRelationship) Clone() *SubstanceDefinitionRelationship {
	if m == nil { return nil }
	return &SubstanceDefinitionRelationship{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		SubstanceDefinitionReference: m.SubstanceDefinitionReference.Clone(),
		SubstanceDefinitionCodeableConcept: m.SubstanceDefinitionCodeableConcept.Clone(),
		Type: m.Type.Clone(),
		IsDefining: m.IsDefining.Clone(),
		AmountQuantity: m.AmountQuantity.Clone(),
		AmountRatio: m.AmountRatio.Clone(),
		AmountString: m.AmountString.Clone(),
		RatioHighLimitAmount: m.RatioHighLimitAmount.Clone(),
		Comparator: m.Comparator.Clone(),
		Source: cloneSlices(m.Source),
	}
}

// Equals checks for equality with another SubstanceDefinitionRelationship instance
func (m *SubstanceDefinitionRelationship) Equals(other *SubstanceDefinitionRelationship) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.SubstanceDefinitionReference.Equals(other.SubstanceDefinitionReference) { return false }
	if !m.SubstanceDefinitionCodeableConcept.Equals(other.SubstanceDefinitionCodeableConcept) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.IsDefining.Equals(other.IsDefining) { return false }
	if !m.AmountQuantity.Equals(other.AmountQuantity) { return false }
	if !m.AmountRatio.Equals(other.AmountRatio) { return false }
	if !m.AmountString.Equals(other.AmountString) { return false }
	if !m.RatioHighLimitAmount.Equals(other.RatioHighLimitAmount) { return false }
	if !m.Comparator.Equals(other.Comparator) { return false }
	if !compareSlices(m.Source, other.Source) { return false }
	return true
}

// SubstanceDefinitionSourceMaterial
// Material or taxonomic/anatomical source for the substance.
type SubstanceDefinitionSourceMaterial struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Genus *CodeableConcept `json:"genus,omitempty"`
	Species *CodeableConcept `json:"species,omitempty"`
	Part_ *CodeableConcept `json:"part,omitempty"`
	CountryOfOrigin []*CodeableConcept `json:"countryoforigin,omitempty"`
}

// NewSubstanceDefinitionSourceMaterial creates a new SubstanceDefinitionSourceMaterial instance
func NewSubstanceDefinitionSourceMaterial() *SubstanceDefinitionSourceMaterial {
	return &SubstanceDefinitionSourceMaterial{}
}

// FromJSON populates SubstanceDefinitionSourceMaterial from JSON data
func (m *SubstanceDefinitionSourceMaterial) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SubstanceDefinitionSourceMaterial to JSON data
func (m *SubstanceDefinitionSourceMaterial) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of SubstanceDefinitionSourceMaterial
func (m *SubstanceDefinitionSourceMaterial) Clone() *SubstanceDefinitionSourceMaterial {
	if m == nil { return nil }
	return &SubstanceDefinitionSourceMaterial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Genus: m.Genus.Clone(),
		Species: m.Species.Clone(),
		Part_: m.Part_.Clone(),
		CountryOfOrigin: cloneSlices(m.CountryOfOrigin),
	}
}

// Equals checks for equality with another SubstanceDefinitionSourceMaterial instance
func (m *SubstanceDefinitionSourceMaterial) Equals(other *SubstanceDefinitionSourceMaterial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Genus.Equals(other.Genus) { return false }
	if !m.Species.Equals(other.Species) { return false }
	if !m.Part_.Equals(other.Part_) { return false }
	if !compareSlices(m.CountryOfOrigin, other.CountryOfOrigin) { return false }
	return true
}

