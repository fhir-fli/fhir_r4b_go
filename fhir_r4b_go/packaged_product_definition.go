// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// PackagedProductDefinition
// A medically related item or items, in a container or package.
type PackagedProductDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	PackageFor []*Reference `json:"packagefor,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	StatusDate *FhirDateTime `json:"statusdate,omitempty"`
	ContainedItemQuantity []*Quantity `json:"containeditemquantity,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	LegalStatusOfSupply []*PackagedProductDefinitionLegalStatusOfSupply `json:"legalstatusofsupply,omitempty"`
	MarketingStatus []*MarketingStatus `json:"marketingstatus,omitempty"`
	Characteristic []*CodeableConcept `json:"characteristic,omitempty"`
	CopackagedIndicator *FhirBoolean `json:"copackagedindicator,omitempty"`
	Manufacturer []*Reference `json:"manufacturer,omitempty"`
	Package *PackagedProductDefinitionPackage `json:"package,omitempty"`
}

// NewPackagedProductDefinition creates a new PackagedProductDefinition instance
func NewPackagedProductDefinition() *PackagedProductDefinition {
	return &PackagedProductDefinition{}
}

// FromJSON populates PackagedProductDefinition from JSON data
func (m *PackagedProductDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts PackagedProductDefinition to JSON data
func (m *PackagedProductDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of PackagedProductDefinition
func (m *PackagedProductDefinition) Clone() *PackagedProductDefinition {
	if m == nil { return nil }
	return &PackagedProductDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
		PackageFor: cloneSlices(m.PackageFor),
		Status: m.Status.Clone(),
		StatusDate: m.StatusDate.Clone(),
		ContainedItemQuantity: cloneSlices(m.ContainedItemQuantity),
		Description: m.Description.Clone(),
		LegalStatusOfSupply: cloneSlices(m.LegalStatusOfSupply),
		MarketingStatus: cloneSlices(m.MarketingStatus),
		Characteristic: cloneSlices(m.Characteristic),
		CopackagedIndicator: m.CopackagedIndicator.Clone(),
		Manufacturer: cloneSlices(m.Manufacturer),
		Package: m.Package.Clone(),
	}
}

// Equals checks for equality with another PackagedProductDefinition instance
func (m *PackagedProductDefinition) Equals(other *PackagedProductDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.PackageFor, other.PackageFor) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !compareSlices(m.ContainedItemQuantity, other.ContainedItemQuantity) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.LegalStatusOfSupply, other.LegalStatusOfSupply) { return false }
	if !compareSlices(m.MarketingStatus, other.MarketingStatus) { return false }
	if !compareSlices(m.Characteristic, other.Characteristic) { return false }
	if !m.CopackagedIndicator.Equals(other.CopackagedIndicator) { return false }
	if !compareSlices(m.Manufacturer, other.Manufacturer) { return false }
	if !m.Package.Equals(other.Package) { return false }
	return true
}

// PackagedProductDefinitionLegalStatusOfSupply
// The legal status of supply of the packaged item as classified by the regulator.
type PackagedProductDefinitionLegalStatusOfSupply struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`
}

// NewPackagedProductDefinitionLegalStatusOfSupply creates a new PackagedProductDefinitionLegalStatusOfSupply instance
func NewPackagedProductDefinitionLegalStatusOfSupply() *PackagedProductDefinitionLegalStatusOfSupply {
	return &PackagedProductDefinitionLegalStatusOfSupply{}
}

// FromJSON populates PackagedProductDefinitionLegalStatusOfSupply from JSON data
func (m *PackagedProductDefinitionLegalStatusOfSupply) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts PackagedProductDefinitionLegalStatusOfSupply to JSON data
func (m *PackagedProductDefinitionLegalStatusOfSupply) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of PackagedProductDefinitionLegalStatusOfSupply
func (m *PackagedProductDefinitionLegalStatusOfSupply) Clone() *PackagedProductDefinitionLegalStatusOfSupply {
	if m == nil { return nil }
	return &PackagedProductDefinitionLegalStatusOfSupply{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Jurisdiction: m.Jurisdiction.Clone(),
	}
}

// Equals checks for equality with another PackagedProductDefinitionLegalStatusOfSupply instance
func (m *PackagedProductDefinitionLegalStatusOfSupply) Equals(other *PackagedProductDefinitionLegalStatusOfSupply) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Jurisdiction.Equals(other.Jurisdiction) { return false }
	return true
}

// PackagedProductDefinitionPackage
// A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
type PackagedProductDefinitionPackage struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Quantity *FhirInteger `json:"quantity,omitempty"`
	Material []*CodeableConcept `json:"material,omitempty"`
	AlternateMaterial []*CodeableConcept `json:"alternatematerial,omitempty"`
	ShelfLifeStorage []*PackagedProductDefinitionShelfLifeStorage `json:"shelflifestorage,omitempty"`
	Manufacturer []*Reference `json:"manufacturer,omitempty"`
	Property []*PackagedProductDefinitionProperty `json:"property,omitempty"`
	ContainedItem []*PackagedProductDefinitionContainedItem `json:"containeditem,omitempty"`
	Package []*PackagedProductDefinitionPackage `json:"package,omitempty"`
}

// NewPackagedProductDefinitionPackage creates a new PackagedProductDefinitionPackage instance
func NewPackagedProductDefinitionPackage() *PackagedProductDefinitionPackage {
	return &PackagedProductDefinitionPackage{}
}

// FromJSON populates PackagedProductDefinitionPackage from JSON data
func (m *PackagedProductDefinitionPackage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts PackagedProductDefinitionPackage to JSON data
func (m *PackagedProductDefinitionPackage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of PackagedProductDefinitionPackage
func (m *PackagedProductDefinitionPackage) Clone() *PackagedProductDefinitionPackage {
	if m == nil { return nil }
	return &PackagedProductDefinitionPackage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Type: m.Type.Clone(),
		Quantity: m.Quantity.Clone(),
		Material: cloneSlices(m.Material),
		AlternateMaterial: cloneSlices(m.AlternateMaterial),
		ShelfLifeStorage: cloneSlices(m.ShelfLifeStorage),
		Manufacturer: cloneSlices(m.Manufacturer),
		Property: cloneSlices(m.Property),
		ContainedItem: cloneSlices(m.ContainedItem),
		Package: cloneSlices(m.Package),
	}
}

// Equals checks for equality with another PackagedProductDefinitionPackage instance
func (m *PackagedProductDefinitionPackage) Equals(other *PackagedProductDefinitionPackage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !compareSlices(m.Material, other.Material) { return false }
	if !compareSlices(m.AlternateMaterial, other.AlternateMaterial) { return false }
	if !compareSlices(m.ShelfLifeStorage, other.ShelfLifeStorage) { return false }
	if !compareSlices(m.Manufacturer, other.Manufacturer) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !compareSlices(m.ContainedItem, other.ContainedItem) { return false }
	if !compareSlices(m.Package, other.Package) { return false }
	return true
}

// PackagedProductDefinitionShelfLifeStorage
// Shelf Life and storage information.
type PackagedProductDefinitionShelfLifeStorage struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	PeriodDuration *FhirDuration `json:"periodduration,omitempty"`
	PeriodString *FhirString `json:"periodstring,omitempty"`
	SpecialPrecautionsForStorage []*CodeableConcept `json:"specialprecautionsforstorage,omitempty"`
}

// NewPackagedProductDefinitionShelfLifeStorage creates a new PackagedProductDefinitionShelfLifeStorage instance
func NewPackagedProductDefinitionShelfLifeStorage() *PackagedProductDefinitionShelfLifeStorage {
	return &PackagedProductDefinitionShelfLifeStorage{}
}

// FromJSON populates PackagedProductDefinitionShelfLifeStorage from JSON data
func (m *PackagedProductDefinitionShelfLifeStorage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts PackagedProductDefinitionShelfLifeStorage to JSON data
func (m *PackagedProductDefinitionShelfLifeStorage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of PackagedProductDefinitionShelfLifeStorage
func (m *PackagedProductDefinitionShelfLifeStorage) Clone() *PackagedProductDefinitionShelfLifeStorage {
	if m == nil { return nil }
	return &PackagedProductDefinitionShelfLifeStorage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		PeriodDuration: m.PeriodDuration.Clone(),
		PeriodString: m.PeriodString.Clone(),
		SpecialPrecautionsForStorage: cloneSlices(m.SpecialPrecautionsForStorage),
	}
}

// Equals checks for equality with another PackagedProductDefinitionShelfLifeStorage instance
func (m *PackagedProductDefinitionShelfLifeStorage) Equals(other *PackagedProductDefinitionShelfLifeStorage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.PeriodDuration.Equals(other.PeriodDuration) { return false }
	if !m.PeriodString.Equals(other.PeriodString) { return false }
	if !compareSlices(m.SpecialPrecautionsForStorage, other.SpecialPrecautionsForStorage) { return false }
	return true
}

// PackagedProductDefinitionProperty
// General characteristics of this item.
type PackagedProductDefinitionProperty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
}

// NewPackagedProductDefinitionProperty creates a new PackagedProductDefinitionProperty instance
func NewPackagedProductDefinitionProperty() *PackagedProductDefinitionProperty {
	return &PackagedProductDefinitionProperty{}
}

// FromJSON populates PackagedProductDefinitionProperty from JSON data
func (m *PackagedProductDefinitionProperty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts PackagedProductDefinitionProperty to JSON data
func (m *PackagedProductDefinitionProperty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of PackagedProductDefinitionProperty
func (m *PackagedProductDefinitionProperty) Clone() *PackagedProductDefinitionProperty {
	if m == nil { return nil }
	return &PackagedProductDefinitionProperty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
	}
}

// Equals checks for equality with another PackagedProductDefinitionProperty instance
func (m *PackagedProductDefinitionProperty) Equals(other *PackagedProductDefinitionProperty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	return true
}

// PackagedProductDefinitionContainedItem
// The item(s) within the packaging.
type PackagedProductDefinitionContainedItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Item *CodeableReference `json:"item,omitempty"`
	Amount *Quantity `json:"amount,omitempty"`
}

// NewPackagedProductDefinitionContainedItem creates a new PackagedProductDefinitionContainedItem instance
func NewPackagedProductDefinitionContainedItem() *PackagedProductDefinitionContainedItem {
	return &PackagedProductDefinitionContainedItem{}
}

// FromJSON populates PackagedProductDefinitionContainedItem from JSON data
func (m *PackagedProductDefinitionContainedItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts PackagedProductDefinitionContainedItem to JSON data
func (m *PackagedProductDefinitionContainedItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of PackagedProductDefinitionContainedItem
func (m *PackagedProductDefinitionContainedItem) Clone() *PackagedProductDefinitionContainedItem {
	if m == nil { return nil }
	return &PackagedProductDefinitionContainedItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Item: m.Item.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks for equality with another PackagedProductDefinitionContainedItem instance
func (m *PackagedProductDefinitionContainedItem) Equals(other *PackagedProductDefinitionContainedItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Item.Equals(other.Item) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

