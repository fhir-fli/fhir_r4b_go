// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// StructureMap
// A Map of relationships between 2 structures that can be used to transform data.
type StructureMap struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	Structure []*StructureMapStructure `json:"structure,omitempty"`
	Import_ []*FhirCanonical `json:"import,omitempty"`
	Group []*StructureMapGroup `json:"group,omitempty"`
}

// NewStructureMap creates a new StructureMap instance
func NewStructureMap() *StructureMap {
	return &StructureMap{}
}

// FromJSON populates StructureMap from JSON data
func (m *StructureMap) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMap to JSON data
func (m *StructureMap) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMap
func (m *StructureMap) Clone() *StructureMap {
	if m == nil { return nil }
	return &StructureMap{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		Structure: cloneSlices(m.Structure),
		Import_: cloneSlices(m.Import_),
		Group: cloneSlices(m.Group),
	}
}

// Equals checks for equality with another StructureMap instance
func (m *StructureMap) Equals(other *StructureMap) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !compareSlices(m.Structure, other.Structure) { return false }
	if !compareSlices(m.Import_, other.Import_) { return false }
	if !compareSlices(m.Group, other.Group) { return false }
	return true
}

// StructureMapStructure
// A structure definition used by this map. The structure definition may describe instances that are converted, or the instances that are produced.
type StructureMapStructure struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirCanonical `json:"url,omitempty"`
	Mode *StructureMapModelMode `json:"mode,omitempty"`
	Alias *FhirString `json:"alias,omitempty"`
	Documentation *FhirString `json:"documentation,omitempty"`
}

// NewStructureMapStructure creates a new StructureMapStructure instance
func NewStructureMapStructure() *StructureMapStructure {
	return &StructureMapStructure{}
}

// FromJSON populates StructureMapStructure from JSON data
func (m *StructureMapStructure) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapStructure to JSON data
func (m *StructureMapStructure) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapStructure
func (m *StructureMapStructure) Clone() *StructureMapStructure {
	if m == nil { return nil }
	return &StructureMapStructure{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Mode: m.Mode.Clone(),
		Alias: m.Alias.Clone(),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another StructureMapStructure instance
func (m *StructureMapStructure) Equals(other *StructureMapStructure) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !m.Alias.Equals(other.Alias) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// StructureMapGroup
// Organizes the mapping into manageable chunks for human review/ease of maintenance.
type StructureMapGroup struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirId `json:"name,omitempty"`
	Extends_ *FhirId `json:"extends,omitempty"`
	TypeMode *StructureMapGroupTypeMode `json:"typemode,omitempty"`
	Documentation *FhirString `json:"documentation,omitempty"`
	Input []*StructureMapInput `json:"input,omitempty"`
	Rule []*StructureMapRule `json:"rule,omitempty"`
}

// NewStructureMapGroup creates a new StructureMapGroup instance
func NewStructureMapGroup() *StructureMapGroup {
	return &StructureMapGroup{}
}

// FromJSON populates StructureMapGroup from JSON data
func (m *StructureMapGroup) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapGroup to JSON data
func (m *StructureMapGroup) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapGroup
func (m *StructureMapGroup) Clone() *StructureMapGroup {
	if m == nil { return nil }
	return &StructureMapGroup{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Extends_: m.Extends_.Clone(),
		TypeMode: m.TypeMode.Clone(),
		Documentation: m.Documentation.Clone(),
		Input: cloneSlices(m.Input),
		Rule: cloneSlices(m.Rule),
	}
}

// Equals checks for equality with another StructureMapGroup instance
func (m *StructureMapGroup) Equals(other *StructureMapGroup) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Extends_.Equals(other.Extends_) { return false }
	if !m.TypeMode.Equals(other.TypeMode) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	if !compareSlices(m.Input, other.Input) { return false }
	if !compareSlices(m.Rule, other.Rule) { return false }
	return true
}

// StructureMapInput
// A name assigned to an instance of data. The instance must be provided when the mapping is invoked.
type StructureMapInput struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirId `json:"name,omitempty"`
	Type *FhirString `json:"type,omitempty"`
	Mode *StructureMapInputMode `json:"mode,omitempty"`
	Documentation *FhirString `json:"documentation,omitempty"`
}

// NewStructureMapInput creates a new StructureMapInput instance
func NewStructureMapInput() *StructureMapInput {
	return &StructureMapInput{}
}

// FromJSON populates StructureMapInput from JSON data
func (m *StructureMapInput) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapInput to JSON data
func (m *StructureMapInput) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapInput
func (m *StructureMapInput) Clone() *StructureMapInput {
	if m == nil { return nil }
	return &StructureMapInput{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
		Mode: m.Mode.Clone(),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another StructureMapInput instance
func (m *StructureMapInput) Equals(other *StructureMapInput) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// StructureMapRule
// Transform Rule from source to target.
type StructureMapRule struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirId `json:"name,omitempty"`
	Source []*StructureMapSource `json:"source,omitempty"`
	Target []*StructureMapTarget `json:"target,omitempty"`
	Rule []*StructureMapRule `json:"rule,omitempty"`
	Dependent []*StructureMapDependent `json:"dependent,omitempty"`
	Documentation *FhirString `json:"documentation,omitempty"`
}

// NewStructureMapRule creates a new StructureMapRule instance
func NewStructureMapRule() *StructureMapRule {
	return &StructureMapRule{}
}

// FromJSON populates StructureMapRule from JSON data
func (m *StructureMapRule) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapRule to JSON data
func (m *StructureMapRule) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapRule
func (m *StructureMapRule) Clone() *StructureMapRule {
	if m == nil { return nil }
	return &StructureMapRule{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Source: cloneSlices(m.Source),
		Target: cloneSlices(m.Target),
		Rule: cloneSlices(m.Rule),
		Dependent: cloneSlices(m.Dependent),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another StructureMapRule instance
func (m *StructureMapRule) Equals(other *StructureMapRule) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !compareSlices(m.Source, other.Source) { return false }
	if !compareSlices(m.Target, other.Target) { return false }
	if !compareSlices(m.Rule, other.Rule) { return false }
	if !compareSlices(m.Dependent, other.Dependent) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// StructureMapSource
// Source inputs to the mapping.
type StructureMapSource struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Context *FhirId `json:"context,omitempty"`
	Min *FhirInteger `json:"min,omitempty"`
	Max *FhirString `json:"max,omitempty"`
	Type *FhirString `json:"type,omitempty"`
	DefaultValueBase64Binary *FhirBase64Binary `json:"defaultvaluebase64binary,omitempty"`
	DefaultValueBoolean *FhirBoolean `json:"defaultvalueboolean,omitempty"`
	DefaultValueCanonical *FhirCanonical `json:"defaultvaluecanonical,omitempty"`
	DefaultValueCode *FhirCode `json:"defaultvaluecode,omitempty"`
	DefaultValueDate *FhirDate `json:"defaultvaluedate,omitempty"`
	DefaultValueDateTime *FhirDateTime `json:"defaultvaluedatetime,omitempty"`
	DefaultValueDecimal *FhirDecimal `json:"defaultvaluedecimal,omitempty"`
	DefaultValueId *FhirId `json:"defaultvalueid,omitempty"`
	DefaultValueInstant *FhirInstant `json:"defaultvalueinstant,omitempty"`
	DefaultValueInteger *FhirInteger `json:"defaultvalueinteger,omitempty"`
	DefaultValueMarkdown *FhirMarkdown `json:"defaultvaluemarkdown,omitempty"`
	DefaultValueOid *FhirOid `json:"defaultvalueoid,omitempty"`
	DefaultValuePositiveInt *FhirPositiveInt `json:"defaultvaluepositiveint,omitempty"`
	DefaultValueString *FhirString `json:"defaultvaluestring,omitempty"`
	DefaultValueTime *FhirTime `json:"defaultvaluetime,omitempty"`
	DefaultValueUnsignedInt *FhirUnsignedInt `json:"defaultvalueunsignedint,omitempty"`
	DefaultValueUri *FhirUri `json:"defaultvalueuri,omitempty"`
	DefaultValueUrl *FhirUrl `json:"defaultvalueurl,omitempty"`
	DefaultValueUuid *FhirUuid `json:"defaultvalueuuid,omitempty"`
	DefaultValueAddress *Address `json:"defaultvalueaddress,omitempty"`
	DefaultValueAge *Age `json:"defaultvalueage,omitempty"`
	DefaultValueAnnotation *Annotation `json:"defaultvalueannotation,omitempty"`
	DefaultValueAttachment *Attachment `json:"defaultvalueattachment,omitempty"`
	DefaultValueCodeableConcept *CodeableConcept `json:"defaultvaluecodeableconcept,omitempty"`
	DefaultValueCoding *Coding `json:"defaultvaluecoding,omitempty"`
	DefaultValueContactPoint *ContactPoint `json:"defaultvaluecontactpoint,omitempty"`
	DefaultValueCount *Count `json:"defaultvaluecount,omitempty"`
	DefaultValueDistance *Distance `json:"defaultvaluedistance,omitempty"`
	DefaultValueDuration *FhirDuration `json:"defaultvalueduration,omitempty"`
	DefaultValueHumanName *HumanName `json:"defaultvaluehumanname,omitempty"`
	DefaultValueIdentifier *Identifier `json:"defaultvalueidentifier,omitempty"`
	DefaultValueMoney *Money `json:"defaultvaluemoney,omitempty"`
	DefaultValuePeriod *Period `json:"defaultvalueperiod,omitempty"`
	DefaultValueQuantity *Quantity `json:"defaultvaluequantity,omitempty"`
	DefaultValueRange *Range `json:"defaultvaluerange,omitempty"`
	DefaultValueRatio *Ratio `json:"defaultvalueratio,omitempty"`
	DefaultValueReference *Reference `json:"defaultvaluereference,omitempty"`
	DefaultValueSampledData *SampledData `json:"defaultvaluesampleddata,omitempty"`
	DefaultValueSignature *Signature `json:"defaultvaluesignature,omitempty"`
	DefaultValueTiming *Timing `json:"defaultvaluetiming,omitempty"`
	DefaultValueContactDetail *ContactDetail `json:"defaultvaluecontactdetail,omitempty"`
	DefaultValueContributor *Contributor `json:"defaultvaluecontributor,omitempty"`
	DefaultValueDataRequirement *DataRequirement `json:"defaultvaluedatarequirement,omitempty"`
	DefaultValueExpression *FhirExpression `json:"defaultvalueexpression,omitempty"`
	DefaultValueParameterDefinition *ParameterDefinition `json:"defaultvalueparameterdefinition,omitempty"`
	DefaultValueRelatedArtifact *RelatedArtifact `json:"defaultvaluerelatedartifact,omitempty"`
	DefaultValueTriggerDefinition *TriggerDefinition `json:"defaultvaluetriggerdefinition,omitempty"`
	DefaultValueUsageContext *UsageContext `json:"defaultvalueusagecontext,omitempty"`
	DefaultValueDosage *Dosage `json:"defaultvaluedosage,omitempty"`
	DefaultValueMeta *FhirMeta `json:"defaultvaluemeta,omitempty"`
	Element *FhirString `json:"element,omitempty"`
	ListMode *StructureMapSourceListMode `json:"listmode,omitempty"`
	Variable *FhirId `json:"variable,omitempty"`
	Condition *FhirString `json:"condition,omitempty"`
	Check *FhirString `json:"check,omitempty"`
	LogMessage *FhirString `json:"logmessage,omitempty"`
}

// NewStructureMapSource creates a new StructureMapSource instance
func NewStructureMapSource() *StructureMapSource {
	return &StructureMapSource{}
}

// FromJSON populates StructureMapSource from JSON data
func (m *StructureMapSource) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapSource to JSON data
func (m *StructureMapSource) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapSource
func (m *StructureMapSource) Clone() *StructureMapSource {
	if m == nil { return nil }
	return &StructureMapSource{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Context: m.Context.Clone(),
		Min: m.Min.Clone(),
		Max: m.Max.Clone(),
		Type: m.Type.Clone(),
		DefaultValueBase64Binary: m.DefaultValueBase64Binary.Clone(),
		DefaultValueBoolean: m.DefaultValueBoolean.Clone(),
		DefaultValueCanonical: m.DefaultValueCanonical.Clone(),
		DefaultValueCode: m.DefaultValueCode.Clone(),
		DefaultValueDate: m.DefaultValueDate.Clone(),
		DefaultValueDateTime: m.DefaultValueDateTime.Clone(),
		DefaultValueDecimal: m.DefaultValueDecimal.Clone(),
		DefaultValueId: m.DefaultValueId.Clone(),
		DefaultValueInstant: m.DefaultValueInstant.Clone(),
		DefaultValueInteger: m.DefaultValueInteger.Clone(),
		DefaultValueMarkdown: m.DefaultValueMarkdown.Clone(),
		DefaultValueOid: m.DefaultValueOid.Clone(),
		DefaultValuePositiveInt: m.DefaultValuePositiveInt.Clone(),
		DefaultValueString: m.DefaultValueString.Clone(),
		DefaultValueTime: m.DefaultValueTime.Clone(),
		DefaultValueUnsignedInt: m.DefaultValueUnsignedInt.Clone(),
		DefaultValueUri: m.DefaultValueUri.Clone(),
		DefaultValueUrl: m.DefaultValueUrl.Clone(),
		DefaultValueUuid: m.DefaultValueUuid.Clone(),
		DefaultValueAddress: m.DefaultValueAddress.Clone(),
		DefaultValueAge: m.DefaultValueAge.Clone(),
		DefaultValueAnnotation: m.DefaultValueAnnotation.Clone(),
		DefaultValueAttachment: m.DefaultValueAttachment.Clone(),
		DefaultValueCodeableConcept: m.DefaultValueCodeableConcept.Clone(),
		DefaultValueCoding: m.DefaultValueCoding.Clone(),
		DefaultValueContactPoint: m.DefaultValueContactPoint.Clone(),
		DefaultValueCount: m.DefaultValueCount.Clone(),
		DefaultValueDistance: m.DefaultValueDistance.Clone(),
		DefaultValueDuration: m.DefaultValueDuration.Clone(),
		DefaultValueHumanName: m.DefaultValueHumanName.Clone(),
		DefaultValueIdentifier: m.DefaultValueIdentifier.Clone(),
		DefaultValueMoney: m.DefaultValueMoney.Clone(),
		DefaultValuePeriod: m.DefaultValuePeriod.Clone(),
		DefaultValueQuantity: m.DefaultValueQuantity.Clone(),
		DefaultValueRange: m.DefaultValueRange.Clone(),
		DefaultValueRatio: m.DefaultValueRatio.Clone(),
		DefaultValueReference: m.DefaultValueReference.Clone(),
		DefaultValueSampledData: m.DefaultValueSampledData.Clone(),
		DefaultValueSignature: m.DefaultValueSignature.Clone(),
		DefaultValueTiming: m.DefaultValueTiming.Clone(),
		DefaultValueContactDetail: m.DefaultValueContactDetail.Clone(),
		DefaultValueContributor: m.DefaultValueContributor.Clone(),
		DefaultValueDataRequirement: m.DefaultValueDataRequirement.Clone(),
		DefaultValueExpression: m.DefaultValueExpression.Clone(),
		DefaultValueParameterDefinition: m.DefaultValueParameterDefinition.Clone(),
		DefaultValueRelatedArtifact: m.DefaultValueRelatedArtifact.Clone(),
		DefaultValueTriggerDefinition: m.DefaultValueTriggerDefinition.Clone(),
		DefaultValueUsageContext: m.DefaultValueUsageContext.Clone(),
		DefaultValueDosage: m.DefaultValueDosage.Clone(),
		DefaultValueMeta: m.DefaultValueMeta.Clone(),
		Element: m.Element.Clone(),
		ListMode: m.ListMode.Clone(),
		Variable: m.Variable.Clone(),
		Condition: m.Condition.Clone(),
		Check: m.Check.Clone(),
		LogMessage: m.LogMessage.Clone(),
	}
}

// Equals checks for equality with another StructureMapSource instance
func (m *StructureMapSource) Equals(other *StructureMapSource) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Context.Equals(other.Context) { return false }
	if !m.Min.Equals(other.Min) { return false }
	if !m.Max.Equals(other.Max) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.DefaultValueBase64Binary.Equals(other.DefaultValueBase64Binary) { return false }
	if !m.DefaultValueBoolean.Equals(other.DefaultValueBoolean) { return false }
	if !m.DefaultValueCanonical.Equals(other.DefaultValueCanonical) { return false }
	if !m.DefaultValueCode.Equals(other.DefaultValueCode) { return false }
	if !m.DefaultValueDate.Equals(other.DefaultValueDate) { return false }
	if !m.DefaultValueDateTime.Equals(other.DefaultValueDateTime) { return false }
	if !m.DefaultValueDecimal.Equals(other.DefaultValueDecimal) { return false }
	if !m.DefaultValueId.Equals(other.DefaultValueId) { return false }
	if !m.DefaultValueInstant.Equals(other.DefaultValueInstant) { return false }
	if !m.DefaultValueInteger.Equals(other.DefaultValueInteger) { return false }
	if !m.DefaultValueMarkdown.Equals(other.DefaultValueMarkdown) { return false }
	if !m.DefaultValueOid.Equals(other.DefaultValueOid) { return false }
	if !m.DefaultValuePositiveInt.Equals(other.DefaultValuePositiveInt) { return false }
	if !m.DefaultValueString.Equals(other.DefaultValueString) { return false }
	if !m.DefaultValueTime.Equals(other.DefaultValueTime) { return false }
	if !m.DefaultValueUnsignedInt.Equals(other.DefaultValueUnsignedInt) { return false }
	if !m.DefaultValueUri.Equals(other.DefaultValueUri) { return false }
	if !m.DefaultValueUrl.Equals(other.DefaultValueUrl) { return false }
	if !m.DefaultValueUuid.Equals(other.DefaultValueUuid) { return false }
	if !m.DefaultValueAddress.Equals(other.DefaultValueAddress) { return false }
	if !m.DefaultValueAge.Equals(other.DefaultValueAge) { return false }
	if !m.DefaultValueAnnotation.Equals(other.DefaultValueAnnotation) { return false }
	if !m.DefaultValueAttachment.Equals(other.DefaultValueAttachment) { return false }
	if !m.DefaultValueCodeableConcept.Equals(other.DefaultValueCodeableConcept) { return false }
	if !m.DefaultValueCoding.Equals(other.DefaultValueCoding) { return false }
	if !m.DefaultValueContactPoint.Equals(other.DefaultValueContactPoint) { return false }
	if !m.DefaultValueCount.Equals(other.DefaultValueCount) { return false }
	if !m.DefaultValueDistance.Equals(other.DefaultValueDistance) { return false }
	if !m.DefaultValueDuration.Equals(other.DefaultValueDuration) { return false }
	if !m.DefaultValueHumanName.Equals(other.DefaultValueHumanName) { return false }
	if !m.DefaultValueIdentifier.Equals(other.DefaultValueIdentifier) { return false }
	if !m.DefaultValueMoney.Equals(other.DefaultValueMoney) { return false }
	if !m.DefaultValuePeriod.Equals(other.DefaultValuePeriod) { return false }
	if !m.DefaultValueQuantity.Equals(other.DefaultValueQuantity) { return false }
	if !m.DefaultValueRange.Equals(other.DefaultValueRange) { return false }
	if !m.DefaultValueRatio.Equals(other.DefaultValueRatio) { return false }
	if !m.DefaultValueReference.Equals(other.DefaultValueReference) { return false }
	if !m.DefaultValueSampledData.Equals(other.DefaultValueSampledData) { return false }
	if !m.DefaultValueSignature.Equals(other.DefaultValueSignature) { return false }
	if !m.DefaultValueTiming.Equals(other.DefaultValueTiming) { return false }
	if !m.DefaultValueContactDetail.Equals(other.DefaultValueContactDetail) { return false }
	if !m.DefaultValueContributor.Equals(other.DefaultValueContributor) { return false }
	if !m.DefaultValueDataRequirement.Equals(other.DefaultValueDataRequirement) { return false }
	if !m.DefaultValueExpression.Equals(other.DefaultValueExpression) { return false }
	if !m.DefaultValueParameterDefinition.Equals(other.DefaultValueParameterDefinition) { return false }
	if !m.DefaultValueRelatedArtifact.Equals(other.DefaultValueRelatedArtifact) { return false }
	if !m.DefaultValueTriggerDefinition.Equals(other.DefaultValueTriggerDefinition) { return false }
	if !m.DefaultValueUsageContext.Equals(other.DefaultValueUsageContext) { return false }
	if !m.DefaultValueDosage.Equals(other.DefaultValueDosage) { return false }
	if !m.DefaultValueMeta.Equals(other.DefaultValueMeta) { return false }
	if !m.Element.Equals(other.Element) { return false }
	if !m.ListMode.Equals(other.ListMode) { return false }
	if !m.Variable.Equals(other.Variable) { return false }
	if !m.Condition.Equals(other.Condition) { return false }
	if !m.Check.Equals(other.Check) { return false }
	if !m.LogMessage.Equals(other.LogMessage) { return false }
	return true
}

// StructureMapTarget
// Content to create because of this mapping rule.
type StructureMapTarget struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Context *FhirId `json:"context,omitempty"`
	ContextType *StructureMapContextType `json:"contexttype,omitempty"`
	Element *FhirString `json:"element,omitempty"`
	Variable *FhirId `json:"variable,omitempty"`
	ListMode []*StructureMapTargetListMode `json:"listmode,omitempty"`
	ListRuleId *FhirId `json:"listruleid,omitempty"`
	Transform *StructureMapTransform `json:"transform,omitempty"`
	Parameter []*StructureMapParameter `json:"parameter,omitempty"`
}

// NewStructureMapTarget creates a new StructureMapTarget instance
func NewStructureMapTarget() *StructureMapTarget {
	return &StructureMapTarget{}
}

// FromJSON populates StructureMapTarget from JSON data
func (m *StructureMapTarget) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapTarget to JSON data
func (m *StructureMapTarget) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapTarget
func (m *StructureMapTarget) Clone() *StructureMapTarget {
	if m == nil { return nil }
	return &StructureMapTarget{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Context: m.Context.Clone(),
		ContextType: m.ContextType.Clone(),
		Element: m.Element.Clone(),
		Variable: m.Variable.Clone(),
		ListMode: cloneSlices(m.ListMode),
		ListRuleId: m.ListRuleId.Clone(),
		Transform: m.Transform.Clone(),
		Parameter: cloneSlices(m.Parameter),
	}
}

// Equals checks for equality with another StructureMapTarget instance
func (m *StructureMapTarget) Equals(other *StructureMapTarget) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Context.Equals(other.Context) { return false }
	if !m.ContextType.Equals(other.ContextType) { return false }
	if !m.Element.Equals(other.Element) { return false }
	if !m.Variable.Equals(other.Variable) { return false }
	if !compareSlices(m.ListMode, other.ListMode) { return false }
	if !m.ListRuleId.Equals(other.ListRuleId) { return false }
	if !m.Transform.Equals(other.Transform) { return false }
	if !compareSlices(m.Parameter, other.Parameter) { return false }
	return true
}

// StructureMapParameter
// Parameters to the transform.
type StructureMapParameter struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ValueId *FhirId `json:"valueid,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
}

// NewStructureMapParameter creates a new StructureMapParameter instance
func NewStructureMapParameter() *StructureMapParameter {
	return &StructureMapParameter{}
}

// FromJSON populates StructureMapParameter from JSON data
func (m *StructureMapParameter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapParameter to JSON data
func (m *StructureMapParameter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapParameter
func (m *StructureMapParameter) Clone() *StructureMapParameter {
	if m == nil { return nil }
	return &StructureMapParameter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ValueId: m.ValueId.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
	}
}

// Equals checks for equality with another StructureMapParameter instance
func (m *StructureMapParameter) Equals(other *StructureMapParameter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ValueId.Equals(other.ValueId) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	return true
}

// StructureMapDependent
// Which other rules to apply in the context of this rule.
type StructureMapDependent struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirId `json:"name,omitempty"`
	Variable []*FhirString `json:"variable,omitempty"`
}

// NewStructureMapDependent creates a new StructureMapDependent instance
func NewStructureMapDependent() *StructureMapDependent {
	return &StructureMapDependent{}
}

// FromJSON populates StructureMapDependent from JSON data
func (m *StructureMapDependent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureMapDependent to JSON data
func (m *StructureMapDependent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureMapDependent
func (m *StructureMapDependent) Clone() *StructureMapDependent {
	if m == nil { return nil }
	return &StructureMapDependent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Variable: cloneSlices(m.Variable),
	}
}

// Equals checks for equality with another StructureMapDependent instance
func (m *StructureMapDependent) Equals(other *StructureMapDependent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !compareSlices(m.Variable, other.Variable) { return false }
	return true
}

