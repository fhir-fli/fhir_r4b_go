// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"
)

// Encounter
// An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
type Encounter struct {
	extends DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *EncounterStatus `json:"status,omitempty"`
	StatusHistory []*EncounterStatusHistory `json:"statushistory,omitempty"`
	Class_ *Coding `json:"class,omitempty"`
	ClassHistory []*EncounterClassHistory `json:"classhistory,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	ServiceType *CodeableConcept `json:"servicetype,omitempty"`
	Priority *CodeableConcept `json:"priority,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	EpisodeOfCare []*Reference `json:"episodeofcare,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	Participant []*EncounterParticipant `json:"participant,omitempty"`
	Appointment []*Reference `json:"appointment,omitempty"`
	Period *Period `json:"period,omitempty"`
	Length *FhirDuration `json:"length,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	Diagnosis []*EncounterDiagnosis `json:"diagnosis,omitempty"`
	Account []*Reference `json:"account,omitempty"`
	Hospitalization *EncounterHospitalization `json:"hospitalization,omitempty"`
	Location []*EncounterLocation `json:"location,omitempty"`
	ServiceProvider *Reference `json:"serviceprovider,omitempty"`
	PartOf *Reference `json:"partof,omitempty"`
}

// NewEncounter creates a new Encounter instance.
func NewEncounter() *Encounter {
	return &Encounter{}
}

// UnmarshalJSON populates Encounter from JSON data.
func (m *Encounter) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *EncounterStatus `json:"status,omitempty"`
		StatusHistory []*EncounterStatusHistory `json:"statushistory,omitempty"`
		Class_ *Coding `json:"class,omitempty"`
		ClassHistory []*EncounterClassHistory `json:"classhistory,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		ServiceType *CodeableConcept `json:"servicetype,omitempty"`
		Priority *CodeableConcept `json:"priority,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		EpisodeOfCare []*Reference `json:"episodeofcare,omitempty"`
		BasedOn []*Reference `json:"basedon,omitempty"`
		Participant []*EncounterParticipant `json:"participant,omitempty"`
		Appointment []*Reference `json:"appointment,omitempty"`
		Period *Period `json:"period,omitempty"`
		Length *FhirDuration `json:"length,omitempty"`
		ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
		ReasonReference []*Reference `json:"reasonreference,omitempty"`
		Diagnosis []*EncounterDiagnosis `json:"diagnosis,omitempty"`
		Account []*Reference `json:"account,omitempty"`
		Hospitalization *EncounterHospitalization `json:"hospitalization,omitempty"`
		Location []*EncounterLocation `json:"location,omitempty"`
		ServiceProvider *Reference `json:"serviceprovider,omitempty"`
		PartOf *Reference `json:"partof,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Meta = temp.Meta
	m.ImplicitRules = temp.ImplicitRules
	m.Language = temp.Language
	m.Text = temp.Text
	m.Contained = temp.Contained
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Identifier = temp.Identifier
	m.Status = temp.Status
	m.StatusHistory = temp.StatusHistory
	m.Class_ = temp.Class_
	m.ClassHistory = temp.ClassHistory
	m.Type = temp.Type
	m.ServiceType = temp.ServiceType
	m.Priority = temp.Priority
	m.Subject = temp.Subject
	m.EpisodeOfCare = temp.EpisodeOfCare
	m.BasedOn = temp.BasedOn
	m.Participant = temp.Participant
	m.Appointment = temp.Appointment
	m.Period = temp.Period
	m.Length = temp.Length
	m.ReasonCode = temp.ReasonCode
	m.ReasonReference = temp.ReasonReference
	m.Diagnosis = temp.Diagnosis
	m.Account = temp.Account
	m.Hospitalization = temp.Hospitalization
	m.Location = temp.Location
	m.ServiceProvider = temp.ServiceProvider
	m.PartOf = temp.PartOf
	return nil
}

// MarshalJSON converts Encounter to JSON data.
func (m *Encounter) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Meta *FhirMeta `json:"meta,omitempty"`
		ImplicitRules interface{} `json:"implicitrules,omitempty"`
		ImplicitRulesElement map[string]interface{} `json:"_implicitrules,omitempty"`
		Language *CommonLanguages `json:"language,omitempty"`
		Text *Narrative `json:"text,omitempty"`
		Contained []*Resource `json:"contained,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Identifier []*Identifier `json:"identifier,omitempty"`
		Status *EncounterStatus `json:"status,omitempty"`
		StatusHistory []*EncounterStatusHistory `json:"statushistory,omitempty"`
		Class_ *Coding `json:"class,omitempty"`
		ClassHistory []*EncounterClassHistory `json:"classhistory,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		ServiceType *CodeableConcept `json:"servicetype,omitempty"`
		Priority *CodeableConcept `json:"priority,omitempty"`
		Subject *Reference `json:"subject,omitempty"`
		EpisodeOfCare []*Reference `json:"episodeofcare,omitempty"`
		BasedOn []*Reference `json:"basedon,omitempty"`
		Participant []*EncounterParticipant `json:"participant,omitempty"`
		Appointment []*Reference `json:"appointment,omitempty"`
		Period *Period `json:"period,omitempty"`
		Length *FhirDuration `json:"length,omitempty"`
		ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
		ReasonReference []*Reference `json:"reasonreference,omitempty"`
		Diagnosis []*EncounterDiagnosis `json:"diagnosis,omitempty"`
		Account []*Reference `json:"account,omitempty"`
		Hospitalization *EncounterHospitalization `json:"hospitalization,omitempty"`
		Location []*EncounterLocation `json:"location,omitempty"`
		ServiceProvider *Reference `json:"serviceprovider,omitempty"`
		PartOf *Reference `json:"partof,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Meta = m.Meta
	if m.ImplicitRules != nil && m.ImplicitRules.Value != nil {
		output.ImplicitRules = m.ImplicitRules.Value
		if m.ImplicitRules.Element != nil {
			output.ImplicitRulesElement = toMapOrNil(m.ImplicitRules.Element.MarshalJSON())
		}
	}
	output.Language = m.Language
	output.Text = m.Text
	output.Contained = m.Contained
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Identifier = m.Identifier
	output.Status = m.Status
	output.StatusHistory = m.StatusHistory
	output.Class_ = m.Class_
	output.ClassHistory = m.ClassHistory
	output.Type = m.Type
	output.ServiceType = m.ServiceType
	output.Priority = m.Priority
	output.Subject = m.Subject
	output.EpisodeOfCare = m.EpisodeOfCare
	output.BasedOn = m.BasedOn
	output.Participant = m.Participant
	output.Appointment = m.Appointment
	output.Period = m.Period
	output.Length = m.Length
	output.ReasonCode = m.ReasonCode
	output.ReasonReference = m.ReasonReference
	output.Diagnosis = m.Diagnosis
	output.Account = m.Account
	output.Hospitalization = m.Hospitalization
	output.Location = m.Location
	output.ServiceProvider = m.ServiceProvider
	output.PartOf = m.PartOf
	return json.Marshal(output)
}

// Clone creates a deep copy of Encounter.
func (m *Encounter) Clone() *Encounter {
	if m == nil { return nil }
	return &Encounter{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		StatusHistory: cloneSlices(m.StatusHistory),
		Class_: m.Class_.Clone(),
		ClassHistory: cloneSlices(m.ClassHistory),
		Type: cloneSlices(m.Type),
		ServiceType: m.ServiceType.Clone(),
		Priority: m.Priority.Clone(),
		Subject: m.Subject.Clone(),
		EpisodeOfCare: cloneSlices(m.EpisodeOfCare),
		BasedOn: cloneSlices(m.BasedOn),
		Participant: cloneSlices(m.Participant),
		Appointment: cloneSlices(m.Appointment),
		Period: m.Period.Clone(),
		Length: m.Length.Clone(),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		Diagnosis: cloneSlices(m.Diagnosis),
		Account: cloneSlices(m.Account),
		Hospitalization: m.Hospitalization.Clone(),
		Location: cloneSlices(m.Location),
		ServiceProvider: m.ServiceProvider.Clone(),
		PartOf: m.PartOf.Clone(),
	}
}

// Equals checks equality between two Encounter instances.
func (m *Encounter) Equals(other *Encounter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.StatusHistory, other.StatusHistory) { return false }
	if !m.Class_.Equals(other.Class_) { return false }
	if !compareSlices(m.ClassHistory, other.ClassHistory) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.ServiceType.Equals(other.ServiceType) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !compareSlices(m.EpisodeOfCare, other.EpisodeOfCare) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !compareSlices(m.Participant, other.Participant) { return false }
	if !compareSlices(m.Appointment, other.Appointment) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.Length.Equals(other.Length) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !compareSlices(m.Diagnosis, other.Diagnosis) { return false }
	if !compareSlices(m.Account, other.Account) { return false }
	if !m.Hospitalization.Equals(other.Hospitalization) { return false }
	if !compareSlices(m.Location, other.Location) { return false }
	if !m.ServiceProvider.Equals(other.ServiceProvider) { return false }
	if !m.PartOf.Equals(other.PartOf) { return false }
	return true
}

// EncounterStatusHistory
// The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
type EncounterStatusHistory struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Status *EncounterStatus `json:"status,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewEncounterStatusHistory creates a new EncounterStatusHistory instance.
func NewEncounterStatusHistory() *EncounterStatusHistory {
	return &EncounterStatusHistory{}
}

// UnmarshalJSON populates EncounterStatusHistory from JSON data.
func (m *EncounterStatusHistory) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Status *EncounterStatus `json:"status,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Status = temp.Status
	m.Period = temp.Period
	return nil
}

// MarshalJSON converts EncounterStatusHistory to JSON data.
func (m *EncounterStatusHistory) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Status *EncounterStatus `json:"status,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Status = m.Status
	output.Period = m.Period
	return json.Marshal(output)
}

// Clone creates a deep copy of EncounterStatusHistory.
func (m *EncounterStatusHistory) Clone() *EncounterStatusHistory {
	if m == nil { return nil }
	return &EncounterStatusHistory{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Status: m.Status.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks equality between two EncounterStatusHistory instances.
func (m *EncounterStatusHistory) Equals(other *EncounterStatusHistory) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// EncounterClassHistory
// The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
type EncounterClassHistory struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Class_ *Coding `json:"class,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewEncounterClassHistory creates a new EncounterClassHistory instance.
func NewEncounterClassHistory() *EncounterClassHistory {
	return &EncounterClassHistory{}
}

// UnmarshalJSON populates EncounterClassHistory from JSON data.
func (m *EncounterClassHistory) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Class_ *Coding `json:"class,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Class_ = temp.Class_
	m.Period = temp.Period
	return nil
}

// MarshalJSON converts EncounterClassHistory to JSON data.
func (m *EncounterClassHistory) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Class_ *Coding `json:"class,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Class_ = m.Class_
	output.Period = m.Period
	return json.Marshal(output)
}

// Clone creates a deep copy of EncounterClassHistory.
func (m *EncounterClassHistory) Clone() *EncounterClassHistory {
	if m == nil { return nil }
	return &EncounterClassHistory{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Class_: m.Class_.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks equality between two EncounterClassHistory instances.
func (m *EncounterClassHistory) Equals(other *EncounterClassHistory) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Class_.Equals(other.Class_) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// EncounterParticipant
// The list of people responsible for providing the service.
type EncounterParticipant struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	Period *Period `json:"period,omitempty"`
	Individual *Reference `json:"individual,omitempty"`
}

// NewEncounterParticipant creates a new EncounterParticipant instance.
func NewEncounterParticipant() *EncounterParticipant {
	return &EncounterParticipant{}
}

// UnmarshalJSON populates EncounterParticipant from JSON data.
func (m *EncounterParticipant) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		Period *Period `json:"period,omitempty"`
		Individual *Reference `json:"individual,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Type = temp.Type
	m.Period = temp.Period
	m.Individual = temp.Individual
	return nil
}

// MarshalJSON converts EncounterParticipant to JSON data.
func (m *EncounterParticipant) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Type []*CodeableConcept `json:"type,omitempty"`
		Period *Period `json:"period,omitempty"`
		Individual *Reference `json:"individual,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Type = m.Type
	output.Period = m.Period
	output.Individual = m.Individual
	return json.Marshal(output)
}

// Clone creates a deep copy of EncounterParticipant.
func (m *EncounterParticipant) Clone() *EncounterParticipant {
	if m == nil { return nil }
	return &EncounterParticipant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: cloneSlices(m.Type),
		Period: m.Period.Clone(),
		Individual: m.Individual.Clone(),
	}
}

// Equals checks equality between two EncounterParticipant instances.
func (m *EncounterParticipant) Equals(other *EncounterParticipant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.Individual.Equals(other.Individual) { return false }
	return true
}

// EncounterDiagnosis
// The list of diagnosis relevant to this encounter.
type EncounterDiagnosis struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Condition *Reference `json:"condition,omitempty"`
	Use *CodeableConcept `json:"use,omitempty"`
	Rank *FhirPositiveInt `json:"rank,omitempty"`
}

// NewEncounterDiagnosis creates a new EncounterDiagnosis instance.
func NewEncounterDiagnosis() *EncounterDiagnosis {
	return &EncounterDiagnosis{}
}

// UnmarshalJSON populates EncounterDiagnosis from JSON data.
func (m *EncounterDiagnosis) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Condition *Reference `json:"condition,omitempty"`
		Use *CodeableConcept `json:"use,omitempty"`
		Rank *FhirPositiveInt `json:"rank,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Condition = temp.Condition
	m.Use = temp.Use
	m.Rank = temp.Rank
	return nil
}

// MarshalJSON converts EncounterDiagnosis to JSON data.
func (m *EncounterDiagnosis) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Condition *Reference `json:"condition,omitempty"`
		Use *CodeableConcept `json:"use,omitempty"`
		Rank interface{} `json:"rank,omitempty"`
		RankElement map[string]interface{} `json:"_rank,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Condition = m.Condition
	output.Use = m.Use
	if m.Rank != nil && m.Rank.Value != nil {
		output.Rank = m.Rank.Value
		if m.Rank.Element != nil {
			output.RankElement = toMapOrNil(m.Rank.Element.MarshalJSON())
		}
	}
	return json.Marshal(output)
}

// Clone creates a deep copy of EncounterDiagnosis.
func (m *EncounterDiagnosis) Clone() *EncounterDiagnosis {
	if m == nil { return nil }
	return &EncounterDiagnosis{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Condition: m.Condition.Clone(),
		Use: m.Use.Clone(),
		Rank: m.Rank.Clone(),
	}
}

// Equals checks equality between two EncounterDiagnosis instances.
func (m *EncounterDiagnosis) Equals(other *EncounterDiagnosis) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Condition.Equals(other.Condition) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Rank.Equals(other.Rank) { return false }
	return true
}

// EncounterHospitalization
// Details about the admission to a healthcare service.
type EncounterHospitalization struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	PreAdmissionIdentifier *Identifier `json:"preadmissionidentifier,omitempty"`
	Origin *Reference `json:"origin,omitempty"`
	AdmitSource *CodeableConcept `json:"admitsource,omitempty"`
	ReAdmission *CodeableConcept `json:"readmission,omitempty"`
	DietPreference []*CodeableConcept `json:"dietpreference,omitempty"`
	SpecialCourtesy []*CodeableConcept `json:"specialcourtesy,omitempty"`
	SpecialArrangement []*CodeableConcept `json:"specialarrangement,omitempty"`
	Destination *Reference `json:"destination,omitempty"`
	DischargeDisposition *CodeableConcept `json:"dischargedisposition,omitempty"`
}

// NewEncounterHospitalization creates a new EncounterHospitalization instance.
func NewEncounterHospitalization() *EncounterHospitalization {
	return &EncounterHospitalization{}
}

// UnmarshalJSON populates EncounterHospitalization from JSON data.
func (m *EncounterHospitalization) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		PreAdmissionIdentifier *Identifier `json:"preadmissionidentifier,omitempty"`
		Origin *Reference `json:"origin,omitempty"`
		AdmitSource *CodeableConcept `json:"admitsource,omitempty"`
		ReAdmission *CodeableConcept `json:"readmission,omitempty"`
		DietPreference []*CodeableConcept `json:"dietpreference,omitempty"`
		SpecialCourtesy []*CodeableConcept `json:"specialcourtesy,omitempty"`
		SpecialArrangement []*CodeableConcept `json:"specialarrangement,omitempty"`
		Destination *Reference `json:"destination,omitempty"`
		DischargeDisposition *CodeableConcept `json:"dischargedisposition,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.PreAdmissionIdentifier = temp.PreAdmissionIdentifier
	m.Origin = temp.Origin
	m.AdmitSource = temp.AdmitSource
	m.ReAdmission = temp.ReAdmission
	m.DietPreference = temp.DietPreference
	m.SpecialCourtesy = temp.SpecialCourtesy
	m.SpecialArrangement = temp.SpecialArrangement
	m.Destination = temp.Destination
	m.DischargeDisposition = temp.DischargeDisposition
	return nil
}

// MarshalJSON converts EncounterHospitalization to JSON data.
func (m *EncounterHospitalization) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		PreAdmissionIdentifier *Identifier `json:"preadmissionidentifier,omitempty"`
		Origin *Reference `json:"origin,omitempty"`
		AdmitSource *CodeableConcept `json:"admitsource,omitempty"`
		ReAdmission *CodeableConcept `json:"readmission,omitempty"`
		DietPreference []*CodeableConcept `json:"dietpreference,omitempty"`
		SpecialCourtesy []*CodeableConcept `json:"specialcourtesy,omitempty"`
		SpecialArrangement []*CodeableConcept `json:"specialarrangement,omitempty"`
		Destination *Reference `json:"destination,omitempty"`
		DischargeDisposition *CodeableConcept `json:"dischargedisposition,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.PreAdmissionIdentifier = m.PreAdmissionIdentifier
	output.Origin = m.Origin
	output.AdmitSource = m.AdmitSource
	output.ReAdmission = m.ReAdmission
	output.DietPreference = m.DietPreference
	output.SpecialCourtesy = m.SpecialCourtesy
	output.SpecialArrangement = m.SpecialArrangement
	output.Destination = m.Destination
	output.DischargeDisposition = m.DischargeDisposition
	return json.Marshal(output)
}

// Clone creates a deep copy of EncounterHospitalization.
func (m *EncounterHospitalization) Clone() *EncounterHospitalization {
	if m == nil { return nil }
	return &EncounterHospitalization{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		PreAdmissionIdentifier: m.PreAdmissionIdentifier.Clone(),
		Origin: m.Origin.Clone(),
		AdmitSource: m.AdmitSource.Clone(),
		ReAdmission: m.ReAdmission.Clone(),
		DietPreference: cloneSlices(m.DietPreference),
		SpecialCourtesy: cloneSlices(m.SpecialCourtesy),
		SpecialArrangement: cloneSlices(m.SpecialArrangement),
		Destination: m.Destination.Clone(),
		DischargeDisposition: m.DischargeDisposition.Clone(),
	}
}

// Equals checks equality between two EncounterHospitalization instances.
func (m *EncounterHospitalization) Equals(other *EncounterHospitalization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.PreAdmissionIdentifier.Equals(other.PreAdmissionIdentifier) { return false }
	if !m.Origin.Equals(other.Origin) { return false }
	if !m.AdmitSource.Equals(other.AdmitSource) { return false }
	if !m.ReAdmission.Equals(other.ReAdmission) { return false }
	if !compareSlices(m.DietPreference, other.DietPreference) { return false }
	if !compareSlices(m.SpecialCourtesy, other.SpecialCourtesy) { return false }
	if !compareSlices(m.SpecialArrangement, other.SpecialArrangement) { return false }
	if !m.Destination.Equals(other.Destination) { return false }
	if !m.DischargeDisposition.Equals(other.DischargeDisposition) { return false }
	return true
}

// EncounterLocation
// List of locations where  the patient has been during this encounter.
type EncounterLocation struct {
	extends BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Status *EncounterLocationStatus `json:"status,omitempty"`
	PhysicalType *CodeableConcept `json:"physicaltype,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewEncounterLocation creates a new EncounterLocation instance.
func NewEncounterLocation() *EncounterLocation {
	return &EncounterLocation{}
}

// UnmarshalJSON populates EncounterLocation from JSON data.
func (m *EncounterLocation) UnmarshalJSON(data []byte) error {
	temp := struct {
		Id *FhirString `json:"id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Location *Reference `json:"location,omitempty"`
		Status *EncounterLocationStatus `json:"status,omitempty"`
		PhysicalType *CodeableConcept `json:"physicaltype,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}
	m.Id = temp.Id
	m.Extension_ = temp.Extension_
	m.ModifierExtension = temp.ModifierExtension
	m.Location = temp.Location
	m.Status = temp.Status
	m.PhysicalType = temp.PhysicalType
	m.Period = temp.Period
	return nil
}

// MarshalJSON converts EncounterLocation to JSON data.
func (m *EncounterLocation) MarshalJSON() ([]byte, error) {
	output := struct {
		Id interface{} `json:"id,omitempty"`
		IdElement map[string]interface{} `json:"_id,omitempty"`
		Extension_ []*FhirExtension `json:"extension,omitempty"`
		ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
		Location *Reference `json:"location,omitempty"`
		Status *EncounterLocationStatus `json:"status,omitempty"`
		PhysicalType *CodeableConcept `json:"physicaltype,omitempty"`
		Period *Period `json:"period,omitempty"`
	}{}
	if m.Id != nil && m.Id.Value != nil {
		output.Id = m.Id.Value
		if m.Id.Element != nil {
			output.IdElement = toMapOrNil(m.Id.Element.MarshalJSON())
		}
	}
	output.Extension_ = m.Extension_
	output.ModifierExtension = m.ModifierExtension
	output.Location = m.Location
	output.Status = m.Status
	output.PhysicalType = m.PhysicalType
	output.Period = m.Period
	return json.Marshal(output)
}

// Clone creates a deep copy of EncounterLocation.
func (m *EncounterLocation) Clone() *EncounterLocation {
	if m == nil { return nil }
	return &EncounterLocation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Location: m.Location.Clone(),
		Status: m.Status.Clone(),
		PhysicalType: m.PhysicalType.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks equality between two EncounterLocation instances.
func (m *EncounterLocation) Equals(other *EncounterLocation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.PhysicalType.Equals(other.PhysicalType) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

