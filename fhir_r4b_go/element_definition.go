// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ElementDefinition
// Captures constraints on each element within the resource, profile, or extension.
type ElementDefinition struct {
	BackboneType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	Representation []*PropertyRepresentation `json:"representation,omitempty"`
	SliceName *FhirString `json:"slicename,omitempty"`
	SliceIsConstraining *FhirBoolean `json:"sliceisconstraining,omitempty"`
	Label *FhirString `json:"label,omitempty"`
	Code []*Coding `json:"code,omitempty"`
	Slicing *ElementDefinitionSlicing `json:"slicing,omitempty"`
	Short *FhirString `json:"short,omitempty"`
	Definition *FhirMarkdown `json:"definition,omitempty"`
	Comment *FhirMarkdown `json:"comment,omitempty"`
	Requirements *FhirMarkdown `json:"requirements,omitempty"`
	Alias []*FhirString `json:"alias,omitempty"`
	Min *FhirUnsignedInt `json:"min,omitempty"`
	Max *FhirString `json:"max,omitempty"`
	Base *ElementDefinitionBase `json:"base,omitempty"`
	ContentReference *FhirUri `json:"contentreference,omitempty"`
	Type []*ElementDefinitionType `json:"type,omitempty"`
	DefaultValueBase64Binary *FhirBase64Binary `json:"defaultvaluebase64binary,omitempty"`
	DefaultValueBoolean *FhirBoolean `json:"defaultvalueboolean,omitempty"`
	DefaultValueCanonical *FhirCanonical `json:"defaultvaluecanonical,omitempty"`
	DefaultValueCode *FhirCode `json:"defaultvaluecode,omitempty"`
	DefaultValueDate *FhirDate `json:"defaultvaluedate,omitempty"`
	DefaultValueDateTime *FhirDateTime `json:"defaultvaluedatetime,omitempty"`
	DefaultValueDecimal *FhirDecimal `json:"defaultvaluedecimal,omitempty"`
	DefaultValueId *FhirId `json:"defaultvalueid,omitempty"`
	DefaultValueInstant *FhirInstant `json:"defaultvalueinstant,omitempty"`
	DefaultValueInteger *FhirInteger `json:"defaultvalueinteger,omitempty"`
	DefaultValueMarkdown *FhirMarkdown `json:"defaultvaluemarkdown,omitempty"`
	DefaultValueOid *FhirOid `json:"defaultvalueoid,omitempty"`
	DefaultValuePositiveInt *FhirPositiveInt `json:"defaultvaluepositiveint,omitempty"`
	DefaultValueString *FhirString `json:"defaultvaluestring,omitempty"`
	DefaultValueTime *FhirTime `json:"defaultvaluetime,omitempty"`
	DefaultValueUnsignedInt *FhirUnsignedInt `json:"defaultvalueunsignedint,omitempty"`
	DefaultValueUri *FhirUri `json:"defaultvalueuri,omitempty"`
	DefaultValueUrl *FhirUrl `json:"defaultvalueurl,omitempty"`
	DefaultValueUuid *FhirUuid `json:"defaultvalueuuid,omitempty"`
	DefaultValueAddress *Address `json:"defaultvalueaddress,omitempty"`
	DefaultValueAge *Age `json:"defaultvalueage,omitempty"`
	DefaultValueAnnotation *Annotation `json:"defaultvalueannotation,omitempty"`
	DefaultValueAttachment *Attachment `json:"defaultvalueattachment,omitempty"`
	DefaultValueCodeableConcept *CodeableConcept `json:"defaultvaluecodeableconcept,omitempty"`
	DefaultValueCodeableReference *CodeableReference `json:"defaultvaluecodeablereference,omitempty"`
	DefaultValueCoding *Coding `json:"defaultvaluecoding,omitempty"`
	DefaultValueContactPoint *ContactPoint `json:"defaultvaluecontactpoint,omitempty"`
	DefaultValueCount *Count `json:"defaultvaluecount,omitempty"`
	DefaultValueDistance *Distance `json:"defaultvaluedistance,omitempty"`
	DefaultValueDuration *FhirDuration `json:"defaultvalueduration,omitempty"`
	DefaultValueHumanName *HumanName `json:"defaultvaluehumanname,omitempty"`
	DefaultValueIdentifier *Identifier `json:"defaultvalueidentifier,omitempty"`
	DefaultValueMoney *Money `json:"defaultvaluemoney,omitempty"`
	DefaultValuePeriod *Period `json:"defaultvalueperiod,omitempty"`
	DefaultValueQuantity *Quantity `json:"defaultvaluequantity,omitempty"`
	DefaultValueRange *Range `json:"defaultvaluerange,omitempty"`
	DefaultValueRatio *Ratio `json:"defaultvalueratio,omitempty"`
	DefaultValueRatioRange *RatioRange `json:"defaultvalueratiorange,omitempty"`
	DefaultValueReference *Reference `json:"defaultvaluereference,omitempty"`
	DefaultValueSampledData *SampledData `json:"defaultvaluesampleddata,omitempty"`
	DefaultValueSignature *Signature `json:"defaultvaluesignature,omitempty"`
	DefaultValueTiming *Timing `json:"defaultvaluetiming,omitempty"`
	DefaultValueContactDetail *ContactDetail `json:"defaultvaluecontactdetail,omitempty"`
	DefaultValueContributor *Contributor `json:"defaultvaluecontributor,omitempty"`
	DefaultValueDataRequirement *DataRequirement `json:"defaultvaluedatarequirement,omitempty"`
	DefaultValueExpression *FhirExpression `json:"defaultvalueexpression,omitempty"`
	DefaultValueParameterDefinition *ParameterDefinition `json:"defaultvalueparameterdefinition,omitempty"`
	DefaultValueRelatedArtifact *RelatedArtifact `json:"defaultvaluerelatedartifact,omitempty"`
	DefaultValueTriggerDefinition *TriggerDefinition `json:"defaultvaluetriggerdefinition,omitempty"`
	DefaultValueUsageContext *UsageContext `json:"defaultvalueusagecontext,omitempty"`
	DefaultValueDosage *Dosage `json:"defaultvaluedosage,omitempty"`
	MeaningWhenMissing *FhirMarkdown `json:"meaningwhenmissing,omitempty"`
	OrderMeaning *FhirString `json:"ordermeaning,omitempty"`
	FixedBase64Binary *FhirBase64Binary `json:"fixedbase64binary,omitempty"`
	FixedBoolean *FhirBoolean `json:"fixedboolean,omitempty"`
	FixedCanonical *FhirCanonical `json:"fixedcanonical,omitempty"`
	FixedCode *FhirCode `json:"fixedcode,omitempty"`
	FixedDate *FhirDate `json:"fixeddate,omitempty"`
	FixedDateTime *FhirDateTime `json:"fixeddatetime,omitempty"`
	FixedDecimal *FhirDecimal `json:"fixeddecimal,omitempty"`
	FixedId *FhirId `json:"fixedid,omitempty"`
	FixedInstant *FhirInstant `json:"fixedinstant,omitempty"`
	FixedInteger *FhirInteger `json:"fixedinteger,omitempty"`
	FixedMarkdown *FhirMarkdown `json:"fixedmarkdown,omitempty"`
	FixedOid *FhirOid `json:"fixedoid,omitempty"`
	FixedPositiveInt *FhirPositiveInt `json:"fixedpositiveint,omitempty"`
	FixedString *FhirString `json:"fixedstring,omitempty"`
	FixedTime *FhirTime `json:"fixedtime,omitempty"`
	FixedUnsignedInt *FhirUnsignedInt `json:"fixedunsignedint,omitempty"`
	FixedUri *FhirUri `json:"fixeduri,omitempty"`
	FixedUrl *FhirUrl `json:"fixedurl,omitempty"`
	FixedUuid *FhirUuid `json:"fixeduuid,omitempty"`
	FixedAddress *Address `json:"fixedaddress,omitempty"`
	FixedAge *Age `json:"fixedage,omitempty"`
	FixedAnnotation *Annotation `json:"fixedannotation,omitempty"`
	FixedAttachment *Attachment `json:"fixedattachment,omitempty"`
	FixedCodeableConcept *CodeableConcept `json:"fixedcodeableconcept,omitempty"`
	FixedCodeableReference *CodeableReference `json:"fixedcodeablereference,omitempty"`
	FixedCoding *Coding `json:"fixedcoding,omitempty"`
	FixedContactPoint *ContactPoint `json:"fixedcontactpoint,omitempty"`
	FixedCount *Count `json:"fixedcount,omitempty"`
	FixedDistance *Distance `json:"fixeddistance,omitempty"`
	FixedDuration *FhirDuration `json:"fixedduration,omitempty"`
	FixedHumanName *HumanName `json:"fixedhumanname,omitempty"`
	FixedIdentifier *Identifier `json:"fixedidentifier,omitempty"`
	FixedMoney *Money `json:"fixedmoney,omitempty"`
	FixedPeriod *Period `json:"fixedperiod,omitempty"`
	FixedQuantity *Quantity `json:"fixedquantity,omitempty"`
	FixedRange *Range `json:"fixedrange,omitempty"`
	FixedRatio *Ratio `json:"fixedratio,omitempty"`
	FixedRatioRange *RatioRange `json:"fixedratiorange,omitempty"`
	FixedReference *Reference `json:"fixedreference,omitempty"`
	FixedSampledData *SampledData `json:"fixedsampleddata,omitempty"`
	FixedSignature *Signature `json:"fixedsignature,omitempty"`
	FixedTiming *Timing `json:"fixedtiming,omitempty"`
	FixedContactDetail *ContactDetail `json:"fixedcontactdetail,omitempty"`
	FixedContributor *Contributor `json:"fixedcontributor,omitempty"`
	FixedDataRequirement *DataRequirement `json:"fixeddatarequirement,omitempty"`
	FixedExpression *FhirExpression `json:"fixedexpression,omitempty"`
	FixedParameterDefinition *ParameterDefinition `json:"fixedparameterdefinition,omitempty"`
	FixedRelatedArtifact *RelatedArtifact `json:"fixedrelatedartifact,omitempty"`
	FixedTriggerDefinition *TriggerDefinition `json:"fixedtriggerdefinition,omitempty"`
	FixedUsageContext *UsageContext `json:"fixedusagecontext,omitempty"`
	FixedDosage *Dosage `json:"fixeddosage,omitempty"`
	PatternBase64Binary *FhirBase64Binary `json:"patternbase64binary,omitempty"`
	PatternBoolean *FhirBoolean `json:"patternboolean,omitempty"`
	PatternCanonical *FhirCanonical `json:"patterncanonical,omitempty"`
	PatternCode *FhirCode `json:"patterncode,omitempty"`
	PatternDate *FhirDate `json:"patterndate,omitempty"`
	PatternDateTime *FhirDateTime `json:"patterndatetime,omitempty"`
	PatternDecimal *FhirDecimal `json:"patterndecimal,omitempty"`
	PatternId *FhirId `json:"patternid,omitempty"`
	PatternInstant *FhirInstant `json:"patterninstant,omitempty"`
	PatternInteger *FhirInteger `json:"patterninteger,omitempty"`
	PatternMarkdown *FhirMarkdown `json:"patternmarkdown,omitempty"`
	PatternOid *FhirOid `json:"patternoid,omitempty"`
	PatternPositiveInt *FhirPositiveInt `json:"patternpositiveint,omitempty"`
	PatternString *FhirString `json:"patternstring,omitempty"`
	PatternTime *FhirTime `json:"patterntime,omitempty"`
	PatternUnsignedInt *FhirUnsignedInt `json:"patternunsignedint,omitempty"`
	PatternUri *FhirUri `json:"patternuri,omitempty"`
	PatternUrl *FhirUrl `json:"patternurl,omitempty"`
	PatternUuid *FhirUuid `json:"patternuuid,omitempty"`
	PatternAddress *Address `json:"patternaddress,omitempty"`
	PatternAge *Age `json:"patternage,omitempty"`
	PatternAnnotation *Annotation `json:"patternannotation,omitempty"`
	PatternAttachment *Attachment `json:"patternattachment,omitempty"`
	PatternCodeableConcept *CodeableConcept `json:"patterncodeableconcept,omitempty"`
	PatternCodeableReference *CodeableReference `json:"patterncodeablereference,omitempty"`
	PatternCoding *Coding `json:"patterncoding,omitempty"`
	PatternContactPoint *ContactPoint `json:"patterncontactpoint,omitempty"`
	PatternCount *Count `json:"patterncount,omitempty"`
	PatternDistance *Distance `json:"patterndistance,omitempty"`
	PatternDuration *FhirDuration `json:"patternduration,omitempty"`
	PatternHumanName *HumanName `json:"patternhumanname,omitempty"`
	PatternIdentifier *Identifier `json:"patternidentifier,omitempty"`
	PatternMoney *Money `json:"patternmoney,omitempty"`
	PatternPeriod *Period `json:"patternperiod,omitempty"`
	PatternQuantity *Quantity `json:"patternquantity,omitempty"`
	PatternRange *Range `json:"patternrange,omitempty"`
	PatternRatio *Ratio `json:"patternratio,omitempty"`
	PatternRatioRange *RatioRange `json:"patternratiorange,omitempty"`
	PatternReference *Reference `json:"patternreference,omitempty"`
	PatternSampledData *SampledData `json:"patternsampleddata,omitempty"`
	PatternSignature *Signature `json:"patternsignature,omitempty"`
	PatternTiming *Timing `json:"patterntiming,omitempty"`
	PatternContactDetail *ContactDetail `json:"patterncontactdetail,omitempty"`
	PatternContributor *Contributor `json:"patterncontributor,omitempty"`
	PatternDataRequirement *DataRequirement `json:"patterndatarequirement,omitempty"`
	PatternExpression *FhirExpression `json:"patternexpression,omitempty"`
	PatternParameterDefinition *ParameterDefinition `json:"patternparameterdefinition,omitempty"`
	PatternRelatedArtifact *RelatedArtifact `json:"patternrelatedartifact,omitempty"`
	PatternTriggerDefinition *TriggerDefinition `json:"patterntriggerdefinition,omitempty"`
	PatternUsageContext *UsageContext `json:"patternusagecontext,omitempty"`
	PatternDosage *Dosage `json:"patterndosage,omitempty"`
	Example []*ElementDefinitionExample `json:"example,omitempty"`
	MinValueDate *FhirDate `json:"minvaluedate,omitempty"`
	MinValueDateTime *FhirDateTime `json:"minvaluedatetime,omitempty"`
	MinValueInstant *FhirInstant `json:"minvalueinstant,omitempty"`
	MinValueTime *FhirTime `json:"minvaluetime,omitempty"`
	MinValueDecimal *FhirDecimal `json:"minvaluedecimal,omitempty"`
	MinValueInteger *FhirInteger `json:"minvalueinteger,omitempty"`
	MinValuePositiveInt *FhirPositiveInt `json:"minvaluepositiveint,omitempty"`
	MinValueUnsignedInt *FhirUnsignedInt `json:"minvalueunsignedint,omitempty"`
	MinValueQuantity *Quantity `json:"minvaluequantity,omitempty"`
	MaxValueDate *FhirDate `json:"maxvaluedate,omitempty"`
	MaxValueDateTime *FhirDateTime `json:"maxvaluedatetime,omitempty"`
	MaxValueInstant *FhirInstant `json:"maxvalueinstant,omitempty"`
	MaxValueTime *FhirTime `json:"maxvaluetime,omitempty"`
	MaxValueDecimal *FhirDecimal `json:"maxvaluedecimal,omitempty"`
	MaxValueInteger *FhirInteger `json:"maxvalueinteger,omitempty"`
	MaxValuePositiveInt *FhirPositiveInt `json:"maxvaluepositiveint,omitempty"`
	MaxValueUnsignedInt *FhirUnsignedInt `json:"maxvalueunsignedint,omitempty"`
	MaxValueQuantity *Quantity `json:"maxvaluequantity,omitempty"`
	MaxLength *FhirInteger `json:"maxlength,omitempty"`
	Condition []*FhirId `json:"condition,omitempty"`
	Constraint []*ElementDefinitionConstraint `json:"constraint,omitempty"`
	MustSupport *FhirBoolean `json:"mustsupport,omitempty"`
	IsModifier *FhirBoolean `json:"ismodifier,omitempty"`
	IsModifierReason *FhirString `json:"ismodifierreason,omitempty"`
	IsSummary *FhirBoolean `json:"issummary,omitempty"`
	Binding *ElementDefinitionBinding `json:"binding,omitempty"`
	Mapping []*ElementDefinitionMapping `json:"mapping,omitempty"`
}

// NewElementDefinition creates a new ElementDefinition instance
func NewElementDefinition() *ElementDefinition {
	return &ElementDefinition{}
}

// FromJSON populates ElementDefinition from JSON data
func (m *ElementDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinition to JSON data
func (m *ElementDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinition
func (m *ElementDefinition) Clone() *ElementDefinition {
	if m == nil { return nil }
	return &ElementDefinition{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Path: m.Path.Clone(),
		Representation: cloneSlices(m.Representation),
		SliceName: m.SliceName.Clone(),
		SliceIsConstraining: m.SliceIsConstraining.Clone(),
		Label: m.Label.Clone(),
		Code: cloneSlices(m.Code),
		Slicing: m.Slicing.Clone(),
		Short: m.Short.Clone(),
		Definition: m.Definition.Clone(),
		Comment: m.Comment.Clone(),
		Requirements: m.Requirements.Clone(),
		Alias: cloneSlices(m.Alias),
		Min: m.Min.Clone(),
		Max: m.Max.Clone(),
		Base: m.Base.Clone(),
		ContentReference: m.ContentReference.Clone(),
		Type: cloneSlices(m.Type),
		DefaultValueBase64Binary: m.DefaultValueBase64Binary.Clone(),
		DefaultValueBoolean: m.DefaultValueBoolean.Clone(),
		DefaultValueCanonical: m.DefaultValueCanonical.Clone(),
		DefaultValueCode: m.DefaultValueCode.Clone(),
		DefaultValueDate: m.DefaultValueDate.Clone(),
		DefaultValueDateTime: m.DefaultValueDateTime.Clone(),
		DefaultValueDecimal: m.DefaultValueDecimal.Clone(),
		DefaultValueId: m.DefaultValueId.Clone(),
		DefaultValueInstant: m.DefaultValueInstant.Clone(),
		DefaultValueInteger: m.DefaultValueInteger.Clone(),
		DefaultValueMarkdown: m.DefaultValueMarkdown.Clone(),
		DefaultValueOid: m.DefaultValueOid.Clone(),
		DefaultValuePositiveInt: m.DefaultValuePositiveInt.Clone(),
		DefaultValueString: m.DefaultValueString.Clone(),
		DefaultValueTime: m.DefaultValueTime.Clone(),
		DefaultValueUnsignedInt: m.DefaultValueUnsignedInt.Clone(),
		DefaultValueUri: m.DefaultValueUri.Clone(),
		DefaultValueUrl: m.DefaultValueUrl.Clone(),
		DefaultValueUuid: m.DefaultValueUuid.Clone(),
		DefaultValueAddress: m.DefaultValueAddress.Clone(),
		DefaultValueAge: m.DefaultValueAge.Clone(),
		DefaultValueAnnotation: m.DefaultValueAnnotation.Clone(),
		DefaultValueAttachment: m.DefaultValueAttachment.Clone(),
		DefaultValueCodeableConcept: m.DefaultValueCodeableConcept.Clone(),
		DefaultValueCodeableReference: m.DefaultValueCodeableReference.Clone(),
		DefaultValueCoding: m.DefaultValueCoding.Clone(),
		DefaultValueContactPoint: m.DefaultValueContactPoint.Clone(),
		DefaultValueCount: m.DefaultValueCount.Clone(),
		DefaultValueDistance: m.DefaultValueDistance.Clone(),
		DefaultValueDuration: m.DefaultValueDuration.Clone(),
		DefaultValueHumanName: m.DefaultValueHumanName.Clone(),
		DefaultValueIdentifier: m.DefaultValueIdentifier.Clone(),
		DefaultValueMoney: m.DefaultValueMoney.Clone(),
		DefaultValuePeriod: m.DefaultValuePeriod.Clone(),
		DefaultValueQuantity: m.DefaultValueQuantity.Clone(),
		DefaultValueRange: m.DefaultValueRange.Clone(),
		DefaultValueRatio: m.DefaultValueRatio.Clone(),
		DefaultValueRatioRange: m.DefaultValueRatioRange.Clone(),
		DefaultValueReference: m.DefaultValueReference.Clone(),
		DefaultValueSampledData: m.DefaultValueSampledData.Clone(),
		DefaultValueSignature: m.DefaultValueSignature.Clone(),
		DefaultValueTiming: m.DefaultValueTiming.Clone(),
		DefaultValueContactDetail: m.DefaultValueContactDetail.Clone(),
		DefaultValueContributor: m.DefaultValueContributor.Clone(),
		DefaultValueDataRequirement: m.DefaultValueDataRequirement.Clone(),
		DefaultValueExpression: m.DefaultValueExpression.Clone(),
		DefaultValueParameterDefinition: m.DefaultValueParameterDefinition.Clone(),
		DefaultValueRelatedArtifact: m.DefaultValueRelatedArtifact.Clone(),
		DefaultValueTriggerDefinition: m.DefaultValueTriggerDefinition.Clone(),
		DefaultValueUsageContext: m.DefaultValueUsageContext.Clone(),
		DefaultValueDosage: m.DefaultValueDosage.Clone(),
		MeaningWhenMissing: m.MeaningWhenMissing.Clone(),
		OrderMeaning: m.OrderMeaning.Clone(),
		FixedBase64Binary: m.FixedBase64Binary.Clone(),
		FixedBoolean: m.FixedBoolean.Clone(),
		FixedCanonical: m.FixedCanonical.Clone(),
		FixedCode: m.FixedCode.Clone(),
		FixedDate: m.FixedDate.Clone(),
		FixedDateTime: m.FixedDateTime.Clone(),
		FixedDecimal: m.FixedDecimal.Clone(),
		FixedId: m.FixedId.Clone(),
		FixedInstant: m.FixedInstant.Clone(),
		FixedInteger: m.FixedInteger.Clone(),
		FixedMarkdown: m.FixedMarkdown.Clone(),
		FixedOid: m.FixedOid.Clone(),
		FixedPositiveInt: m.FixedPositiveInt.Clone(),
		FixedString: m.FixedString.Clone(),
		FixedTime: m.FixedTime.Clone(),
		FixedUnsignedInt: m.FixedUnsignedInt.Clone(),
		FixedUri: m.FixedUri.Clone(),
		FixedUrl: m.FixedUrl.Clone(),
		FixedUuid: m.FixedUuid.Clone(),
		FixedAddress: m.FixedAddress.Clone(),
		FixedAge: m.FixedAge.Clone(),
		FixedAnnotation: m.FixedAnnotation.Clone(),
		FixedAttachment: m.FixedAttachment.Clone(),
		FixedCodeableConcept: m.FixedCodeableConcept.Clone(),
		FixedCodeableReference: m.FixedCodeableReference.Clone(),
		FixedCoding: m.FixedCoding.Clone(),
		FixedContactPoint: m.FixedContactPoint.Clone(),
		FixedCount: m.FixedCount.Clone(),
		FixedDistance: m.FixedDistance.Clone(),
		FixedDuration: m.FixedDuration.Clone(),
		FixedHumanName: m.FixedHumanName.Clone(),
		FixedIdentifier: m.FixedIdentifier.Clone(),
		FixedMoney: m.FixedMoney.Clone(),
		FixedPeriod: m.FixedPeriod.Clone(),
		FixedQuantity: m.FixedQuantity.Clone(),
		FixedRange: m.FixedRange.Clone(),
		FixedRatio: m.FixedRatio.Clone(),
		FixedRatioRange: m.FixedRatioRange.Clone(),
		FixedReference: m.FixedReference.Clone(),
		FixedSampledData: m.FixedSampledData.Clone(),
		FixedSignature: m.FixedSignature.Clone(),
		FixedTiming: m.FixedTiming.Clone(),
		FixedContactDetail: m.FixedContactDetail.Clone(),
		FixedContributor: m.FixedContributor.Clone(),
		FixedDataRequirement: m.FixedDataRequirement.Clone(),
		FixedExpression: m.FixedExpression.Clone(),
		FixedParameterDefinition: m.FixedParameterDefinition.Clone(),
		FixedRelatedArtifact: m.FixedRelatedArtifact.Clone(),
		FixedTriggerDefinition: m.FixedTriggerDefinition.Clone(),
		FixedUsageContext: m.FixedUsageContext.Clone(),
		FixedDosage: m.FixedDosage.Clone(),
		PatternBase64Binary: m.PatternBase64Binary.Clone(),
		PatternBoolean: m.PatternBoolean.Clone(),
		PatternCanonical: m.PatternCanonical.Clone(),
		PatternCode: m.PatternCode.Clone(),
		PatternDate: m.PatternDate.Clone(),
		PatternDateTime: m.PatternDateTime.Clone(),
		PatternDecimal: m.PatternDecimal.Clone(),
		PatternId: m.PatternId.Clone(),
		PatternInstant: m.PatternInstant.Clone(),
		PatternInteger: m.PatternInteger.Clone(),
		PatternMarkdown: m.PatternMarkdown.Clone(),
		PatternOid: m.PatternOid.Clone(),
		PatternPositiveInt: m.PatternPositiveInt.Clone(),
		PatternString: m.PatternString.Clone(),
		PatternTime: m.PatternTime.Clone(),
		PatternUnsignedInt: m.PatternUnsignedInt.Clone(),
		PatternUri: m.PatternUri.Clone(),
		PatternUrl: m.PatternUrl.Clone(),
		PatternUuid: m.PatternUuid.Clone(),
		PatternAddress: m.PatternAddress.Clone(),
		PatternAge: m.PatternAge.Clone(),
		PatternAnnotation: m.PatternAnnotation.Clone(),
		PatternAttachment: m.PatternAttachment.Clone(),
		PatternCodeableConcept: m.PatternCodeableConcept.Clone(),
		PatternCodeableReference: m.PatternCodeableReference.Clone(),
		PatternCoding: m.PatternCoding.Clone(),
		PatternContactPoint: m.PatternContactPoint.Clone(),
		PatternCount: m.PatternCount.Clone(),
		PatternDistance: m.PatternDistance.Clone(),
		PatternDuration: m.PatternDuration.Clone(),
		PatternHumanName: m.PatternHumanName.Clone(),
		PatternIdentifier: m.PatternIdentifier.Clone(),
		PatternMoney: m.PatternMoney.Clone(),
		PatternPeriod: m.PatternPeriod.Clone(),
		PatternQuantity: m.PatternQuantity.Clone(),
		PatternRange: m.PatternRange.Clone(),
		PatternRatio: m.PatternRatio.Clone(),
		PatternRatioRange: m.PatternRatioRange.Clone(),
		PatternReference: m.PatternReference.Clone(),
		PatternSampledData: m.PatternSampledData.Clone(),
		PatternSignature: m.PatternSignature.Clone(),
		PatternTiming: m.PatternTiming.Clone(),
		PatternContactDetail: m.PatternContactDetail.Clone(),
		PatternContributor: m.PatternContributor.Clone(),
		PatternDataRequirement: m.PatternDataRequirement.Clone(),
		PatternExpression: m.PatternExpression.Clone(),
		PatternParameterDefinition: m.PatternParameterDefinition.Clone(),
		PatternRelatedArtifact: m.PatternRelatedArtifact.Clone(),
		PatternTriggerDefinition: m.PatternTriggerDefinition.Clone(),
		PatternUsageContext: m.PatternUsageContext.Clone(),
		PatternDosage: m.PatternDosage.Clone(),
		Example: cloneSlices(m.Example),
		MinValueDate: m.MinValueDate.Clone(),
		MinValueDateTime: m.MinValueDateTime.Clone(),
		MinValueInstant: m.MinValueInstant.Clone(),
		MinValueTime: m.MinValueTime.Clone(),
		MinValueDecimal: m.MinValueDecimal.Clone(),
		MinValueInteger: m.MinValueInteger.Clone(),
		MinValuePositiveInt: m.MinValuePositiveInt.Clone(),
		MinValueUnsignedInt: m.MinValueUnsignedInt.Clone(),
		MinValueQuantity: m.MinValueQuantity.Clone(),
		MaxValueDate: m.MaxValueDate.Clone(),
		MaxValueDateTime: m.MaxValueDateTime.Clone(),
		MaxValueInstant: m.MaxValueInstant.Clone(),
		MaxValueTime: m.MaxValueTime.Clone(),
		MaxValueDecimal: m.MaxValueDecimal.Clone(),
		MaxValueInteger: m.MaxValueInteger.Clone(),
		MaxValuePositiveInt: m.MaxValuePositiveInt.Clone(),
		MaxValueUnsignedInt: m.MaxValueUnsignedInt.Clone(),
		MaxValueQuantity: m.MaxValueQuantity.Clone(),
		MaxLength: m.MaxLength.Clone(),
		Condition: cloneSlices(m.Condition),
		Constraint: cloneSlices(m.Constraint),
		MustSupport: m.MustSupport.Clone(),
		IsModifier: m.IsModifier.Clone(),
		IsModifierReason: m.IsModifierReason.Clone(),
		IsSummary: m.IsSummary.Clone(),
		Binding: m.Binding.Clone(),
		Mapping: cloneSlices(m.Mapping),
	}
}

// Equals checks for equality with another ElementDefinition instance
func (m *ElementDefinition) Equals(other *ElementDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !compareSlices(m.Representation, other.Representation) { return false }
	if !m.SliceName.Equals(other.SliceName) { return false }
	if !m.SliceIsConstraining.Equals(other.SliceIsConstraining) { return false }
	if !m.Label.Equals(other.Label) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !m.Slicing.Equals(other.Slicing) { return false }
	if !m.Short.Equals(other.Short) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	if !m.Comment.Equals(other.Comment) { return false }
	if !m.Requirements.Equals(other.Requirements) { return false }
	if !compareSlices(m.Alias, other.Alias) { return false }
	if !m.Min.Equals(other.Min) { return false }
	if !m.Max.Equals(other.Max) { return false }
	if !m.Base.Equals(other.Base) { return false }
	if !m.ContentReference.Equals(other.ContentReference) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.DefaultValueBase64Binary.Equals(other.DefaultValueBase64Binary) { return false }
	if !m.DefaultValueBoolean.Equals(other.DefaultValueBoolean) { return false }
	if !m.DefaultValueCanonical.Equals(other.DefaultValueCanonical) { return false }
	if !m.DefaultValueCode.Equals(other.DefaultValueCode) { return false }
	if !m.DefaultValueDate.Equals(other.DefaultValueDate) { return false }
	if !m.DefaultValueDateTime.Equals(other.DefaultValueDateTime) { return false }
	if !m.DefaultValueDecimal.Equals(other.DefaultValueDecimal) { return false }
	if !m.DefaultValueId.Equals(other.DefaultValueId) { return false }
	if !m.DefaultValueInstant.Equals(other.DefaultValueInstant) { return false }
	if !m.DefaultValueInteger.Equals(other.DefaultValueInteger) { return false }
	if !m.DefaultValueMarkdown.Equals(other.DefaultValueMarkdown) { return false }
	if !m.DefaultValueOid.Equals(other.DefaultValueOid) { return false }
	if !m.DefaultValuePositiveInt.Equals(other.DefaultValuePositiveInt) { return false }
	if !m.DefaultValueString.Equals(other.DefaultValueString) { return false }
	if !m.DefaultValueTime.Equals(other.DefaultValueTime) { return false }
	if !m.DefaultValueUnsignedInt.Equals(other.DefaultValueUnsignedInt) { return false }
	if !m.DefaultValueUri.Equals(other.DefaultValueUri) { return false }
	if !m.DefaultValueUrl.Equals(other.DefaultValueUrl) { return false }
	if !m.DefaultValueUuid.Equals(other.DefaultValueUuid) { return false }
	if !m.DefaultValueAddress.Equals(other.DefaultValueAddress) { return false }
	if !m.DefaultValueAge.Equals(other.DefaultValueAge) { return false }
	if !m.DefaultValueAnnotation.Equals(other.DefaultValueAnnotation) { return false }
	if !m.DefaultValueAttachment.Equals(other.DefaultValueAttachment) { return false }
	if !m.DefaultValueCodeableConcept.Equals(other.DefaultValueCodeableConcept) { return false }
	if !m.DefaultValueCodeableReference.Equals(other.DefaultValueCodeableReference) { return false }
	if !m.DefaultValueCoding.Equals(other.DefaultValueCoding) { return false }
	if !m.DefaultValueContactPoint.Equals(other.DefaultValueContactPoint) { return false }
	if !m.DefaultValueCount.Equals(other.DefaultValueCount) { return false }
	if !m.DefaultValueDistance.Equals(other.DefaultValueDistance) { return false }
	if !m.DefaultValueDuration.Equals(other.DefaultValueDuration) { return false }
	if !m.DefaultValueHumanName.Equals(other.DefaultValueHumanName) { return false }
	if !m.DefaultValueIdentifier.Equals(other.DefaultValueIdentifier) { return false }
	if !m.DefaultValueMoney.Equals(other.DefaultValueMoney) { return false }
	if !m.DefaultValuePeriod.Equals(other.DefaultValuePeriod) { return false }
	if !m.DefaultValueQuantity.Equals(other.DefaultValueQuantity) { return false }
	if !m.DefaultValueRange.Equals(other.DefaultValueRange) { return false }
	if !m.DefaultValueRatio.Equals(other.DefaultValueRatio) { return false }
	if !m.DefaultValueRatioRange.Equals(other.DefaultValueRatioRange) { return false }
	if !m.DefaultValueReference.Equals(other.DefaultValueReference) { return false }
	if !m.DefaultValueSampledData.Equals(other.DefaultValueSampledData) { return false }
	if !m.DefaultValueSignature.Equals(other.DefaultValueSignature) { return false }
	if !m.DefaultValueTiming.Equals(other.DefaultValueTiming) { return false }
	if !m.DefaultValueContactDetail.Equals(other.DefaultValueContactDetail) { return false }
	if !m.DefaultValueContributor.Equals(other.DefaultValueContributor) { return false }
	if !m.DefaultValueDataRequirement.Equals(other.DefaultValueDataRequirement) { return false }
	if !m.DefaultValueExpression.Equals(other.DefaultValueExpression) { return false }
	if !m.DefaultValueParameterDefinition.Equals(other.DefaultValueParameterDefinition) { return false }
	if !m.DefaultValueRelatedArtifact.Equals(other.DefaultValueRelatedArtifact) { return false }
	if !m.DefaultValueTriggerDefinition.Equals(other.DefaultValueTriggerDefinition) { return false }
	if !m.DefaultValueUsageContext.Equals(other.DefaultValueUsageContext) { return false }
	if !m.DefaultValueDosage.Equals(other.DefaultValueDosage) { return false }
	if !m.MeaningWhenMissing.Equals(other.MeaningWhenMissing) { return false }
	if !m.OrderMeaning.Equals(other.OrderMeaning) { return false }
	if !m.FixedBase64Binary.Equals(other.FixedBase64Binary) { return false }
	if !m.FixedBoolean.Equals(other.FixedBoolean) { return false }
	if !m.FixedCanonical.Equals(other.FixedCanonical) { return false }
	if !m.FixedCode.Equals(other.FixedCode) { return false }
	if !m.FixedDate.Equals(other.FixedDate) { return false }
	if !m.FixedDateTime.Equals(other.FixedDateTime) { return false }
	if !m.FixedDecimal.Equals(other.FixedDecimal) { return false }
	if !m.FixedId.Equals(other.FixedId) { return false }
	if !m.FixedInstant.Equals(other.FixedInstant) { return false }
	if !m.FixedInteger.Equals(other.FixedInteger) { return false }
	if !m.FixedMarkdown.Equals(other.FixedMarkdown) { return false }
	if !m.FixedOid.Equals(other.FixedOid) { return false }
	if !m.FixedPositiveInt.Equals(other.FixedPositiveInt) { return false }
	if !m.FixedString.Equals(other.FixedString) { return false }
	if !m.FixedTime.Equals(other.FixedTime) { return false }
	if !m.FixedUnsignedInt.Equals(other.FixedUnsignedInt) { return false }
	if !m.FixedUri.Equals(other.FixedUri) { return false }
	if !m.FixedUrl.Equals(other.FixedUrl) { return false }
	if !m.FixedUuid.Equals(other.FixedUuid) { return false }
	if !m.FixedAddress.Equals(other.FixedAddress) { return false }
	if !m.FixedAge.Equals(other.FixedAge) { return false }
	if !m.FixedAnnotation.Equals(other.FixedAnnotation) { return false }
	if !m.FixedAttachment.Equals(other.FixedAttachment) { return false }
	if !m.FixedCodeableConcept.Equals(other.FixedCodeableConcept) { return false }
	if !m.FixedCodeableReference.Equals(other.FixedCodeableReference) { return false }
	if !m.FixedCoding.Equals(other.FixedCoding) { return false }
	if !m.FixedContactPoint.Equals(other.FixedContactPoint) { return false }
	if !m.FixedCount.Equals(other.FixedCount) { return false }
	if !m.FixedDistance.Equals(other.FixedDistance) { return false }
	if !m.FixedDuration.Equals(other.FixedDuration) { return false }
	if !m.FixedHumanName.Equals(other.FixedHumanName) { return false }
	if !m.FixedIdentifier.Equals(other.FixedIdentifier) { return false }
	if !m.FixedMoney.Equals(other.FixedMoney) { return false }
	if !m.FixedPeriod.Equals(other.FixedPeriod) { return false }
	if !m.FixedQuantity.Equals(other.FixedQuantity) { return false }
	if !m.FixedRange.Equals(other.FixedRange) { return false }
	if !m.FixedRatio.Equals(other.FixedRatio) { return false }
	if !m.FixedRatioRange.Equals(other.FixedRatioRange) { return false }
	if !m.FixedReference.Equals(other.FixedReference) { return false }
	if !m.FixedSampledData.Equals(other.FixedSampledData) { return false }
	if !m.FixedSignature.Equals(other.FixedSignature) { return false }
	if !m.FixedTiming.Equals(other.FixedTiming) { return false }
	if !m.FixedContactDetail.Equals(other.FixedContactDetail) { return false }
	if !m.FixedContributor.Equals(other.FixedContributor) { return false }
	if !m.FixedDataRequirement.Equals(other.FixedDataRequirement) { return false }
	if !m.FixedExpression.Equals(other.FixedExpression) { return false }
	if !m.FixedParameterDefinition.Equals(other.FixedParameterDefinition) { return false }
	if !m.FixedRelatedArtifact.Equals(other.FixedRelatedArtifact) { return false }
	if !m.FixedTriggerDefinition.Equals(other.FixedTriggerDefinition) { return false }
	if !m.FixedUsageContext.Equals(other.FixedUsageContext) { return false }
	if !m.FixedDosage.Equals(other.FixedDosage) { return false }
	if !m.PatternBase64Binary.Equals(other.PatternBase64Binary) { return false }
	if !m.PatternBoolean.Equals(other.PatternBoolean) { return false }
	if !m.PatternCanonical.Equals(other.PatternCanonical) { return false }
	if !m.PatternCode.Equals(other.PatternCode) { return false }
	if !m.PatternDate.Equals(other.PatternDate) { return false }
	if !m.PatternDateTime.Equals(other.PatternDateTime) { return false }
	if !m.PatternDecimal.Equals(other.PatternDecimal) { return false }
	if !m.PatternId.Equals(other.PatternId) { return false }
	if !m.PatternInstant.Equals(other.PatternInstant) { return false }
	if !m.PatternInteger.Equals(other.PatternInteger) { return false }
	if !m.PatternMarkdown.Equals(other.PatternMarkdown) { return false }
	if !m.PatternOid.Equals(other.PatternOid) { return false }
	if !m.PatternPositiveInt.Equals(other.PatternPositiveInt) { return false }
	if !m.PatternString.Equals(other.PatternString) { return false }
	if !m.PatternTime.Equals(other.PatternTime) { return false }
	if !m.PatternUnsignedInt.Equals(other.PatternUnsignedInt) { return false }
	if !m.PatternUri.Equals(other.PatternUri) { return false }
	if !m.PatternUrl.Equals(other.PatternUrl) { return false }
	if !m.PatternUuid.Equals(other.PatternUuid) { return false }
	if !m.PatternAddress.Equals(other.PatternAddress) { return false }
	if !m.PatternAge.Equals(other.PatternAge) { return false }
	if !m.PatternAnnotation.Equals(other.PatternAnnotation) { return false }
	if !m.PatternAttachment.Equals(other.PatternAttachment) { return false }
	if !m.PatternCodeableConcept.Equals(other.PatternCodeableConcept) { return false }
	if !m.PatternCodeableReference.Equals(other.PatternCodeableReference) { return false }
	if !m.PatternCoding.Equals(other.PatternCoding) { return false }
	if !m.PatternContactPoint.Equals(other.PatternContactPoint) { return false }
	if !m.PatternCount.Equals(other.PatternCount) { return false }
	if !m.PatternDistance.Equals(other.PatternDistance) { return false }
	if !m.PatternDuration.Equals(other.PatternDuration) { return false }
	if !m.PatternHumanName.Equals(other.PatternHumanName) { return false }
	if !m.PatternIdentifier.Equals(other.PatternIdentifier) { return false }
	if !m.PatternMoney.Equals(other.PatternMoney) { return false }
	if !m.PatternPeriod.Equals(other.PatternPeriod) { return false }
	if !m.PatternQuantity.Equals(other.PatternQuantity) { return false }
	if !m.PatternRange.Equals(other.PatternRange) { return false }
	if !m.PatternRatio.Equals(other.PatternRatio) { return false }
	if !m.PatternRatioRange.Equals(other.PatternRatioRange) { return false }
	if !m.PatternReference.Equals(other.PatternReference) { return false }
	if !m.PatternSampledData.Equals(other.PatternSampledData) { return false }
	if !m.PatternSignature.Equals(other.PatternSignature) { return false }
	if !m.PatternTiming.Equals(other.PatternTiming) { return false }
	if !m.PatternContactDetail.Equals(other.PatternContactDetail) { return false }
	if !m.PatternContributor.Equals(other.PatternContributor) { return false }
	if !m.PatternDataRequirement.Equals(other.PatternDataRequirement) { return false }
	if !m.PatternExpression.Equals(other.PatternExpression) { return false }
	if !m.PatternParameterDefinition.Equals(other.PatternParameterDefinition) { return false }
	if !m.PatternRelatedArtifact.Equals(other.PatternRelatedArtifact) { return false }
	if !m.PatternTriggerDefinition.Equals(other.PatternTriggerDefinition) { return false }
	if !m.PatternUsageContext.Equals(other.PatternUsageContext) { return false }
	if !m.PatternDosage.Equals(other.PatternDosage) { return false }
	if !compareSlices(m.Example, other.Example) { return false }
	if !m.MinValueDate.Equals(other.MinValueDate) { return false }
	if !m.MinValueDateTime.Equals(other.MinValueDateTime) { return false }
	if !m.MinValueInstant.Equals(other.MinValueInstant) { return false }
	if !m.MinValueTime.Equals(other.MinValueTime) { return false }
	if !m.MinValueDecimal.Equals(other.MinValueDecimal) { return false }
	if !m.MinValueInteger.Equals(other.MinValueInteger) { return false }
	if !m.MinValuePositiveInt.Equals(other.MinValuePositiveInt) { return false }
	if !m.MinValueUnsignedInt.Equals(other.MinValueUnsignedInt) { return false }
	if !m.MinValueQuantity.Equals(other.MinValueQuantity) { return false }
	if !m.MaxValueDate.Equals(other.MaxValueDate) { return false }
	if !m.MaxValueDateTime.Equals(other.MaxValueDateTime) { return false }
	if !m.MaxValueInstant.Equals(other.MaxValueInstant) { return false }
	if !m.MaxValueTime.Equals(other.MaxValueTime) { return false }
	if !m.MaxValueDecimal.Equals(other.MaxValueDecimal) { return false }
	if !m.MaxValueInteger.Equals(other.MaxValueInteger) { return false }
	if !m.MaxValuePositiveInt.Equals(other.MaxValuePositiveInt) { return false }
	if !m.MaxValueUnsignedInt.Equals(other.MaxValueUnsignedInt) { return false }
	if !m.MaxValueQuantity.Equals(other.MaxValueQuantity) { return false }
	if !m.MaxLength.Equals(other.MaxLength) { return false }
	if !compareSlices(m.Condition, other.Condition) { return false }
	if !compareSlices(m.Constraint, other.Constraint) { return false }
	if !m.MustSupport.Equals(other.MustSupport) { return false }
	if !m.IsModifier.Equals(other.IsModifier) { return false }
	if !m.IsModifierReason.Equals(other.IsModifierReason) { return false }
	if !m.IsSummary.Equals(other.IsSummary) { return false }
	if !m.Binding.Equals(other.Binding) { return false }
	if !compareSlices(m.Mapping, other.Mapping) { return false }
	return true
}

// ElementDefinitionSlicing
// Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
type ElementDefinitionSlicing struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Discriminator []*ElementDefinitionDiscriminator `json:"discriminator,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Ordered *FhirBoolean `json:"ordered,omitempty"`
	Rules *SlicingRules `json:"rules,omitempty"`
}

// NewElementDefinitionSlicing creates a new ElementDefinitionSlicing instance
func NewElementDefinitionSlicing() *ElementDefinitionSlicing {
	return &ElementDefinitionSlicing{}
}

// FromJSON populates ElementDefinitionSlicing from JSON data
func (m *ElementDefinitionSlicing) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionSlicing to JSON data
func (m *ElementDefinitionSlicing) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionSlicing
func (m *ElementDefinitionSlicing) Clone() *ElementDefinitionSlicing {
	if m == nil { return nil }
	return &ElementDefinitionSlicing{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Discriminator: cloneSlices(m.Discriminator),
		Description: m.Description.Clone(),
		Ordered: m.Ordered.Clone(),
		Rules: m.Rules.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionSlicing instance
func (m *ElementDefinitionSlicing) Equals(other *ElementDefinitionSlicing) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.Discriminator, other.Discriminator) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Ordered.Equals(other.Ordered) { return false }
	if !m.Rules.Equals(other.Rules) { return false }
	return true
}

// ElementDefinitionDiscriminator
// Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
type ElementDefinitionDiscriminator struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Type *DiscriminatorType `json:"type,omitempty"`
	Path *FhirString `json:"path,omitempty"`
}

// NewElementDefinitionDiscriminator creates a new ElementDefinitionDiscriminator instance
func NewElementDefinitionDiscriminator() *ElementDefinitionDiscriminator {
	return &ElementDefinitionDiscriminator{}
}

// FromJSON populates ElementDefinitionDiscriminator from JSON data
func (m *ElementDefinitionDiscriminator) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionDiscriminator to JSON data
func (m *ElementDefinitionDiscriminator) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionDiscriminator
func (m *ElementDefinitionDiscriminator) Clone() *ElementDefinitionDiscriminator {
	if m == nil { return nil }
	return &ElementDefinitionDiscriminator{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Type: m.Type.Clone(),
		Path: m.Path.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionDiscriminator instance
func (m *ElementDefinitionDiscriminator) Equals(other *ElementDefinitionDiscriminator) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Path.Equals(other.Path) { return false }
	return true
}

// ElementDefinitionBase
// Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - i.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
type ElementDefinitionBase struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	Min *FhirUnsignedInt `json:"min,omitempty"`
	Max *FhirString `json:"max,omitempty"`
}

// NewElementDefinitionBase creates a new ElementDefinitionBase instance
func NewElementDefinitionBase() *ElementDefinitionBase {
	return &ElementDefinitionBase{}
}

// FromJSON populates ElementDefinitionBase from JSON data
func (m *ElementDefinitionBase) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionBase to JSON data
func (m *ElementDefinitionBase) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionBase
func (m *ElementDefinitionBase) Clone() *ElementDefinitionBase {
	if m == nil { return nil }
	return &ElementDefinitionBase{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Path: m.Path.Clone(),
		Min: m.Min.Clone(),
		Max: m.Max.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionBase instance
func (m *ElementDefinitionBase) Equals(other *ElementDefinitionBase) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !m.Min.Equals(other.Min) { return false }
	if !m.Max.Equals(other.Max) { return false }
	return true
}

// ElementDefinitionType
// The data type or resource that the value of this element is permitted to be.
type ElementDefinitionType struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Code *FhirUri `json:"code,omitempty"`
	Profile []*FhirCanonical `json:"profile,omitempty"`
	TargetProfile []*FhirCanonical `json:"targetprofile,omitempty"`
	Aggregation []*AggregationMode `json:"aggregation,omitempty"`
	Versioning *ReferenceVersionRules `json:"versioning,omitempty"`
}

// NewElementDefinitionType creates a new ElementDefinitionType instance
func NewElementDefinitionType() *ElementDefinitionType {
	return &ElementDefinitionType{}
}

// FromJSON populates ElementDefinitionType from JSON data
func (m *ElementDefinitionType) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionType to JSON data
func (m *ElementDefinitionType) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionType
func (m *ElementDefinitionType) Clone() *ElementDefinitionType {
	if m == nil { return nil }
	return &ElementDefinitionType{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Code: m.Code.Clone(),
		Profile: cloneSlices(m.Profile),
		TargetProfile: cloneSlices(m.TargetProfile),
		Aggregation: cloneSlices(m.Aggregation),
		Versioning: m.Versioning.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionType instance
func (m *ElementDefinitionType) Equals(other *ElementDefinitionType) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.Profile, other.Profile) { return false }
	if !compareSlices(m.TargetProfile, other.TargetProfile) { return false }
	if !compareSlices(m.Aggregation, other.Aggregation) { return false }
	if !m.Versioning.Equals(other.Versioning) { return false }
	return true
}

// ElementDefinitionExample
// A sample value for this element demonstrating the type of information that would typically be found in the element.
type ElementDefinitionExample struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Label *FhirString `json:"label,omitempty"`
	ValueBase64Binary *FhirBase64Binary `json:"valuebase64binary,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueCanonical *FhirCanonical `json:"valuecanonical,omitempty"`
	ValueCode *FhirCode `json:"valuecode,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueId *FhirId `json:"valueid,omitempty"`
	ValueInstant *FhirInstant `json:"valueinstant,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueMarkdown *FhirMarkdown `json:"valuemarkdown,omitempty"`
	ValueOid *FhirOid `json:"valueoid,omitempty"`
	ValuePositiveInt *FhirPositiveInt `json:"valuepositiveint,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueUnsignedInt *FhirUnsignedInt `json:"valueunsignedint,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueUrl *FhirUrl `json:"valueurl,omitempty"`
	ValueUuid *FhirUuid `json:"valueuuid,omitempty"`
	ValueAddress *Address `json:"valueaddress,omitempty"`
	ValueAge *Age `json:"valueage,omitempty"`
	ValueAnnotation *Annotation `json:"valueannotation,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueCodeableReference *CodeableReference `json:"valuecodeablereference,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueContactPoint *ContactPoint `json:"valuecontactpoint,omitempty"`
	ValueCount *Count `json:"valuecount,omitempty"`
	ValueDistance *Distance `json:"valuedistance,omitempty"`
	ValueDuration *FhirDuration `json:"valueduration,omitempty"`
	ValueHumanName *HumanName `json:"valuehumanname,omitempty"`
	ValueIdentifier *Identifier `json:"valueidentifier,omitempty"`
	ValueMoney *Money `json:"valuemoney,omitempty"`
	ValuePeriod *Period `json:"valueperiod,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueRange *Range `json:"valuerange,omitempty"`
	ValueRatio *Ratio `json:"valueratio,omitempty"`
	ValueRatioRange *RatioRange `json:"valueratiorange,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	ValueSampledData *SampledData `json:"valuesampleddata,omitempty"`
	ValueSignature *Signature `json:"valuesignature,omitempty"`
	ValueTiming *Timing `json:"valuetiming,omitempty"`
	ValueContactDetail *ContactDetail `json:"valuecontactdetail,omitempty"`
	ValueContributor *Contributor `json:"valuecontributor,omitempty"`
	ValueDataRequirement *DataRequirement `json:"valuedatarequirement,omitempty"`
	ValueExpression *FhirExpression `json:"valueexpression,omitempty"`
	ValueParameterDefinition *ParameterDefinition `json:"valueparameterdefinition,omitempty"`
	ValueRelatedArtifact *RelatedArtifact `json:"valuerelatedartifact,omitempty"`
	ValueTriggerDefinition *TriggerDefinition `json:"valuetriggerdefinition,omitempty"`
	ValueUsageContext *UsageContext `json:"valueusagecontext,omitempty"`
	ValueDosage *Dosage `json:"valuedosage,omitempty"`
}

// NewElementDefinitionExample creates a new ElementDefinitionExample instance
func NewElementDefinitionExample() *ElementDefinitionExample {
	return &ElementDefinitionExample{}
}

// FromJSON populates ElementDefinitionExample from JSON data
func (m *ElementDefinitionExample) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionExample to JSON data
func (m *ElementDefinitionExample) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionExample
func (m *ElementDefinitionExample) Clone() *ElementDefinitionExample {
	if m == nil { return nil }
	return &ElementDefinitionExample{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Label: m.Label.Clone(),
		ValueBase64Binary: m.ValueBase64Binary.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueCanonical: m.ValueCanonical.Clone(),
		ValueCode: m.ValueCode.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueId: m.ValueId.Clone(),
		ValueInstant: m.ValueInstant.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueMarkdown: m.ValueMarkdown.Clone(),
		ValueOid: m.ValueOid.Clone(),
		ValuePositiveInt: m.ValuePositiveInt.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueUnsignedInt: m.ValueUnsignedInt.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueUrl: m.ValueUrl.Clone(),
		ValueUuid: m.ValueUuid.Clone(),
		ValueAddress: m.ValueAddress.Clone(),
		ValueAge: m.ValueAge.Clone(),
		ValueAnnotation: m.ValueAnnotation.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueCodeableReference: m.ValueCodeableReference.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueContactPoint: m.ValueContactPoint.Clone(),
		ValueCount: m.ValueCount.Clone(),
		ValueDistance: m.ValueDistance.Clone(),
		ValueDuration: m.ValueDuration.Clone(),
		ValueHumanName: m.ValueHumanName.Clone(),
		ValueIdentifier: m.ValueIdentifier.Clone(),
		ValueMoney: m.ValueMoney.Clone(),
		ValuePeriod: m.ValuePeriod.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueRange: m.ValueRange.Clone(),
		ValueRatio: m.ValueRatio.Clone(),
		ValueRatioRange: m.ValueRatioRange.Clone(),
		ValueReference: m.ValueReference.Clone(),
		ValueSampledData: m.ValueSampledData.Clone(),
		ValueSignature: m.ValueSignature.Clone(),
		ValueTiming: m.ValueTiming.Clone(),
		ValueContactDetail: m.ValueContactDetail.Clone(),
		ValueContributor: m.ValueContributor.Clone(),
		ValueDataRequirement: m.ValueDataRequirement.Clone(),
		ValueExpression: m.ValueExpression.Clone(),
		ValueParameterDefinition: m.ValueParameterDefinition.Clone(),
		ValueRelatedArtifact: m.ValueRelatedArtifact.Clone(),
		ValueTriggerDefinition: m.ValueTriggerDefinition.Clone(),
		ValueUsageContext: m.ValueUsageContext.Clone(),
		ValueDosage: m.ValueDosage.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionExample instance
func (m *ElementDefinitionExample) Equals(other *ElementDefinitionExample) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Label.Equals(other.Label) { return false }
	if !m.ValueBase64Binary.Equals(other.ValueBase64Binary) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueCanonical.Equals(other.ValueCanonical) { return false }
	if !m.ValueCode.Equals(other.ValueCode) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueId.Equals(other.ValueId) { return false }
	if !m.ValueInstant.Equals(other.ValueInstant) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueMarkdown.Equals(other.ValueMarkdown) { return false }
	if !m.ValueOid.Equals(other.ValueOid) { return false }
	if !m.ValuePositiveInt.Equals(other.ValuePositiveInt) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueUnsignedInt.Equals(other.ValueUnsignedInt) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueUrl.Equals(other.ValueUrl) { return false }
	if !m.ValueUuid.Equals(other.ValueUuid) { return false }
	if !m.ValueAddress.Equals(other.ValueAddress) { return false }
	if !m.ValueAge.Equals(other.ValueAge) { return false }
	if !m.ValueAnnotation.Equals(other.ValueAnnotation) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueCodeableReference.Equals(other.ValueCodeableReference) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueContactPoint.Equals(other.ValueContactPoint) { return false }
	if !m.ValueCount.Equals(other.ValueCount) { return false }
	if !m.ValueDistance.Equals(other.ValueDistance) { return false }
	if !m.ValueDuration.Equals(other.ValueDuration) { return false }
	if !m.ValueHumanName.Equals(other.ValueHumanName) { return false }
	if !m.ValueIdentifier.Equals(other.ValueIdentifier) { return false }
	if !m.ValueMoney.Equals(other.ValueMoney) { return false }
	if !m.ValuePeriod.Equals(other.ValuePeriod) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueRange.Equals(other.ValueRange) { return false }
	if !m.ValueRatio.Equals(other.ValueRatio) { return false }
	if !m.ValueRatioRange.Equals(other.ValueRatioRange) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !m.ValueSampledData.Equals(other.ValueSampledData) { return false }
	if !m.ValueSignature.Equals(other.ValueSignature) { return false }
	if !m.ValueTiming.Equals(other.ValueTiming) { return false }
	if !m.ValueContactDetail.Equals(other.ValueContactDetail) { return false }
	if !m.ValueContributor.Equals(other.ValueContributor) { return false }
	if !m.ValueDataRequirement.Equals(other.ValueDataRequirement) { return false }
	if !m.ValueExpression.Equals(other.ValueExpression) { return false }
	if !m.ValueParameterDefinition.Equals(other.ValueParameterDefinition) { return false }
	if !m.ValueRelatedArtifact.Equals(other.ValueRelatedArtifact) { return false }
	if !m.ValueTriggerDefinition.Equals(other.ValueTriggerDefinition) { return false }
	if !m.ValueUsageContext.Equals(other.ValueUsageContext) { return false }
	if !m.ValueDosage.Equals(other.ValueDosage) { return false }
	return true
}

// ElementDefinitionConstraint
// Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
type ElementDefinitionConstraint struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Key *FhirId `json:"key,omitempty"`
	Requirements *FhirString `json:"requirements,omitempty"`
	Severity *ConstraintSeverity `json:"severity,omitempty"`
	Human *FhirString `json:"human,omitempty"`
	Expression *FhirString `json:"expression,omitempty"`
	Xpath *FhirString `json:"xpath,omitempty"`
	Source *FhirCanonical `json:"source,omitempty"`
}

// NewElementDefinitionConstraint creates a new ElementDefinitionConstraint instance
func NewElementDefinitionConstraint() *ElementDefinitionConstraint {
	return &ElementDefinitionConstraint{}
}

// FromJSON populates ElementDefinitionConstraint from JSON data
func (m *ElementDefinitionConstraint) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionConstraint to JSON data
func (m *ElementDefinitionConstraint) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionConstraint
func (m *ElementDefinitionConstraint) Clone() *ElementDefinitionConstraint {
	if m == nil { return nil }
	return &ElementDefinitionConstraint{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Key: m.Key.Clone(),
		Requirements: m.Requirements.Clone(),
		Severity: m.Severity.Clone(),
		Human: m.Human.Clone(),
		Expression: m.Expression.Clone(),
		Xpath: m.Xpath.Clone(),
		Source: m.Source.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionConstraint instance
func (m *ElementDefinitionConstraint) Equals(other *ElementDefinitionConstraint) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Key.Equals(other.Key) { return false }
	if !m.Requirements.Equals(other.Requirements) { return false }
	if !m.Severity.Equals(other.Severity) { return false }
	if !m.Human.Equals(other.Human) { return false }
	if !m.Expression.Equals(other.Expression) { return false }
	if !m.Xpath.Equals(other.Xpath) { return false }
	if !m.Source.Equals(other.Source) { return false }
	return true
}

// ElementDefinitionBinding
// Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
type ElementDefinitionBinding struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Strength *BindingStrength `json:"strength,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	ValueSet *FhirCanonical `json:"valueset,omitempty"`
}

// NewElementDefinitionBinding creates a new ElementDefinitionBinding instance
func NewElementDefinitionBinding() *ElementDefinitionBinding {
	return &ElementDefinitionBinding{}
}

// FromJSON populates ElementDefinitionBinding from JSON data
func (m *ElementDefinitionBinding) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionBinding to JSON data
func (m *ElementDefinitionBinding) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionBinding
func (m *ElementDefinitionBinding) Clone() *ElementDefinitionBinding {
	if m == nil { return nil }
	return &ElementDefinitionBinding{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Strength: m.Strength.Clone(),
		Description: m.Description.Clone(),
		ValueSet: m.ValueSet.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionBinding instance
func (m *ElementDefinitionBinding) Equals(other *ElementDefinitionBinding) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Strength.Equals(other.Strength) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.ValueSet.Equals(other.ValueSet) { return false }
	return true
}

// ElementDefinitionMapping
// Identifies a concept from an external specification that roughly corresponds to this element.
type ElementDefinitionMapping struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Identity *FhirId `json:"identity,omitempty"`
	Language *FhirCode `json:"language,omitempty"`
	Map *FhirString `json:"map,omitempty"`
	Comment *FhirString `json:"comment,omitempty"`
}

// NewElementDefinitionMapping creates a new ElementDefinitionMapping instance
func NewElementDefinitionMapping() *ElementDefinitionMapping {
	return &ElementDefinitionMapping{}
}

// FromJSON populates ElementDefinitionMapping from JSON data
func (m *ElementDefinitionMapping) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ElementDefinitionMapping to JSON data
func (m *ElementDefinitionMapping) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ElementDefinitionMapping
func (m *ElementDefinitionMapping) Clone() *ElementDefinitionMapping {
	if m == nil { return nil }
	return &ElementDefinitionMapping{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Identity: m.Identity.Clone(),
		Language: m.Language.Clone(),
		Map: m.Map.Clone(),
		Comment: m.Comment.Clone(),
	}
}

// Equals checks for equality with another ElementDefinitionMapping instance
func (m *ElementDefinitionMapping) Equals(other *ElementDefinitionMapping) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Identity.Equals(other.Identity) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Map.Equals(other.Map) { return false }
	if !m.Comment.Equals(other.Comment) { return false }
	return true
}

