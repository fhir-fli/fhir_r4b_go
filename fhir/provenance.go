// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Provenance
// Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
type Provenance struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Target []*Reference `json:"target,omitempty"`
	OccurredPeriod *Period `json:"occurredperiod,omitempty"`
	OccurredDateTime *FhirDateTime `json:"occurreddatetime,omitempty"`
	Recorded *FhirInstant `json:"recorded,omitempty"`
	Policy []*FhirUri `json:"policy,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Reason []*CodeableConcept `json:"reason,omitempty"`
	Activity *CodeableConcept `json:"activity,omitempty"`
	Agent []*ProvenanceAgent `json:"agent,omitempty"`
	Entity []*ProvenanceEntity `json:"entity,omitempty"`
	Signature []*Signature `json:"signature,omitempty"`
}

// NewProvenance creates a new Provenance instance
func NewProvenance() *Provenance {
	return &Provenance{}
}

// FromJSON populates Provenance from JSON data
func (m *Provenance) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Provenance to JSON data
func (m *Provenance) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Provenance
func (m *Provenance) Clone() *Provenance {
	if m == nil { return nil }
	return &Provenance{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Target: cloneSlices(m.Target),
		OccurredPeriod: m.OccurredPeriod.Clone(),
		OccurredDateTime: m.OccurredDateTime.Clone(),
		Recorded: m.Recorded.Clone(),
		Policy: cloneSlices(m.Policy),
		Location: m.Location.Clone(),
		Reason: cloneSlices(m.Reason),
		Activity: m.Activity.Clone(),
		Agent: cloneSlices(m.Agent),
		Entity: cloneSlices(m.Entity),
		Signature: cloneSlices(m.Signature),
	}
}

// Equals checks for equality with another Provenance instance
func (m *Provenance) Equals(other *Provenance) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Target, other.Target) { return false }
	if !m.OccurredPeriod.Equals(other.OccurredPeriod) { return false }
	if !m.OccurredDateTime.Equals(other.OccurredDateTime) { return false }
	if !m.Recorded.Equals(other.Recorded) { return false }
	if !compareSlices(m.Policy, other.Policy) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !compareSlices(m.Reason, other.Reason) { return false }
	if !m.Activity.Equals(other.Activity) { return false }
	if !compareSlices(m.Agent, other.Agent) { return false }
	if !compareSlices(m.Entity, other.Entity) { return false }
	if !compareSlices(m.Signature, other.Signature) { return false }
	return true
}

// ProvenanceAgent
// An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
type ProvenanceAgent struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Role []*CodeableConcept `json:"role,omitempty"`
	Who *Reference `json:"who,omitempty"`
	OnBehalfOf *Reference `json:"onbehalfof,omitempty"`
}

// NewProvenanceAgent creates a new ProvenanceAgent instance
func NewProvenanceAgent() *ProvenanceAgent {
	return &ProvenanceAgent{}
}

// FromJSON populates ProvenanceAgent from JSON data
func (m *ProvenanceAgent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ProvenanceAgent to JSON data
func (m *ProvenanceAgent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ProvenanceAgent
func (m *ProvenanceAgent) Clone() *ProvenanceAgent {
	if m == nil { return nil }
	return &ProvenanceAgent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Role: cloneSlices(m.Role),
		Who: m.Who.Clone(),
		OnBehalfOf: m.OnBehalfOf.Clone(),
	}
}

// Equals checks for equality with another ProvenanceAgent instance
func (m *ProvenanceAgent) Equals(other *ProvenanceAgent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Role, other.Role) { return false }
	if !m.Who.Equals(other.Who) { return false }
	if !m.OnBehalfOf.Equals(other.OnBehalfOf) { return false }
	return true
}

// ProvenanceEntity
// An entity used in this activity.
type ProvenanceEntity struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Role *ProvenanceEntityRole `json:"role,omitempty"`
	What *Reference `json:"what,omitempty"`
	Agent []*ProvenanceAgent `json:"agent,omitempty"`
}

// NewProvenanceEntity creates a new ProvenanceEntity instance
func NewProvenanceEntity() *ProvenanceEntity {
	return &ProvenanceEntity{}
}

// FromJSON populates ProvenanceEntity from JSON data
func (m *ProvenanceEntity) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ProvenanceEntity to JSON data
func (m *ProvenanceEntity) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ProvenanceEntity
func (m *ProvenanceEntity) Clone() *ProvenanceEntity {
	if m == nil { return nil }
	return &ProvenanceEntity{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Role: m.Role.Clone(),
		What: m.What.Clone(),
		Agent: cloneSlices(m.Agent),
	}
}

// Equals checks for equality with another ProvenanceEntity instance
func (m *ProvenanceEntity) Equals(other *ProvenanceEntity) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.What.Equals(other.What) { return false }
	if !compareSlices(m.Agent, other.Agent) { return false }
	return true
}

