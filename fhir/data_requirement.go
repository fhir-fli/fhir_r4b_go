// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// DataRequirement
// Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
type DataRequirement struct {
	DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Type *FHIRAllTypes `json:"type,omitempty"`
	Profile []*FhirCanonical `json:"profile,omitempty"`
	SubjectCodeableConcept *CodeableConcept `json:"subjectcodeableconcept,omitempty"`
	SubjectReference *Reference `json:"subjectreference,omitempty"`
	MustSupport []*FhirString `json:"mustsupport,omitempty"`
	CodeFilter []*DataRequirementCodeFilter `json:"codefilter,omitempty"`
	DateFilter []*DataRequirementDateFilter `json:"datefilter,omitempty"`
	Limit *FhirPositiveInt `json:"limit,omitempty"`
	Sort []*DataRequirementSort `json:"sort,omitempty"`
}

// NewDataRequirement creates a new DataRequirement instance
func NewDataRequirement() *DataRequirement {
	return &DataRequirement{}
}

// FromJSON populates DataRequirement from JSON data
func (m *DataRequirement) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DataRequirement to JSON data
func (m *DataRequirement) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DataRequirement
func (m *DataRequirement) Clone() *DataRequirement {
	if m == nil { return nil }
	return &DataRequirement{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Type: m.Type.Clone(),
		Profile: cloneSlices(m.Profile),
		SubjectCodeableConcept: m.SubjectCodeableConcept.Clone(),
		SubjectReference: m.SubjectReference.Clone(),
		MustSupport: cloneSlices(m.MustSupport),
		CodeFilter: cloneSlices(m.CodeFilter),
		DateFilter: cloneSlices(m.DateFilter),
		Limit: m.Limit.Clone(),
		Sort: cloneSlices(m.Sort),
	}
}

// Equals checks for equality with another DataRequirement instance
func (m *DataRequirement) Equals(other *DataRequirement) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Profile, other.Profile) { return false }
	if !m.SubjectCodeableConcept.Equals(other.SubjectCodeableConcept) { return false }
	if !m.SubjectReference.Equals(other.SubjectReference) { return false }
	if !compareSlices(m.MustSupport, other.MustSupport) { return false }
	if !compareSlices(m.CodeFilter, other.CodeFilter) { return false }
	if !compareSlices(m.DateFilter, other.DateFilter) { return false }
	if !m.Limit.Equals(other.Limit) { return false }
	if !compareSlices(m.Sort, other.Sort) { return false }
	return true
}

// DataRequirementCodeFilter
// Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
type DataRequirementCodeFilter struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	SearchParam *FhirString `json:"searchparam,omitempty"`
	ValueSet *FhirCanonical `json:"valueset,omitempty"`
	Code []*Coding `json:"code,omitempty"`
}

// NewDataRequirementCodeFilter creates a new DataRequirementCodeFilter instance
func NewDataRequirementCodeFilter() *DataRequirementCodeFilter {
	return &DataRequirementCodeFilter{}
}

// FromJSON populates DataRequirementCodeFilter from JSON data
func (m *DataRequirementCodeFilter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DataRequirementCodeFilter to JSON data
func (m *DataRequirementCodeFilter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DataRequirementCodeFilter
func (m *DataRequirementCodeFilter) Clone() *DataRequirementCodeFilter {
	if m == nil { return nil }
	return &DataRequirementCodeFilter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Path: m.Path.Clone(),
		SearchParam: m.SearchParam.Clone(),
		ValueSet: m.ValueSet.Clone(),
		Code: cloneSlices(m.Code),
	}
}

// Equals checks for equality with another DataRequirementCodeFilter instance
func (m *DataRequirementCodeFilter) Equals(other *DataRequirementCodeFilter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !m.SearchParam.Equals(other.SearchParam) { return false }
	if !m.ValueSet.Equals(other.ValueSet) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	return true
}

// DataRequirementDateFilter
// Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
type DataRequirementDateFilter struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	SearchParam *FhirString `json:"searchparam,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValuePeriod *Period `json:"valueperiod,omitempty"`
	ValueDuration *FhirDuration `json:"valueduration,omitempty"`
}

// NewDataRequirementDateFilter creates a new DataRequirementDateFilter instance
func NewDataRequirementDateFilter() *DataRequirementDateFilter {
	return &DataRequirementDateFilter{}
}

// FromJSON populates DataRequirementDateFilter from JSON data
func (m *DataRequirementDateFilter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DataRequirementDateFilter to JSON data
func (m *DataRequirementDateFilter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DataRequirementDateFilter
func (m *DataRequirementDateFilter) Clone() *DataRequirementDateFilter {
	if m == nil { return nil }
	return &DataRequirementDateFilter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Path: m.Path.Clone(),
		SearchParam: m.SearchParam.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValuePeriod: m.ValuePeriod.Clone(),
		ValueDuration: m.ValueDuration.Clone(),
	}
}

// Equals checks for equality with another DataRequirementDateFilter instance
func (m *DataRequirementDateFilter) Equals(other *DataRequirementDateFilter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !m.SearchParam.Equals(other.SearchParam) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValuePeriod.Equals(other.ValuePeriod) { return false }
	if !m.ValueDuration.Equals(other.ValueDuration) { return false }
	return true
}

// DataRequirementSort
// Specifies the order of the results to be returned.
type DataRequirementSort struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Path *FhirString `json:"path,omitempty"`
	Direction *SortDirection `json:"direction,omitempty"`
}

// NewDataRequirementSort creates a new DataRequirementSort instance
func NewDataRequirementSort() *DataRequirementSort {
	return &DataRequirementSort{}
}

// FromJSON populates DataRequirementSort from JSON data
func (m *DataRequirementSort) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DataRequirementSort to JSON data
func (m *DataRequirementSort) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DataRequirementSort
func (m *DataRequirementSort) Clone() *DataRequirementSort {
	if m == nil { return nil }
	return &DataRequirementSort{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Path: m.Path.Clone(),
		Direction: m.Direction.Clone(),
	}
}

// Equals checks for equality with another DataRequirementSort instance
func (m *DataRequirementSort) Equals(other *DataRequirementSort) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Path.Equals(other.Path) { return false }
	if !m.Direction.Equals(other.Direction) { return false }
	return true
}

