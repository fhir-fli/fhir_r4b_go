// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Questionnaire
// A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.
type Questionnaire struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	DerivedFrom []*FhirCanonical `json:"derivedfrom,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	SubjectType []*FhirCode `json:"subjecttype,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	Code []*Coding `json:"code,omitempty"`
	Item []*QuestionnaireItem `json:"item,omitempty"`
}

// NewQuestionnaire creates a new Questionnaire instance
func NewQuestionnaire() *Questionnaire {
	return &Questionnaire{}
}

// FromJSON populates Questionnaire from JSON data
func (m *Questionnaire) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Questionnaire to JSON data
func (m *Questionnaire) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Questionnaire
func (m *Questionnaire) Clone() *Questionnaire {
	if m == nil { return nil }
	return &Questionnaire{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		DerivedFrom: cloneSlices(m.DerivedFrom),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		SubjectType: cloneSlices(m.SubjectType),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		Code: cloneSlices(m.Code),
		Item: cloneSlices(m.Item),
	}
}

// Equals checks for equality with another Questionnaire instance
func (m *Questionnaire) Equals(other *Questionnaire) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !compareSlices(m.DerivedFrom, other.DerivedFrom) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !compareSlices(m.SubjectType, other.SubjectType) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	return true
}

// QuestionnaireItem
// A particular question, question grouping or display text that is part of the questionnaire.
type QuestionnaireItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	LinkId *FhirString `json:"linkid,omitempty"`
	Definition *FhirUri `json:"definition,omitempty"`
	Code []*Coding `json:"code,omitempty"`
	Prefix *FhirString `json:"prefix,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	Type *QuestionnaireItemType `json:"type,omitempty"`
	EnableWhen []*QuestionnaireEnableWhen `json:"enablewhen,omitempty"`
	EnableBehavior *EnableWhenBehavior `json:"enablebehavior,omitempty"`
	Required_ *FhirBoolean `json:"required,omitempty"`
	Repeats *FhirBoolean `json:"repeats,omitempty"`
	ReadOnly *FhirBoolean `json:"readonly,omitempty"`
	MaxLength *FhirInteger `json:"maxlength,omitempty"`
	AnswerValueSet *FhirCanonical `json:"answervalueset,omitempty"`
	AnswerOption []*QuestionnaireAnswerOption `json:"answeroption,omitempty"`
	Initial []*QuestionnaireInitial `json:"initial,omitempty"`
	Item []*QuestionnaireItem `json:"item,omitempty"`
}

// NewQuestionnaireItem creates a new QuestionnaireItem instance
func NewQuestionnaireItem() *QuestionnaireItem {
	return &QuestionnaireItem{}
}

// FromJSON populates QuestionnaireItem from JSON data
func (m *QuestionnaireItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts QuestionnaireItem to JSON data
func (m *QuestionnaireItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of QuestionnaireItem
func (m *QuestionnaireItem) Clone() *QuestionnaireItem {
	if m == nil { return nil }
	return &QuestionnaireItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		LinkId: m.LinkId.Clone(),
		Definition: m.Definition.Clone(),
		Code: cloneSlices(m.Code),
		Prefix: m.Prefix.Clone(),
		Text: m.Text.Clone(),
		Type: m.Type.Clone(),
		EnableWhen: cloneSlices(m.EnableWhen),
		EnableBehavior: m.EnableBehavior.Clone(),
		Required_: m.Required_.Clone(),
		Repeats: m.Repeats.Clone(),
		ReadOnly: m.ReadOnly.Clone(),
		MaxLength: m.MaxLength.Clone(),
		AnswerValueSet: m.AnswerValueSet.Clone(),
		AnswerOption: cloneSlices(m.AnswerOption),
		Initial: cloneSlices(m.Initial),
		Item: cloneSlices(m.Item),
	}
}

// Equals checks for equality with another QuestionnaireItem instance
func (m *QuestionnaireItem) Equals(other *QuestionnaireItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.LinkId.Equals(other.LinkId) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !m.Prefix.Equals(other.Prefix) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.EnableWhen, other.EnableWhen) { return false }
	if !m.EnableBehavior.Equals(other.EnableBehavior) { return false }
	if !m.Required_.Equals(other.Required_) { return false }
	if !m.Repeats.Equals(other.Repeats) { return false }
	if !m.ReadOnly.Equals(other.ReadOnly) { return false }
	if !m.MaxLength.Equals(other.MaxLength) { return false }
	if !m.AnswerValueSet.Equals(other.AnswerValueSet) { return false }
	if !compareSlices(m.AnswerOption, other.AnswerOption) { return false }
	if !compareSlices(m.Initial, other.Initial) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	return true
}

// QuestionnaireEnableWhen
// A constraint indicating that this item should only be enabled (displayed/allow answers to be captured) when the specified condition is true.
type QuestionnaireEnableWhen struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Question *FhirString `json:"question,omitempty"`
	Operator_ *QuestionnaireItemOperator `json:"operator,omitempty"`
	AnswerBoolean *FhirBoolean `json:"answerboolean,omitempty"`
	AnswerDecimal *FhirDecimal `json:"answerdecimal,omitempty"`
	AnswerInteger *FhirInteger `json:"answerinteger,omitempty"`
	AnswerDate *FhirDate `json:"answerdate,omitempty"`
	AnswerDateTime *FhirDateTime `json:"answerdatetime,omitempty"`
	AnswerTime *FhirTime `json:"answertime,omitempty"`
	AnswerString *FhirString `json:"answerstring,omitempty"`
	AnswerCoding *Coding `json:"answercoding,omitempty"`
	AnswerQuantity *Quantity `json:"answerquantity,omitempty"`
	AnswerReference *Reference `json:"answerreference,omitempty"`
}

// NewQuestionnaireEnableWhen creates a new QuestionnaireEnableWhen instance
func NewQuestionnaireEnableWhen() *QuestionnaireEnableWhen {
	return &QuestionnaireEnableWhen{}
}

// FromJSON populates QuestionnaireEnableWhen from JSON data
func (m *QuestionnaireEnableWhen) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts QuestionnaireEnableWhen to JSON data
func (m *QuestionnaireEnableWhen) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of QuestionnaireEnableWhen
func (m *QuestionnaireEnableWhen) Clone() *QuestionnaireEnableWhen {
	if m == nil { return nil }
	return &QuestionnaireEnableWhen{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Question: m.Question.Clone(),
		Operator_: m.Operator_.Clone(),
		AnswerBoolean: m.AnswerBoolean.Clone(),
		AnswerDecimal: m.AnswerDecimal.Clone(),
		AnswerInteger: m.AnswerInteger.Clone(),
		AnswerDate: m.AnswerDate.Clone(),
		AnswerDateTime: m.AnswerDateTime.Clone(),
		AnswerTime: m.AnswerTime.Clone(),
		AnswerString: m.AnswerString.Clone(),
		AnswerCoding: m.AnswerCoding.Clone(),
		AnswerQuantity: m.AnswerQuantity.Clone(),
		AnswerReference: m.AnswerReference.Clone(),
	}
}

// Equals checks for equality with another QuestionnaireEnableWhen instance
func (m *QuestionnaireEnableWhen) Equals(other *QuestionnaireEnableWhen) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Question.Equals(other.Question) { return false }
	if !m.Operator_.Equals(other.Operator_) { return false }
	if !m.AnswerBoolean.Equals(other.AnswerBoolean) { return false }
	if !m.AnswerDecimal.Equals(other.AnswerDecimal) { return false }
	if !m.AnswerInteger.Equals(other.AnswerInteger) { return false }
	if !m.AnswerDate.Equals(other.AnswerDate) { return false }
	if !m.AnswerDateTime.Equals(other.AnswerDateTime) { return false }
	if !m.AnswerTime.Equals(other.AnswerTime) { return false }
	if !m.AnswerString.Equals(other.AnswerString) { return false }
	if !m.AnswerCoding.Equals(other.AnswerCoding) { return false }
	if !m.AnswerQuantity.Equals(other.AnswerQuantity) { return false }
	if !m.AnswerReference.Equals(other.AnswerReference) { return false }
	return true
}

// QuestionnaireAnswerOption
// One of the permitted answers for a "choice" or "open-choice" question.
type QuestionnaireAnswerOption struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	InitialSelected *FhirBoolean `json:"initialselected,omitempty"`
}

// NewQuestionnaireAnswerOption creates a new QuestionnaireAnswerOption instance
func NewQuestionnaireAnswerOption() *QuestionnaireAnswerOption {
	return &QuestionnaireAnswerOption{}
}

// FromJSON populates QuestionnaireAnswerOption from JSON data
func (m *QuestionnaireAnswerOption) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts QuestionnaireAnswerOption to JSON data
func (m *QuestionnaireAnswerOption) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of QuestionnaireAnswerOption
func (m *QuestionnaireAnswerOption) Clone() *QuestionnaireAnswerOption {
	if m == nil { return nil }
	return &QuestionnaireAnswerOption{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ValueInteger: m.ValueInteger.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueReference: m.ValueReference.Clone(),
		InitialSelected: m.InitialSelected.Clone(),
	}
}

// Equals checks for equality with another QuestionnaireAnswerOption instance
func (m *QuestionnaireAnswerOption) Equals(other *QuestionnaireAnswerOption) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !m.InitialSelected.Equals(other.InitialSelected) { return false }
	return true
}

// QuestionnaireInitial
// One or more values that should be pre-populated in the answer when initially rendering the questionnaire for user input.
type QuestionnaireInitial struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
}

// NewQuestionnaireInitial creates a new QuestionnaireInitial instance
func NewQuestionnaireInitial() *QuestionnaireInitial {
	return &QuestionnaireInitial{}
}

// FromJSON populates QuestionnaireInitial from JSON data
func (m *QuestionnaireInitial) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts QuestionnaireInitial to JSON data
func (m *QuestionnaireInitial) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of QuestionnaireInitial
func (m *QuestionnaireInitial) Clone() *QuestionnaireInitial {
	if m == nil { return nil }
	return &QuestionnaireInitial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueReference: m.ValueReference.Clone(),
	}
}

// Equals checks for equality with another QuestionnaireInitial instance
func (m *QuestionnaireInitial) Equals(other *QuestionnaireInitial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	return true
}

