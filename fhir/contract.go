// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Contract
// Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
type Contract struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Status *ContractResourceStatusCodes `json:"status,omitempty"`
	LegalState *CodeableConcept `json:"legalstate,omitempty"`
	InstantiatesCanonical *Reference `json:"instantiatescanonical,omitempty"`
	InstantiatesUri *FhirUri `json:"instantiatesuri,omitempty"`
	ContentDerivative *CodeableConcept `json:"contentderivative,omitempty"`
	Issued *FhirDateTime `json:"issued,omitempty"`
	Applies *Period `json:"applies,omitempty"`
	ExpirationType *CodeableConcept `json:"expirationtype,omitempty"`
	Subject []*Reference `json:"subject,omitempty"`
	Authority []*Reference `json:"authority,omitempty"`
	Domain []*Reference `json:"domain,omitempty"`
	Site []*Reference `json:"site,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Subtitle *FhirString `json:"subtitle,omitempty"`
	Alias []*FhirString `json:"alias,omitempty"`
	Author *Reference `json:"author,omitempty"`
	Scope *CodeableConcept `json:"scope,omitempty"`
	TopicCodeableConcept *CodeableConcept `json:"topiccodeableconcept,omitempty"`
	TopicReference *Reference `json:"topicreference,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	SubType []*CodeableConcept `json:"subtype,omitempty"`
	ContentDefinition *ContractContentDefinition `json:"contentdefinition,omitempty"`
	Term []*ContractTerm `json:"term,omitempty"`
	SupportingInfo []*Reference `json:"supportinginfo,omitempty"`
	RelevantHistory []*Reference `json:"relevanthistory,omitempty"`
	Signer []*ContractSigner `json:"signer,omitempty"`
	Friendly []*ContractFriendly `json:"friendly,omitempty"`
	Legal []*ContractLegal `json:"legal,omitempty"`
	Rule []*ContractRule `json:"rule,omitempty"`
	LegallyBindingAttachment *Attachment `json:"legallybindingattachment,omitempty"`
	LegallyBindingReference *Reference `json:"legallybindingreference,omitempty"`
}

// NewContract creates a new Contract instance
func NewContract() *Contract {
	return &Contract{}
}

// FromJSON populates Contract from JSON data
func (m *Contract) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Contract to JSON data
func (m *Contract) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Contract
func (m *Contract) Clone() *Contract {
	if m == nil { return nil }
	return &Contract{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Url: m.Url.Clone(),
		Version: m.Version.Clone(),
		Status: m.Status.Clone(),
		LegalState: m.LegalState.Clone(),
		InstantiatesCanonical: m.InstantiatesCanonical.Clone(),
		InstantiatesUri: m.InstantiatesUri.Clone(),
		ContentDerivative: m.ContentDerivative.Clone(),
		Issued: m.Issued.Clone(),
		Applies: m.Applies.Clone(),
		ExpirationType: m.ExpirationType.Clone(),
		Subject: cloneSlices(m.Subject),
		Authority: cloneSlices(m.Authority),
		Domain: cloneSlices(m.Domain),
		Site: cloneSlices(m.Site),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Subtitle: m.Subtitle.Clone(),
		Alias: cloneSlices(m.Alias),
		Author: m.Author.Clone(),
		Scope: m.Scope.Clone(),
		TopicCodeableConcept: m.TopicCodeableConcept.Clone(),
		TopicReference: m.TopicReference.Clone(),
		Type: m.Type.Clone(),
		SubType: cloneSlices(m.SubType),
		ContentDefinition: m.ContentDefinition.Clone(),
		Term: cloneSlices(m.Term),
		SupportingInfo: cloneSlices(m.SupportingInfo),
		RelevantHistory: cloneSlices(m.RelevantHistory),
		Signer: cloneSlices(m.Signer),
		Friendly: cloneSlices(m.Friendly),
		Legal: cloneSlices(m.Legal),
		Rule: cloneSlices(m.Rule),
		LegallyBindingAttachment: m.LegallyBindingAttachment.Clone(),
		LegallyBindingReference: m.LegallyBindingReference.Clone(),
	}
}

// Equals checks for equality with another Contract instance
func (m *Contract) Equals(other *Contract) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.LegalState.Equals(other.LegalState) { return false }
	if !m.InstantiatesCanonical.Equals(other.InstantiatesCanonical) { return false }
	if !m.InstantiatesUri.Equals(other.InstantiatesUri) { return false }
	if !m.ContentDerivative.Equals(other.ContentDerivative) { return false }
	if !m.Issued.Equals(other.Issued) { return false }
	if !m.Applies.Equals(other.Applies) { return false }
	if !m.ExpirationType.Equals(other.ExpirationType) { return false }
	if !compareSlices(m.Subject, other.Subject) { return false }
	if !compareSlices(m.Authority, other.Authority) { return false }
	if !compareSlices(m.Domain, other.Domain) { return false }
	if !compareSlices(m.Site, other.Site) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Subtitle.Equals(other.Subtitle) { return false }
	if !compareSlices(m.Alias, other.Alias) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !m.Scope.Equals(other.Scope) { return false }
	if !m.TopicCodeableConcept.Equals(other.TopicCodeableConcept) { return false }
	if !m.TopicReference.Equals(other.TopicReference) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.SubType, other.SubType) { return false }
	if !m.ContentDefinition.Equals(other.ContentDefinition) { return false }
	if !compareSlices(m.Term, other.Term) { return false }
	if !compareSlices(m.SupportingInfo, other.SupportingInfo) { return false }
	if !compareSlices(m.RelevantHistory, other.RelevantHistory) { return false }
	if !compareSlices(m.Signer, other.Signer) { return false }
	if !compareSlices(m.Friendly, other.Friendly) { return false }
	if !compareSlices(m.Legal, other.Legal) { return false }
	if !compareSlices(m.Rule, other.Rule) { return false }
	if !m.LegallyBindingAttachment.Equals(other.LegallyBindingAttachment) { return false }
	if !m.LegallyBindingReference.Equals(other.LegallyBindingReference) { return false }
	return true
}

// ContractContentDefinition
// Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
type ContractContentDefinition struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	SubType *CodeableConcept `json:"subtype,omitempty"`
	Publisher *Reference `json:"publisher,omitempty"`
	PublicationDate *FhirDateTime `json:"publicationdate,omitempty"`
	PublicationStatus *ContractResourcePublicationStatusCodes `json:"publicationstatus,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
}

// NewContractContentDefinition creates a new ContractContentDefinition instance
func NewContractContentDefinition() *ContractContentDefinition {
	return &ContractContentDefinition{}
}

// FromJSON populates ContractContentDefinition from JSON data
func (m *ContractContentDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractContentDefinition to JSON data
func (m *ContractContentDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractContentDefinition
func (m *ContractContentDefinition) Clone() *ContractContentDefinition {
	if m == nil { return nil }
	return &ContractContentDefinition{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		SubType: m.SubType.Clone(),
		Publisher: m.Publisher.Clone(),
		PublicationDate: m.PublicationDate.Clone(),
		PublicationStatus: m.PublicationStatus.Clone(),
		Copyright: m.Copyright.Clone(),
	}
}

// Equals checks for equality with another ContractContentDefinition instance
func (m *ContractContentDefinition) Equals(other *ContractContentDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.SubType.Equals(other.SubType) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !m.PublicationDate.Equals(other.PublicationDate) { return false }
	if !m.PublicationStatus.Equals(other.PublicationStatus) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	return true
}

// ContractTerm
// One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
type ContractTerm struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Issued *FhirDateTime `json:"issued,omitempty"`
	Applies *Period `json:"applies,omitempty"`
	TopicCodeableConcept *CodeableConcept `json:"topiccodeableconcept,omitempty"`
	TopicReference *Reference `json:"topicreference,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	SubType *CodeableConcept `json:"subtype,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	SecurityLabel []*ContractSecurityLabel `json:"securitylabel,omitempty"`
	Offer *ContractOffer `json:"offer,omitempty"`
	Asset []*ContractAsset `json:"asset,omitempty"`
	Action []*ContractAction `json:"action,omitempty"`
	Group []*ContractTerm `json:"group,omitempty"`
}

// NewContractTerm creates a new ContractTerm instance
func NewContractTerm() *ContractTerm {
	return &ContractTerm{}
}

// FromJSON populates ContractTerm from JSON data
func (m *ContractTerm) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractTerm to JSON data
func (m *ContractTerm) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractTerm
func (m *ContractTerm) Clone() *ContractTerm {
	if m == nil { return nil }
	return &ContractTerm{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Issued: m.Issued.Clone(),
		Applies: m.Applies.Clone(),
		TopicCodeableConcept: m.TopicCodeableConcept.Clone(),
		TopicReference: m.TopicReference.Clone(),
		Type: m.Type.Clone(),
		SubType: m.SubType.Clone(),
		Text: m.Text.Clone(),
		SecurityLabel: cloneSlices(m.SecurityLabel),
		Offer: m.Offer.Clone(),
		Asset: cloneSlices(m.Asset),
		Action: cloneSlices(m.Action),
		Group: cloneSlices(m.Group),
	}
}

// Equals checks for equality with another ContractTerm instance
func (m *ContractTerm) Equals(other *ContractTerm) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Issued.Equals(other.Issued) { return false }
	if !m.Applies.Equals(other.Applies) { return false }
	if !m.TopicCodeableConcept.Equals(other.TopicCodeableConcept) { return false }
	if !m.TopicReference.Equals(other.TopicReference) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.SubType.Equals(other.SubType) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.SecurityLabel, other.SecurityLabel) { return false }
	if !m.Offer.Equals(other.Offer) { return false }
	if !compareSlices(m.Asset, other.Asset) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	if !compareSlices(m.Group, other.Group) { return false }
	return true
}

// ContractSecurityLabel
// Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
type ContractSecurityLabel struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Number []*FhirUnsignedInt `json:"number,omitempty"`
	Classification *Coding `json:"classification,omitempty"`
	Category []*Coding `json:"category,omitempty"`
	Control []*Coding `json:"control,omitempty"`
}

// NewContractSecurityLabel creates a new ContractSecurityLabel instance
func NewContractSecurityLabel() *ContractSecurityLabel {
	return &ContractSecurityLabel{}
}

// FromJSON populates ContractSecurityLabel from JSON data
func (m *ContractSecurityLabel) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractSecurityLabel to JSON data
func (m *ContractSecurityLabel) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractSecurityLabel
func (m *ContractSecurityLabel) Clone() *ContractSecurityLabel {
	if m == nil { return nil }
	return &ContractSecurityLabel{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Number: cloneSlices(m.Number),
		Classification: m.Classification.Clone(),
		Category: cloneSlices(m.Category),
		Control: cloneSlices(m.Control),
	}
}

// Equals checks for equality with another ContractSecurityLabel instance
func (m *ContractSecurityLabel) Equals(other *ContractSecurityLabel) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Number, other.Number) { return false }
	if !m.Classification.Equals(other.Classification) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !compareSlices(m.Control, other.Control) { return false }
	return true
}

// ContractOffer
// The matter of concern in the context of this provision of the agrement.
type ContractOffer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Party []*ContractParty `json:"party,omitempty"`
	Topic *Reference `json:"topic,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Decision *CodeableConcept `json:"decision,omitempty"`
	DecisionMode []*CodeableConcept `json:"decisionmode,omitempty"`
	Answer []*ContractAnswer `json:"answer,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	LinkId []*FhirString `json:"linkid,omitempty"`
	SecurityLabelNumber []*FhirUnsignedInt `json:"securitylabelnumber,omitempty"`
}

// NewContractOffer creates a new ContractOffer instance
func NewContractOffer() *ContractOffer {
	return &ContractOffer{}
}

// FromJSON populates ContractOffer from JSON data
func (m *ContractOffer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractOffer to JSON data
func (m *ContractOffer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractOffer
func (m *ContractOffer) Clone() *ContractOffer {
	if m == nil { return nil }
	return &ContractOffer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Party: cloneSlices(m.Party),
		Topic: m.Topic.Clone(),
		Type: m.Type.Clone(),
		Decision: m.Decision.Clone(),
		DecisionMode: cloneSlices(m.DecisionMode),
		Answer: cloneSlices(m.Answer),
		Text: m.Text.Clone(),
		LinkId: cloneSlices(m.LinkId),
		SecurityLabelNumber: cloneSlices(m.SecurityLabelNumber),
	}
}

// Equals checks for equality with another ContractOffer instance
func (m *ContractOffer) Equals(other *ContractOffer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.Party, other.Party) { return false }
	if !m.Topic.Equals(other.Topic) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Decision.Equals(other.Decision) { return false }
	if !compareSlices(m.DecisionMode, other.DecisionMode) { return false }
	if !compareSlices(m.Answer, other.Answer) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.LinkId, other.LinkId) { return false }
	if !compareSlices(m.SecurityLabelNumber, other.SecurityLabelNumber) { return false }
	return true
}

// ContractParty
// Offer Recipient.
type ContractParty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Reference []*Reference `json:"reference,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
}

// NewContractParty creates a new ContractParty instance
func NewContractParty() *ContractParty {
	return &ContractParty{}
}

// FromJSON populates ContractParty from JSON data
func (m *ContractParty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractParty to JSON data
func (m *ContractParty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractParty
func (m *ContractParty) Clone() *ContractParty {
	if m == nil { return nil }
	return &ContractParty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Reference: cloneSlices(m.Reference),
		Role: m.Role.Clone(),
	}
}

// Equals checks for equality with another ContractParty instance
func (m *ContractParty) Equals(other *ContractParty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Reference, other.Reference) { return false }
	if !m.Role.Equals(other.Role) { return false }
	return true
}

// ContractAnswer
// Response to offer text.
type ContractAnswer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
}

// NewContractAnswer creates a new ContractAnswer instance
func NewContractAnswer() *ContractAnswer {
	return &ContractAnswer{}
}

// FromJSON populates ContractAnswer from JSON data
func (m *ContractAnswer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractAnswer to JSON data
func (m *ContractAnswer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractAnswer
func (m *ContractAnswer) Clone() *ContractAnswer {
	if m == nil { return nil }
	return &ContractAnswer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueReference: m.ValueReference.Clone(),
	}
}

// Equals checks for equality with another ContractAnswer instance
func (m *ContractAnswer) Equals(other *ContractAnswer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	return true
}

// ContractAsset
// Contract Term Asset List.
type ContractAsset struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Scope *CodeableConcept `json:"scope,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	TypeReference []*Reference `json:"typereference,omitempty"`
	Subtype []*CodeableConcept `json:"subtype,omitempty"`
	Relationship *Coding `json:"relationship,omitempty"`
	Context []*ContractContext `json:"context,omitempty"`
	Condition *FhirString `json:"condition,omitempty"`
	PeriodType []*CodeableConcept `json:"periodtype,omitempty"`
	Period []*Period `json:"period,omitempty"`
	UsePeriod []*Period `json:"useperiod,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	LinkId []*FhirString `json:"linkid,omitempty"`
	Answer []*ContractAnswer `json:"answer,omitempty"`
	SecurityLabelNumber []*FhirUnsignedInt `json:"securitylabelnumber,omitempty"`
	ValuedItem []*ContractValuedItem `json:"valueditem,omitempty"`
}

// NewContractAsset creates a new ContractAsset instance
func NewContractAsset() *ContractAsset {
	return &ContractAsset{}
}

// FromJSON populates ContractAsset from JSON data
func (m *ContractAsset) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractAsset to JSON data
func (m *ContractAsset) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractAsset
func (m *ContractAsset) Clone() *ContractAsset {
	if m == nil { return nil }
	return &ContractAsset{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Scope: m.Scope.Clone(),
		Type: cloneSlices(m.Type),
		TypeReference: cloneSlices(m.TypeReference),
		Subtype: cloneSlices(m.Subtype),
		Relationship: m.Relationship.Clone(),
		Context: cloneSlices(m.Context),
		Condition: m.Condition.Clone(),
		PeriodType: cloneSlices(m.PeriodType),
		Period: cloneSlices(m.Period),
		UsePeriod: cloneSlices(m.UsePeriod),
		Text: m.Text.Clone(),
		LinkId: cloneSlices(m.LinkId),
		Answer: cloneSlices(m.Answer),
		SecurityLabelNumber: cloneSlices(m.SecurityLabelNumber),
		ValuedItem: cloneSlices(m.ValuedItem),
	}
}

// Equals checks for equality with another ContractAsset instance
func (m *ContractAsset) Equals(other *ContractAsset) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Scope.Equals(other.Scope) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !compareSlices(m.TypeReference, other.TypeReference) { return false }
	if !compareSlices(m.Subtype, other.Subtype) { return false }
	if !m.Relationship.Equals(other.Relationship) { return false }
	if !compareSlices(m.Context, other.Context) { return false }
	if !m.Condition.Equals(other.Condition) { return false }
	if !compareSlices(m.PeriodType, other.PeriodType) { return false }
	if !compareSlices(m.Period, other.Period) { return false }
	if !compareSlices(m.UsePeriod, other.UsePeriod) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.LinkId, other.LinkId) { return false }
	if !compareSlices(m.Answer, other.Answer) { return false }
	if !compareSlices(m.SecurityLabelNumber, other.SecurityLabelNumber) { return false }
	if !compareSlices(m.ValuedItem, other.ValuedItem) { return false }
	return true
}

// ContractContext
// Circumstance of the asset.
type ContractContext struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Reference *Reference `json:"reference,omitempty"`
	Code []*CodeableConcept `json:"code,omitempty"`
	Text *FhirString `json:"text,omitempty"`
}

// NewContractContext creates a new ContractContext instance
func NewContractContext() *ContractContext {
	return &ContractContext{}
}

// FromJSON populates ContractContext from JSON data
func (m *ContractContext) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractContext to JSON data
func (m *ContractContext) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractContext
func (m *ContractContext) Clone() *ContractContext {
	if m == nil { return nil }
	return &ContractContext{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Reference: m.Reference.Clone(),
		Code: cloneSlices(m.Code),
		Text: m.Text.Clone(),
	}
}

// Equals checks for equality with another ContractContext instance
func (m *ContractContext) Equals(other *ContractContext) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !m.Text.Equals(other.Text) { return false }
	return true
}

// ContractValuedItem
// Contract Valued Item List.
type ContractValuedItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	EntityCodeableConcept *CodeableConcept `json:"entitycodeableconcept,omitempty"`
	EntityReference *Reference `json:"entityreference,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	EffectiveTime *FhirDateTime `json:"effectivetime,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	UnitPrice *Money `json:"unitprice,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Points *FhirDecimal `json:"points,omitempty"`
	Net *Money `json:"net,omitempty"`
	Payment *FhirString `json:"payment,omitempty"`
	PaymentDate *FhirDateTime `json:"paymentdate,omitempty"`
	Responsible *Reference `json:"responsible,omitempty"`
	Recipient *Reference `json:"recipient,omitempty"`
	LinkId []*FhirString `json:"linkid,omitempty"`
	SecurityLabelNumber []*FhirUnsignedInt `json:"securitylabelnumber,omitempty"`
}

// NewContractValuedItem creates a new ContractValuedItem instance
func NewContractValuedItem() *ContractValuedItem {
	return &ContractValuedItem{}
}

// FromJSON populates ContractValuedItem from JSON data
func (m *ContractValuedItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractValuedItem to JSON data
func (m *ContractValuedItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractValuedItem
func (m *ContractValuedItem) Clone() *ContractValuedItem {
	if m == nil { return nil }
	return &ContractValuedItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		EntityCodeableConcept: m.EntityCodeableConcept.Clone(),
		EntityReference: m.EntityReference.Clone(),
		Identifier: m.Identifier.Clone(),
		EffectiveTime: m.EffectiveTime.Clone(),
		Quantity: m.Quantity.Clone(),
		UnitPrice: m.UnitPrice.Clone(),
		Factor: m.Factor.Clone(),
		Points: m.Points.Clone(),
		Net: m.Net.Clone(),
		Payment: m.Payment.Clone(),
		PaymentDate: m.PaymentDate.Clone(),
		Responsible: m.Responsible.Clone(),
		Recipient: m.Recipient.Clone(),
		LinkId: cloneSlices(m.LinkId),
		SecurityLabelNumber: cloneSlices(m.SecurityLabelNumber),
	}
}

// Equals checks for equality with another ContractValuedItem instance
func (m *ContractValuedItem) Equals(other *ContractValuedItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.EntityCodeableConcept.Equals(other.EntityCodeableConcept) { return false }
	if !m.EntityReference.Equals(other.EntityReference) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.EffectiveTime.Equals(other.EffectiveTime) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.UnitPrice.Equals(other.UnitPrice) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Points.Equals(other.Points) { return false }
	if !m.Net.Equals(other.Net) { return false }
	if !m.Payment.Equals(other.Payment) { return false }
	if !m.PaymentDate.Equals(other.PaymentDate) { return false }
	if !m.Responsible.Equals(other.Responsible) { return false }
	if !m.Recipient.Equals(other.Recipient) { return false }
	if !compareSlices(m.LinkId, other.LinkId) { return false }
	if !compareSlices(m.SecurityLabelNumber, other.SecurityLabelNumber) { return false }
	return true
}

// ContractAction
// An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
type ContractAction struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DoNotPerform *FhirBoolean `json:"donotperform,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Subject []*ContractSubject `json:"subject,omitempty"`
	Intent *CodeableConcept `json:"intent,omitempty"`
	LinkId []*FhirString `json:"linkid,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Context *Reference `json:"context,omitempty"`
	ContextLinkId []*FhirString `json:"contextlinkid,omitempty"`
	OccurrenceDateTime *FhirDateTime `json:"occurrencedatetime,omitempty"`
	OccurrencePeriod *Period `json:"occurrenceperiod,omitempty"`
	OccurrenceTiming *Timing `json:"occurrencetiming,omitempty"`
	Requester []*Reference `json:"requester,omitempty"`
	RequesterLinkId []*FhirString `json:"requesterlinkid,omitempty"`
	PerformerType []*CodeableConcept `json:"performertype,omitempty"`
	PerformerRole *CodeableConcept `json:"performerrole,omitempty"`
	Performer *Reference `json:"performer,omitempty"`
	PerformerLinkId []*FhirString `json:"performerlinkid,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	Reason []*FhirString `json:"reason,omitempty"`
	ReasonLinkId []*FhirString `json:"reasonlinkid,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	SecurityLabelNumber []*FhirUnsignedInt `json:"securitylabelnumber,omitempty"`
}

// NewContractAction creates a new ContractAction instance
func NewContractAction() *ContractAction {
	return &ContractAction{}
}

// FromJSON populates ContractAction from JSON data
func (m *ContractAction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractAction to JSON data
func (m *ContractAction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractAction
func (m *ContractAction) Clone() *ContractAction {
	if m == nil { return nil }
	return &ContractAction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DoNotPerform: m.DoNotPerform.Clone(),
		Type: m.Type.Clone(),
		Subject: cloneSlices(m.Subject),
		Intent: m.Intent.Clone(),
		LinkId: cloneSlices(m.LinkId),
		Status: m.Status.Clone(),
		Context: m.Context.Clone(),
		ContextLinkId: cloneSlices(m.ContextLinkId),
		OccurrenceDateTime: m.OccurrenceDateTime.Clone(),
		OccurrencePeriod: m.OccurrencePeriod.Clone(),
		OccurrenceTiming: m.OccurrenceTiming.Clone(),
		Requester: cloneSlices(m.Requester),
		RequesterLinkId: cloneSlices(m.RequesterLinkId),
		PerformerType: cloneSlices(m.PerformerType),
		PerformerRole: m.PerformerRole.Clone(),
		Performer: m.Performer.Clone(),
		PerformerLinkId: cloneSlices(m.PerformerLinkId),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		Reason: cloneSlices(m.Reason),
		ReasonLinkId: cloneSlices(m.ReasonLinkId),
		Note: cloneSlices(m.Note),
		SecurityLabelNumber: cloneSlices(m.SecurityLabelNumber),
	}
}

// Equals checks for equality with another ContractAction instance
func (m *ContractAction) Equals(other *ContractAction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.DoNotPerform.Equals(other.DoNotPerform) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Subject, other.Subject) { return false }
	if !m.Intent.Equals(other.Intent) { return false }
	if !compareSlices(m.LinkId, other.LinkId) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Context.Equals(other.Context) { return false }
	if !compareSlices(m.ContextLinkId, other.ContextLinkId) { return false }
	if !m.OccurrenceDateTime.Equals(other.OccurrenceDateTime) { return false }
	if !m.OccurrencePeriod.Equals(other.OccurrencePeriod) { return false }
	if !m.OccurrenceTiming.Equals(other.OccurrenceTiming) { return false }
	if !compareSlices(m.Requester, other.Requester) { return false }
	if !compareSlices(m.RequesterLinkId, other.RequesterLinkId) { return false }
	if !compareSlices(m.PerformerType, other.PerformerType) { return false }
	if !m.PerformerRole.Equals(other.PerformerRole) { return false }
	if !m.Performer.Equals(other.Performer) { return false }
	if !compareSlices(m.PerformerLinkId, other.PerformerLinkId) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !compareSlices(m.Reason, other.Reason) { return false }
	if !compareSlices(m.ReasonLinkId, other.ReasonLinkId) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.SecurityLabelNumber, other.SecurityLabelNumber) { return false }
	return true
}

// ContractSubject
// Entity of the action.
type ContractSubject struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Reference []*Reference `json:"reference,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
}

// NewContractSubject creates a new ContractSubject instance
func NewContractSubject() *ContractSubject {
	return &ContractSubject{}
}

// FromJSON populates ContractSubject from JSON data
func (m *ContractSubject) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractSubject to JSON data
func (m *ContractSubject) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractSubject
func (m *ContractSubject) Clone() *ContractSubject {
	if m == nil { return nil }
	return &ContractSubject{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Reference: cloneSlices(m.Reference),
		Role: m.Role.Clone(),
	}
}

// Equals checks for equality with another ContractSubject instance
func (m *ContractSubject) Equals(other *ContractSubject) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Reference, other.Reference) { return false }
	if !m.Role.Equals(other.Role) { return false }
	return true
}

// ContractSigner
// Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
type ContractSigner struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *Coding `json:"type,omitempty"`
	Party *Reference `json:"party,omitempty"`
	Signature []*Signature `json:"signature,omitempty"`
}

// NewContractSigner creates a new ContractSigner instance
func NewContractSigner() *ContractSigner {
	return &ContractSigner{}
}

// FromJSON populates ContractSigner from JSON data
func (m *ContractSigner) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractSigner to JSON data
func (m *ContractSigner) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractSigner
func (m *ContractSigner) Clone() *ContractSigner {
	if m == nil { return nil }
	return &ContractSigner{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Party: m.Party.Clone(),
		Signature: cloneSlices(m.Signature),
	}
}

// Equals checks for equality with another ContractSigner instance
func (m *ContractSigner) Equals(other *ContractSigner) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Party.Equals(other.Party) { return false }
	if !compareSlices(m.Signature, other.Signature) { return false }
	return true
}

// ContractFriendly
// The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
type ContractFriendly struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ContentAttachment *Attachment `json:"contentattachment,omitempty"`
	ContentReference *Reference `json:"contentreference,omitempty"`
}

// NewContractFriendly creates a new ContractFriendly instance
func NewContractFriendly() *ContractFriendly {
	return &ContractFriendly{}
}

// FromJSON populates ContractFriendly from JSON data
func (m *ContractFriendly) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractFriendly to JSON data
func (m *ContractFriendly) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractFriendly
func (m *ContractFriendly) Clone() *ContractFriendly {
	if m == nil { return nil }
	return &ContractFriendly{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ContentAttachment: m.ContentAttachment.Clone(),
		ContentReference: m.ContentReference.Clone(),
	}
}

// Equals checks for equality with another ContractFriendly instance
func (m *ContractFriendly) Equals(other *ContractFriendly) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ContentAttachment.Equals(other.ContentAttachment) { return false }
	if !m.ContentReference.Equals(other.ContentReference) { return false }
	return true
}

// ContractLegal
// List of Legal expressions or representations of this Contract.
type ContractLegal struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ContentAttachment *Attachment `json:"contentattachment,omitempty"`
	ContentReference *Reference `json:"contentreference,omitempty"`
}

// NewContractLegal creates a new ContractLegal instance
func NewContractLegal() *ContractLegal {
	return &ContractLegal{}
}

// FromJSON populates ContractLegal from JSON data
func (m *ContractLegal) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractLegal to JSON data
func (m *ContractLegal) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractLegal
func (m *ContractLegal) Clone() *ContractLegal {
	if m == nil { return nil }
	return &ContractLegal{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ContentAttachment: m.ContentAttachment.Clone(),
		ContentReference: m.ContentReference.Clone(),
	}
}

// Equals checks for equality with another ContractLegal instance
func (m *ContractLegal) Equals(other *ContractLegal) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ContentAttachment.Equals(other.ContentAttachment) { return false }
	if !m.ContentReference.Equals(other.ContentReference) { return false }
	return true
}

// ContractRule
// List of Computable Policy Rule Language Representations of this Contract.
type ContractRule struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ContentAttachment *Attachment `json:"contentattachment,omitempty"`
	ContentReference *Reference `json:"contentreference,omitempty"`
}

// NewContractRule creates a new ContractRule instance
func NewContractRule() *ContractRule {
	return &ContractRule{}
}

// FromJSON populates ContractRule from JSON data
func (m *ContractRule) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ContractRule to JSON data
func (m *ContractRule) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ContractRule
func (m *ContractRule) Clone() *ContractRule {
	if m == nil { return nil }
	return &ContractRule{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ContentAttachment: m.ContentAttachment.Clone(),
		ContentReference: m.ContentReference.Clone(),
	}
}

// Equals checks for equality with another ContractRule instance
func (m *ContractRule) Equals(other *ContractRule) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ContentAttachment.Equals(other.ContentAttachment) { return false }
	if !m.ContentReference.Equals(other.ContentReference) { return false }
	return true
}

