// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ObservationDefinition
// Set of definitional characteristics for a kind of observation or measurement produced or consumed by an orderable health care service.
type ObservationDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	PermittedDataType []*ObservationDataType `json:"permitteddatatype,omitempty"`
	MultipleResultsAllowed *FhirBoolean `json:"multipleresultsallowed,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	PreferredReportName *FhirString `json:"preferredreportname,omitempty"`
	QuantitativeDetails *ObservationDefinitionQuantitativeDetails `json:"quantitativedetails,omitempty"`
	QualifiedInterval []*ObservationDefinitionQualifiedInterval `json:"qualifiedinterval,omitempty"`
	ValidCodedValueSet *Reference `json:"validcodedvalueset,omitempty"`
	NormalCodedValueSet *Reference `json:"normalcodedvalueset,omitempty"`
	AbnormalCodedValueSet *Reference `json:"abnormalcodedvalueset,omitempty"`
	CriticalCodedValueSet *Reference `json:"criticalcodedvalueset,omitempty"`
}

// NewObservationDefinition creates a new ObservationDefinition instance
func NewObservationDefinition() *ObservationDefinition {
	return &ObservationDefinition{}
}

// FromJSON populates ObservationDefinition from JSON data
func (m *ObservationDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ObservationDefinition to JSON data
func (m *ObservationDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ObservationDefinition
func (m *ObservationDefinition) Clone() *ObservationDefinition {
	if m == nil { return nil }
	return &ObservationDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: cloneSlices(m.Category),
		Code: m.Code.Clone(),
		Identifier: cloneSlices(m.Identifier),
		PermittedDataType: cloneSlices(m.PermittedDataType),
		MultipleResultsAllowed: m.MultipleResultsAllowed.Clone(),
		Method: m.Method.Clone(),
		PreferredReportName: m.PreferredReportName.Clone(),
		QuantitativeDetails: m.QuantitativeDetails.Clone(),
		QualifiedInterval: cloneSlices(m.QualifiedInterval),
		ValidCodedValueSet: m.ValidCodedValueSet.Clone(),
		NormalCodedValueSet: m.NormalCodedValueSet.Clone(),
		AbnormalCodedValueSet: m.AbnormalCodedValueSet.Clone(),
		CriticalCodedValueSet: m.CriticalCodedValueSet.Clone(),
	}
}

// Equals checks for equality with another ObservationDefinition instance
func (m *ObservationDefinition) Equals(other *ObservationDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.PermittedDataType, other.PermittedDataType) { return false }
	if !m.MultipleResultsAllowed.Equals(other.MultipleResultsAllowed) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.PreferredReportName.Equals(other.PreferredReportName) { return false }
	if !m.QuantitativeDetails.Equals(other.QuantitativeDetails) { return false }
	if !compareSlices(m.QualifiedInterval, other.QualifiedInterval) { return false }
	if !m.ValidCodedValueSet.Equals(other.ValidCodedValueSet) { return false }
	if !m.NormalCodedValueSet.Equals(other.NormalCodedValueSet) { return false }
	if !m.AbnormalCodedValueSet.Equals(other.AbnormalCodedValueSet) { return false }
	if !m.CriticalCodedValueSet.Equals(other.CriticalCodedValueSet) { return false }
	return true
}

// ObservationDefinitionQuantitativeDetails
// Characteristics for quantitative results of this observation.
type ObservationDefinitionQuantitativeDetails struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	CustomaryUnit *CodeableConcept `json:"customaryunit,omitempty"`
	Unit *CodeableConcept `json:"unit,omitempty"`
	ConversionFactor *FhirDecimal `json:"conversionfactor,omitempty"`
	DecimalPrecision *FhirInteger `json:"decimalprecision,omitempty"`
}

// NewObservationDefinitionQuantitativeDetails creates a new ObservationDefinitionQuantitativeDetails instance
func NewObservationDefinitionQuantitativeDetails() *ObservationDefinitionQuantitativeDetails {
	return &ObservationDefinitionQuantitativeDetails{}
}

// FromJSON populates ObservationDefinitionQuantitativeDetails from JSON data
func (m *ObservationDefinitionQuantitativeDetails) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ObservationDefinitionQuantitativeDetails to JSON data
func (m *ObservationDefinitionQuantitativeDetails) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ObservationDefinitionQuantitativeDetails
func (m *ObservationDefinitionQuantitativeDetails) Clone() *ObservationDefinitionQuantitativeDetails {
	if m == nil { return nil }
	return &ObservationDefinitionQuantitativeDetails{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		CustomaryUnit: m.CustomaryUnit.Clone(),
		Unit: m.Unit.Clone(),
		ConversionFactor: m.ConversionFactor.Clone(),
		DecimalPrecision: m.DecimalPrecision.Clone(),
	}
}

// Equals checks for equality with another ObservationDefinitionQuantitativeDetails instance
func (m *ObservationDefinitionQuantitativeDetails) Equals(other *ObservationDefinitionQuantitativeDetails) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.CustomaryUnit.Equals(other.CustomaryUnit) { return false }
	if !m.Unit.Equals(other.Unit) { return false }
	if !m.ConversionFactor.Equals(other.ConversionFactor) { return false }
	if !m.DecimalPrecision.Equals(other.DecimalPrecision) { return false }
	return true
}

// ObservationDefinitionQualifiedInterval
// Multiple  ranges of results qualified by different contexts for ordinal or continuous observations conforming to this ObservationDefinition.
type ObservationDefinitionQualifiedInterval struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Category *ObservationRangeCategory `json:"category,omitempty"`
	Range *Range `json:"range,omitempty"`
	Context *CodeableConcept `json:"context,omitempty"`
	AppliesTo []*CodeableConcept `json:"appliesto,omitempty"`
	Gender *AdministrativeGender `json:"gender,omitempty"`
	Age *Range `json:"age,omitempty"`
	GestationalAge *Range `json:"gestationalage,omitempty"`
	Condition *FhirString `json:"condition,omitempty"`
}

// NewObservationDefinitionQualifiedInterval creates a new ObservationDefinitionQualifiedInterval instance
func NewObservationDefinitionQualifiedInterval() *ObservationDefinitionQualifiedInterval {
	return &ObservationDefinitionQualifiedInterval{}
}

// FromJSON populates ObservationDefinitionQualifiedInterval from JSON data
func (m *ObservationDefinitionQualifiedInterval) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ObservationDefinitionQualifiedInterval to JSON data
func (m *ObservationDefinitionQualifiedInterval) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ObservationDefinitionQualifiedInterval
func (m *ObservationDefinitionQualifiedInterval) Clone() *ObservationDefinitionQualifiedInterval {
	if m == nil { return nil }
	return &ObservationDefinitionQualifiedInterval{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Category: m.Category.Clone(),
		Range: m.Range.Clone(),
		Context: m.Context.Clone(),
		AppliesTo: cloneSlices(m.AppliesTo),
		Gender: m.Gender.Clone(),
		Age: m.Age.Clone(),
		GestationalAge: m.GestationalAge.Clone(),
		Condition: m.Condition.Clone(),
	}
}

// Equals checks for equality with another ObservationDefinitionQualifiedInterval instance
func (m *ObservationDefinitionQualifiedInterval) Equals(other *ObservationDefinitionQualifiedInterval) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Range.Equals(other.Range) { return false }
	if !m.Context.Equals(other.Context) { return false }
	if !compareSlices(m.AppliesTo, other.AppliesTo) { return false }
	if !m.Gender.Equals(other.Gender) { return false }
	if !m.Age.Equals(other.Age) { return false }
	if !m.GestationalAge.Equals(other.GestationalAge) { return false }
	if !m.Condition.Equals(other.Condition) { return false }
	return true
}

