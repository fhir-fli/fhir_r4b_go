// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Invoice
// Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose.
type Invoice struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *InvoiceStatus `json:"status,omitempty"`
	CancelledReason *FhirString `json:"cancelledreason,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Recipient *Reference `json:"recipient,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Participant []*InvoiceParticipant `json:"participant,omitempty"`
	Issuer *Reference `json:"issuer,omitempty"`
	Account *Reference `json:"account,omitempty"`
	LineItem []*InvoiceLineItem `json:"lineitem,omitempty"`
	TotalPriceComponent []*InvoicePriceComponent `json:"totalpricecomponent,omitempty"`
	TotalNet *Money `json:"totalnet,omitempty"`
	TotalGross *Money `json:"totalgross,omitempty"`
	PaymentTerms *FhirMarkdown `json:"paymentterms,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewInvoice creates a new Invoice instance
func NewInvoice() *Invoice {
	return &Invoice{}
}

// FromJSON populates Invoice from JSON data
func (m *Invoice) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Invoice to JSON data
func (m *Invoice) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Invoice
func (m *Invoice) Clone() *Invoice {
	if m == nil { return nil }
	return &Invoice{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		CancelledReason: m.CancelledReason.Clone(),
		Type: m.Type.Clone(),
		Subject: m.Subject.Clone(),
		Recipient: m.Recipient.Clone(),
		Date: m.Date.Clone(),
		Participant: cloneSlices(m.Participant),
		Issuer: m.Issuer.Clone(),
		Account: m.Account.Clone(),
		LineItem: cloneSlices(m.LineItem),
		TotalPriceComponent: cloneSlices(m.TotalPriceComponent),
		TotalNet: m.TotalNet.Clone(),
		TotalGross: m.TotalGross.Clone(),
		PaymentTerms: m.PaymentTerms.Clone(),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks for equality with another Invoice instance
func (m *Invoice) Equals(other *Invoice) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.CancelledReason.Equals(other.CancelledReason) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Recipient.Equals(other.Recipient) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !compareSlices(m.Participant, other.Participant) { return false }
	if !m.Issuer.Equals(other.Issuer) { return false }
	if !m.Account.Equals(other.Account) { return false }
	if !compareSlices(m.LineItem, other.LineItem) { return false }
	if !compareSlices(m.TotalPriceComponent, other.TotalPriceComponent) { return false }
	if !m.TotalNet.Equals(other.TotalNet) { return false }
	if !m.TotalGross.Equals(other.TotalGross) { return false }
	if !m.PaymentTerms.Equals(other.PaymentTerms) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// InvoiceParticipant
// Indicates who or what performed or participated in the charged service.
type InvoiceParticipant struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewInvoiceParticipant creates a new InvoiceParticipant instance
func NewInvoiceParticipant() *InvoiceParticipant {
	return &InvoiceParticipant{}
}

// FromJSON populates InvoiceParticipant from JSON data
func (m *InvoiceParticipant) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts InvoiceParticipant to JSON data
func (m *InvoiceParticipant) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of InvoiceParticipant
func (m *InvoiceParticipant) Clone() *InvoiceParticipant {
	if m == nil { return nil }
	return &InvoiceParticipant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Role: m.Role.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks for equality with another InvoiceParticipant instance
func (m *InvoiceParticipant) Equals(other *InvoiceParticipant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

// InvoiceLineItem
// Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
type InvoiceLineItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Sequence *FhirPositiveInt `json:"sequence,omitempty"`
	ChargeItemReference *Reference `json:"chargeitemreference,omitempty"`
	ChargeItemCodeableConcept *CodeableConcept `json:"chargeitemcodeableconcept,omitempty"`
	PriceComponent []*InvoicePriceComponent `json:"pricecomponent,omitempty"`
}

// NewInvoiceLineItem creates a new InvoiceLineItem instance
func NewInvoiceLineItem() *InvoiceLineItem {
	return &InvoiceLineItem{}
}

// FromJSON populates InvoiceLineItem from JSON data
func (m *InvoiceLineItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts InvoiceLineItem to JSON data
func (m *InvoiceLineItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of InvoiceLineItem
func (m *InvoiceLineItem) Clone() *InvoiceLineItem {
	if m == nil { return nil }
	return &InvoiceLineItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Sequence: m.Sequence.Clone(),
		ChargeItemReference: m.ChargeItemReference.Clone(),
		ChargeItemCodeableConcept: m.ChargeItemCodeableConcept.Clone(),
		PriceComponent: cloneSlices(m.PriceComponent),
	}
}

// Equals checks for equality with another InvoiceLineItem instance
func (m *InvoiceLineItem) Equals(other *InvoiceLineItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Sequence.Equals(other.Sequence) { return false }
	if !m.ChargeItemReference.Equals(other.ChargeItemReference) { return false }
	if !m.ChargeItemCodeableConcept.Equals(other.ChargeItemCodeableConcept) { return false }
	if !compareSlices(m.PriceComponent, other.PriceComponent) { return false }
	return true
}

// InvoicePriceComponent
// The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
type InvoicePriceComponent struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *InvoicePriceComponentType `json:"type,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Factor *FhirDecimal `json:"factor,omitempty"`
	Amount *Money `json:"amount,omitempty"`
}

// NewInvoicePriceComponent creates a new InvoicePriceComponent instance
func NewInvoicePriceComponent() *InvoicePriceComponent {
	return &InvoicePriceComponent{}
}

// FromJSON populates InvoicePriceComponent from JSON data
func (m *InvoicePriceComponent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts InvoicePriceComponent to JSON data
func (m *InvoicePriceComponent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of InvoicePriceComponent
func (m *InvoicePriceComponent) Clone() *InvoicePriceComponent {
	if m == nil { return nil }
	return &InvoicePriceComponent{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Code: m.Code.Clone(),
		Factor: m.Factor.Clone(),
		Amount: m.Amount.Clone(),
	}
}

// Equals checks for equality with another InvoicePriceComponent instance
func (m *InvoicePriceComponent) Equals(other *InvoicePriceComponent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Factor.Equals(other.Factor) { return false }
	if !m.Amount.Equals(other.Amount) { return false }
	return true
}

