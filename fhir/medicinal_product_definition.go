// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// MedicinalProductDefinition
// A medicinal product, being a substance or combination of substances that is intended to treat, prevent or diagnose a disease, or to restore, correct or modify physiological functions by exerting a pharmacological, immunological or metabolic action. This resource is intended to define and detail such products and their properties, for uses other than direct patient care (e.g. regulatory use, or drug catalogs).
type MedicinalProductDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Domain *CodeableConcept `json:"domain,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	StatusDate *FhirDateTime `json:"statusdate,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	CombinedPharmaceuticalDoseForm *CodeableConcept `json:"combinedpharmaceuticaldoseform,omitempty"`
	Route []*CodeableConcept `json:"route,omitempty"`
	Indication *FhirMarkdown `json:"indication,omitempty"`
	LegalStatusOfSupply *CodeableConcept `json:"legalstatusofsupply,omitempty"`
	AdditionalMonitoringIndicator *CodeableConcept `json:"additionalmonitoringindicator,omitempty"`
	SpecialMeasures []*CodeableConcept `json:"specialmeasures,omitempty"`
	PediatricUseIndicator *CodeableConcept `json:"pediatricuseindicator,omitempty"`
	Classification []*CodeableConcept `json:"classification,omitempty"`
	MarketingStatus []*MarketingStatus `json:"marketingstatus,omitempty"`
	PackagedMedicinalProduct []*CodeableConcept `json:"packagedmedicinalproduct,omitempty"`
	Ingredient []*CodeableConcept `json:"ingredient,omitempty"`
	Impurity []*CodeableReference `json:"impurity,omitempty"`
	AttachedDocument []*Reference `json:"attacheddocument,omitempty"`
	MasterFile []*Reference `json:"masterfile,omitempty"`
	Contact []*MedicinalProductDefinitionContact `json:"contact,omitempty"`
	ClinicalTrial []*Reference `json:"clinicaltrial,omitempty"`
	Code []*Coding `json:"code,omitempty"`
	Name []*MedicinalProductDefinitionName `json:"name,omitempty"`
	CrossReference []*MedicinalProductDefinitionCrossReference `json:"crossreference,omitempty"`
	Operation []*MedicinalProductDefinitionOperation `json:"operation,omitempty"`
	Characteristic []*MedicinalProductDefinitionCharacteristic `json:"characteristic,omitempty"`
}

// NewMedicinalProductDefinition creates a new MedicinalProductDefinition instance
func NewMedicinalProductDefinition() *MedicinalProductDefinition {
	return &MedicinalProductDefinition{}
}

// FromJSON populates MedicinalProductDefinition from JSON data
func (m *MedicinalProductDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinition to JSON data
func (m *MedicinalProductDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinition
func (m *MedicinalProductDefinition) Clone() *MedicinalProductDefinition {
	if m == nil { return nil }
	return &MedicinalProductDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Type: m.Type.Clone(),
		Domain: m.Domain.Clone(),
		Version: m.Version.Clone(),
		Status: m.Status.Clone(),
		StatusDate: m.StatusDate.Clone(),
		Description: m.Description.Clone(),
		CombinedPharmaceuticalDoseForm: m.CombinedPharmaceuticalDoseForm.Clone(),
		Route: cloneSlices(m.Route),
		Indication: m.Indication.Clone(),
		LegalStatusOfSupply: m.LegalStatusOfSupply.Clone(),
		AdditionalMonitoringIndicator: m.AdditionalMonitoringIndicator.Clone(),
		SpecialMeasures: cloneSlices(m.SpecialMeasures),
		PediatricUseIndicator: m.PediatricUseIndicator.Clone(),
		Classification: cloneSlices(m.Classification),
		MarketingStatus: cloneSlices(m.MarketingStatus),
		PackagedMedicinalProduct: cloneSlices(m.PackagedMedicinalProduct),
		Ingredient: cloneSlices(m.Ingredient),
		Impurity: cloneSlices(m.Impurity),
		AttachedDocument: cloneSlices(m.AttachedDocument),
		MasterFile: cloneSlices(m.MasterFile),
		Contact: cloneSlices(m.Contact),
		ClinicalTrial: cloneSlices(m.ClinicalTrial),
		Code: cloneSlices(m.Code),
		Name: cloneSlices(m.Name),
		CrossReference: cloneSlices(m.CrossReference),
		Operation: cloneSlices(m.Operation),
		Characteristic: cloneSlices(m.Characteristic),
	}
}

// Equals checks for equality with another MedicinalProductDefinition instance
func (m *MedicinalProductDefinition) Equals(other *MedicinalProductDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Domain.Equals(other.Domain) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.CombinedPharmaceuticalDoseForm.Equals(other.CombinedPharmaceuticalDoseForm) { return false }
	if !compareSlices(m.Route, other.Route) { return false }
	if !m.Indication.Equals(other.Indication) { return false }
	if !m.LegalStatusOfSupply.Equals(other.LegalStatusOfSupply) { return false }
	if !m.AdditionalMonitoringIndicator.Equals(other.AdditionalMonitoringIndicator) { return false }
	if !compareSlices(m.SpecialMeasures, other.SpecialMeasures) { return false }
	if !m.PediatricUseIndicator.Equals(other.PediatricUseIndicator) { return false }
	if !compareSlices(m.Classification, other.Classification) { return false }
	if !compareSlices(m.MarketingStatus, other.MarketingStatus) { return false }
	if !compareSlices(m.PackagedMedicinalProduct, other.PackagedMedicinalProduct) { return false }
	if !compareSlices(m.Ingredient, other.Ingredient) { return false }
	if !compareSlices(m.Impurity, other.Impurity) { return false }
	if !compareSlices(m.AttachedDocument, other.AttachedDocument) { return false }
	if !compareSlices(m.MasterFile, other.MasterFile) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !compareSlices(m.ClinicalTrial, other.ClinicalTrial) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Name, other.Name) { return false }
	if !compareSlices(m.CrossReference, other.CrossReference) { return false }
	if !compareSlices(m.Operation, other.Operation) { return false }
	if !compareSlices(m.Characteristic, other.Characteristic) { return false }
	return true
}

// MedicinalProductDefinitionContact
// A product specific contact, person (in a role), or an organization.
type MedicinalProductDefinitionContact struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Contact *Reference `json:"contact,omitempty"`
}

// NewMedicinalProductDefinitionContact creates a new MedicinalProductDefinitionContact instance
func NewMedicinalProductDefinitionContact() *MedicinalProductDefinitionContact {
	return &MedicinalProductDefinitionContact{}
}

// FromJSON populates MedicinalProductDefinitionContact from JSON data
func (m *MedicinalProductDefinitionContact) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinitionContact to JSON data
func (m *MedicinalProductDefinitionContact) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinitionContact
func (m *MedicinalProductDefinitionContact) Clone() *MedicinalProductDefinitionContact {
	if m == nil { return nil }
	return &MedicinalProductDefinitionContact{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Contact: m.Contact.Clone(),
	}
}

// Equals checks for equality with another MedicinalProductDefinitionContact instance
func (m *MedicinalProductDefinitionContact) Equals(other *MedicinalProductDefinitionContact) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Contact.Equals(other.Contact) { return false }
	return true
}

// MedicinalProductDefinitionName
// The product's name, including full name and possibly coded parts.
type MedicinalProductDefinitionName struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ProductName *FhirString `json:"productname,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	NamePart []*MedicinalProductDefinitionNamePart `json:"namepart,omitempty"`
	CountryLanguage []*MedicinalProductDefinitionCountryLanguage `json:"countrylanguage,omitempty"`
}

// NewMedicinalProductDefinitionName creates a new MedicinalProductDefinitionName instance
func NewMedicinalProductDefinitionName() *MedicinalProductDefinitionName {
	return &MedicinalProductDefinitionName{}
}

// FromJSON populates MedicinalProductDefinitionName from JSON data
func (m *MedicinalProductDefinitionName) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinitionName to JSON data
func (m *MedicinalProductDefinitionName) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinitionName
func (m *MedicinalProductDefinitionName) Clone() *MedicinalProductDefinitionName {
	if m == nil { return nil }
	return &MedicinalProductDefinitionName{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ProductName: m.ProductName.Clone(),
		Type: m.Type.Clone(),
		NamePart: cloneSlices(m.NamePart),
		CountryLanguage: cloneSlices(m.CountryLanguage),
	}
}

// Equals checks for equality with another MedicinalProductDefinitionName instance
func (m *MedicinalProductDefinitionName) Equals(other *MedicinalProductDefinitionName) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ProductName.Equals(other.ProductName) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.NamePart, other.NamePart) { return false }
	if !compareSlices(m.CountryLanguage, other.CountryLanguage) { return false }
	return true
}

// MedicinalProductDefinitionNamePart
// Coding words or phrases of the name.
type MedicinalProductDefinitionNamePart struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Part_ *FhirString `json:"part,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
}

// NewMedicinalProductDefinitionNamePart creates a new MedicinalProductDefinitionNamePart instance
func NewMedicinalProductDefinitionNamePart() *MedicinalProductDefinitionNamePart {
	return &MedicinalProductDefinitionNamePart{}
}

// FromJSON populates MedicinalProductDefinitionNamePart from JSON data
func (m *MedicinalProductDefinitionNamePart) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinitionNamePart to JSON data
func (m *MedicinalProductDefinitionNamePart) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinitionNamePart
func (m *MedicinalProductDefinitionNamePart) Clone() *MedicinalProductDefinitionNamePart {
	if m == nil { return nil }
	return &MedicinalProductDefinitionNamePart{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Part_: m.Part_.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks for equality with another MedicinalProductDefinitionNamePart instance
func (m *MedicinalProductDefinitionNamePart) Equals(other *MedicinalProductDefinitionNamePart) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Part_.Equals(other.Part_) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// MedicinalProductDefinitionCountryLanguage
// Country and jurisdiction where the name applies, and associated language.
type MedicinalProductDefinitionCountryLanguage struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Country *CodeableConcept `json:"country,omitempty"`
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`
	Language *CodeableConcept `json:"language,omitempty"`
}

// NewMedicinalProductDefinitionCountryLanguage creates a new MedicinalProductDefinitionCountryLanguage instance
func NewMedicinalProductDefinitionCountryLanguage() *MedicinalProductDefinitionCountryLanguage {
	return &MedicinalProductDefinitionCountryLanguage{}
}

// FromJSON populates MedicinalProductDefinitionCountryLanguage from JSON data
func (m *MedicinalProductDefinitionCountryLanguage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinitionCountryLanguage to JSON data
func (m *MedicinalProductDefinitionCountryLanguage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinitionCountryLanguage
func (m *MedicinalProductDefinitionCountryLanguage) Clone() *MedicinalProductDefinitionCountryLanguage {
	if m == nil { return nil }
	return &MedicinalProductDefinitionCountryLanguage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Country: m.Country.Clone(),
		Jurisdiction: m.Jurisdiction.Clone(),
		Language: m.Language.Clone(),
	}
}

// Equals checks for equality with another MedicinalProductDefinitionCountryLanguage instance
func (m *MedicinalProductDefinitionCountryLanguage) Equals(other *MedicinalProductDefinitionCountryLanguage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Country.Equals(other.Country) { return false }
	if !m.Jurisdiction.Equals(other.Jurisdiction) { return false }
	if !m.Language.Equals(other.Language) { return false }
	return true
}

// MedicinalProductDefinitionCrossReference
// Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
type MedicinalProductDefinitionCrossReference struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Product *CodeableReference `json:"product,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
}

// NewMedicinalProductDefinitionCrossReference creates a new MedicinalProductDefinitionCrossReference instance
func NewMedicinalProductDefinitionCrossReference() *MedicinalProductDefinitionCrossReference {
	return &MedicinalProductDefinitionCrossReference{}
}

// FromJSON populates MedicinalProductDefinitionCrossReference from JSON data
func (m *MedicinalProductDefinitionCrossReference) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinitionCrossReference to JSON data
func (m *MedicinalProductDefinitionCrossReference) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinitionCrossReference
func (m *MedicinalProductDefinitionCrossReference) Clone() *MedicinalProductDefinitionCrossReference {
	if m == nil { return nil }
	return &MedicinalProductDefinitionCrossReference{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Product: m.Product.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks for equality with another MedicinalProductDefinitionCrossReference instance
func (m *MedicinalProductDefinitionCrossReference) Equals(other *MedicinalProductDefinitionCrossReference) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Product.Equals(other.Product) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// MedicinalProductDefinitionOperation
// A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
type MedicinalProductDefinitionOperation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableReference `json:"type,omitempty"`
	EffectiveDate *Period `json:"effectivedate,omitempty"`
	Organization []*Reference `json:"organization,omitempty"`
	ConfidentialityIndicator *CodeableConcept `json:"confidentialityindicator,omitempty"`
}

// NewMedicinalProductDefinitionOperation creates a new MedicinalProductDefinitionOperation instance
func NewMedicinalProductDefinitionOperation() *MedicinalProductDefinitionOperation {
	return &MedicinalProductDefinitionOperation{}
}

// FromJSON populates MedicinalProductDefinitionOperation from JSON data
func (m *MedicinalProductDefinitionOperation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinitionOperation to JSON data
func (m *MedicinalProductDefinitionOperation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinitionOperation
func (m *MedicinalProductDefinitionOperation) Clone() *MedicinalProductDefinitionOperation {
	if m == nil { return nil }
	return &MedicinalProductDefinitionOperation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		EffectiveDate: m.EffectiveDate.Clone(),
		Organization: cloneSlices(m.Organization),
		ConfidentialityIndicator: m.ConfidentialityIndicator.Clone(),
	}
}

// Equals checks for equality with another MedicinalProductDefinitionOperation instance
func (m *MedicinalProductDefinitionOperation) Equals(other *MedicinalProductDefinitionOperation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.EffectiveDate.Equals(other.EffectiveDate) { return false }
	if !compareSlices(m.Organization, other.Organization) { return false }
	if !m.ConfidentialityIndicator.Equals(other.ConfidentialityIndicator) { return false }
	return true
}

// MedicinalProductDefinitionCharacteristic
// Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
type MedicinalProductDefinitionCharacteristic struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
}

// NewMedicinalProductDefinitionCharacteristic creates a new MedicinalProductDefinitionCharacteristic instance
func NewMedicinalProductDefinitionCharacteristic() *MedicinalProductDefinitionCharacteristic {
	return &MedicinalProductDefinitionCharacteristic{}
}

// FromJSON populates MedicinalProductDefinitionCharacteristic from JSON data
func (m *MedicinalProductDefinitionCharacteristic) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MedicinalProductDefinitionCharacteristic to JSON data
func (m *MedicinalProductDefinitionCharacteristic) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MedicinalProductDefinitionCharacteristic
func (m *MedicinalProductDefinitionCharacteristic) Clone() *MedicinalProductDefinitionCharacteristic {
	if m == nil { return nil }
	return &MedicinalProductDefinitionCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
	}
}

// Equals checks for equality with another MedicinalProductDefinitionCharacteristic instance
func (m *MedicinalProductDefinitionCharacteristic) Equals(other *MedicinalProductDefinitionCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	return true
}

