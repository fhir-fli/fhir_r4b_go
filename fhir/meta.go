// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// FhirMeta
// The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
type FhirMeta struct {
	DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	VersionId *FhirId `json:"versionid,omitempty"`
	LastUpdated *FhirInstant `json:"lastupdated,omitempty"`
	Source *FhirUri `json:"source,omitempty"`
	Profile []*FhirCanonical `json:"profile,omitempty"`
	Security []*Coding `json:"security,omitempty"`
	Tag []*Coding `json:"tag,omitempty"`
}

// NewFhirMeta creates a new FhirMeta instance
func NewFhirMeta() *FhirMeta {
	return &FhirMeta{}
}

// FromJSON populates FhirMeta from JSON data
func (m *FhirMeta) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts FhirMeta to JSON data
func (m *FhirMeta) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of FhirMeta
func (m *FhirMeta) Clone() *FhirMeta {
	if m == nil { return nil }
	return &FhirMeta{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		VersionId: m.VersionId.Clone(),
		LastUpdated: m.LastUpdated.Clone(),
		Source: m.Source.Clone(),
		Profile: cloneSlices(m.Profile),
		Security: cloneSlices(m.Security),
		Tag: cloneSlices(m.Tag),
	}
}

// Equals checks for equality with another FhirMeta instance
func (m *FhirMeta) Equals(other *FhirMeta) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.VersionId.Equals(other.VersionId) { return false }
	if !m.LastUpdated.Equals(other.LastUpdated) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !compareSlices(m.Profile, other.Profile) { return false }
	if !compareSlices(m.Security, other.Security) { return false }
	if !compareSlices(m.Tag, other.Tag) { return false }
	return true
}

