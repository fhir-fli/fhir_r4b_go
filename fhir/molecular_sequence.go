// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// MolecularSequence
// Raw data describing a biological sequence.
type MolecularSequence struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Type *SequenceType `json:"type,omitempty"`
	CoordinateSystem *FhirInteger `json:"coordinatesystem,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	Specimen *Reference `json:"specimen,omitempty"`
	Device *Reference `json:"device,omitempty"`
	Performer *Reference `json:"performer,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	ReferenceSeq *MolecularSequenceReferenceSeq `json:"referenceseq,omitempty"`
	Variant []*MolecularSequenceVariant `json:"variant,omitempty"`
	ObservedSeq *FhirString `json:"observedseq,omitempty"`
	Quality []*MolecularSequenceQuality `json:"quality,omitempty"`
	ReadCoverage *FhirInteger `json:"readcoverage,omitempty"`
	Repository []*MolecularSequenceRepository `json:"repository,omitempty"`
	Pointer []*Reference `json:"pointer,omitempty"`
	StructureVariant []*MolecularSequenceStructureVariant `json:"structurevariant,omitempty"`
}

// NewMolecularSequence creates a new MolecularSequence instance
func NewMolecularSequence() *MolecularSequence {
	return &MolecularSequence{}
}

// FromJSON populates MolecularSequence from JSON data
func (m *MolecularSequence) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequence to JSON data
func (m *MolecularSequence) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequence
func (m *MolecularSequence) Clone() *MolecularSequence {
	if m == nil { return nil }
	return &MolecularSequence{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Type: m.Type.Clone(),
		CoordinateSystem: m.CoordinateSystem.Clone(),
		Patient: m.Patient.Clone(),
		Specimen: m.Specimen.Clone(),
		Device: m.Device.Clone(),
		Performer: m.Performer.Clone(),
		Quantity: m.Quantity.Clone(),
		ReferenceSeq: m.ReferenceSeq.Clone(),
		Variant: cloneSlices(m.Variant),
		ObservedSeq: m.ObservedSeq.Clone(),
		Quality: cloneSlices(m.Quality),
		ReadCoverage: m.ReadCoverage.Clone(),
		Repository: cloneSlices(m.Repository),
		Pointer: cloneSlices(m.Pointer),
		StructureVariant: cloneSlices(m.StructureVariant),
	}
}

// Equals checks for equality with another MolecularSequence instance
func (m *MolecularSequence) Equals(other *MolecularSequence) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.CoordinateSystem.Equals(other.CoordinateSystem) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.Specimen.Equals(other.Specimen) { return false }
	if !m.Device.Equals(other.Device) { return false }
	if !m.Performer.Equals(other.Performer) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.ReferenceSeq.Equals(other.ReferenceSeq) { return false }
	if !compareSlices(m.Variant, other.Variant) { return false }
	if !m.ObservedSeq.Equals(other.ObservedSeq) { return false }
	if !compareSlices(m.Quality, other.Quality) { return false }
	if !m.ReadCoverage.Equals(other.ReadCoverage) { return false }
	if !compareSlices(m.Repository, other.Repository) { return false }
	if !compareSlices(m.Pointer, other.Pointer) { return false }
	if !compareSlices(m.StructureVariant, other.StructureVariant) { return false }
	return true
}

// MolecularSequenceReferenceSeq
// A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
type MolecularSequenceReferenceSeq struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Chromosome *CodeableConcept `json:"chromosome,omitempty"`
	GenomeBuild *FhirString `json:"genomebuild,omitempty"`
	Orientation *OrientationType `json:"orientation,omitempty"`
	ReferenceSeqId *CodeableConcept `json:"referenceseqid,omitempty"`
	ReferenceSeqPointer *Reference `json:"referenceseqpointer,omitempty"`
	ReferenceSeqString *FhirString `json:"referenceseqstring,omitempty"`
	Strand *StrandType `json:"strand,omitempty"`
	WindowStart *FhirInteger `json:"windowstart,omitempty"`
	WindowEnd *FhirInteger `json:"windowend,omitempty"`
}

// NewMolecularSequenceReferenceSeq creates a new MolecularSequenceReferenceSeq instance
func NewMolecularSequenceReferenceSeq() *MolecularSequenceReferenceSeq {
	return &MolecularSequenceReferenceSeq{}
}

// FromJSON populates MolecularSequenceReferenceSeq from JSON data
func (m *MolecularSequenceReferenceSeq) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceReferenceSeq to JSON data
func (m *MolecularSequenceReferenceSeq) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceReferenceSeq
func (m *MolecularSequenceReferenceSeq) Clone() *MolecularSequenceReferenceSeq {
	if m == nil { return nil }
	return &MolecularSequenceReferenceSeq{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Chromosome: m.Chromosome.Clone(),
		GenomeBuild: m.GenomeBuild.Clone(),
		Orientation: m.Orientation.Clone(),
		ReferenceSeqId: m.ReferenceSeqId.Clone(),
		ReferenceSeqPointer: m.ReferenceSeqPointer.Clone(),
		ReferenceSeqString: m.ReferenceSeqString.Clone(),
		Strand: m.Strand.Clone(),
		WindowStart: m.WindowStart.Clone(),
		WindowEnd: m.WindowEnd.Clone(),
	}
}

// Equals checks for equality with another MolecularSequenceReferenceSeq instance
func (m *MolecularSequenceReferenceSeq) Equals(other *MolecularSequenceReferenceSeq) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Chromosome.Equals(other.Chromosome) { return false }
	if !m.GenomeBuild.Equals(other.GenomeBuild) { return false }
	if !m.Orientation.Equals(other.Orientation) { return false }
	if !m.ReferenceSeqId.Equals(other.ReferenceSeqId) { return false }
	if !m.ReferenceSeqPointer.Equals(other.ReferenceSeqPointer) { return false }
	if !m.ReferenceSeqString.Equals(other.ReferenceSeqString) { return false }
	if !m.Strand.Equals(other.Strand) { return false }
	if !m.WindowStart.Equals(other.WindowStart) { return false }
	if !m.WindowEnd.Equals(other.WindowEnd) { return false }
	return true
}

// MolecularSequenceVariant
// The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
type MolecularSequenceVariant struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Start *FhirInteger `json:"start,omitempty"`
	End *FhirInteger `json:"end,omitempty"`
	ObservedAllele *FhirString `json:"observedallele,omitempty"`
	ReferenceAllele *FhirString `json:"referenceallele,omitempty"`
	Cigar *FhirString `json:"cigar,omitempty"`
	VariantPointer *Reference `json:"variantpointer,omitempty"`
}

// NewMolecularSequenceVariant creates a new MolecularSequenceVariant instance
func NewMolecularSequenceVariant() *MolecularSequenceVariant {
	return &MolecularSequenceVariant{}
}

// FromJSON populates MolecularSequenceVariant from JSON data
func (m *MolecularSequenceVariant) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceVariant to JSON data
func (m *MolecularSequenceVariant) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceVariant
func (m *MolecularSequenceVariant) Clone() *MolecularSequenceVariant {
	if m == nil { return nil }
	return &MolecularSequenceVariant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Start: m.Start.Clone(),
		End: m.End.Clone(),
		ObservedAllele: m.ObservedAllele.Clone(),
		ReferenceAllele: m.ReferenceAllele.Clone(),
		Cigar: m.Cigar.Clone(),
		VariantPointer: m.VariantPointer.Clone(),
	}
}

// Equals checks for equality with another MolecularSequenceVariant instance
func (m *MolecularSequenceVariant) Equals(other *MolecularSequenceVariant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Start.Equals(other.Start) { return false }
	if !m.End.Equals(other.End) { return false }
	if !m.ObservedAllele.Equals(other.ObservedAllele) { return false }
	if !m.ReferenceAllele.Equals(other.ReferenceAllele) { return false }
	if !m.Cigar.Equals(other.Cigar) { return false }
	if !m.VariantPointer.Equals(other.VariantPointer) { return false }
	return true
}

// MolecularSequenceQuality
// An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
type MolecularSequenceQuality struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *QualityType `json:"type,omitempty"`
	StandardSequence *CodeableConcept `json:"standardsequence,omitempty"`
	Start *FhirInteger `json:"start,omitempty"`
	End *FhirInteger `json:"end,omitempty"`
	Score *Quantity `json:"score,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	TruthTP *FhirDecimal `json:"truthtp,omitempty"`
	QueryTP *FhirDecimal `json:"querytp,omitempty"`
	TruthFN *FhirDecimal `json:"truthfn,omitempty"`
	QueryFP *FhirDecimal `json:"queryfp,omitempty"`
	GtFP *FhirDecimal `json:"gtfp,omitempty"`
	Precision *FhirDecimal `json:"precision,omitempty"`
	Recall *FhirDecimal `json:"recall,omitempty"`
	FScore *FhirDecimal `json:"fscore,omitempty"`
	Roc *MolecularSequenceRoc `json:"roc,omitempty"`
}

// NewMolecularSequenceQuality creates a new MolecularSequenceQuality instance
func NewMolecularSequenceQuality() *MolecularSequenceQuality {
	return &MolecularSequenceQuality{}
}

// FromJSON populates MolecularSequenceQuality from JSON data
func (m *MolecularSequenceQuality) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceQuality to JSON data
func (m *MolecularSequenceQuality) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceQuality
func (m *MolecularSequenceQuality) Clone() *MolecularSequenceQuality {
	if m == nil { return nil }
	return &MolecularSequenceQuality{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		StandardSequence: m.StandardSequence.Clone(),
		Start: m.Start.Clone(),
		End: m.End.Clone(),
		Score: m.Score.Clone(),
		Method: m.Method.Clone(),
		TruthTP: m.TruthTP.Clone(),
		QueryTP: m.QueryTP.Clone(),
		TruthFN: m.TruthFN.Clone(),
		QueryFP: m.QueryFP.Clone(),
		GtFP: m.GtFP.Clone(),
		Precision: m.Precision.Clone(),
		Recall: m.Recall.Clone(),
		FScore: m.FScore.Clone(),
		Roc: m.Roc.Clone(),
	}
}

// Equals checks for equality with another MolecularSequenceQuality instance
func (m *MolecularSequenceQuality) Equals(other *MolecularSequenceQuality) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.StandardSequence.Equals(other.StandardSequence) { return false }
	if !m.Start.Equals(other.Start) { return false }
	if !m.End.Equals(other.End) { return false }
	if !m.Score.Equals(other.Score) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.TruthTP.Equals(other.TruthTP) { return false }
	if !m.QueryTP.Equals(other.QueryTP) { return false }
	if !m.TruthFN.Equals(other.TruthFN) { return false }
	if !m.QueryFP.Equals(other.QueryFP) { return false }
	if !m.GtFP.Equals(other.GtFP) { return false }
	if !m.Precision.Equals(other.Precision) { return false }
	if !m.Recall.Equals(other.Recall) { return false }
	if !m.FScore.Equals(other.FScore) { return false }
	if !m.Roc.Equals(other.Roc) { return false }
	return true
}

// MolecularSequenceRoc
// Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
type MolecularSequenceRoc struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Score []*FhirInteger `json:"score,omitempty"`
	NumTP []*FhirInteger `json:"numtp,omitempty"`
	NumFP []*FhirInteger `json:"numfp,omitempty"`
	NumFN []*FhirInteger `json:"numfn,omitempty"`
	Precision []*FhirDecimal `json:"precision,omitempty"`
	Sensitivity []*FhirDecimal `json:"sensitivity,omitempty"`
	FMeasure []*FhirDecimal `json:"fmeasure,omitempty"`
}

// NewMolecularSequenceRoc creates a new MolecularSequenceRoc instance
func NewMolecularSequenceRoc() *MolecularSequenceRoc {
	return &MolecularSequenceRoc{}
}

// FromJSON populates MolecularSequenceRoc from JSON data
func (m *MolecularSequenceRoc) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceRoc to JSON data
func (m *MolecularSequenceRoc) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceRoc
func (m *MolecularSequenceRoc) Clone() *MolecularSequenceRoc {
	if m == nil { return nil }
	return &MolecularSequenceRoc{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Score: cloneSlices(m.Score),
		NumTP: cloneSlices(m.NumTP),
		NumFP: cloneSlices(m.NumFP),
		NumFN: cloneSlices(m.NumFN),
		Precision: cloneSlices(m.Precision),
		Sensitivity: cloneSlices(m.Sensitivity),
		FMeasure: cloneSlices(m.FMeasure),
	}
}

// Equals checks for equality with another MolecularSequenceRoc instance
func (m *MolecularSequenceRoc) Equals(other *MolecularSequenceRoc) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Score, other.Score) { return false }
	if !compareSlices(m.NumTP, other.NumTP) { return false }
	if !compareSlices(m.NumFP, other.NumFP) { return false }
	if !compareSlices(m.NumFN, other.NumFN) { return false }
	if !compareSlices(m.Precision, other.Precision) { return false }
	if !compareSlices(m.Sensitivity, other.Sensitivity) { return false }
	if !compareSlices(m.FMeasure, other.FMeasure) { return false }
	return true
}

// MolecularSequenceRepository
// Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
type MolecularSequenceRepository struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *RepositoryType `json:"type,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	DatasetId *FhirString `json:"datasetid,omitempty"`
	VariantsetId *FhirString `json:"variantsetid,omitempty"`
	ReadsetId *FhirString `json:"readsetid,omitempty"`
}

// NewMolecularSequenceRepository creates a new MolecularSequenceRepository instance
func NewMolecularSequenceRepository() *MolecularSequenceRepository {
	return &MolecularSequenceRepository{}
}

// FromJSON populates MolecularSequenceRepository from JSON data
func (m *MolecularSequenceRepository) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceRepository to JSON data
func (m *MolecularSequenceRepository) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceRepository
func (m *MolecularSequenceRepository) Clone() *MolecularSequenceRepository {
	if m == nil { return nil }
	return &MolecularSequenceRepository{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Url: m.Url.Clone(),
		Name: m.Name.Clone(),
		DatasetId: m.DatasetId.Clone(),
		VariantsetId: m.VariantsetId.Clone(),
		ReadsetId: m.ReadsetId.Clone(),
	}
}

// Equals checks for equality with another MolecularSequenceRepository instance
func (m *MolecularSequenceRepository) Equals(other *MolecularSequenceRepository) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.DatasetId.Equals(other.DatasetId) { return false }
	if !m.VariantsetId.Equals(other.VariantsetId) { return false }
	if !m.ReadsetId.Equals(other.ReadsetId) { return false }
	return true
}

// MolecularSequenceStructureVariant
// Information about chromosome structure variation.
type MolecularSequenceStructureVariant struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	VariantType *CodeableConcept `json:"varianttype,omitempty"`
	Exact *FhirBoolean `json:"exact,omitempty"`
	Length *FhirInteger `json:"length,omitempty"`
	Outer *MolecularSequenceOuter `json:"outer,omitempty"`
	Inner *MolecularSequenceInner `json:"inner,omitempty"`
}

// NewMolecularSequenceStructureVariant creates a new MolecularSequenceStructureVariant instance
func NewMolecularSequenceStructureVariant() *MolecularSequenceStructureVariant {
	return &MolecularSequenceStructureVariant{}
}

// FromJSON populates MolecularSequenceStructureVariant from JSON data
func (m *MolecularSequenceStructureVariant) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceStructureVariant to JSON data
func (m *MolecularSequenceStructureVariant) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceStructureVariant
func (m *MolecularSequenceStructureVariant) Clone() *MolecularSequenceStructureVariant {
	if m == nil { return nil }
	return &MolecularSequenceStructureVariant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		VariantType: m.VariantType.Clone(),
		Exact: m.Exact.Clone(),
		Length: m.Length.Clone(),
		Outer: m.Outer.Clone(),
		Inner: m.Inner.Clone(),
	}
}

// Equals checks for equality with another MolecularSequenceStructureVariant instance
func (m *MolecularSequenceStructureVariant) Equals(other *MolecularSequenceStructureVariant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.VariantType.Equals(other.VariantType) { return false }
	if !m.Exact.Equals(other.Exact) { return false }
	if !m.Length.Equals(other.Length) { return false }
	if !m.Outer.Equals(other.Outer) { return false }
	if !m.Inner.Equals(other.Inner) { return false }
	return true
}

// MolecularSequenceOuter
// Structural variant outer.
type MolecularSequenceOuter struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Start *FhirInteger `json:"start,omitempty"`
	End *FhirInteger `json:"end,omitempty"`
}

// NewMolecularSequenceOuter creates a new MolecularSequenceOuter instance
func NewMolecularSequenceOuter() *MolecularSequenceOuter {
	return &MolecularSequenceOuter{}
}

// FromJSON populates MolecularSequenceOuter from JSON data
func (m *MolecularSequenceOuter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceOuter to JSON data
func (m *MolecularSequenceOuter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceOuter
func (m *MolecularSequenceOuter) Clone() *MolecularSequenceOuter {
	if m == nil { return nil }
	return &MolecularSequenceOuter{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Start: m.Start.Clone(),
		End: m.End.Clone(),
	}
}

// Equals checks for equality with another MolecularSequenceOuter instance
func (m *MolecularSequenceOuter) Equals(other *MolecularSequenceOuter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Start.Equals(other.Start) { return false }
	if !m.End.Equals(other.End) { return false }
	return true
}

// MolecularSequenceInner
// Structural variant inner.
type MolecularSequenceInner struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Start *FhirInteger `json:"start,omitempty"`
	End *FhirInteger `json:"end,omitempty"`
}

// NewMolecularSequenceInner creates a new MolecularSequenceInner instance
func NewMolecularSequenceInner() *MolecularSequenceInner {
	return &MolecularSequenceInner{}
}

// FromJSON populates MolecularSequenceInner from JSON data
func (m *MolecularSequenceInner) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MolecularSequenceInner to JSON data
func (m *MolecularSequenceInner) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MolecularSequenceInner
func (m *MolecularSequenceInner) Clone() *MolecularSequenceInner {
	if m == nil { return nil }
	return &MolecularSequenceInner{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Start: m.Start.Clone(),
		End: m.End.Clone(),
	}
}

// Equals checks for equality with another MolecularSequenceInner instance
func (m *MolecularSequenceInner) Equals(other *MolecularSequenceInner) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Start.Equals(other.Start) { return false }
	if !m.End.Equals(other.End) { return false }
	return true
}

