// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// DiagnosticReport
// The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
type DiagnosticReport struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	Status *DiagnosticReportStatus `json:"status,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	EffectiveDateTime *FhirDateTime `json:"effectivedatetime,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	Issued *FhirInstant `json:"issued,omitempty"`
	Performer []*Reference `json:"performer,omitempty"`
	ResultsInterpreter []*Reference `json:"resultsinterpreter,omitempty"`
	Specimen []*Reference `json:"specimen,omitempty"`
	Result []*Reference `json:"result,omitempty"`
	ImagingStudy []*Reference `json:"imagingstudy,omitempty"`
	Media []*DiagnosticReportMedia `json:"media,omitempty"`
	Conclusion *FhirString `json:"conclusion,omitempty"`
	ConclusionCode []*CodeableConcept `json:"conclusioncode,omitempty"`
	PresentedForm []*Attachment `json:"presentedform,omitempty"`
}

// NewDiagnosticReport creates a new DiagnosticReport instance
func NewDiagnosticReport() *DiagnosticReport {
	return &DiagnosticReport{}
}

// FromJSON populates DiagnosticReport from JSON data
func (m *DiagnosticReport) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DiagnosticReport to JSON data
func (m *DiagnosticReport) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DiagnosticReport
func (m *DiagnosticReport) Clone() *DiagnosticReport {
	if m == nil { return nil }
	return &DiagnosticReport{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		BasedOn: cloneSlices(m.BasedOn),
		Status: m.Status.Clone(),
		Category: cloneSlices(m.Category),
		Code: m.Code.Clone(),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		EffectiveDateTime: m.EffectiveDateTime.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		Issued: m.Issued.Clone(),
		Performer: cloneSlices(m.Performer),
		ResultsInterpreter: cloneSlices(m.ResultsInterpreter),
		Specimen: cloneSlices(m.Specimen),
		Result: cloneSlices(m.Result),
		ImagingStudy: cloneSlices(m.ImagingStudy),
		Media: cloneSlices(m.Media),
		Conclusion: m.Conclusion.Clone(),
		ConclusionCode: cloneSlices(m.ConclusionCode),
		PresentedForm: cloneSlices(m.PresentedForm),
	}
}

// Equals checks for equality with another DiagnosticReport instance
func (m *DiagnosticReport) Equals(other *DiagnosticReport) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.EffectiveDateTime.Equals(other.EffectiveDateTime) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !m.Issued.Equals(other.Issued) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !compareSlices(m.ResultsInterpreter, other.ResultsInterpreter) { return false }
	if !compareSlices(m.Specimen, other.Specimen) { return false }
	if !compareSlices(m.Result, other.Result) { return false }
	if !compareSlices(m.ImagingStudy, other.ImagingStudy) { return false }
	if !compareSlices(m.Media, other.Media) { return false }
	if !m.Conclusion.Equals(other.Conclusion) { return false }
	if !compareSlices(m.ConclusionCode, other.ConclusionCode) { return false }
	if !compareSlices(m.PresentedForm, other.PresentedForm) { return false }
	return true
}

// DiagnosticReportMedia
// A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
type DiagnosticReportMedia struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Comment *FhirString `json:"comment,omitempty"`
	Link *Reference `json:"link,omitempty"`
}

// NewDiagnosticReportMedia creates a new DiagnosticReportMedia instance
func NewDiagnosticReportMedia() *DiagnosticReportMedia {
	return &DiagnosticReportMedia{}
}

// FromJSON populates DiagnosticReportMedia from JSON data
func (m *DiagnosticReportMedia) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DiagnosticReportMedia to JSON data
func (m *DiagnosticReportMedia) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DiagnosticReportMedia
func (m *DiagnosticReportMedia) Clone() *DiagnosticReportMedia {
	if m == nil { return nil }
	return &DiagnosticReportMedia{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Comment: m.Comment.Clone(),
		Link: m.Link.Clone(),
	}
}

// Equals checks for equality with another DiagnosticReportMedia instance
func (m *DiagnosticReportMedia) Equals(other *DiagnosticReportMedia) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Comment.Equals(other.Comment) { return false }
	if !m.Link.Equals(other.Link) { return false }
	return true
}

