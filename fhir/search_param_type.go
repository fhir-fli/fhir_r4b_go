// Code generated by FHIR Generator. DO NOT EDIT.
// Data types allowed to be used for search parameters.
package fhir_r4b_go
// SearchParamType represents the FHIR ValueSet as an enumeration
type SearchParamType struct {
	Value   *string  `json:"value,omitempty"`
	Element *Element `json:"_value,omitempty"`
}

// Enum constants
const (
	SearchParamType_Number = "number" // Number: Search parameter SHALL be a number (a whole number, or a decimal).
	SearchParamType_Date = "date" // Date/DateTime: Search parameter is on a date/time. The date format is the standard XML format, though other formats may be supported.
	SearchParamType_String = "string" // String: Search parameter is a simple string, like a name part. Search is case-insensitive and accent-insensitive. May match just the start of a string. String parameters may contain spaces.
	SearchParamType_Token = "token" // Token: Search parameter on a coded element or identifier. May be used to search through the text, display, code and code/codesystem (for codes) and label, system and key (for identifier). Its value is either a string or a pair of namespace and value, separated by a "|", depending on the modifier used.
	SearchParamType_Reference = "reference" // Reference: A reference to another resource (Reference or canonical).
	SearchParamType_Composite = "composite" // Composite: A composite search parameter that combines a search on two values together.
	SearchParamType_Quantity = "quantity" // Quantity: A search parameter that searches on a quantity.
	SearchParamType_Uri = "uri" // URI: A search parameter that searches on a URI (RFC 3986).
	SearchParamType_Special = "special" // Special: Special logic applies to this parameter per the description of the search parameter.
)

// Clone creates a deep copy of the enum
func (e SearchParamType) Clone() *SearchParamType {
	return &SearchParamType{Value: e.Value, Element: e.Element.Clone()}
}

// Equals checks equality between two enums
func (e *SearchParamType) Equals(other *SearchParamType) bool {
	return e.Value == other.Value && e.Element.Equals(other.Element)
}

