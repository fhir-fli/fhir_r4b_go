// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Location
// Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
type Location struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *LocationStatus `json:"status,omitempty"`
	OperationalStatus *Coding `json:"operationalstatus,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Alias []*FhirString `json:"alias,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Mode *LocationMode `json:"mode,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	Telecom []*ContactPoint `json:"telecom,omitempty"`
	Address *Address `json:"address,omitempty"`
	PhysicalType *CodeableConcept `json:"physicaltype,omitempty"`
	Position *LocationPosition `json:"position,omitempty"`
	ManagingOrganization *Reference `json:"managingorganization,omitempty"`
	PartOf *Reference `json:"partof,omitempty"`
	HoursOfOperation []*LocationHoursOfOperation `json:"hoursofoperation,omitempty"`
	AvailabilityExceptions *FhirString `json:"availabilityexceptions,omitempty"`
	Endpoint []*Reference `json:"endpoint,omitempty"`
}

// NewLocation creates a new Location instance
func NewLocation() *Location {
	return &Location{}
}

// FromJSON populates Location from JSON data
func (m *Location) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Location to JSON data
func (m *Location) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Location
func (m *Location) Clone() *Location {
	if m == nil { return nil }
	return &Location{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		OperationalStatus: m.OperationalStatus.Clone(),
		Name: m.Name.Clone(),
		Alias: cloneSlices(m.Alias),
		Description: m.Description.Clone(),
		Mode: m.Mode.Clone(),
		Type: cloneSlices(m.Type),
		Telecom: cloneSlices(m.Telecom),
		Address: m.Address.Clone(),
		PhysicalType: m.PhysicalType.Clone(),
		Position: m.Position.Clone(),
		ManagingOrganization: m.ManagingOrganization.Clone(),
		PartOf: m.PartOf.Clone(),
		HoursOfOperation: cloneSlices(m.HoursOfOperation),
		AvailabilityExceptions: m.AvailabilityExceptions.Clone(),
		Endpoint: cloneSlices(m.Endpoint),
	}
}

// Equals checks for equality with another Location instance
func (m *Location) Equals(other *Location) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.OperationalStatus.Equals(other.OperationalStatus) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !compareSlices(m.Alias, other.Alias) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !compareSlices(m.Telecom, other.Telecom) { return false }
	if !m.Address.Equals(other.Address) { return false }
	if !m.PhysicalType.Equals(other.PhysicalType) { return false }
	if !m.Position.Equals(other.Position) { return false }
	if !m.ManagingOrganization.Equals(other.ManagingOrganization) { return false }
	if !m.PartOf.Equals(other.PartOf) { return false }
	if !compareSlices(m.HoursOfOperation, other.HoursOfOperation) { return false }
	if !m.AvailabilityExceptions.Equals(other.AvailabilityExceptions) { return false }
	if !compareSlices(m.Endpoint, other.Endpoint) { return false }
	return true
}

// LocationPosition
// The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
type LocationPosition struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Longitude *FhirDecimal `json:"longitude,omitempty"`
	Latitude *FhirDecimal `json:"latitude,omitempty"`
	Altitude *FhirDecimal `json:"altitude,omitempty"`
}

// NewLocationPosition creates a new LocationPosition instance
func NewLocationPosition() *LocationPosition {
	return &LocationPosition{}
}

// FromJSON populates LocationPosition from JSON data
func (m *LocationPosition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts LocationPosition to JSON data
func (m *LocationPosition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of LocationPosition
func (m *LocationPosition) Clone() *LocationPosition {
	if m == nil { return nil }
	return &LocationPosition{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Longitude: m.Longitude.Clone(),
		Latitude: m.Latitude.Clone(),
		Altitude: m.Altitude.Clone(),
	}
}

// Equals checks for equality with another LocationPosition instance
func (m *LocationPosition) Equals(other *LocationPosition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Longitude.Equals(other.Longitude) { return false }
	if !m.Latitude.Equals(other.Latitude) { return false }
	if !m.Altitude.Equals(other.Altitude) { return false }
	return true
}

// LocationHoursOfOperation
// What days/times during a week is this location usually open.
type LocationHoursOfOperation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DaysOfWeek []*DaysOfWeek `json:"daysofweek,omitempty"`
	AllDay *FhirBoolean `json:"allday,omitempty"`
	OpeningTime *FhirTime `json:"openingtime,omitempty"`
	ClosingTime *FhirTime `json:"closingtime,omitempty"`
}

// NewLocationHoursOfOperation creates a new LocationHoursOfOperation instance
func NewLocationHoursOfOperation() *LocationHoursOfOperation {
	return &LocationHoursOfOperation{}
}

// FromJSON populates LocationHoursOfOperation from JSON data
func (m *LocationHoursOfOperation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts LocationHoursOfOperation to JSON data
func (m *LocationHoursOfOperation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of LocationHoursOfOperation
func (m *LocationHoursOfOperation) Clone() *LocationHoursOfOperation {
	if m == nil { return nil }
	return &LocationHoursOfOperation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DaysOfWeek: cloneSlices(m.DaysOfWeek),
		AllDay: m.AllDay.Clone(),
		OpeningTime: m.OpeningTime.Clone(),
		ClosingTime: m.ClosingTime.Clone(),
	}
}

// Equals checks for equality with another LocationHoursOfOperation instance
func (m *LocationHoursOfOperation) Equals(other *LocationHoursOfOperation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.DaysOfWeek, other.DaysOfWeek) { return false }
	if !m.AllDay.Equals(other.AllDay) { return false }
	if !m.OpeningTime.Equals(other.OpeningTime) { return false }
	if !m.ClosingTime.Equals(other.ClosingTime) { return false }
	return true
}

