// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// EvidenceVariable
// The EvidenceVariable resource describes an element that knowledge (Evidence) is about.
type EvidenceVariable struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	ShortTitle *FhirString `json:"shorttitle,omitempty"`
	Subtitle *FhirString `json:"subtitle,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Author []*ContactDetail `json:"author,omitempty"`
	Editor []*ContactDetail `json:"editor,omitempty"`
	Reviewer []*ContactDetail `json:"reviewer,omitempty"`
	Endorser []*ContactDetail `json:"endorser,omitempty"`
	RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
	Actual *FhirBoolean `json:"actual,omitempty"`
	CharacteristicCombination *CharacteristicCombination `json:"characteristiccombination,omitempty"`
	Characteristic []*EvidenceVariableCharacteristic `json:"characteristic,omitempty"`
	Handling *EvidenceVariableHandling `json:"handling,omitempty"`
	Category []*EvidenceVariableCategory `json:"category,omitempty"`
}

// NewEvidenceVariable creates a new EvidenceVariable instance
func NewEvidenceVariable() *EvidenceVariable {
	return &EvidenceVariable{}
}

// FromJSON populates EvidenceVariable from JSON data
func (m *EvidenceVariable) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceVariable to JSON data
func (m *EvidenceVariable) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceVariable
func (m *EvidenceVariable) Clone() *EvidenceVariable {
	if m == nil { return nil }
	return &EvidenceVariable{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		ShortTitle: m.ShortTitle.Clone(),
		Subtitle: m.Subtitle.Clone(),
		Status: m.Status.Clone(),
		Date: m.Date.Clone(),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		UseContext: cloneSlices(m.UseContext),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Author: cloneSlices(m.Author),
		Editor: cloneSlices(m.Editor),
		Reviewer: cloneSlices(m.Reviewer),
		Endorser: cloneSlices(m.Endorser),
		RelatedArtifact: cloneSlices(m.RelatedArtifact),
		Actual: m.Actual.Clone(),
		CharacteristicCombination: m.CharacteristicCombination.Clone(),
		Characteristic: cloneSlices(m.Characteristic),
		Handling: m.Handling.Clone(),
		Category: cloneSlices(m.Category),
	}
}

// Equals checks for equality with another EvidenceVariable instance
func (m *EvidenceVariable) Equals(other *EvidenceVariable) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.ShortTitle.Equals(other.ShortTitle) { return false }
	if !m.Subtitle.Equals(other.Subtitle) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !compareSlices(m.Author, other.Author) { return false }
	if !compareSlices(m.Editor, other.Editor) { return false }
	if !compareSlices(m.Reviewer, other.Reviewer) { return false }
	if !compareSlices(m.Endorser, other.Endorser) { return false }
	if !compareSlices(m.RelatedArtifact, other.RelatedArtifact) { return false }
	if !m.Actual.Equals(other.Actual) { return false }
	if !m.CharacteristicCombination.Equals(other.CharacteristicCombination) { return false }
	if !compareSlices(m.Characteristic, other.Characteristic) { return false }
	if !m.Handling.Equals(other.Handling) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	return true
}

// EvidenceVariableCharacteristic
// A characteristic that defines the members of the evidence element. Multiple characteristics are applied with "and" semantics.
type EvidenceVariableCharacteristic struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	DefinitionReference *Reference `json:"definitionreference,omitempty"`
	DefinitionCanonical *FhirCanonical `json:"definitioncanonical,omitempty"`
	DefinitionCodeableConcept *CodeableConcept `json:"definitioncodeableconcept,omitempty"`
	DefinitionExpression *FhirExpression `json:"definitionexpression,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
	Device *Reference `json:"device,omitempty"`
	Exclude *FhirBoolean `json:"exclude,omitempty"`
	TimeFromStart *EvidenceVariableTimeFromStart `json:"timefromstart,omitempty"`
	GroupMeasure *GroupMeasure `json:"groupmeasure,omitempty"`
}

// NewEvidenceVariableCharacteristic creates a new EvidenceVariableCharacteristic instance
func NewEvidenceVariableCharacteristic() *EvidenceVariableCharacteristic {
	return &EvidenceVariableCharacteristic{}
}

// FromJSON populates EvidenceVariableCharacteristic from JSON data
func (m *EvidenceVariableCharacteristic) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceVariableCharacteristic to JSON data
func (m *EvidenceVariableCharacteristic) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceVariableCharacteristic
func (m *EvidenceVariableCharacteristic) Clone() *EvidenceVariableCharacteristic {
	if m == nil { return nil }
	return &EvidenceVariableCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		DefinitionReference: m.DefinitionReference.Clone(),
		DefinitionCanonical: m.DefinitionCanonical.Clone(),
		DefinitionCodeableConcept: m.DefinitionCodeableConcept.Clone(),
		DefinitionExpression: m.DefinitionExpression.Clone(),
		Method: m.Method.Clone(),
		Device: m.Device.Clone(),
		Exclude: m.Exclude.Clone(),
		TimeFromStart: m.TimeFromStart.Clone(),
		GroupMeasure: m.GroupMeasure.Clone(),
	}
}

// Equals checks for equality with another EvidenceVariableCharacteristic instance
func (m *EvidenceVariableCharacteristic) Equals(other *EvidenceVariableCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.DefinitionReference.Equals(other.DefinitionReference) { return false }
	if !m.DefinitionCanonical.Equals(other.DefinitionCanonical) { return false }
	if !m.DefinitionCodeableConcept.Equals(other.DefinitionCodeableConcept) { return false }
	if !m.DefinitionExpression.Equals(other.DefinitionExpression) { return false }
	if !m.Method.Equals(other.Method) { return false }
	if !m.Device.Equals(other.Device) { return false }
	if !m.Exclude.Equals(other.Exclude) { return false }
	if !m.TimeFromStart.Equals(other.TimeFromStart) { return false }
	if !m.GroupMeasure.Equals(other.GroupMeasure) { return false }
	return true
}

// EvidenceVariableTimeFromStart
// Indicates duration, period, or point of observation from the participant's study entry.
type EvidenceVariableTimeFromStart struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Range *Range `json:"range,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewEvidenceVariableTimeFromStart creates a new EvidenceVariableTimeFromStart instance
func NewEvidenceVariableTimeFromStart() *EvidenceVariableTimeFromStart {
	return &EvidenceVariableTimeFromStart{}
}

// FromJSON populates EvidenceVariableTimeFromStart from JSON data
func (m *EvidenceVariableTimeFromStart) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceVariableTimeFromStart to JSON data
func (m *EvidenceVariableTimeFromStart) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceVariableTimeFromStart
func (m *EvidenceVariableTimeFromStart) Clone() *EvidenceVariableTimeFromStart {
	if m == nil { return nil }
	return &EvidenceVariableTimeFromStart{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Quantity: m.Quantity.Clone(),
		Range: m.Range.Clone(),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks for equality with another EvidenceVariableTimeFromStart instance
func (m *EvidenceVariableTimeFromStart) Equals(other *EvidenceVariableTimeFromStart) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.Range.Equals(other.Range) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// EvidenceVariableCategory
// A grouping (or set of values) described along with other groupings to specify the set of groupings allowed for the variable.
type EvidenceVariableCategory struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueRange *Range `json:"valuerange,omitempty"`
}

// NewEvidenceVariableCategory creates a new EvidenceVariableCategory instance
func NewEvidenceVariableCategory() *EvidenceVariableCategory {
	return &EvidenceVariableCategory{}
}

// FromJSON populates EvidenceVariableCategory from JSON data
func (m *EvidenceVariableCategory) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceVariableCategory to JSON data
func (m *EvidenceVariableCategory) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceVariableCategory
func (m *EvidenceVariableCategory) Clone() *EvidenceVariableCategory {
	if m == nil { return nil }
	return &EvidenceVariableCategory{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueRange: m.ValueRange.Clone(),
	}
}

// Equals checks for equality with another EvidenceVariableCategory instance
func (m *EvidenceVariableCategory) Equals(other *EvidenceVariableCategory) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueRange.Equals(other.ValueRange) { return false }
	return true
}

