// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"

)

// TriggerDefinition
// A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
type TriggerDefinition struct {
	DataType
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// type
	// The type of triggering event.
	Type_ TriggerType `json:"type,omitempty"`
	// name
	// A formal name for the event. This may be an absolute URI that identifies the event formally (e.g. from a trigger registry), or a simple relative URI that identifies the event in a local context.
	Name FhirString `json:"name,omitempty"`
	// timingTiming
	// The timing of the event (if this is a periodic trigger).
	TimingTiming Timing `json:"timingTiming,omitempty"`
	// timingReference
	// The timing of the event (if this is a periodic trigger).
	TimingReference Reference `json:"timingReference,omitempty"`
	// timingDate
	// The timing of the event (if this is a periodic trigger).
	TimingDate FhirDate `json:"timingDate,omitempty"`
	// timingDateTime
	// The timing of the event (if this is a periodic trigger).
	TimingDateTime FhirDateTime `json:"timingDateTime,omitempty"`
	// data
	// The triggering data of the event (if this is a data trigger). If more than one data is requirement is specified, then all the data requirements must be true.
	Data []DataRequirement `json:"data,omitempty"`
	// condition
	// A boolean-valued expression that is evaluated in the context of the container of the trigger definition and returns whether or not the trigger fires.
	Condition FhirExpression `json:"condition,omitempty"`
}

// NewTriggerDefinition creates a new TriggerDefinition instance
func NewTriggerDefinition(
	id FhirString,
	extension_ []FhirExtension,
	type_ TriggerType,
	name FhirString,
	timingTiming Timing,
	timingReference Reference,
	timingDate FhirDate,
	timingDateTime FhirDateTime,
	data []DataRequirement,
	condition FhirExpression,
) *TriggerDefinition {
	return &TriggerDefinition{
		Id: id,
		Extension_: extension_,
		Type_: type_,
		Name: name,
		TimingTiming: timingTiming,
		TimingReference: timingReference,
		TimingDate: timingDate,
		TimingDateTime: timingDateTime,
		Data: data,
		Condition: condition,
	}
}
// FromJSON populates TriggerDefinition from JSON data
func (m *TriggerDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TriggerDefinition to JSON data
func (m *TriggerDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of TriggerDefinition
func (m *TriggerDefinition) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	type_ *TriggerType,
	name *FhirString,
	timingTiming *Timing,
	timingReference *Reference,
	timingDate *FhirDate,
	timingDateTime *FhirDateTime,
	data *[]DataRequirement,
	condition *FhirExpression,
) *TriggerDefinition {
	return &TriggerDefinition{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		Type_: func() TriggerType {
			if type_ != nil { return *type_ }
			return m.Type_
		}(),
		Name: func() FhirString {
			if name != nil { return *name }
			return m.Name
		}(),
		TimingTiming: func() Timing {
			if timingTiming != nil { return *timingTiming }
			return m.TimingTiming
		}(),
		TimingReference: func() Reference {
			if timingReference != nil { return *timingReference }
			return m.TimingReference
		}(),
		TimingDate: func() FhirDate {
			if timingDate != nil { return *timingDate }
			return m.TimingDate
		}(),
		TimingDateTime: func() FhirDateTime {
			if timingDateTime != nil { return *timingDateTime }
			return m.TimingDateTime
		}(),
		Data: func() []DataRequirement {
			if data != nil { return *data }
			return m.Data
		}(),
		Condition: func() FhirExpression {
			if condition != nil { return *condition }
			return m.Condition
		}(),
	}
}
