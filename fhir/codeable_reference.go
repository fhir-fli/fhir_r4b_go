// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"

)

// CodeableReference
// A reference to a resource (by instance), or instead, a reference to a concept defined in a terminology or ontology (by class).
type CodeableReference struct {
	DataType
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// concept
	// A reference to a concept - e.g. the information is identified by its general class to the degree of precision found in the terminology.
	Concept CodeableConcept `json:"concept,omitempty"`
	// reference
	// A reference to a resource the provides exact details about the information being referenced.
	Reference Reference `json:"reference,omitempty"`
}

// NewCodeableReference creates a new CodeableReference instance
func NewCodeableReference(
	id FhirString,
	extension_ []FhirExtension,
	concept CodeableConcept,
	reference Reference,
) *CodeableReference {
	return &CodeableReference{
		Id: id,
		Extension_: extension_,
		Concept: concept,
		Reference: reference,
	}
}
// FromJSON populates CodeableReference from JSON data
func (m *CodeableReference) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CodeableReference to JSON data
func (m *CodeableReference) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of CodeableReference
func (m *CodeableReference) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	concept *CodeableConcept,
	reference *Reference,
) *CodeableReference {
	return &CodeableReference{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		Concept: func() CodeableConcept {
			if concept != nil { return *concept }
			return m.Concept
		}(),
		Reference: func() Reference {
			if reference != nil { return *reference }
			return m.Reference
		}(),
	}
}
