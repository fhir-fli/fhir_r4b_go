// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// RequestGroup
// A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
type RequestGroup struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	InstantiatesCanonical []*FhirCanonical `json:"instantiatescanonical,omitempty"`
	InstantiatesUri []*FhirUri `json:"instantiatesuri,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	Replaces []*Reference `json:"replaces,omitempty"`
	GroupIdentifier *Identifier `json:"groupidentifier,omitempty"`
	Status *RequestStatus `json:"status,omitempty"`
	Intent *RequestIntent `json:"intent,omitempty"`
	Priority *RequestPriority `json:"priority,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	AuthoredOn *FhirDateTime `json:"authoredon,omitempty"`
	Author *Reference `json:"author,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Action []*RequestGroupAction `json:"action,omitempty"`
}

// NewRequestGroup creates a new RequestGroup instance
func NewRequestGroup() *RequestGroup {
	return &RequestGroup{}
}

// FromJSON populates RequestGroup from JSON data
func (m *RequestGroup) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts RequestGroup to JSON data
func (m *RequestGroup) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of RequestGroup
func (m *RequestGroup) Clone() *RequestGroup {
	if m == nil { return nil }
	return &RequestGroup{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		InstantiatesCanonical: cloneSlices(m.InstantiatesCanonical),
		InstantiatesUri: cloneSlices(m.InstantiatesUri),
		BasedOn: cloneSlices(m.BasedOn),
		Replaces: cloneSlices(m.Replaces),
		GroupIdentifier: m.GroupIdentifier.Clone(),
		Status: m.Status.Clone(),
		Intent: m.Intent.Clone(),
		Priority: m.Priority.Clone(),
		Code: m.Code.Clone(),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		AuthoredOn: m.AuthoredOn.Clone(),
		Author: m.Author.Clone(),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		Note: cloneSlices(m.Note),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks for equality with another RequestGroup instance
func (m *RequestGroup) Equals(other *RequestGroup) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.InstantiatesCanonical, other.InstantiatesCanonical) { return false }
	if !compareSlices(m.InstantiatesUri, other.InstantiatesUri) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !compareSlices(m.Replaces, other.Replaces) { return false }
	if !m.GroupIdentifier.Equals(other.GroupIdentifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Intent.Equals(other.Intent) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.AuthoredOn.Equals(other.AuthoredOn) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// RequestGroupAction
// The actions, if any, produced by the evaluation of the artifact.
type RequestGroupAction struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Prefix *FhirString `json:"prefix,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	TextEquivalent *FhirString `json:"textequivalent,omitempty"`
	Priority *RequestPriority `json:"priority,omitempty"`
	Code []*CodeableConcept `json:"code,omitempty"`
	Documentation []*RelatedArtifact `json:"documentation,omitempty"`
	Condition []*RequestGroupCondition `json:"condition,omitempty"`
	RelatedAction []*RequestGroupRelatedAction `json:"relatedaction,omitempty"`
	TimingDateTime *FhirDateTime `json:"timingdatetime,omitempty"`
	TimingAge *Age `json:"timingage,omitempty"`
	TimingPeriod *Period `json:"timingperiod,omitempty"`
	TimingDuration *FhirDuration `json:"timingduration,omitempty"`
	TimingRange *Range `json:"timingrange,omitempty"`
	TimingTiming *Timing `json:"timingtiming,omitempty"`
	Participant []*Reference `json:"participant,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	GroupingBehavior *ActionGroupingBehavior `json:"groupingbehavior,omitempty"`
	SelectionBehavior *ActionSelectionBehavior `json:"selectionbehavior,omitempty"`
	RequiredBehavior *ActionRequiredBehavior `json:"requiredbehavior,omitempty"`
	PrecheckBehavior *ActionPrecheckBehavior `json:"precheckbehavior,omitempty"`
	CardinalityBehavior *ActionCardinalityBehavior `json:"cardinalitybehavior,omitempty"`
	Resource *Reference `json:"resource,omitempty"`
	Action []*RequestGroupAction `json:"action,omitempty"`
}

// NewRequestGroupAction creates a new RequestGroupAction instance
func NewRequestGroupAction() *RequestGroupAction {
	return &RequestGroupAction{}
}

// FromJSON populates RequestGroupAction from JSON data
func (m *RequestGroupAction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts RequestGroupAction to JSON data
func (m *RequestGroupAction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of RequestGroupAction
func (m *RequestGroupAction) Clone() *RequestGroupAction {
	if m == nil { return nil }
	return &RequestGroupAction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Prefix: m.Prefix.Clone(),
		Title: m.Title.Clone(),
		Description: m.Description.Clone(),
		TextEquivalent: m.TextEquivalent.Clone(),
		Priority: m.Priority.Clone(),
		Code: cloneSlices(m.Code),
		Documentation: cloneSlices(m.Documentation),
		Condition: cloneSlices(m.Condition),
		RelatedAction: cloneSlices(m.RelatedAction),
		TimingDateTime: m.TimingDateTime.Clone(),
		TimingAge: m.TimingAge.Clone(),
		TimingPeriod: m.TimingPeriod.Clone(),
		TimingDuration: m.TimingDuration.Clone(),
		TimingRange: m.TimingRange.Clone(),
		TimingTiming: m.TimingTiming.Clone(),
		Participant: cloneSlices(m.Participant),
		Type: m.Type.Clone(),
		GroupingBehavior: m.GroupingBehavior.Clone(),
		SelectionBehavior: m.SelectionBehavior.Clone(),
		RequiredBehavior: m.RequiredBehavior.Clone(),
		PrecheckBehavior: m.PrecheckBehavior.Clone(),
		CardinalityBehavior: m.CardinalityBehavior.Clone(),
		Resource: m.Resource.Clone(),
		Action: cloneSlices(m.Action),
	}
}

// Equals checks for equality with another RequestGroupAction instance
func (m *RequestGroupAction) Equals(other *RequestGroupAction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Prefix.Equals(other.Prefix) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.TextEquivalent.Equals(other.TextEquivalent) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Documentation, other.Documentation) { return false }
	if !compareSlices(m.Condition, other.Condition) { return false }
	if !compareSlices(m.RelatedAction, other.RelatedAction) { return false }
	if !m.TimingDateTime.Equals(other.TimingDateTime) { return false }
	if !m.TimingAge.Equals(other.TimingAge) { return false }
	if !m.TimingPeriod.Equals(other.TimingPeriod) { return false }
	if !m.TimingDuration.Equals(other.TimingDuration) { return false }
	if !m.TimingRange.Equals(other.TimingRange) { return false }
	if !m.TimingTiming.Equals(other.TimingTiming) { return false }
	if !compareSlices(m.Participant, other.Participant) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.GroupingBehavior.Equals(other.GroupingBehavior) { return false }
	if !m.SelectionBehavior.Equals(other.SelectionBehavior) { return false }
	if !m.RequiredBehavior.Equals(other.RequiredBehavior) { return false }
	if !m.PrecheckBehavior.Equals(other.PrecheckBehavior) { return false }
	if !m.CardinalityBehavior.Equals(other.CardinalityBehavior) { return false }
	if !m.Resource.Equals(other.Resource) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	return true
}

// RequestGroupCondition
// An expression that describes applicability criteria, or start/stop conditions for the action.
type RequestGroupCondition struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Kind *ActionConditionKind `json:"kind,omitempty"`
	Expression *FhirExpression `json:"expression,omitempty"`
}

// NewRequestGroupCondition creates a new RequestGroupCondition instance
func NewRequestGroupCondition() *RequestGroupCondition {
	return &RequestGroupCondition{}
}

// FromJSON populates RequestGroupCondition from JSON data
func (m *RequestGroupCondition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts RequestGroupCondition to JSON data
func (m *RequestGroupCondition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of RequestGroupCondition
func (m *RequestGroupCondition) Clone() *RequestGroupCondition {
	if m == nil { return nil }
	return &RequestGroupCondition{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Kind: m.Kind.Clone(),
		Expression: m.Expression.Clone(),
	}
}

// Equals checks for equality with another RequestGroupCondition instance
func (m *RequestGroupCondition) Equals(other *RequestGroupCondition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Kind.Equals(other.Kind) { return false }
	if !m.Expression.Equals(other.Expression) { return false }
	return true
}

// RequestGroupRelatedAction
// A relationship to another action such as "before" or "30-60 minutes after start of".
type RequestGroupRelatedAction struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ActionId *FhirId `json:"actionid,omitempty"`
	Relationship *ActionRelationshipType `json:"relationship,omitempty"`
	OffsetDuration *FhirDuration `json:"offsetduration,omitempty"`
	OffsetRange *Range `json:"offsetrange,omitempty"`
}

// NewRequestGroupRelatedAction creates a new RequestGroupRelatedAction instance
func NewRequestGroupRelatedAction() *RequestGroupRelatedAction {
	return &RequestGroupRelatedAction{}
}

// FromJSON populates RequestGroupRelatedAction from JSON data
func (m *RequestGroupRelatedAction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts RequestGroupRelatedAction to JSON data
func (m *RequestGroupRelatedAction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of RequestGroupRelatedAction
func (m *RequestGroupRelatedAction) Clone() *RequestGroupRelatedAction {
	if m == nil { return nil }
	return &RequestGroupRelatedAction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ActionId: m.ActionId.Clone(),
		Relationship: m.Relationship.Clone(),
		OffsetDuration: m.OffsetDuration.Clone(),
		OffsetRange: m.OffsetRange.Clone(),
	}
}

// Equals checks for equality with another RequestGroupRelatedAction instance
func (m *RequestGroupRelatedAction) Equals(other *RequestGroupRelatedAction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ActionId.Equals(other.ActionId) { return false }
	if !m.Relationship.Equals(other.Relationship) { return false }
	if !m.OffsetDuration.Equals(other.OffsetDuration) { return false }
	if !m.OffsetRange.Equals(other.OffsetRange) { return false }
	return true
}

