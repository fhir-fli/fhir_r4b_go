// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Consent
// A record of a healthcare consumerâ€™s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
type Consent struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ConsentState `json:"status,omitempty"`
	Scope *CodeableConcept `json:"scope,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	DateTime *FhirDateTime `json:"datetime,omitempty"`
	Performer []*Reference `json:"performer,omitempty"`
	Organization []*Reference `json:"organization,omitempty"`
	SourceAttachment *Attachment `json:"sourceattachment,omitempty"`
	SourceReference *Reference `json:"sourcereference,omitempty"`
	Policy []*ConsentPolicy `json:"policy,omitempty"`
	PolicyRule *CodeableConcept `json:"policyrule,omitempty"`
	Verification []*ConsentVerification `json:"verification,omitempty"`
	Provision *ConsentProvision `json:"provision,omitempty"`
}

// NewConsent creates a new Consent instance
func NewConsent() *Consent {
	return &Consent{}
}

// FromJSON populates Consent from JSON data
func (m *Consent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Consent to JSON data
func (m *Consent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Consent
func (m *Consent) Clone() *Consent {
	if m == nil { return nil }
	return &Consent{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Scope: m.Scope.Clone(),
		Category: cloneSlices(m.Category),
		Patient: m.Patient.Clone(),
		DateTime: m.DateTime.Clone(),
		Performer: cloneSlices(m.Performer),
		Organization: cloneSlices(m.Organization),
		SourceAttachment: m.SourceAttachment.Clone(),
		SourceReference: m.SourceReference.Clone(),
		Policy: cloneSlices(m.Policy),
		PolicyRule: m.PolicyRule.Clone(),
		Verification: cloneSlices(m.Verification),
		Provision: m.Provision.Clone(),
	}
}

// Equals checks for equality with another Consent instance
func (m *Consent) Equals(other *Consent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Scope.Equals(other.Scope) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.DateTime.Equals(other.DateTime) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !compareSlices(m.Organization, other.Organization) { return false }
	if !m.SourceAttachment.Equals(other.SourceAttachment) { return false }
	if !m.SourceReference.Equals(other.SourceReference) { return false }
	if !compareSlices(m.Policy, other.Policy) { return false }
	if !m.PolicyRule.Equals(other.PolicyRule) { return false }
	if !compareSlices(m.Verification, other.Verification) { return false }
	if !m.Provision.Equals(other.Provision) { return false }
	return true
}

// ConsentPolicy
// The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
type ConsentPolicy struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Authority *FhirUri `json:"authority,omitempty"`
	Uri *FhirUri `json:"uri,omitempty"`
}

// NewConsentPolicy creates a new ConsentPolicy instance
func NewConsentPolicy() *ConsentPolicy {
	return &ConsentPolicy{}
}

// FromJSON populates ConsentPolicy from JSON data
func (m *ConsentPolicy) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ConsentPolicy to JSON data
func (m *ConsentPolicy) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ConsentPolicy
func (m *ConsentPolicy) Clone() *ConsentPolicy {
	if m == nil { return nil }
	return &ConsentPolicy{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Authority: m.Authority.Clone(),
		Uri: m.Uri.Clone(),
	}
}

// Equals checks for equality with another ConsentPolicy instance
func (m *ConsentPolicy) Equals(other *ConsentPolicy) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Authority.Equals(other.Authority) { return false }
	if !m.Uri.Equals(other.Uri) { return false }
	return true
}

// ConsentVerification
// Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
type ConsentVerification struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Verified *FhirBoolean `json:"verified,omitempty"`
	VerifiedWith *Reference `json:"verifiedwith,omitempty"`
	VerificationDate *FhirDateTime `json:"verificationdate,omitempty"`
}

// NewConsentVerification creates a new ConsentVerification instance
func NewConsentVerification() *ConsentVerification {
	return &ConsentVerification{}
}

// FromJSON populates ConsentVerification from JSON data
func (m *ConsentVerification) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ConsentVerification to JSON data
func (m *ConsentVerification) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ConsentVerification
func (m *ConsentVerification) Clone() *ConsentVerification {
	if m == nil { return nil }
	return &ConsentVerification{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Verified: m.Verified.Clone(),
		VerifiedWith: m.VerifiedWith.Clone(),
		VerificationDate: m.VerificationDate.Clone(),
	}
}

// Equals checks for equality with another ConsentVerification instance
func (m *ConsentVerification) Equals(other *ConsentVerification) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Verified.Equals(other.Verified) { return false }
	if !m.VerifiedWith.Equals(other.VerifiedWith) { return false }
	if !m.VerificationDate.Equals(other.VerificationDate) { return false }
	return true
}

// ConsentProvision
// An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
type ConsentProvision struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *ConsentProvisionType `json:"type,omitempty"`
	Period *Period `json:"period,omitempty"`
	Actor []*ConsentActor `json:"actor,omitempty"`
	Action []*CodeableConcept `json:"action,omitempty"`
	SecurityLabel []*Coding `json:"securitylabel,omitempty"`
	Purpose []*Coding `json:"purpose,omitempty"`
	Class_ []*Coding `json:"class,omitempty"`
	Code []*CodeableConcept `json:"code,omitempty"`
	DataPeriod *Period `json:"dataperiod,omitempty"`
	Data []*ConsentData `json:"data,omitempty"`
	Provision []*ConsentProvision `json:"provision,omitempty"`
}

// NewConsentProvision creates a new ConsentProvision instance
func NewConsentProvision() *ConsentProvision {
	return &ConsentProvision{}
}

// FromJSON populates ConsentProvision from JSON data
func (m *ConsentProvision) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ConsentProvision to JSON data
func (m *ConsentProvision) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ConsentProvision
func (m *ConsentProvision) Clone() *ConsentProvision {
	if m == nil { return nil }
	return &ConsentProvision{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Period: m.Period.Clone(),
		Actor: cloneSlices(m.Actor),
		Action: cloneSlices(m.Action),
		SecurityLabel: cloneSlices(m.SecurityLabel),
		Purpose: cloneSlices(m.Purpose),
		Class_: cloneSlices(m.Class_),
		Code: cloneSlices(m.Code),
		DataPeriod: m.DataPeriod.Clone(),
		Data: cloneSlices(m.Data),
		Provision: cloneSlices(m.Provision),
	}
}

// Equals checks for equality with another ConsentProvision instance
func (m *ConsentProvision) Equals(other *ConsentProvision) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !compareSlices(m.Actor, other.Actor) { return false }
	if !compareSlices(m.Action, other.Action) { return false }
	if !compareSlices(m.SecurityLabel, other.SecurityLabel) { return false }
	if !compareSlices(m.Purpose, other.Purpose) { return false }
	if !compareSlices(m.Class_, other.Class_) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !m.DataPeriod.Equals(other.DataPeriod) { return false }
	if !compareSlices(m.Data, other.Data) { return false }
	if !compareSlices(m.Provision, other.Provision) { return false }
	return true
}

// ConsentActor
// Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
type ConsentActor struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Role *CodeableConcept `json:"role,omitempty"`
	Reference *Reference `json:"reference,omitempty"`
}

// NewConsentActor creates a new ConsentActor instance
func NewConsentActor() *ConsentActor {
	return &ConsentActor{}
}

// FromJSON populates ConsentActor from JSON data
func (m *ConsentActor) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ConsentActor to JSON data
func (m *ConsentActor) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ConsentActor
func (m *ConsentActor) Clone() *ConsentActor {
	if m == nil { return nil }
	return &ConsentActor{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Role: m.Role.Clone(),
		Reference: m.Reference.Clone(),
	}
}

// Equals checks for equality with another ConsentActor instance
func (m *ConsentActor) Equals(other *ConsentActor) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Role.Equals(other.Role) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	return true
}

// ConsentData
// The resources controlled by this rule if specific resources are referenced.
type ConsentData struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Meaning *ConsentDataMeaning `json:"meaning,omitempty"`
	Reference *Reference `json:"reference,omitempty"`
}

// NewConsentData creates a new ConsentData instance
func NewConsentData() *ConsentData {
	return &ConsentData{}
}

// FromJSON populates ConsentData from JSON data
func (m *ConsentData) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ConsentData to JSON data
func (m *ConsentData) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ConsentData
func (m *ConsentData) Clone() *ConsentData {
	if m == nil { return nil }
	return &ConsentData{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Meaning: m.Meaning.Clone(),
		Reference: m.Reference.Clone(),
	}
}

// Equals checks for equality with another ConsentData instance
func (m *ConsentData) Equals(other *ConsentData) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Meaning.Equals(other.Meaning) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	return true
}

