// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// BiologicallyDerivedProduct
// A material substance originating from a biological entity intended to be transplanted or infused
// into another (possibly the same) biological entity.
type BiologicallyDerivedProduct struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	ProductCategory *BiologicallyDerivedProductCategory `json:"productcategory,omitempty"`
	ProductCode *CodeableConcept `json:"productcode,omitempty"`
	Status *BiologicallyDerivedProductStatus `json:"status,omitempty"`
	Request []*Reference `json:"request,omitempty"`
	Quantity *FhirInteger `json:"quantity,omitempty"`
	Parent []*Reference `json:"parent,omitempty"`
	Collection *BiologicallyDerivedProductCollection `json:"collection,omitempty"`
	Processing []*BiologicallyDerivedProductProcessing `json:"processing,omitempty"`
	Manipulation *BiologicallyDerivedProductManipulation `json:"manipulation,omitempty"`
	Storage []*BiologicallyDerivedProductStorage `json:"storage,omitempty"`
}

// NewBiologicallyDerivedProduct creates a new BiologicallyDerivedProduct instance
func NewBiologicallyDerivedProduct() *BiologicallyDerivedProduct {
	return &BiologicallyDerivedProduct{}
}

// FromJSON populates BiologicallyDerivedProduct from JSON data
func (m *BiologicallyDerivedProduct) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BiologicallyDerivedProduct to JSON data
func (m *BiologicallyDerivedProduct) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BiologicallyDerivedProduct
func (m *BiologicallyDerivedProduct) Clone() *BiologicallyDerivedProduct {
	if m == nil { return nil }
	return &BiologicallyDerivedProduct{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		ProductCategory: m.ProductCategory.Clone(),
		ProductCode: m.ProductCode.Clone(),
		Status: m.Status.Clone(),
		Request: cloneSlices(m.Request),
		Quantity: m.Quantity.Clone(),
		Parent: cloneSlices(m.Parent),
		Collection: m.Collection.Clone(),
		Processing: cloneSlices(m.Processing),
		Manipulation: m.Manipulation.Clone(),
		Storage: cloneSlices(m.Storage),
	}
}

// Equals checks for equality with another BiologicallyDerivedProduct instance
func (m *BiologicallyDerivedProduct) Equals(other *BiologicallyDerivedProduct) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.ProductCategory.Equals(other.ProductCategory) { return false }
	if !m.ProductCode.Equals(other.ProductCode) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.Request, other.Request) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !compareSlices(m.Parent, other.Parent) { return false }
	if !m.Collection.Equals(other.Collection) { return false }
	if !compareSlices(m.Processing, other.Processing) { return false }
	if !m.Manipulation.Equals(other.Manipulation) { return false }
	if !compareSlices(m.Storage, other.Storage) { return false }
	return true
}

// BiologicallyDerivedProductCollection
// How this product was collected.
type BiologicallyDerivedProductCollection struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Collector *Reference `json:"collector,omitempty"`
	Source *Reference `json:"source,omitempty"`
	CollectedDateTime *FhirDateTime `json:"collecteddatetime,omitempty"`
	CollectedPeriod *Period `json:"collectedperiod,omitempty"`
}

// NewBiologicallyDerivedProductCollection creates a new BiologicallyDerivedProductCollection instance
func NewBiologicallyDerivedProductCollection() *BiologicallyDerivedProductCollection {
	return &BiologicallyDerivedProductCollection{}
}

// FromJSON populates BiologicallyDerivedProductCollection from JSON data
func (m *BiologicallyDerivedProductCollection) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BiologicallyDerivedProductCollection to JSON data
func (m *BiologicallyDerivedProductCollection) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BiologicallyDerivedProductCollection
func (m *BiologicallyDerivedProductCollection) Clone() *BiologicallyDerivedProductCollection {
	if m == nil { return nil }
	return &BiologicallyDerivedProductCollection{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Collector: m.Collector.Clone(),
		Source: m.Source.Clone(),
		CollectedDateTime: m.CollectedDateTime.Clone(),
		CollectedPeriod: m.CollectedPeriod.Clone(),
	}
}

// Equals checks for equality with another BiologicallyDerivedProductCollection instance
func (m *BiologicallyDerivedProductCollection) Equals(other *BiologicallyDerivedProductCollection) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Collector.Equals(other.Collector) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !m.CollectedDateTime.Equals(other.CollectedDateTime) { return false }
	if !m.CollectedPeriod.Equals(other.CollectedPeriod) { return false }
	return true
}

// BiologicallyDerivedProductProcessing
// Any processing of the product during collection that does not change the fundamental nature of the product. For example adding anti-coagulants during the collection of Peripheral Blood Stem Cells.
type BiologicallyDerivedProductProcessing struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Procedure *CodeableConcept `json:"procedure,omitempty"`
	Additive *Reference `json:"additive,omitempty"`
	TimeDateTime *FhirDateTime `json:"timedatetime,omitempty"`
	TimePeriod *Period `json:"timeperiod,omitempty"`
}

// NewBiologicallyDerivedProductProcessing creates a new BiologicallyDerivedProductProcessing instance
func NewBiologicallyDerivedProductProcessing() *BiologicallyDerivedProductProcessing {
	return &BiologicallyDerivedProductProcessing{}
}

// FromJSON populates BiologicallyDerivedProductProcessing from JSON data
func (m *BiologicallyDerivedProductProcessing) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BiologicallyDerivedProductProcessing to JSON data
func (m *BiologicallyDerivedProductProcessing) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BiologicallyDerivedProductProcessing
func (m *BiologicallyDerivedProductProcessing) Clone() *BiologicallyDerivedProductProcessing {
	if m == nil { return nil }
	return &BiologicallyDerivedProductProcessing{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Procedure: m.Procedure.Clone(),
		Additive: m.Additive.Clone(),
		TimeDateTime: m.TimeDateTime.Clone(),
		TimePeriod: m.TimePeriod.Clone(),
	}
}

// Equals checks for equality with another BiologicallyDerivedProductProcessing instance
func (m *BiologicallyDerivedProductProcessing) Equals(other *BiologicallyDerivedProductProcessing) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Procedure.Equals(other.Procedure) { return false }
	if !m.Additive.Equals(other.Additive) { return false }
	if !m.TimeDateTime.Equals(other.TimeDateTime) { return false }
	if !m.TimePeriod.Equals(other.TimePeriod) { return false }
	return true
}

// BiologicallyDerivedProductManipulation
// Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion.
type BiologicallyDerivedProductManipulation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	TimeDateTime *FhirDateTime `json:"timedatetime,omitempty"`
	TimePeriod *Period `json:"timeperiod,omitempty"`
}

// NewBiologicallyDerivedProductManipulation creates a new BiologicallyDerivedProductManipulation instance
func NewBiologicallyDerivedProductManipulation() *BiologicallyDerivedProductManipulation {
	return &BiologicallyDerivedProductManipulation{}
}

// FromJSON populates BiologicallyDerivedProductManipulation from JSON data
func (m *BiologicallyDerivedProductManipulation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BiologicallyDerivedProductManipulation to JSON data
func (m *BiologicallyDerivedProductManipulation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BiologicallyDerivedProductManipulation
func (m *BiologicallyDerivedProductManipulation) Clone() *BiologicallyDerivedProductManipulation {
	if m == nil { return nil }
	return &BiologicallyDerivedProductManipulation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		TimeDateTime: m.TimeDateTime.Clone(),
		TimePeriod: m.TimePeriod.Clone(),
	}
}

// Equals checks for equality with another BiologicallyDerivedProductManipulation instance
func (m *BiologicallyDerivedProductManipulation) Equals(other *BiologicallyDerivedProductManipulation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.TimeDateTime.Equals(other.TimeDateTime) { return false }
	if !m.TimePeriod.Equals(other.TimePeriod) { return false }
	return true
}

// BiologicallyDerivedProductStorage
// Product storage.
type BiologicallyDerivedProductStorage struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Temperature *FhirDecimal `json:"temperature,omitempty"`
	Scale *BiologicallyDerivedProductStorageScale `json:"scale,omitempty"`
	Duration *Period `json:"duration,omitempty"`
}

// NewBiologicallyDerivedProductStorage creates a new BiologicallyDerivedProductStorage instance
func NewBiologicallyDerivedProductStorage() *BiologicallyDerivedProductStorage {
	return &BiologicallyDerivedProductStorage{}
}

// FromJSON populates BiologicallyDerivedProductStorage from JSON data
func (m *BiologicallyDerivedProductStorage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts BiologicallyDerivedProductStorage to JSON data
func (m *BiologicallyDerivedProductStorage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of BiologicallyDerivedProductStorage
func (m *BiologicallyDerivedProductStorage) Clone() *BiologicallyDerivedProductStorage {
	if m == nil { return nil }
	return &BiologicallyDerivedProductStorage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Temperature: m.Temperature.Clone(),
		Scale: m.Scale.Clone(),
		Duration: m.Duration.Clone(),
	}
}

// Equals checks for equality with another BiologicallyDerivedProductStorage instance
func (m *BiologicallyDerivedProductStorage) Equals(other *BiologicallyDerivedProductStorage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Temperature.Equals(other.Temperature) { return false }
	if !m.Scale.Equals(other.Scale) { return false }
	if !m.Duration.Equals(other.Duration) { return false }
	return true
}

