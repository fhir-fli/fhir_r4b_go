// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"

)

// SampledData
// A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
type SampledData struct {
	DataType
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// origin
	// The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
	Origin Quantity `json:"origin,omitempty"`
	// period
	// The length of time between sampling times, measured in milliseconds.
	Period FhirDecimal `json:"period,omitempty"`
	// factor
	// A correction factor that is applied to the sampled data points before they are added to the origin.
	Factor FhirDecimal `json:"factor,omitempty"`
	// lowerLimit
	// The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
	LowerLimit FhirDecimal `json:"lowerLimit,omitempty"`
	// upperLimit
	// The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
	UpperLimit FhirDecimal `json:"upperLimit,omitempty"`
	// dimensions
	// The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
	Dimensions FhirPositiveInt `json:"dimensions,omitempty"`
	// data
	// A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
	Data FhirString `json:"data,omitempty"`
}

// NewSampledData creates a new SampledData instance
func NewSampledData(
	id FhirString,
	extension_ []FhirExtension,
	origin Quantity,
	period FhirDecimal,
	factor FhirDecimal,
	lowerLimit FhirDecimal,
	upperLimit FhirDecimal,
	dimensions FhirPositiveInt,
	data FhirString,
) *SampledData {
	return &SampledData{
		Id: id,
		Extension_: extension_,
		Origin: origin,
		Period: period,
		Factor: factor,
		LowerLimit: lowerLimit,
		UpperLimit: upperLimit,
		Dimensions: dimensions,
		Data: data,
	}
}
// FromJSON populates SampledData from JSON data
func (m *SampledData) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts SampledData to JSON data
func (m *SampledData) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of SampledData
func (m *SampledData) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	origin *Quantity,
	period *FhirDecimal,
	factor *FhirDecimal,
	lowerLimit *FhirDecimal,
	upperLimit *FhirDecimal,
	dimensions *FhirPositiveInt,
	data *FhirString,
) *SampledData {
	return &SampledData{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		Origin: func() Quantity {
			if origin != nil { return *origin }
			return m.Origin
		}(),
		Period: func() FhirDecimal {
			if period != nil { return *period }
			return m.Period
		}(),
		Factor: func() FhirDecimal {
			if factor != nil { return *factor }
			return m.Factor
		}(),
		LowerLimit: func() FhirDecimal {
			if lowerLimit != nil { return *lowerLimit }
			return m.LowerLimit
		}(),
		UpperLimit: func() FhirDecimal {
			if upperLimit != nil { return *upperLimit }
			return m.UpperLimit
		}(),
		Dimensions: func() FhirPositiveInt {
			if dimensions != nil { return *dimensions }
			return m.Dimensions
		}(),
		Data: func() FhirString {
			if data != nil { return *data }
			return m.Data
		}(),
	}
}
