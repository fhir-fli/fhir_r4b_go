// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// AdministrableProductDefinition
// A medicinal product in the final form which is suitable for administering to a patient (after any mixing of multiple components, dissolution etc. has been performed).
type AdministrableProductDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	FormOf []*Reference `json:"formof,omitempty"`
	AdministrableDoseForm *CodeableConcept `json:"administrabledoseform,omitempty"`
	UnitOfPresentation *CodeableConcept `json:"unitofpresentation,omitempty"`
	ProducedFrom []*Reference `json:"producedfrom,omitempty"`
	Ingredient []*CodeableConcept `json:"ingredient,omitempty"`
	Device *Reference `json:"device,omitempty"`
	Property []*AdministrableProductDefinitionProperty `json:"property,omitempty"`
	RouteOfAdministration []*AdministrableProductDefinitionRouteOfAdministration `json:"routeofadministration,omitempty"`
}

// NewAdministrableProductDefinition creates a new AdministrableProductDefinition instance
func NewAdministrableProductDefinition() *AdministrableProductDefinition {
	return &AdministrableProductDefinition{}
}

// FromJSON populates AdministrableProductDefinition from JSON data
func (m *AdministrableProductDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdministrableProductDefinition to JSON data
func (m *AdministrableProductDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdministrableProductDefinition
func (m *AdministrableProductDefinition) Clone() *AdministrableProductDefinition {
	if m == nil { return nil }
	return &AdministrableProductDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		FormOf: cloneSlices(m.FormOf),
		AdministrableDoseForm: m.AdministrableDoseForm.Clone(),
		UnitOfPresentation: m.UnitOfPresentation.Clone(),
		ProducedFrom: cloneSlices(m.ProducedFrom),
		Ingredient: cloneSlices(m.Ingredient),
		Device: m.Device.Clone(),
		Property: cloneSlices(m.Property),
		RouteOfAdministration: cloneSlices(m.RouteOfAdministration),
	}
}

// Equals checks for equality with another AdministrableProductDefinition instance
func (m *AdministrableProductDefinition) Equals(other *AdministrableProductDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.FormOf, other.FormOf) { return false }
	if !m.AdministrableDoseForm.Equals(other.AdministrableDoseForm) { return false }
	if !m.UnitOfPresentation.Equals(other.UnitOfPresentation) { return false }
	if !compareSlices(m.ProducedFrom, other.ProducedFrom) { return false }
	if !compareSlices(m.Ingredient, other.Ingredient) { return false }
	if !m.Device.Equals(other.Device) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !compareSlices(m.RouteOfAdministration, other.RouteOfAdministration) { return false }
	return true
}

// AdministrableProductDefinitionProperty
// Characteristics e.g. a product's onset of action.
type AdministrableProductDefinitionProperty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueCodeableConcept *CodeableConcept `json:"valuecodeableconcept,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
}

// NewAdministrableProductDefinitionProperty creates a new AdministrableProductDefinitionProperty instance
func NewAdministrableProductDefinitionProperty() *AdministrableProductDefinitionProperty {
	return &AdministrableProductDefinitionProperty{}
}

// FromJSON populates AdministrableProductDefinitionProperty from JSON data
func (m *AdministrableProductDefinitionProperty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdministrableProductDefinitionProperty to JSON data
func (m *AdministrableProductDefinitionProperty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdministrableProductDefinitionProperty
func (m *AdministrableProductDefinitionProperty) Clone() *AdministrableProductDefinitionProperty {
	if m == nil { return nil }
	return &AdministrableProductDefinitionProperty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueCodeableConcept: m.ValueCodeableConcept.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		Status: m.Status.Clone(),
	}
}

// Equals checks for equality with another AdministrableProductDefinitionProperty instance
func (m *AdministrableProductDefinitionProperty) Equals(other *AdministrableProductDefinitionProperty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.ValueCodeableConcept.Equals(other.ValueCodeableConcept) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.Status.Equals(other.Status) { return false }
	return true
}

// AdministrableProductDefinitionRouteOfAdministration
// The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. RouteOfAdministration cannot be used when the 'formOf' product already uses MedicinalProductDefinition.route (and vice versa).
type AdministrableProductDefinitionRouteOfAdministration struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	FirstDose *Quantity `json:"firstdose,omitempty"`
	MaxSingleDose *Quantity `json:"maxsingledose,omitempty"`
	MaxDosePerDay *Quantity `json:"maxdoseperday,omitempty"`
	MaxDosePerTreatmentPeriod *Ratio `json:"maxdosepertreatmentperiod,omitempty"`
	MaxTreatmentPeriod *FhirDuration `json:"maxtreatmentperiod,omitempty"`
	TargetSpecies []*AdministrableProductDefinitionTargetSpecies `json:"targetspecies,omitempty"`
}

// NewAdministrableProductDefinitionRouteOfAdministration creates a new AdministrableProductDefinitionRouteOfAdministration instance
func NewAdministrableProductDefinitionRouteOfAdministration() *AdministrableProductDefinitionRouteOfAdministration {
	return &AdministrableProductDefinitionRouteOfAdministration{}
}

// FromJSON populates AdministrableProductDefinitionRouteOfAdministration from JSON data
func (m *AdministrableProductDefinitionRouteOfAdministration) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdministrableProductDefinitionRouteOfAdministration to JSON data
func (m *AdministrableProductDefinitionRouteOfAdministration) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdministrableProductDefinitionRouteOfAdministration
func (m *AdministrableProductDefinitionRouteOfAdministration) Clone() *AdministrableProductDefinitionRouteOfAdministration {
	if m == nil { return nil }
	return &AdministrableProductDefinitionRouteOfAdministration{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		FirstDose: m.FirstDose.Clone(),
		MaxSingleDose: m.MaxSingleDose.Clone(),
		MaxDosePerDay: m.MaxDosePerDay.Clone(),
		MaxDosePerTreatmentPeriod: m.MaxDosePerTreatmentPeriod.Clone(),
		MaxTreatmentPeriod: m.MaxTreatmentPeriod.Clone(),
		TargetSpecies: cloneSlices(m.TargetSpecies),
	}
}

// Equals checks for equality with another AdministrableProductDefinitionRouteOfAdministration instance
func (m *AdministrableProductDefinitionRouteOfAdministration) Equals(other *AdministrableProductDefinitionRouteOfAdministration) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.FirstDose.Equals(other.FirstDose) { return false }
	if !m.MaxSingleDose.Equals(other.MaxSingleDose) { return false }
	if !m.MaxDosePerDay.Equals(other.MaxDosePerDay) { return false }
	if !m.MaxDosePerTreatmentPeriod.Equals(other.MaxDosePerTreatmentPeriod) { return false }
	if !m.MaxTreatmentPeriod.Equals(other.MaxTreatmentPeriod) { return false }
	if !compareSlices(m.TargetSpecies, other.TargetSpecies) { return false }
	return true
}

// AdministrableProductDefinitionTargetSpecies
// A species for which this route applies.
type AdministrableProductDefinitionTargetSpecies struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	WithdrawalPeriod []*AdministrableProductDefinitionWithdrawalPeriod `json:"withdrawalperiod,omitempty"`
}

// NewAdministrableProductDefinitionTargetSpecies creates a new AdministrableProductDefinitionTargetSpecies instance
func NewAdministrableProductDefinitionTargetSpecies() *AdministrableProductDefinitionTargetSpecies {
	return &AdministrableProductDefinitionTargetSpecies{}
}

// FromJSON populates AdministrableProductDefinitionTargetSpecies from JSON data
func (m *AdministrableProductDefinitionTargetSpecies) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdministrableProductDefinitionTargetSpecies to JSON data
func (m *AdministrableProductDefinitionTargetSpecies) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdministrableProductDefinitionTargetSpecies
func (m *AdministrableProductDefinitionTargetSpecies) Clone() *AdministrableProductDefinitionTargetSpecies {
	if m == nil { return nil }
	return &AdministrableProductDefinitionTargetSpecies{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		WithdrawalPeriod: cloneSlices(m.WithdrawalPeriod),
	}
}

// Equals checks for equality with another AdministrableProductDefinitionTargetSpecies instance
func (m *AdministrableProductDefinitionTargetSpecies) Equals(other *AdministrableProductDefinitionTargetSpecies) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.WithdrawalPeriod, other.WithdrawalPeriod) { return false }
	return true
}

// AdministrableProductDefinitionWithdrawalPeriod
// A species specific time during which consumption of animal product is not appropriate.
type AdministrableProductDefinitionWithdrawalPeriod struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Tissue *CodeableConcept `json:"tissue,omitempty"`
	Value *Quantity `json:"value,omitempty"`
	SupportingInformation *FhirString `json:"supportinginformation,omitempty"`
}

// NewAdministrableProductDefinitionWithdrawalPeriod creates a new AdministrableProductDefinitionWithdrawalPeriod instance
func NewAdministrableProductDefinitionWithdrawalPeriod() *AdministrableProductDefinitionWithdrawalPeriod {
	return &AdministrableProductDefinitionWithdrawalPeriod{}
}

// FromJSON populates AdministrableProductDefinitionWithdrawalPeriod from JSON data
func (m *AdministrableProductDefinitionWithdrawalPeriod) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdministrableProductDefinitionWithdrawalPeriod to JSON data
func (m *AdministrableProductDefinitionWithdrawalPeriod) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdministrableProductDefinitionWithdrawalPeriod
func (m *AdministrableProductDefinitionWithdrawalPeriod) Clone() *AdministrableProductDefinitionWithdrawalPeriod {
	if m == nil { return nil }
	return &AdministrableProductDefinitionWithdrawalPeriod{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Tissue: m.Tissue.Clone(),
		Value: m.Value.Clone(),
		SupportingInformation: m.SupportingInformation.Clone(),
	}
}

// Equals checks for equality with another AdministrableProductDefinitionWithdrawalPeriod instance
func (m *AdministrableProductDefinitionWithdrawalPeriod) Equals(other *AdministrableProductDefinitionWithdrawalPeriod) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Tissue.Equals(other.Tissue) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !m.SupportingInformation.Equals(other.SupportingInformation) { return false }
	return true
}

