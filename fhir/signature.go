// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Signature
// A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
type Signature struct {
	DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Type []*Coding `json:"type,omitempty"`
	When *FhirInstant `json:"when,omitempty"`
	Who *Reference `json:"who,omitempty"`
	OnBehalfOf *Reference `json:"onbehalfof,omitempty"`
	TargetFormat *FhirCode `json:"targetformat,omitempty"`
	SigFormat *FhirCode `json:"sigformat,omitempty"`
	Data *FhirBase64Binary `json:"data,omitempty"`
}

// NewSignature creates a new Signature instance
func NewSignature() *Signature {
	return &Signature{}
}

// FromJSON populates Signature from JSON data
func (m *Signature) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Signature to JSON data
func (m *Signature) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Signature
func (m *Signature) Clone() *Signature {
	if m == nil { return nil }
	return &Signature{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Type: cloneSlices(m.Type),
		When: m.When.Clone(),
		Who: m.Who.Clone(),
		OnBehalfOf: m.OnBehalfOf.Clone(),
		TargetFormat: m.TargetFormat.Clone(),
		SigFormat: m.SigFormat.Clone(),
		Data: m.Data.Clone(),
	}
}

// Equals checks for equality with another Signature instance
func (m *Signature) Equals(other *Signature) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.When.Equals(other.When) { return false }
	if !m.Who.Equals(other.Who) { return false }
	if !m.OnBehalfOf.Equals(other.OnBehalfOf) { return false }
	if !m.TargetFormat.Equals(other.TargetFormat) { return false }
	if !m.SigFormat.Equals(other.SigFormat) { return false }
	if !m.Data.Equals(other.Data) { return false }
	return true
}

