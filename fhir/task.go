// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"

)

// Task
// A task to be performed.
type Task struct {
	DomainResource
	// id
	// The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.
	Id FhirString `json:"id,omitempty"`
	// meta
	// The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
	Meta FhirMeta `json:"meta,omitempty"`
	// implicitRules
	// A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
	ImplicitRules FhirUri `json:"implicitRules,omitempty"`
	// language
	// The base language in which the resource is written.
	Language CommonLanguages `json:"language,omitempty"`
	// text
	// A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
	Text Narrative `json:"text,omitempty"`
	// contained
	// These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
	Contained []Resource `json:"contained,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// identifier
	// The business identifier for this task.
	Identifier []Identifier `json:"identifier,omitempty"`
	// instantiatesCanonical
	// The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
	InstantiatesCanonical FhirCanonical `json:"instantiatesCanonical,omitempty"`
	// instantiatesUri
	// The URL pointing to an *externally* maintained  protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
	InstantiatesUri FhirUri `json:"instantiatesUri,omitempty"`
	// basedOn
	// BasedOn refers to a higher-level authorization that triggered the creation of the task.  It references a "request" resource such as a ServiceRequest, MedicationRequest, ServiceRequest, CarePlan, etc. which is distinct from the "request" resource the task is seeking to fulfill.  This latter resource is referenced by FocusOn.  For example, based on a ServiceRequest (= BasedOn), a task is created to fulfill a procedureRequest ( = FocusOn ) to collect a specimen from a patient.
	BasedOn []Reference `json:"basedOn,omitempty"`
	// groupIdentifier
	// An identifier that links together multiple tasks and other requests that were created in the same context.
	GroupIdentifier Identifier `json:"groupIdentifier,omitempty"`
	// partOf
	// Task that this particular task is part of.
	PartOf []Reference `json:"partOf,omitempty"`
	// status
	// The current status of the task.
	Status TaskStatus `json:"status,omitempty"`
	// statusReason
	// An explanation as to why this task is held, failed, was refused, etc.
	StatusReason CodeableConcept `json:"statusReason,omitempty"`
	// businessStatus
	// Contains business-specific nuances of the business state.
	BusinessStatus CodeableConcept `json:"businessStatus,omitempty"`
	// intent
	// Indicates the "level" of actionability associated with the Task, i.e. i+R[9]Cs this a proposed task, a planned task, an actionable task, etc.
	Intent TaskIntent `json:"intent,omitempty"`
	// priority
	// Indicates how quickly the Task should be addressed with respect to other requests.
	Priority RequestPriority `json:"priority,omitempty"`
	// code
	// A name or code (or both) briefly describing what the task involves.
	Code CodeableConcept `json:"code,omitempty"`
	// description
	// A free-text description of what is to be performed.
	Description FhirString `json:"description,omitempty"`
	// focus
	// The request being actioned or the resource being manipulated by this task.
	Focus Reference `json:"focus,omitempty"`
	// for
	// The entity who benefits from the performance of the service specified in the task (e.g., the patient).
	For_ Reference `json:"for,omitempty"`
	// encounter
	// The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created.
	Encounter Reference `json:"encounter,omitempty"`
	// executionPeriod
	// Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end).
	ExecutionPeriod Period `json:"executionPeriod,omitempty"`
	// authoredOn
	// The date and time this task was created.
	AuthoredOn FhirDateTime `json:"authoredOn,omitempty"`
	// lastModified
	// The date and time of last modification to this task.
	LastModified FhirDateTime `json:"lastModified,omitempty"`
	// requester
	// The creator of the task.
	Requester Reference `json:"requester,omitempty"`
	// performerType
	// The kind of participant that should perform the task.
	PerformerType []CodeableConcept `json:"performerType,omitempty"`
	// owner
	// Individual organization or Device currently responsible for task execution.
	Owner Reference `json:"owner,omitempty"`
	// location
	// Principal physical location where the this task is performed.
	Location Reference `json:"location,omitempty"`
	// reasonCode
	// A description or code indicating why this task needs to be performed.
	ReasonCode CodeableConcept `json:"reasonCode,omitempty"`
	// reasonReference
	// A resource reference indicating why this task needs to be performed.
	ReasonReference Reference `json:"reasonReference,omitempty"`
	// insurance
	// Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be relevant to the Task.
	Insurance []Reference `json:"insurance,omitempty"`
	// note
	// Free-text information captured about the task as it progresses.
	Note []Annotation `json:"note,omitempty"`
	// relevantHistory
	// Links to Provenance records for past versions of this Task that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the task.
	RelevantHistory []Reference `json:"relevantHistory,omitempty"`
	// restriction
	// If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
	Restriction TaskRestriction `json:"restriction,omitempty"`
	// input
	// Additional information that may be needed in the execution of the task.
	Input []TaskInput `json:"input,omitempty"`
	// output
	// Outputs produced by the Task.
	Output []TaskOutput `json:"output,omitempty"`
}

// NewTask creates a new Task instance
func NewTask(
	id FhirString,
	meta FhirMeta,
	implicitRules FhirUri,
	language CommonLanguages,
	text Narrative,
	contained []Resource,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	identifier []Identifier,
	instantiatesCanonical FhirCanonical,
	instantiatesUri FhirUri,
	basedOn []Reference,
	groupIdentifier Identifier,
	partOf []Reference,
	status TaskStatus,
	statusReason CodeableConcept,
	businessStatus CodeableConcept,
	intent TaskIntent,
	priority RequestPriority,
	code CodeableConcept,
	description FhirString,
	focus Reference,
	for_ Reference,
	encounter Reference,
	executionPeriod Period,
	authoredOn FhirDateTime,
	lastModified FhirDateTime,
	requester Reference,
	performerType []CodeableConcept,
	owner Reference,
	location Reference,
	reasonCode CodeableConcept,
	reasonReference Reference,
	insurance []Reference,
	note []Annotation,
	relevantHistory []Reference,
	restriction TaskRestriction,
	input []TaskInput,
	output []TaskOutput,
) *Task {
	return &Task{
		Id: id,
		Meta: meta,
		ImplicitRules: implicitRules,
		Language: language,
		Text: text,
		Contained: contained,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		Identifier: identifier,
		InstantiatesCanonical: instantiatesCanonical,
		InstantiatesUri: instantiatesUri,
		BasedOn: basedOn,
		GroupIdentifier: groupIdentifier,
		PartOf: partOf,
		Status: status,
		StatusReason: statusReason,
		BusinessStatus: businessStatus,
		Intent: intent,
		Priority: priority,
		Code: code,
		Description: description,
		Focus: focus,
		For_: for_,
		Encounter: encounter,
		ExecutionPeriod: executionPeriod,
		AuthoredOn: authoredOn,
		LastModified: lastModified,
		Requester: requester,
		PerformerType: performerType,
		Owner: owner,
		Location: location,
		ReasonCode: reasonCode,
		ReasonReference: reasonReference,
		Insurance: insurance,
		Note: note,
		RelevantHistory: relevantHistory,
		Restriction: restriction,
		Input: input,
		Output: output,
	}
}
// FromJSON populates Task from JSON data
func (m *Task) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Task to JSON data
func (m *Task) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of Task
func (m *Task) CopyWith(
	id *FhirString,
	meta *FhirMeta,
	implicitRules *FhirUri,
	language *CommonLanguages,
	text *Narrative,
	contained *[]Resource,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	identifier *[]Identifier,
	instantiatesCanonical *FhirCanonical,
	instantiatesUri *FhirUri,
	basedOn *[]Reference,
	groupIdentifier *Identifier,
	partOf *[]Reference,
	status *TaskStatus,
	statusReason *CodeableConcept,
	businessStatus *CodeableConcept,
	intent *TaskIntent,
	priority *RequestPriority,
	code *CodeableConcept,
	description *FhirString,
	focus *Reference,
	for_ *Reference,
	encounter *Reference,
	executionPeriod *Period,
	authoredOn *FhirDateTime,
	lastModified *FhirDateTime,
	requester *Reference,
	performerType *[]CodeableConcept,
	owner *Reference,
	location *Reference,
	reasonCode *CodeableConcept,
	reasonReference *Reference,
	insurance *[]Reference,
	note *[]Annotation,
	relevantHistory *[]Reference,
	restriction *TaskRestriction,
	input *[]TaskInput,
	output *[]TaskOutput,
) *Task {
	return &Task{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Meta: func() FhirMeta {
			if meta != nil { return *meta }
			return m.Meta
		}(),
		ImplicitRules: func() FhirUri {
			if implicitRules != nil { return *implicitRules }
			return m.ImplicitRules
		}(),
		Language: func() CommonLanguages {
			if language != nil { return *language }
			return m.Language
		}(),
		Text: func() Narrative {
			if text != nil { return *text }
			return m.Text
		}(),
		Contained: func() []Resource {
			if contained != nil { return *contained }
			return m.Contained
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		Identifier: func() []Identifier {
			if identifier != nil { return *identifier }
			return m.Identifier
		}(),
		InstantiatesCanonical: func() FhirCanonical {
			if instantiatesCanonical != nil { return *instantiatesCanonical }
			return m.InstantiatesCanonical
		}(),
		InstantiatesUri: func() FhirUri {
			if instantiatesUri != nil { return *instantiatesUri }
			return m.InstantiatesUri
		}(),
		BasedOn: func() []Reference {
			if basedOn != nil { return *basedOn }
			return m.BasedOn
		}(),
		GroupIdentifier: func() Identifier {
			if groupIdentifier != nil { return *groupIdentifier }
			return m.GroupIdentifier
		}(),
		PartOf: func() []Reference {
			if partOf != nil { return *partOf }
			return m.PartOf
		}(),
		Status: func() TaskStatus {
			if status != nil { return *status }
			return m.Status
		}(),
		StatusReason: func() CodeableConcept {
			if statusReason != nil { return *statusReason }
			return m.StatusReason
		}(),
		BusinessStatus: func() CodeableConcept {
			if businessStatus != nil { return *businessStatus }
			return m.BusinessStatus
		}(),
		Intent: func() TaskIntent {
			if intent != nil { return *intent }
			return m.Intent
		}(),
		Priority: func() RequestPriority {
			if priority != nil { return *priority }
			return m.Priority
		}(),
		Code: func() CodeableConcept {
			if code != nil { return *code }
			return m.Code
		}(),
		Description: func() FhirString {
			if description != nil { return *description }
			return m.Description
		}(),
		Focus: func() Reference {
			if focus != nil { return *focus }
			return m.Focus
		}(),
		For_: func() Reference {
			if for_ != nil { return *for_ }
			return m.For_
		}(),
		Encounter: func() Reference {
			if encounter != nil { return *encounter }
			return m.Encounter
		}(),
		ExecutionPeriod: func() Period {
			if executionPeriod != nil { return *executionPeriod }
			return m.ExecutionPeriod
		}(),
		AuthoredOn: func() FhirDateTime {
			if authoredOn != nil { return *authoredOn }
			return m.AuthoredOn
		}(),
		LastModified: func() FhirDateTime {
			if lastModified != nil { return *lastModified }
			return m.LastModified
		}(),
		Requester: func() Reference {
			if requester != nil { return *requester }
			return m.Requester
		}(),
		PerformerType: func() []CodeableConcept {
			if performerType != nil { return *performerType }
			return m.PerformerType
		}(),
		Owner: func() Reference {
			if owner != nil { return *owner }
			return m.Owner
		}(),
		Location: func() Reference {
			if location != nil { return *location }
			return m.Location
		}(),
		ReasonCode: func() CodeableConcept {
			if reasonCode != nil { return *reasonCode }
			return m.ReasonCode
		}(),
		ReasonReference: func() Reference {
			if reasonReference != nil { return *reasonReference }
			return m.ReasonReference
		}(),
		Insurance: func() []Reference {
			if insurance != nil { return *insurance }
			return m.Insurance
		}(),
		Note: func() []Annotation {
			if note != nil { return *note }
			return m.Note
		}(),
		RelevantHistory: func() []Reference {
			if relevantHistory != nil { return *relevantHistory }
			return m.RelevantHistory
		}(),
		Restriction: func() TaskRestriction {
			if restriction != nil { return *restriction }
			return m.Restriction
		}(),
		Input: func() []TaskInput {
			if input != nil { return *input }
			return m.Input
		}(),
		Output: func() []TaskOutput {
			if output != nil { return *output }
			return m.Output
		}(),
	}
}
// TaskRestriction
// If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
type TaskRestriction struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// repetitions
	// Indicates the number of times the requested action should occur.
	Repetitions FhirPositiveInt `json:"repetitions,omitempty"`
	// period
	// Over what time-period is fulfillment sought.
	Period Period `json:"period,omitempty"`
	// recipient
	// For requests that are targeted to more than on potential recipient/target, for whom is fulfillment sought?
	Recipient []Reference `json:"recipient,omitempty"`
}

// NewTaskRestriction creates a new TaskRestriction instance
func NewTaskRestriction(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	repetitions FhirPositiveInt,
	period Period,
	recipient []Reference,
) *TaskRestriction {
	return &TaskRestriction{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		Repetitions: repetitions,
		Period: period,
		Recipient: recipient,
	}
}
// FromJSON populates TaskRestriction from JSON data
func (m *TaskRestriction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TaskRestriction to JSON data
func (m *TaskRestriction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of TaskRestriction
func (m *TaskRestriction) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	repetitions *FhirPositiveInt,
	period *Period,
	recipient *[]Reference,
) *TaskRestriction {
	return &TaskRestriction{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		Repetitions: func() FhirPositiveInt {
			if repetitions != nil { return *repetitions }
			return m.Repetitions
		}(),
		Period: func() Period {
			if period != nil { return *period }
			return m.Period
		}(),
		Recipient: func() []Reference {
			if recipient != nil { return *recipient }
			return m.Recipient
		}(),
	}
}
// TaskInput
// Additional information that may be needed in the execution of the task.
type TaskInput struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// type
	// A code or description indicating how the input is intended to be used as part of the task execution.
	Type_ CodeableConcept `json:"type,omitempty"`
	// valueBase64Binary
	// The value of the input parameter as a basic type.
	ValueBase64Binary FhirBase64Binary `json:"valueBase64Binary,omitempty"`
	// valueBoolean
	// The value of the input parameter as a basic type.
	ValueBoolean FhirBoolean `json:"valueBoolean,omitempty"`
	// valueCanonical
	// The value of the input parameter as a basic type.
	ValueCanonical FhirCanonical `json:"valueCanonical,omitempty"`
	// valueCode
	// The value of the input parameter as a basic type.
	ValueCode FhirCode `json:"valueCode,omitempty"`
	// valueDate
	// The value of the input parameter as a basic type.
	ValueDate FhirDate `json:"valueDate,omitempty"`
	// valueDateTime
	// The value of the input parameter as a basic type.
	ValueDateTime FhirDateTime `json:"valueDateTime,omitempty"`
	// valueDecimal
	// The value of the input parameter as a basic type.
	ValueDecimal FhirDecimal `json:"valueDecimal,omitempty"`
	// valueId
	// The value of the input parameter as a basic type.
	ValueId FhirId `json:"valueId,omitempty"`
	// valueInstant
	// The value of the input parameter as a basic type.
	ValueInstant FhirInstant `json:"valueInstant,omitempty"`
	// valueInteger
	// The value of the input parameter as a basic type.
	ValueInteger FhirInteger `json:"valueInteger,omitempty"`
	// valueMarkdown
	// The value of the input parameter as a basic type.
	ValueMarkdown FhirMarkdown `json:"valueMarkdown,omitempty"`
	// valueOid
	// The value of the input parameter as a basic type.
	ValueOid FhirOid `json:"valueOid,omitempty"`
	// valuePositiveInt
	// The value of the input parameter as a basic type.
	ValuePositiveInt FhirPositiveInt `json:"valuePositiveInt,omitempty"`
	// valueString
	// The value of the input parameter as a basic type.
	ValueString FhirString `json:"valueString,omitempty"`
	// valueTime
	// The value of the input parameter as a basic type.
	ValueTime FhirTime `json:"valueTime,omitempty"`
	// valueUnsignedInt
	// The value of the input parameter as a basic type.
	ValueUnsignedInt FhirUnsignedInt `json:"valueUnsignedInt,omitempty"`
	// valueUri
	// The value of the input parameter as a basic type.
	ValueUri FhirUri `json:"valueUri,omitempty"`
	// valueUrl
	// The value of the input parameter as a basic type.
	ValueUrl FhirUrl `json:"valueUrl,omitempty"`
	// valueUuid
	// The value of the input parameter as a basic type.
	ValueUuid FhirUuid `json:"valueUuid,omitempty"`
	// valueAddress
	// The value of the input parameter as a basic type.
	ValueAddress Address `json:"valueAddress,omitempty"`
	// valueAge
	// The value of the input parameter as a basic type.
	ValueAge Age `json:"valueAge,omitempty"`
	// valueAnnotation
	// The value of the input parameter as a basic type.
	ValueAnnotation Annotation `json:"valueAnnotation,omitempty"`
	// valueAttachment
	// The value of the input parameter as a basic type.
	ValueAttachment Attachment `json:"valueAttachment,omitempty"`
	// valueCodeableConcept
	// The value of the input parameter as a basic type.
	ValueCodeableConcept CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// valueCoding
	// The value of the input parameter as a basic type.
	ValueCoding Coding `json:"valueCoding,omitempty"`
	// valueContactPoint
	// The value of the input parameter as a basic type.
	ValueContactPoint ContactPoint `json:"valueContactPoint,omitempty"`
	// valueCount
	// The value of the input parameter as a basic type.
	ValueCount Count `json:"valueCount,omitempty"`
	// valueDistance
	// The value of the input parameter as a basic type.
	ValueDistance Distance `json:"valueDistance,omitempty"`
	// valueDuration
	// The value of the input parameter as a basic type.
	ValueDuration FhirDuration `json:"valueDuration,omitempty"`
	// valueHumanName
	// The value of the input parameter as a basic type.
	ValueHumanName HumanName `json:"valueHumanName,omitempty"`
	// valueIdentifier
	// The value of the input parameter as a basic type.
	ValueIdentifier Identifier `json:"valueIdentifier,omitempty"`
	// valueMoney
	// The value of the input parameter as a basic type.
	ValueMoney Money `json:"valueMoney,omitempty"`
	// valuePeriod
	// The value of the input parameter as a basic type.
	ValuePeriod Period `json:"valuePeriod,omitempty"`
	// valueQuantity
	// The value of the input parameter as a basic type.
	ValueQuantity Quantity `json:"valueQuantity,omitempty"`
	// valueRange
	// The value of the input parameter as a basic type.
	ValueRange Range `json:"valueRange,omitempty"`
	// valueRatio
	// The value of the input parameter as a basic type.
	ValueRatio Ratio `json:"valueRatio,omitempty"`
	// valueReference
	// The value of the input parameter as a basic type.
	ValueReference Reference `json:"valueReference,omitempty"`
	// valueSampledData
	// The value of the input parameter as a basic type.
	ValueSampledData SampledData `json:"valueSampledData,omitempty"`
	// valueSignature
	// The value of the input parameter as a basic type.
	ValueSignature Signature `json:"valueSignature,omitempty"`
	// valueTiming
	// The value of the input parameter as a basic type.
	ValueTiming Timing `json:"valueTiming,omitempty"`
	// valueContactDetail
	// The value of the input parameter as a basic type.
	ValueContactDetail ContactDetail `json:"valueContactDetail,omitempty"`
	// valueContributor
	// The value of the input parameter as a basic type.
	ValueContributor Contributor `json:"valueContributor,omitempty"`
	// valueDataRequirement
	// The value of the input parameter as a basic type.
	ValueDataRequirement DataRequirement `json:"valueDataRequirement,omitempty"`
	// valueExpression
	// The value of the input parameter as a basic type.
	ValueExpression FhirExpression `json:"valueExpression,omitempty"`
	// valueParameterDefinition
	// The value of the input parameter as a basic type.
	ValueParameterDefinition ParameterDefinition `json:"valueParameterDefinition,omitempty"`
	// valueRelatedArtifact
	// The value of the input parameter as a basic type.
	ValueRelatedArtifact RelatedArtifact `json:"valueRelatedArtifact,omitempty"`
	// valueTriggerDefinition
	// The value of the input parameter as a basic type.
	ValueTriggerDefinition TriggerDefinition `json:"valueTriggerDefinition,omitempty"`
	// valueUsageContext
	// The value of the input parameter as a basic type.
	ValueUsageContext UsageContext `json:"valueUsageContext,omitempty"`
	// valueDosage
	// The value of the input parameter as a basic type.
	ValueDosage Dosage `json:"valueDosage,omitempty"`
	// valueMeta
	// The value of the input parameter as a basic type.
	ValueMeta FhirMeta `json:"valueMeta,omitempty"`
}

// NewTaskInput creates a new TaskInput instance
func NewTaskInput(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	type_ CodeableConcept,
	valueBase64Binary FhirBase64Binary,
	valueBoolean FhirBoolean,
	valueCanonical FhirCanonical,
	valueCode FhirCode,
	valueDate FhirDate,
	valueDateTime FhirDateTime,
	valueDecimal FhirDecimal,
	valueId FhirId,
	valueInstant FhirInstant,
	valueInteger FhirInteger,
	valueMarkdown FhirMarkdown,
	valueOid FhirOid,
	valuePositiveInt FhirPositiveInt,
	valueString FhirString,
	valueTime FhirTime,
	valueUnsignedInt FhirUnsignedInt,
	valueUri FhirUri,
	valueUrl FhirUrl,
	valueUuid FhirUuid,
	valueAddress Address,
	valueAge Age,
	valueAnnotation Annotation,
	valueAttachment Attachment,
	valueCodeableConcept CodeableConcept,
	valueCoding Coding,
	valueContactPoint ContactPoint,
	valueCount Count,
	valueDistance Distance,
	valueDuration FhirDuration,
	valueHumanName HumanName,
	valueIdentifier Identifier,
	valueMoney Money,
	valuePeriod Period,
	valueQuantity Quantity,
	valueRange Range,
	valueRatio Ratio,
	valueReference Reference,
	valueSampledData SampledData,
	valueSignature Signature,
	valueTiming Timing,
	valueContactDetail ContactDetail,
	valueContributor Contributor,
	valueDataRequirement DataRequirement,
	valueExpression FhirExpression,
	valueParameterDefinition ParameterDefinition,
	valueRelatedArtifact RelatedArtifact,
	valueTriggerDefinition TriggerDefinition,
	valueUsageContext UsageContext,
	valueDosage Dosage,
	valueMeta FhirMeta,
) *TaskInput {
	return &TaskInput{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		Type_: type_,
		ValueBase64Binary: valueBase64Binary,
		ValueBoolean: valueBoolean,
		ValueCanonical: valueCanonical,
		ValueCode: valueCode,
		ValueDate: valueDate,
		ValueDateTime: valueDateTime,
		ValueDecimal: valueDecimal,
		ValueId: valueId,
		ValueInstant: valueInstant,
		ValueInteger: valueInteger,
		ValueMarkdown: valueMarkdown,
		ValueOid: valueOid,
		ValuePositiveInt: valuePositiveInt,
		ValueString: valueString,
		ValueTime: valueTime,
		ValueUnsignedInt: valueUnsignedInt,
		ValueUri: valueUri,
		ValueUrl: valueUrl,
		ValueUuid: valueUuid,
		ValueAddress: valueAddress,
		ValueAge: valueAge,
		ValueAnnotation: valueAnnotation,
		ValueAttachment: valueAttachment,
		ValueCodeableConcept: valueCodeableConcept,
		ValueCoding: valueCoding,
		ValueContactPoint: valueContactPoint,
		ValueCount: valueCount,
		ValueDistance: valueDistance,
		ValueDuration: valueDuration,
		ValueHumanName: valueHumanName,
		ValueIdentifier: valueIdentifier,
		ValueMoney: valueMoney,
		ValuePeriod: valuePeriod,
		ValueQuantity: valueQuantity,
		ValueRange: valueRange,
		ValueRatio: valueRatio,
		ValueReference: valueReference,
		ValueSampledData: valueSampledData,
		ValueSignature: valueSignature,
		ValueTiming: valueTiming,
		ValueContactDetail: valueContactDetail,
		ValueContributor: valueContributor,
		ValueDataRequirement: valueDataRequirement,
		ValueExpression: valueExpression,
		ValueParameterDefinition: valueParameterDefinition,
		ValueRelatedArtifact: valueRelatedArtifact,
		ValueTriggerDefinition: valueTriggerDefinition,
		ValueUsageContext: valueUsageContext,
		ValueDosage: valueDosage,
		ValueMeta: valueMeta,
	}
}
// FromJSON populates TaskInput from JSON data
func (m *TaskInput) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TaskInput to JSON data
func (m *TaskInput) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of TaskInput
func (m *TaskInput) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	type_ *CodeableConcept,
	valueBase64Binary *FhirBase64Binary,
	valueBoolean *FhirBoolean,
	valueCanonical *FhirCanonical,
	valueCode *FhirCode,
	valueDate *FhirDate,
	valueDateTime *FhirDateTime,
	valueDecimal *FhirDecimal,
	valueId *FhirId,
	valueInstant *FhirInstant,
	valueInteger *FhirInteger,
	valueMarkdown *FhirMarkdown,
	valueOid *FhirOid,
	valuePositiveInt *FhirPositiveInt,
	valueString *FhirString,
	valueTime *FhirTime,
	valueUnsignedInt *FhirUnsignedInt,
	valueUri *FhirUri,
	valueUrl *FhirUrl,
	valueUuid *FhirUuid,
	valueAddress *Address,
	valueAge *Age,
	valueAnnotation *Annotation,
	valueAttachment *Attachment,
	valueCodeableConcept *CodeableConcept,
	valueCoding *Coding,
	valueContactPoint *ContactPoint,
	valueCount *Count,
	valueDistance *Distance,
	valueDuration *FhirDuration,
	valueHumanName *HumanName,
	valueIdentifier *Identifier,
	valueMoney *Money,
	valuePeriod *Period,
	valueQuantity *Quantity,
	valueRange *Range,
	valueRatio *Ratio,
	valueReference *Reference,
	valueSampledData *SampledData,
	valueSignature *Signature,
	valueTiming *Timing,
	valueContactDetail *ContactDetail,
	valueContributor *Contributor,
	valueDataRequirement *DataRequirement,
	valueExpression *FhirExpression,
	valueParameterDefinition *ParameterDefinition,
	valueRelatedArtifact *RelatedArtifact,
	valueTriggerDefinition *TriggerDefinition,
	valueUsageContext *UsageContext,
	valueDosage *Dosage,
	valueMeta *FhirMeta,
) *TaskInput {
	return &TaskInput{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		Type_: func() CodeableConcept {
			if type_ != nil { return *type_ }
			return m.Type_
		}(),
		ValueBase64Binary: func() FhirBase64Binary {
			if valueBase64Binary != nil { return *valueBase64Binary }
			return m.ValueBase64Binary
		}(),
		ValueBoolean: func() FhirBoolean {
			if valueBoolean != nil { return *valueBoolean }
			return m.ValueBoolean
		}(),
		ValueCanonical: func() FhirCanonical {
			if valueCanonical != nil { return *valueCanonical }
			return m.ValueCanonical
		}(),
		ValueCode: func() FhirCode {
			if valueCode != nil { return *valueCode }
			return m.ValueCode
		}(),
		ValueDate: func() FhirDate {
			if valueDate != nil { return *valueDate }
			return m.ValueDate
		}(),
		ValueDateTime: func() FhirDateTime {
			if valueDateTime != nil { return *valueDateTime }
			return m.ValueDateTime
		}(),
		ValueDecimal: func() FhirDecimal {
			if valueDecimal != nil { return *valueDecimal }
			return m.ValueDecimal
		}(),
		ValueId: func() FhirId {
			if valueId != nil { return *valueId }
			return m.ValueId
		}(),
		ValueInstant: func() FhirInstant {
			if valueInstant != nil { return *valueInstant }
			return m.ValueInstant
		}(),
		ValueInteger: func() FhirInteger {
			if valueInteger != nil { return *valueInteger }
			return m.ValueInteger
		}(),
		ValueMarkdown: func() FhirMarkdown {
			if valueMarkdown != nil { return *valueMarkdown }
			return m.ValueMarkdown
		}(),
		ValueOid: func() FhirOid {
			if valueOid != nil { return *valueOid }
			return m.ValueOid
		}(),
		ValuePositiveInt: func() FhirPositiveInt {
			if valuePositiveInt != nil { return *valuePositiveInt }
			return m.ValuePositiveInt
		}(),
		ValueString: func() FhirString {
			if valueString != nil { return *valueString }
			return m.ValueString
		}(),
		ValueTime: func() FhirTime {
			if valueTime != nil { return *valueTime }
			return m.ValueTime
		}(),
		ValueUnsignedInt: func() FhirUnsignedInt {
			if valueUnsignedInt != nil { return *valueUnsignedInt }
			return m.ValueUnsignedInt
		}(),
		ValueUri: func() FhirUri {
			if valueUri != nil { return *valueUri }
			return m.ValueUri
		}(),
		ValueUrl: func() FhirUrl {
			if valueUrl != nil { return *valueUrl }
			return m.ValueUrl
		}(),
		ValueUuid: func() FhirUuid {
			if valueUuid != nil { return *valueUuid }
			return m.ValueUuid
		}(),
		ValueAddress: func() Address {
			if valueAddress != nil { return *valueAddress }
			return m.ValueAddress
		}(),
		ValueAge: func() Age {
			if valueAge != nil { return *valueAge }
			return m.ValueAge
		}(),
		ValueAnnotation: func() Annotation {
			if valueAnnotation != nil { return *valueAnnotation }
			return m.ValueAnnotation
		}(),
		ValueAttachment: func() Attachment {
			if valueAttachment != nil { return *valueAttachment }
			return m.ValueAttachment
		}(),
		ValueCodeableConcept: func() CodeableConcept {
			if valueCodeableConcept != nil { return *valueCodeableConcept }
			return m.ValueCodeableConcept
		}(),
		ValueCoding: func() Coding {
			if valueCoding != nil { return *valueCoding }
			return m.ValueCoding
		}(),
		ValueContactPoint: func() ContactPoint {
			if valueContactPoint != nil { return *valueContactPoint }
			return m.ValueContactPoint
		}(),
		ValueCount: func() Count {
			if valueCount != nil { return *valueCount }
			return m.ValueCount
		}(),
		ValueDistance: func() Distance {
			if valueDistance != nil { return *valueDistance }
			return m.ValueDistance
		}(),
		ValueDuration: func() FhirDuration {
			if valueDuration != nil { return *valueDuration }
			return m.ValueDuration
		}(),
		ValueHumanName: func() HumanName {
			if valueHumanName != nil { return *valueHumanName }
			return m.ValueHumanName
		}(),
		ValueIdentifier: func() Identifier {
			if valueIdentifier != nil { return *valueIdentifier }
			return m.ValueIdentifier
		}(),
		ValueMoney: func() Money {
			if valueMoney != nil { return *valueMoney }
			return m.ValueMoney
		}(),
		ValuePeriod: func() Period {
			if valuePeriod != nil { return *valuePeriod }
			return m.ValuePeriod
		}(),
		ValueQuantity: func() Quantity {
			if valueQuantity != nil { return *valueQuantity }
			return m.ValueQuantity
		}(),
		ValueRange: func() Range {
			if valueRange != nil { return *valueRange }
			return m.ValueRange
		}(),
		ValueRatio: func() Ratio {
			if valueRatio != nil { return *valueRatio }
			return m.ValueRatio
		}(),
		ValueReference: func() Reference {
			if valueReference != nil { return *valueReference }
			return m.ValueReference
		}(),
		ValueSampledData: func() SampledData {
			if valueSampledData != nil { return *valueSampledData }
			return m.ValueSampledData
		}(),
		ValueSignature: func() Signature {
			if valueSignature != nil { return *valueSignature }
			return m.ValueSignature
		}(),
		ValueTiming: func() Timing {
			if valueTiming != nil { return *valueTiming }
			return m.ValueTiming
		}(),
		ValueContactDetail: func() ContactDetail {
			if valueContactDetail != nil { return *valueContactDetail }
			return m.ValueContactDetail
		}(),
		ValueContributor: func() Contributor {
			if valueContributor != nil { return *valueContributor }
			return m.ValueContributor
		}(),
		ValueDataRequirement: func() DataRequirement {
			if valueDataRequirement != nil { return *valueDataRequirement }
			return m.ValueDataRequirement
		}(),
		ValueExpression: func() FhirExpression {
			if valueExpression != nil { return *valueExpression }
			return m.ValueExpression
		}(),
		ValueParameterDefinition: func() ParameterDefinition {
			if valueParameterDefinition != nil { return *valueParameterDefinition }
			return m.ValueParameterDefinition
		}(),
		ValueRelatedArtifact: func() RelatedArtifact {
			if valueRelatedArtifact != nil { return *valueRelatedArtifact }
			return m.ValueRelatedArtifact
		}(),
		ValueTriggerDefinition: func() TriggerDefinition {
			if valueTriggerDefinition != nil { return *valueTriggerDefinition }
			return m.ValueTriggerDefinition
		}(),
		ValueUsageContext: func() UsageContext {
			if valueUsageContext != nil { return *valueUsageContext }
			return m.ValueUsageContext
		}(),
		ValueDosage: func() Dosage {
			if valueDosage != nil { return *valueDosage }
			return m.ValueDosage
		}(),
		ValueMeta: func() FhirMeta {
			if valueMeta != nil { return *valueMeta }
			return m.ValueMeta
		}(),
	}
}
// TaskOutput
// Outputs produced by the Task.
type TaskOutput struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// type
	// The name of the Output parameter.
	Type_ CodeableConcept `json:"type,omitempty"`
	// valueBase64Binary
	// The value of the Output parameter as a basic type.
	ValueBase64Binary FhirBase64Binary `json:"valueBase64Binary,omitempty"`
	// valueBoolean
	// The value of the Output parameter as a basic type.
	ValueBoolean FhirBoolean `json:"valueBoolean,omitempty"`
	// valueCanonical
	// The value of the Output parameter as a basic type.
	ValueCanonical FhirCanonical `json:"valueCanonical,omitempty"`
	// valueCode
	// The value of the Output parameter as a basic type.
	ValueCode FhirCode `json:"valueCode,omitempty"`
	// valueDate
	// The value of the Output parameter as a basic type.
	ValueDate FhirDate `json:"valueDate,omitempty"`
	// valueDateTime
	// The value of the Output parameter as a basic type.
	ValueDateTime FhirDateTime `json:"valueDateTime,omitempty"`
	// valueDecimal
	// The value of the Output parameter as a basic type.
	ValueDecimal FhirDecimal `json:"valueDecimal,omitempty"`
	// valueId
	// The value of the Output parameter as a basic type.
	ValueId FhirId `json:"valueId,omitempty"`
	// valueInstant
	// The value of the Output parameter as a basic type.
	ValueInstant FhirInstant `json:"valueInstant,omitempty"`
	// valueInteger
	// The value of the Output parameter as a basic type.
	ValueInteger FhirInteger `json:"valueInteger,omitempty"`
	// valueMarkdown
	// The value of the Output parameter as a basic type.
	ValueMarkdown FhirMarkdown `json:"valueMarkdown,omitempty"`
	// valueOid
	// The value of the Output parameter as a basic type.
	ValueOid FhirOid `json:"valueOid,omitempty"`
	// valuePositiveInt
	// The value of the Output parameter as a basic type.
	ValuePositiveInt FhirPositiveInt `json:"valuePositiveInt,omitempty"`
	// valueString
	// The value of the Output parameter as a basic type.
	ValueString FhirString `json:"valueString,omitempty"`
	// valueTime
	// The value of the Output parameter as a basic type.
	ValueTime FhirTime `json:"valueTime,omitempty"`
	// valueUnsignedInt
	// The value of the Output parameter as a basic type.
	ValueUnsignedInt FhirUnsignedInt `json:"valueUnsignedInt,omitempty"`
	// valueUri
	// The value of the Output parameter as a basic type.
	ValueUri FhirUri `json:"valueUri,omitempty"`
	// valueUrl
	// The value of the Output parameter as a basic type.
	ValueUrl FhirUrl `json:"valueUrl,omitempty"`
	// valueUuid
	// The value of the Output parameter as a basic type.
	ValueUuid FhirUuid `json:"valueUuid,omitempty"`
	// valueAddress
	// The value of the Output parameter as a basic type.
	ValueAddress Address `json:"valueAddress,omitempty"`
	// valueAge
	// The value of the Output parameter as a basic type.
	ValueAge Age `json:"valueAge,omitempty"`
	// valueAnnotation
	// The value of the Output parameter as a basic type.
	ValueAnnotation Annotation `json:"valueAnnotation,omitempty"`
	// valueAttachment
	// The value of the Output parameter as a basic type.
	ValueAttachment Attachment `json:"valueAttachment,omitempty"`
	// valueCodeableConcept
	// The value of the Output parameter as a basic type.
	ValueCodeableConcept CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// valueCoding
	// The value of the Output parameter as a basic type.
	ValueCoding Coding `json:"valueCoding,omitempty"`
	// valueContactPoint
	// The value of the Output parameter as a basic type.
	ValueContactPoint ContactPoint `json:"valueContactPoint,omitempty"`
	// valueCount
	// The value of the Output parameter as a basic type.
	ValueCount Count `json:"valueCount,omitempty"`
	// valueDistance
	// The value of the Output parameter as a basic type.
	ValueDistance Distance `json:"valueDistance,omitempty"`
	// valueDuration
	// The value of the Output parameter as a basic type.
	ValueDuration FhirDuration `json:"valueDuration,omitempty"`
	// valueHumanName
	// The value of the Output parameter as a basic type.
	ValueHumanName HumanName `json:"valueHumanName,omitempty"`
	// valueIdentifier
	// The value of the Output parameter as a basic type.
	ValueIdentifier Identifier `json:"valueIdentifier,omitempty"`
	// valueMoney
	// The value of the Output parameter as a basic type.
	ValueMoney Money `json:"valueMoney,omitempty"`
	// valuePeriod
	// The value of the Output parameter as a basic type.
	ValuePeriod Period `json:"valuePeriod,omitempty"`
	// valueQuantity
	// The value of the Output parameter as a basic type.
	ValueQuantity Quantity `json:"valueQuantity,omitempty"`
	// valueRange
	// The value of the Output parameter as a basic type.
	ValueRange Range `json:"valueRange,omitempty"`
	// valueRatio
	// The value of the Output parameter as a basic type.
	ValueRatio Ratio `json:"valueRatio,omitempty"`
	// valueReference
	// The value of the Output parameter as a basic type.
	ValueReference Reference `json:"valueReference,omitempty"`
	// valueSampledData
	// The value of the Output parameter as a basic type.
	ValueSampledData SampledData `json:"valueSampledData,omitempty"`
	// valueSignature
	// The value of the Output parameter as a basic type.
	ValueSignature Signature `json:"valueSignature,omitempty"`
	// valueTiming
	// The value of the Output parameter as a basic type.
	ValueTiming Timing `json:"valueTiming,omitempty"`
	// valueContactDetail
	// The value of the Output parameter as a basic type.
	ValueContactDetail ContactDetail `json:"valueContactDetail,omitempty"`
	// valueContributor
	// The value of the Output parameter as a basic type.
	ValueContributor Contributor `json:"valueContributor,omitempty"`
	// valueDataRequirement
	// The value of the Output parameter as a basic type.
	ValueDataRequirement DataRequirement `json:"valueDataRequirement,omitempty"`
	// valueExpression
	// The value of the Output parameter as a basic type.
	ValueExpression FhirExpression `json:"valueExpression,omitempty"`
	// valueParameterDefinition
	// The value of the Output parameter as a basic type.
	ValueParameterDefinition ParameterDefinition `json:"valueParameterDefinition,omitempty"`
	// valueRelatedArtifact
	// The value of the Output parameter as a basic type.
	ValueRelatedArtifact RelatedArtifact `json:"valueRelatedArtifact,omitempty"`
	// valueTriggerDefinition
	// The value of the Output parameter as a basic type.
	ValueTriggerDefinition TriggerDefinition `json:"valueTriggerDefinition,omitempty"`
	// valueUsageContext
	// The value of the Output parameter as a basic type.
	ValueUsageContext UsageContext `json:"valueUsageContext,omitempty"`
	// valueDosage
	// The value of the Output parameter as a basic type.
	ValueDosage Dosage `json:"valueDosage,omitempty"`
	// valueMeta
	// The value of the Output parameter as a basic type.
	ValueMeta FhirMeta `json:"valueMeta,omitempty"`
}

// NewTaskOutput creates a new TaskOutput instance
func NewTaskOutput(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	type_ CodeableConcept,
	valueBase64Binary FhirBase64Binary,
	valueBoolean FhirBoolean,
	valueCanonical FhirCanonical,
	valueCode FhirCode,
	valueDate FhirDate,
	valueDateTime FhirDateTime,
	valueDecimal FhirDecimal,
	valueId FhirId,
	valueInstant FhirInstant,
	valueInteger FhirInteger,
	valueMarkdown FhirMarkdown,
	valueOid FhirOid,
	valuePositiveInt FhirPositiveInt,
	valueString FhirString,
	valueTime FhirTime,
	valueUnsignedInt FhirUnsignedInt,
	valueUri FhirUri,
	valueUrl FhirUrl,
	valueUuid FhirUuid,
	valueAddress Address,
	valueAge Age,
	valueAnnotation Annotation,
	valueAttachment Attachment,
	valueCodeableConcept CodeableConcept,
	valueCoding Coding,
	valueContactPoint ContactPoint,
	valueCount Count,
	valueDistance Distance,
	valueDuration FhirDuration,
	valueHumanName HumanName,
	valueIdentifier Identifier,
	valueMoney Money,
	valuePeriod Period,
	valueQuantity Quantity,
	valueRange Range,
	valueRatio Ratio,
	valueReference Reference,
	valueSampledData SampledData,
	valueSignature Signature,
	valueTiming Timing,
	valueContactDetail ContactDetail,
	valueContributor Contributor,
	valueDataRequirement DataRequirement,
	valueExpression FhirExpression,
	valueParameterDefinition ParameterDefinition,
	valueRelatedArtifact RelatedArtifact,
	valueTriggerDefinition TriggerDefinition,
	valueUsageContext UsageContext,
	valueDosage Dosage,
	valueMeta FhirMeta,
) *TaskOutput {
	return &TaskOutput{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		Type_: type_,
		ValueBase64Binary: valueBase64Binary,
		ValueBoolean: valueBoolean,
		ValueCanonical: valueCanonical,
		ValueCode: valueCode,
		ValueDate: valueDate,
		ValueDateTime: valueDateTime,
		ValueDecimal: valueDecimal,
		ValueId: valueId,
		ValueInstant: valueInstant,
		ValueInteger: valueInteger,
		ValueMarkdown: valueMarkdown,
		ValueOid: valueOid,
		ValuePositiveInt: valuePositiveInt,
		ValueString: valueString,
		ValueTime: valueTime,
		ValueUnsignedInt: valueUnsignedInt,
		ValueUri: valueUri,
		ValueUrl: valueUrl,
		ValueUuid: valueUuid,
		ValueAddress: valueAddress,
		ValueAge: valueAge,
		ValueAnnotation: valueAnnotation,
		ValueAttachment: valueAttachment,
		ValueCodeableConcept: valueCodeableConcept,
		ValueCoding: valueCoding,
		ValueContactPoint: valueContactPoint,
		ValueCount: valueCount,
		ValueDistance: valueDistance,
		ValueDuration: valueDuration,
		ValueHumanName: valueHumanName,
		ValueIdentifier: valueIdentifier,
		ValueMoney: valueMoney,
		ValuePeriod: valuePeriod,
		ValueQuantity: valueQuantity,
		ValueRange: valueRange,
		ValueRatio: valueRatio,
		ValueReference: valueReference,
		ValueSampledData: valueSampledData,
		ValueSignature: valueSignature,
		ValueTiming: valueTiming,
		ValueContactDetail: valueContactDetail,
		ValueContributor: valueContributor,
		ValueDataRequirement: valueDataRequirement,
		ValueExpression: valueExpression,
		ValueParameterDefinition: valueParameterDefinition,
		ValueRelatedArtifact: valueRelatedArtifact,
		ValueTriggerDefinition: valueTriggerDefinition,
		ValueUsageContext: valueUsageContext,
		ValueDosage: valueDosage,
		ValueMeta: valueMeta,
	}
}
// FromJSON populates TaskOutput from JSON data
func (m *TaskOutput) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TaskOutput to JSON data
func (m *TaskOutput) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of TaskOutput
func (m *TaskOutput) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	type_ *CodeableConcept,
	valueBase64Binary *FhirBase64Binary,
	valueBoolean *FhirBoolean,
	valueCanonical *FhirCanonical,
	valueCode *FhirCode,
	valueDate *FhirDate,
	valueDateTime *FhirDateTime,
	valueDecimal *FhirDecimal,
	valueId *FhirId,
	valueInstant *FhirInstant,
	valueInteger *FhirInteger,
	valueMarkdown *FhirMarkdown,
	valueOid *FhirOid,
	valuePositiveInt *FhirPositiveInt,
	valueString *FhirString,
	valueTime *FhirTime,
	valueUnsignedInt *FhirUnsignedInt,
	valueUri *FhirUri,
	valueUrl *FhirUrl,
	valueUuid *FhirUuid,
	valueAddress *Address,
	valueAge *Age,
	valueAnnotation *Annotation,
	valueAttachment *Attachment,
	valueCodeableConcept *CodeableConcept,
	valueCoding *Coding,
	valueContactPoint *ContactPoint,
	valueCount *Count,
	valueDistance *Distance,
	valueDuration *FhirDuration,
	valueHumanName *HumanName,
	valueIdentifier *Identifier,
	valueMoney *Money,
	valuePeriod *Period,
	valueQuantity *Quantity,
	valueRange *Range,
	valueRatio *Ratio,
	valueReference *Reference,
	valueSampledData *SampledData,
	valueSignature *Signature,
	valueTiming *Timing,
	valueContactDetail *ContactDetail,
	valueContributor *Contributor,
	valueDataRequirement *DataRequirement,
	valueExpression *FhirExpression,
	valueParameterDefinition *ParameterDefinition,
	valueRelatedArtifact *RelatedArtifact,
	valueTriggerDefinition *TriggerDefinition,
	valueUsageContext *UsageContext,
	valueDosage *Dosage,
	valueMeta *FhirMeta,
) *TaskOutput {
	return &TaskOutput{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		Type_: func() CodeableConcept {
			if type_ != nil { return *type_ }
			return m.Type_
		}(),
		ValueBase64Binary: func() FhirBase64Binary {
			if valueBase64Binary != nil { return *valueBase64Binary }
			return m.ValueBase64Binary
		}(),
		ValueBoolean: func() FhirBoolean {
			if valueBoolean != nil { return *valueBoolean }
			return m.ValueBoolean
		}(),
		ValueCanonical: func() FhirCanonical {
			if valueCanonical != nil { return *valueCanonical }
			return m.ValueCanonical
		}(),
		ValueCode: func() FhirCode {
			if valueCode != nil { return *valueCode }
			return m.ValueCode
		}(),
		ValueDate: func() FhirDate {
			if valueDate != nil { return *valueDate }
			return m.ValueDate
		}(),
		ValueDateTime: func() FhirDateTime {
			if valueDateTime != nil { return *valueDateTime }
			return m.ValueDateTime
		}(),
		ValueDecimal: func() FhirDecimal {
			if valueDecimal != nil { return *valueDecimal }
			return m.ValueDecimal
		}(),
		ValueId: func() FhirId {
			if valueId != nil { return *valueId }
			return m.ValueId
		}(),
		ValueInstant: func() FhirInstant {
			if valueInstant != nil { return *valueInstant }
			return m.ValueInstant
		}(),
		ValueInteger: func() FhirInteger {
			if valueInteger != nil { return *valueInteger }
			return m.ValueInteger
		}(),
		ValueMarkdown: func() FhirMarkdown {
			if valueMarkdown != nil { return *valueMarkdown }
			return m.ValueMarkdown
		}(),
		ValueOid: func() FhirOid {
			if valueOid != nil { return *valueOid }
			return m.ValueOid
		}(),
		ValuePositiveInt: func() FhirPositiveInt {
			if valuePositiveInt != nil { return *valuePositiveInt }
			return m.ValuePositiveInt
		}(),
		ValueString: func() FhirString {
			if valueString != nil { return *valueString }
			return m.ValueString
		}(),
		ValueTime: func() FhirTime {
			if valueTime != nil { return *valueTime }
			return m.ValueTime
		}(),
		ValueUnsignedInt: func() FhirUnsignedInt {
			if valueUnsignedInt != nil { return *valueUnsignedInt }
			return m.ValueUnsignedInt
		}(),
		ValueUri: func() FhirUri {
			if valueUri != nil { return *valueUri }
			return m.ValueUri
		}(),
		ValueUrl: func() FhirUrl {
			if valueUrl != nil { return *valueUrl }
			return m.ValueUrl
		}(),
		ValueUuid: func() FhirUuid {
			if valueUuid != nil { return *valueUuid }
			return m.ValueUuid
		}(),
		ValueAddress: func() Address {
			if valueAddress != nil { return *valueAddress }
			return m.ValueAddress
		}(),
		ValueAge: func() Age {
			if valueAge != nil { return *valueAge }
			return m.ValueAge
		}(),
		ValueAnnotation: func() Annotation {
			if valueAnnotation != nil { return *valueAnnotation }
			return m.ValueAnnotation
		}(),
		ValueAttachment: func() Attachment {
			if valueAttachment != nil { return *valueAttachment }
			return m.ValueAttachment
		}(),
		ValueCodeableConcept: func() CodeableConcept {
			if valueCodeableConcept != nil { return *valueCodeableConcept }
			return m.ValueCodeableConcept
		}(),
		ValueCoding: func() Coding {
			if valueCoding != nil { return *valueCoding }
			return m.ValueCoding
		}(),
		ValueContactPoint: func() ContactPoint {
			if valueContactPoint != nil { return *valueContactPoint }
			return m.ValueContactPoint
		}(),
		ValueCount: func() Count {
			if valueCount != nil { return *valueCount }
			return m.ValueCount
		}(),
		ValueDistance: func() Distance {
			if valueDistance != nil { return *valueDistance }
			return m.ValueDistance
		}(),
		ValueDuration: func() FhirDuration {
			if valueDuration != nil { return *valueDuration }
			return m.ValueDuration
		}(),
		ValueHumanName: func() HumanName {
			if valueHumanName != nil { return *valueHumanName }
			return m.ValueHumanName
		}(),
		ValueIdentifier: func() Identifier {
			if valueIdentifier != nil { return *valueIdentifier }
			return m.ValueIdentifier
		}(),
		ValueMoney: func() Money {
			if valueMoney != nil { return *valueMoney }
			return m.ValueMoney
		}(),
		ValuePeriod: func() Period {
			if valuePeriod != nil { return *valuePeriod }
			return m.ValuePeriod
		}(),
		ValueQuantity: func() Quantity {
			if valueQuantity != nil { return *valueQuantity }
			return m.ValueQuantity
		}(),
		ValueRange: func() Range {
			if valueRange != nil { return *valueRange }
			return m.ValueRange
		}(),
		ValueRatio: func() Ratio {
			if valueRatio != nil { return *valueRatio }
			return m.ValueRatio
		}(),
		ValueReference: func() Reference {
			if valueReference != nil { return *valueReference }
			return m.ValueReference
		}(),
		ValueSampledData: func() SampledData {
			if valueSampledData != nil { return *valueSampledData }
			return m.ValueSampledData
		}(),
		ValueSignature: func() Signature {
			if valueSignature != nil { return *valueSignature }
			return m.ValueSignature
		}(),
		ValueTiming: func() Timing {
			if valueTiming != nil { return *valueTiming }
			return m.ValueTiming
		}(),
		ValueContactDetail: func() ContactDetail {
			if valueContactDetail != nil { return *valueContactDetail }
			return m.ValueContactDetail
		}(),
		ValueContributor: func() Contributor {
			if valueContributor != nil { return *valueContributor }
			return m.ValueContributor
		}(),
		ValueDataRequirement: func() DataRequirement {
			if valueDataRequirement != nil { return *valueDataRequirement }
			return m.ValueDataRequirement
		}(),
		ValueExpression: func() FhirExpression {
			if valueExpression != nil { return *valueExpression }
			return m.ValueExpression
		}(),
		ValueParameterDefinition: func() ParameterDefinition {
			if valueParameterDefinition != nil { return *valueParameterDefinition }
			return m.ValueParameterDefinition
		}(),
		ValueRelatedArtifact: func() RelatedArtifact {
			if valueRelatedArtifact != nil { return *valueRelatedArtifact }
			return m.ValueRelatedArtifact
		}(),
		ValueTriggerDefinition: func() TriggerDefinition {
			if valueTriggerDefinition != nil { return *valueTriggerDefinition }
			return m.ValueTriggerDefinition
		}(),
		ValueUsageContext: func() UsageContext {
			if valueUsageContext != nil { return *valueUsageContext }
			return m.ValueUsageContext
		}(),
		ValueDosage: func() Dosage {
			if valueDosage != nil { return *valueDosage }
			return m.ValueDosage
		}(),
		ValueMeta: func() FhirMeta {
			if valueMeta != nil { return *valueMeta }
			return m.ValueMeta
		}(),
	}
}
