// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ClinicalUseDefinition
// A single issue - either an indication, contraindication, interaction or an undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Type *ClinicalUseDefinitionType `json:"type,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Subject []*Reference `json:"subject,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	Contraindication *ClinicalUseDefinitionContraindication `json:"contraindication,omitempty"`
	Indication *ClinicalUseDefinitionIndication `json:"indication,omitempty"`
	Interaction *ClinicalUseDefinitionInteraction `json:"interaction,omitempty"`
	Population []*Reference `json:"population,omitempty"`
	UndesirableEffect *ClinicalUseDefinitionUndesirableEffect `json:"undesirableeffect,omitempty"`
	Warning *ClinicalUseDefinitionWarning `json:"warning,omitempty"`
}

// NewClinicalUseDefinition creates a new ClinicalUseDefinition instance
func NewClinicalUseDefinition() *ClinicalUseDefinition {
	return &ClinicalUseDefinition{}
}

// FromJSON populates ClinicalUseDefinition from JSON data
func (m *ClinicalUseDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinition to JSON data
func (m *ClinicalUseDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinition
func (m *ClinicalUseDefinition) Clone() *ClinicalUseDefinition {
	if m == nil { return nil }
	return &ClinicalUseDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Type: m.Type.Clone(),
		Category: cloneSlices(m.Category),
		Subject: cloneSlices(m.Subject),
		Status: m.Status.Clone(),
		Contraindication: m.Contraindication.Clone(),
		Indication: m.Indication.Clone(),
		Interaction: m.Interaction.Clone(),
		Population: cloneSlices(m.Population),
		UndesirableEffect: m.UndesirableEffect.Clone(),
		Warning: m.Warning.Clone(),
	}
}

// Equals checks for equality with another ClinicalUseDefinition instance
func (m *ClinicalUseDefinition) Equals(other *ClinicalUseDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !compareSlices(m.Subject, other.Subject) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Contraindication.Equals(other.Contraindication) { return false }
	if !m.Indication.Equals(other.Indication) { return false }
	if !m.Interaction.Equals(other.Interaction) { return false }
	if !compareSlices(m.Population, other.Population) { return false }
	if !m.UndesirableEffect.Equals(other.UndesirableEffect) { return false }
	if !m.Warning.Equals(other.Warning) { return false }
	return true
}

// ClinicalUseDefinitionContraindication
// Specifics for when this is a contraindication.
type ClinicalUseDefinitionContraindication struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DiseaseSymptomProcedure *CodeableReference `json:"diseasesymptomprocedure,omitempty"`
	DiseaseStatus *CodeableReference `json:"diseasestatus,omitempty"`
	Comorbidity []*CodeableReference `json:"comorbidity,omitempty"`
	Indication []*Reference `json:"indication,omitempty"`
	OtherTherapy []*ClinicalUseDefinitionOtherTherapy `json:"othertherapy,omitempty"`
}

// NewClinicalUseDefinitionContraindication creates a new ClinicalUseDefinitionContraindication instance
func NewClinicalUseDefinitionContraindication() *ClinicalUseDefinitionContraindication {
	return &ClinicalUseDefinitionContraindication{}
}

// FromJSON populates ClinicalUseDefinitionContraindication from JSON data
func (m *ClinicalUseDefinitionContraindication) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionContraindication to JSON data
func (m *ClinicalUseDefinitionContraindication) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinitionContraindication
func (m *ClinicalUseDefinitionContraindication) Clone() *ClinicalUseDefinitionContraindication {
	if m == nil { return nil }
	return &ClinicalUseDefinitionContraindication{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DiseaseSymptomProcedure: m.DiseaseSymptomProcedure.Clone(),
		DiseaseStatus: m.DiseaseStatus.Clone(),
		Comorbidity: cloneSlices(m.Comorbidity),
		Indication: cloneSlices(m.Indication),
		OtherTherapy: cloneSlices(m.OtherTherapy),
	}
}

// Equals checks for equality with another ClinicalUseDefinitionContraindication instance
func (m *ClinicalUseDefinitionContraindication) Equals(other *ClinicalUseDefinitionContraindication) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.DiseaseSymptomProcedure.Equals(other.DiseaseSymptomProcedure) { return false }
	if !m.DiseaseStatus.Equals(other.DiseaseStatus) { return false }
	if !compareSlices(m.Comorbidity, other.Comorbidity) { return false }
	if !compareSlices(m.Indication, other.Indication) { return false }
	if !compareSlices(m.OtherTherapy, other.OtherTherapy) { return false }
	return true
}

// ClinicalUseDefinitionOtherTherapy
// Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
type ClinicalUseDefinitionOtherTherapy struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	RelationshipType *CodeableConcept `json:"relationshiptype,omitempty"`
	Therapy *CodeableReference `json:"therapy,omitempty"`
}

// NewClinicalUseDefinitionOtherTherapy creates a new ClinicalUseDefinitionOtherTherapy instance
func NewClinicalUseDefinitionOtherTherapy() *ClinicalUseDefinitionOtherTherapy {
	return &ClinicalUseDefinitionOtherTherapy{}
}

// FromJSON populates ClinicalUseDefinitionOtherTherapy from JSON data
func (m *ClinicalUseDefinitionOtherTherapy) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionOtherTherapy to JSON data
func (m *ClinicalUseDefinitionOtherTherapy) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinitionOtherTherapy
func (m *ClinicalUseDefinitionOtherTherapy) Clone() *ClinicalUseDefinitionOtherTherapy {
	if m == nil { return nil }
	return &ClinicalUseDefinitionOtherTherapy{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		RelationshipType: m.RelationshipType.Clone(),
		Therapy: m.Therapy.Clone(),
	}
}

// Equals checks for equality with another ClinicalUseDefinitionOtherTherapy instance
func (m *ClinicalUseDefinitionOtherTherapy) Equals(other *ClinicalUseDefinitionOtherTherapy) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.RelationshipType.Equals(other.RelationshipType) { return false }
	if !m.Therapy.Equals(other.Therapy) { return false }
	return true
}

// ClinicalUseDefinitionIndication
// Specifics for when this is an indication.
type ClinicalUseDefinitionIndication struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DiseaseSymptomProcedure *CodeableReference `json:"diseasesymptomprocedure,omitempty"`
	DiseaseStatus *CodeableReference `json:"diseasestatus,omitempty"`
	Comorbidity []*CodeableReference `json:"comorbidity,omitempty"`
	IntendedEffect *CodeableReference `json:"intendedeffect,omitempty"`
	DurationRange *Range `json:"durationrange,omitempty"`
	DurationString *FhirString `json:"durationstring,omitempty"`
	UndesirableEffect []*Reference `json:"undesirableeffect,omitempty"`
	OtherTherapy []*ClinicalUseDefinitionOtherTherapy `json:"othertherapy,omitempty"`
}

// NewClinicalUseDefinitionIndication creates a new ClinicalUseDefinitionIndication instance
func NewClinicalUseDefinitionIndication() *ClinicalUseDefinitionIndication {
	return &ClinicalUseDefinitionIndication{}
}

// FromJSON populates ClinicalUseDefinitionIndication from JSON data
func (m *ClinicalUseDefinitionIndication) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionIndication to JSON data
func (m *ClinicalUseDefinitionIndication) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinitionIndication
func (m *ClinicalUseDefinitionIndication) Clone() *ClinicalUseDefinitionIndication {
	if m == nil { return nil }
	return &ClinicalUseDefinitionIndication{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DiseaseSymptomProcedure: m.DiseaseSymptomProcedure.Clone(),
		DiseaseStatus: m.DiseaseStatus.Clone(),
		Comorbidity: cloneSlices(m.Comorbidity),
		IntendedEffect: m.IntendedEffect.Clone(),
		DurationRange: m.DurationRange.Clone(),
		DurationString: m.DurationString.Clone(),
		UndesirableEffect: cloneSlices(m.UndesirableEffect),
		OtherTherapy: cloneSlices(m.OtherTherapy),
	}
}

// Equals checks for equality with another ClinicalUseDefinitionIndication instance
func (m *ClinicalUseDefinitionIndication) Equals(other *ClinicalUseDefinitionIndication) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.DiseaseSymptomProcedure.Equals(other.DiseaseSymptomProcedure) { return false }
	if !m.DiseaseStatus.Equals(other.DiseaseStatus) { return false }
	if !compareSlices(m.Comorbidity, other.Comorbidity) { return false }
	if !m.IntendedEffect.Equals(other.IntendedEffect) { return false }
	if !m.DurationRange.Equals(other.DurationRange) { return false }
	if !m.DurationString.Equals(other.DurationString) { return false }
	if !compareSlices(m.UndesirableEffect, other.UndesirableEffect) { return false }
	if !compareSlices(m.OtherTherapy, other.OtherTherapy) { return false }
	return true
}

// ClinicalUseDefinitionInteraction
// Specifics for when this is an interaction.
type ClinicalUseDefinitionInteraction struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Interactant []*ClinicalUseDefinitionInteractant `json:"interactant,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Effect *CodeableReference `json:"effect,omitempty"`
	Incidence *CodeableConcept `json:"incidence,omitempty"`
	Management []*CodeableConcept `json:"management,omitempty"`
}

// NewClinicalUseDefinitionInteraction creates a new ClinicalUseDefinitionInteraction instance
func NewClinicalUseDefinitionInteraction() *ClinicalUseDefinitionInteraction {
	return &ClinicalUseDefinitionInteraction{}
}

// FromJSON populates ClinicalUseDefinitionInteraction from JSON data
func (m *ClinicalUseDefinitionInteraction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionInteraction to JSON data
func (m *ClinicalUseDefinitionInteraction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinitionInteraction
func (m *ClinicalUseDefinitionInteraction) Clone() *ClinicalUseDefinitionInteraction {
	if m == nil { return nil }
	return &ClinicalUseDefinitionInteraction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Interactant: cloneSlices(m.Interactant),
		Type: m.Type.Clone(),
		Effect: m.Effect.Clone(),
		Incidence: m.Incidence.Clone(),
		Management: cloneSlices(m.Management),
	}
}

// Equals checks for equality with another ClinicalUseDefinitionInteraction instance
func (m *ClinicalUseDefinitionInteraction) Equals(other *ClinicalUseDefinitionInteraction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Interactant, other.Interactant) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Effect.Equals(other.Effect) { return false }
	if !m.Incidence.Equals(other.Incidence) { return false }
	if !compareSlices(m.Management, other.Management) { return false }
	return true
}

// ClinicalUseDefinitionInteractant
// The specific medication, food, substance or laboratory test that interacts.
type ClinicalUseDefinitionInteractant struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemReference *Reference `json:"itemreference,omitempty"`
	ItemCodeableConcept *CodeableConcept `json:"itemcodeableconcept,omitempty"`
}

// NewClinicalUseDefinitionInteractant creates a new ClinicalUseDefinitionInteractant instance
func NewClinicalUseDefinitionInteractant() *ClinicalUseDefinitionInteractant {
	return &ClinicalUseDefinitionInteractant{}
}

// FromJSON populates ClinicalUseDefinitionInteractant from JSON data
func (m *ClinicalUseDefinitionInteractant) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionInteractant to JSON data
func (m *ClinicalUseDefinitionInteractant) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinitionInteractant
func (m *ClinicalUseDefinitionInteractant) Clone() *ClinicalUseDefinitionInteractant {
	if m == nil { return nil }
	return &ClinicalUseDefinitionInteractant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemReference: m.ItemReference.Clone(),
		ItemCodeableConcept: m.ItemCodeableConcept.Clone(),
	}
}

// Equals checks for equality with another ClinicalUseDefinitionInteractant instance
func (m *ClinicalUseDefinitionInteractant) Equals(other *ClinicalUseDefinitionInteractant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ItemReference.Equals(other.ItemReference) { return false }
	if !m.ItemCodeableConcept.Equals(other.ItemCodeableConcept) { return false }
	return true
}

// ClinicalUseDefinitionUndesirableEffect
// Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.
type ClinicalUseDefinitionUndesirableEffect struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	SymptomConditionEffect *CodeableReference `json:"symptomconditioneffect,omitempty"`
	Classification *CodeableConcept `json:"classification,omitempty"`
	FrequencyOfOccurrence *CodeableConcept `json:"frequencyofoccurrence,omitempty"`
}

// NewClinicalUseDefinitionUndesirableEffect creates a new ClinicalUseDefinitionUndesirableEffect instance
func NewClinicalUseDefinitionUndesirableEffect() *ClinicalUseDefinitionUndesirableEffect {
	return &ClinicalUseDefinitionUndesirableEffect{}
}

// FromJSON populates ClinicalUseDefinitionUndesirableEffect from JSON data
func (m *ClinicalUseDefinitionUndesirableEffect) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionUndesirableEffect to JSON data
func (m *ClinicalUseDefinitionUndesirableEffect) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinitionUndesirableEffect
func (m *ClinicalUseDefinitionUndesirableEffect) Clone() *ClinicalUseDefinitionUndesirableEffect {
	if m == nil { return nil }
	return &ClinicalUseDefinitionUndesirableEffect{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		SymptomConditionEffect: m.SymptomConditionEffect.Clone(),
		Classification: m.Classification.Clone(),
		FrequencyOfOccurrence: m.FrequencyOfOccurrence.Clone(),
	}
}

// Equals checks for equality with another ClinicalUseDefinitionUndesirableEffect instance
func (m *ClinicalUseDefinitionUndesirableEffect) Equals(other *ClinicalUseDefinitionUndesirableEffect) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.SymptomConditionEffect.Equals(other.SymptomConditionEffect) { return false }
	if !m.Classification.Equals(other.Classification) { return false }
	if !m.FrequencyOfOccurrence.Equals(other.FrequencyOfOccurrence) { return false }
	return true
}

// ClinicalUseDefinitionWarning
// A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
type ClinicalUseDefinitionWarning struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
}

// NewClinicalUseDefinitionWarning creates a new ClinicalUseDefinitionWarning instance
func NewClinicalUseDefinitionWarning() *ClinicalUseDefinitionWarning {
	return &ClinicalUseDefinitionWarning{}
}

// FromJSON populates ClinicalUseDefinitionWarning from JSON data
func (m *ClinicalUseDefinitionWarning) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionWarning to JSON data
func (m *ClinicalUseDefinitionWarning) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalUseDefinitionWarning
func (m *ClinicalUseDefinitionWarning) Clone() *ClinicalUseDefinitionWarning {
	if m == nil { return nil }
	return &ClinicalUseDefinitionWarning{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Code: m.Code.Clone(),
	}
}

// Equals checks for equality with another ClinicalUseDefinitionWarning instance
func (m *ClinicalUseDefinitionWarning) Equals(other *ClinicalUseDefinitionWarning) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Code.Equals(other.Code) { return false }
	return true
}

