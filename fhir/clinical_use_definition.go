// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json"

)

// ClinicalUseDefinition
// A single issue - either an indication, contraindication, interaction or an undesirable effect for a medicinal product, medication, device or procedure.
type ClinicalUseDefinition struct {
	DomainResource
	// id
	// The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.
	Id FhirString `json:"id,omitempty"`
	// meta
	// The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
	Meta FhirMeta `json:"meta,omitempty"`
	// implicitRules
	// A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
	ImplicitRules FhirUri `json:"implicitRules,omitempty"`
	// language
	// The base language in which the resource is written.
	Language CommonLanguages `json:"language,omitempty"`
	// text
	// A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
	Text Narrative `json:"text,omitempty"`
	// contained
	// These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
	Contained []Resource `json:"contained,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// identifier
	// Business identifier for this issue.
	Identifier []Identifier `json:"identifier,omitempty"`
	// type
	// indication | contraindication | interaction | undesirable-effect | warning.
	Type_ ClinicalUseDefinitionType `json:"type,omitempty"`
	// category
	// A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".
	Category []CodeableConcept `json:"category,omitempty"`
	// subject
	// The medication or procedure for which this is an indication.
	Subject []Reference `json:"subject,omitempty"`
	// status
	// Whether this is a current issue or one that has been retired etc.
	Status CodeableConcept `json:"status,omitempty"`
	// contraindication
	// Specifics for when this is a contraindication.
	Contraindication ClinicalUseDefinitionContraindication `json:"contraindication,omitempty"`
	// indication
	// Specifics for when this is an indication.
	Indication ClinicalUseDefinitionIndication `json:"indication,omitempty"`
	// interaction
	// Specifics for when this is an interaction.
	Interaction ClinicalUseDefinitionInteraction `json:"interaction,omitempty"`
	// population
	// The population group to which this applies.
	Population []Reference `json:"population,omitempty"`
	// undesirableEffect
	// Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.
	UndesirableEffect ClinicalUseDefinitionUndesirableEffect `json:"undesirableEffect,omitempty"`
	// warning
	// A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
	Warning ClinicalUseDefinitionWarning `json:"warning,omitempty"`
}

// NewClinicalUseDefinition creates a new ClinicalUseDefinition instance
func NewClinicalUseDefinition(
	id FhirString,
	meta FhirMeta,
	implicitRules FhirUri,
	language CommonLanguages,
	text Narrative,
	contained []Resource,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	identifier []Identifier,
	type_ ClinicalUseDefinitionType,
	category []CodeableConcept,
	subject []Reference,
	status CodeableConcept,
	contraindication ClinicalUseDefinitionContraindication,
	indication ClinicalUseDefinitionIndication,
	interaction ClinicalUseDefinitionInteraction,
	population []Reference,
	undesirableEffect ClinicalUseDefinitionUndesirableEffect,
	warning ClinicalUseDefinitionWarning,
) *ClinicalUseDefinition {
	return &ClinicalUseDefinition{
		Id: id,
		Meta: meta,
		ImplicitRules: implicitRules,
		Language: language,
		Text: text,
		Contained: contained,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		Identifier: identifier,
		Type_: type_,
		Category: category,
		Subject: subject,
		Status: status,
		Contraindication: contraindication,
		Indication: indication,
		Interaction: interaction,
		Population: population,
		UndesirableEffect: undesirableEffect,
		Warning: warning,
	}
}
// FromJSON populates ClinicalUseDefinition from JSON data
func (m *ClinicalUseDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinition to JSON data
func (m *ClinicalUseDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinition
func (m *ClinicalUseDefinition) CopyWith(
	id *FhirString,
	meta *FhirMeta,
	implicitRules *FhirUri,
	language *CommonLanguages,
	text *Narrative,
	contained *[]Resource,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	identifier *[]Identifier,
	type_ *ClinicalUseDefinitionType,
	category *[]CodeableConcept,
	subject *[]Reference,
	status *CodeableConcept,
	contraindication *ClinicalUseDefinitionContraindication,
	indication *ClinicalUseDefinitionIndication,
	interaction *ClinicalUseDefinitionInteraction,
	population *[]Reference,
	undesirableEffect *ClinicalUseDefinitionUndesirableEffect,
	warning *ClinicalUseDefinitionWarning,
) *ClinicalUseDefinition {
	return &ClinicalUseDefinition{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Meta: func() FhirMeta {
			if meta != nil { return *meta }
			return m.Meta
		}(),
		ImplicitRules: func() FhirUri {
			if implicitRules != nil { return *implicitRules }
			return m.ImplicitRules
		}(),
		Language: func() CommonLanguages {
			if language != nil { return *language }
			return m.Language
		}(),
		Text: func() Narrative {
			if text != nil { return *text }
			return m.Text
		}(),
		Contained: func() []Resource {
			if contained != nil { return *contained }
			return m.Contained
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		Identifier: func() []Identifier {
			if identifier != nil { return *identifier }
			return m.Identifier
		}(),
		Type_: func() ClinicalUseDefinitionType {
			if type_ != nil { return *type_ }
			return m.Type_
		}(),
		Category: func() []CodeableConcept {
			if category != nil { return *category }
			return m.Category
		}(),
		Subject: func() []Reference {
			if subject != nil { return *subject }
			return m.Subject
		}(),
		Status: func() CodeableConcept {
			if status != nil { return *status }
			return m.Status
		}(),
		Contraindication: func() ClinicalUseDefinitionContraindication {
			if contraindication != nil { return *contraindication }
			return m.Contraindication
		}(),
		Indication: func() ClinicalUseDefinitionIndication {
			if indication != nil { return *indication }
			return m.Indication
		}(),
		Interaction: func() ClinicalUseDefinitionInteraction {
			if interaction != nil { return *interaction }
			return m.Interaction
		}(),
		Population: func() []Reference {
			if population != nil { return *population }
			return m.Population
		}(),
		UndesirableEffect: func() ClinicalUseDefinitionUndesirableEffect {
			if undesirableEffect != nil { return *undesirableEffect }
			return m.UndesirableEffect
		}(),
		Warning: func() ClinicalUseDefinitionWarning {
			if warning != nil { return *warning }
			return m.Warning
		}(),
	}
}
// ClinicalUseDefinitionContraindication
// Specifics for when this is a contraindication.
type ClinicalUseDefinitionContraindication struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// diseaseSymptomProcedure
	// The situation that is being documented as contraindicating against this item.
	DiseaseSymptomProcedure CodeableReference `json:"diseaseSymptomProcedure,omitempty"`
	// diseaseStatus
	// The status of the disease or symptom for the contraindication, for example "chronic" or "metastatic".
	DiseaseStatus CodeableReference `json:"diseaseStatus,omitempty"`
	// comorbidity
	// A comorbidity (concurrent condition) or coinfection.
	Comorbidity []CodeableReference `json:"comorbidity,omitempty"`
	// indication
	// The indication which this is a contraidication for.
	Indication []Reference `json:"indication,omitempty"`
	// otherTherapy
	// Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
	OtherTherapy []ClinicalUseDefinitionOtherTherapy `json:"otherTherapy,omitempty"`
}

// NewClinicalUseDefinitionContraindication creates a new ClinicalUseDefinitionContraindication instance
func NewClinicalUseDefinitionContraindication(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	diseaseSymptomProcedure CodeableReference,
	diseaseStatus CodeableReference,
	comorbidity []CodeableReference,
	indication []Reference,
	otherTherapy []ClinicalUseDefinitionOtherTherapy,
) *ClinicalUseDefinitionContraindication {
	return &ClinicalUseDefinitionContraindication{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		DiseaseSymptomProcedure: diseaseSymptomProcedure,
		DiseaseStatus: diseaseStatus,
		Comorbidity: comorbidity,
		Indication: indication,
		OtherTherapy: otherTherapy,
	}
}
// FromJSON populates ClinicalUseDefinitionContraindication from JSON data
func (m *ClinicalUseDefinitionContraindication) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionContraindication to JSON data
func (m *ClinicalUseDefinitionContraindication) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinitionContraindication
func (m *ClinicalUseDefinitionContraindication) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	diseaseSymptomProcedure *CodeableReference,
	diseaseStatus *CodeableReference,
	comorbidity *[]CodeableReference,
	indication *[]Reference,
	otherTherapy *[]ClinicalUseDefinitionOtherTherapy,
) *ClinicalUseDefinitionContraindication {
	return &ClinicalUseDefinitionContraindication{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		DiseaseSymptomProcedure: func() CodeableReference {
			if diseaseSymptomProcedure != nil { return *diseaseSymptomProcedure }
			return m.DiseaseSymptomProcedure
		}(),
		DiseaseStatus: func() CodeableReference {
			if diseaseStatus != nil { return *diseaseStatus }
			return m.DiseaseStatus
		}(),
		Comorbidity: func() []CodeableReference {
			if comorbidity != nil { return *comorbidity }
			return m.Comorbidity
		}(),
		Indication: func() []Reference {
			if indication != nil { return *indication }
			return m.Indication
		}(),
		OtherTherapy: func() []ClinicalUseDefinitionOtherTherapy {
			if otherTherapy != nil { return *otherTherapy }
			return m.OtherTherapy
		}(),
	}
}
// ClinicalUseDefinitionOtherTherapy
// Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
type ClinicalUseDefinitionOtherTherapy struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// relationshipType
	// The type of relationship between the medicinal product indication or contraindication and another therapy.
	RelationshipType CodeableConcept `json:"relationshipType,omitempty"`
	// therapy
	// Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
	Therapy CodeableReference `json:"therapy,omitempty"`
}

// NewClinicalUseDefinitionOtherTherapy creates a new ClinicalUseDefinitionOtherTherapy instance
func NewClinicalUseDefinitionOtherTherapy(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	relationshipType CodeableConcept,
	therapy CodeableReference,
) *ClinicalUseDefinitionOtherTherapy {
	return &ClinicalUseDefinitionOtherTherapy{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		RelationshipType: relationshipType,
		Therapy: therapy,
	}
}
// FromJSON populates ClinicalUseDefinitionOtherTherapy from JSON data
func (m *ClinicalUseDefinitionOtherTherapy) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionOtherTherapy to JSON data
func (m *ClinicalUseDefinitionOtherTherapy) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinitionOtherTherapy
func (m *ClinicalUseDefinitionOtherTherapy) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	relationshipType *CodeableConcept,
	therapy *CodeableReference,
) *ClinicalUseDefinitionOtherTherapy {
	return &ClinicalUseDefinitionOtherTherapy{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		RelationshipType: func() CodeableConcept {
			if relationshipType != nil { return *relationshipType }
			return m.RelationshipType
		}(),
		Therapy: func() CodeableReference {
			if therapy != nil { return *therapy }
			return m.Therapy
		}(),
	}
}
// ClinicalUseDefinitionIndication
// Specifics for when this is an indication.
type ClinicalUseDefinitionIndication struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// diseaseSymptomProcedure
	// The situation that is being documented as an indicaton for this item.
	DiseaseSymptomProcedure CodeableReference `json:"diseaseSymptomProcedure,omitempty"`
	// diseaseStatus
	// The status of the disease or symptom for the indication, for example "chronic" or "metastatic".
	DiseaseStatus CodeableReference `json:"diseaseStatus,omitempty"`
	// comorbidity
	// A comorbidity (concurrent condition) or coinfection as part of the indication.
	Comorbidity []CodeableReference `json:"comorbidity,omitempty"`
	// intendedEffect
	// The intended effect, aim or strategy to be achieved.
	IntendedEffect CodeableReference `json:"intendedEffect,omitempty"`
	// durationRange
	// Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
	DurationRange Range `json:"durationRange,omitempty"`
	// durationString
	// Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
	DurationString FhirString `json:"durationString,omitempty"`
	// undesirableEffect
	// An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.
	UndesirableEffect []Reference `json:"undesirableEffect,omitempty"`
	// otherTherapy
	// Information about the use of the medicinal product in relation to other therapies described as part of the indication.
	OtherTherapy []ClinicalUseDefinitionOtherTherapy `json:"otherTherapy,omitempty"`
}

// NewClinicalUseDefinitionIndication creates a new ClinicalUseDefinitionIndication instance
func NewClinicalUseDefinitionIndication(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	diseaseSymptomProcedure CodeableReference,
	diseaseStatus CodeableReference,
	comorbidity []CodeableReference,
	intendedEffect CodeableReference,
	durationRange Range,
	durationString FhirString,
	undesirableEffect []Reference,
	otherTherapy []ClinicalUseDefinitionOtherTherapy,
) *ClinicalUseDefinitionIndication {
	return &ClinicalUseDefinitionIndication{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		DiseaseSymptomProcedure: diseaseSymptomProcedure,
		DiseaseStatus: diseaseStatus,
		Comorbidity: comorbidity,
		IntendedEffect: intendedEffect,
		DurationRange: durationRange,
		DurationString: durationString,
		UndesirableEffect: undesirableEffect,
		OtherTherapy: otherTherapy,
	}
}
// FromJSON populates ClinicalUseDefinitionIndication from JSON data
func (m *ClinicalUseDefinitionIndication) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionIndication to JSON data
func (m *ClinicalUseDefinitionIndication) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinitionIndication
func (m *ClinicalUseDefinitionIndication) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	diseaseSymptomProcedure *CodeableReference,
	diseaseStatus *CodeableReference,
	comorbidity *[]CodeableReference,
	intendedEffect *CodeableReference,
	durationRange *Range,
	durationString *FhirString,
	undesirableEffect *[]Reference,
	otherTherapy *[]ClinicalUseDefinitionOtherTherapy,
) *ClinicalUseDefinitionIndication {
	return &ClinicalUseDefinitionIndication{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		DiseaseSymptomProcedure: func() CodeableReference {
			if diseaseSymptomProcedure != nil { return *diseaseSymptomProcedure }
			return m.DiseaseSymptomProcedure
		}(),
		DiseaseStatus: func() CodeableReference {
			if diseaseStatus != nil { return *diseaseStatus }
			return m.DiseaseStatus
		}(),
		Comorbidity: func() []CodeableReference {
			if comorbidity != nil { return *comorbidity }
			return m.Comorbidity
		}(),
		IntendedEffect: func() CodeableReference {
			if intendedEffect != nil { return *intendedEffect }
			return m.IntendedEffect
		}(),
		DurationRange: func() Range {
			if durationRange != nil { return *durationRange }
			return m.DurationRange
		}(),
		DurationString: func() FhirString {
			if durationString != nil { return *durationString }
			return m.DurationString
		}(),
		UndesirableEffect: func() []Reference {
			if undesirableEffect != nil { return *undesirableEffect }
			return m.UndesirableEffect
		}(),
		OtherTherapy: func() []ClinicalUseDefinitionOtherTherapy {
			if otherTherapy != nil { return *otherTherapy }
			return m.OtherTherapy
		}(),
	}
}
// ClinicalUseDefinitionInteraction
// Specifics for when this is an interaction.
type ClinicalUseDefinitionInteraction struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// interactant
	// The specific medication, food, substance or laboratory test that interacts.
	Interactant []ClinicalUseDefinitionInteractant `json:"interactant,omitempty"`
	// type
	// The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.
	Type_ CodeableConcept `json:"type,omitempty"`
	// effect
	// The effect of the interaction, for example "reduced gastric absorption of primary medication".
	Effect CodeableReference `json:"effect,omitempty"`
	// incidence
	// The incidence of the interaction, e.g. theoretical, observed.
	Incidence CodeableConcept `json:"incidence,omitempty"`
	// management
	// Actions for managing the interaction.
	Management []CodeableConcept `json:"management,omitempty"`
}

// NewClinicalUseDefinitionInteraction creates a new ClinicalUseDefinitionInteraction instance
func NewClinicalUseDefinitionInteraction(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	interactant []ClinicalUseDefinitionInteractant,
	type_ CodeableConcept,
	effect CodeableReference,
	incidence CodeableConcept,
	management []CodeableConcept,
) *ClinicalUseDefinitionInteraction {
	return &ClinicalUseDefinitionInteraction{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		Interactant: interactant,
		Type_: type_,
		Effect: effect,
		Incidence: incidence,
		Management: management,
	}
}
// FromJSON populates ClinicalUseDefinitionInteraction from JSON data
func (m *ClinicalUseDefinitionInteraction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionInteraction to JSON data
func (m *ClinicalUseDefinitionInteraction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinitionInteraction
func (m *ClinicalUseDefinitionInteraction) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	interactant *[]ClinicalUseDefinitionInteractant,
	type_ *CodeableConcept,
	effect *CodeableReference,
	incidence *CodeableConcept,
	management *[]CodeableConcept,
) *ClinicalUseDefinitionInteraction {
	return &ClinicalUseDefinitionInteraction{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		Interactant: func() []ClinicalUseDefinitionInteractant {
			if interactant != nil { return *interactant }
			return m.Interactant
		}(),
		Type_: func() CodeableConcept {
			if type_ != nil { return *type_ }
			return m.Type_
		}(),
		Effect: func() CodeableReference {
			if effect != nil { return *effect }
			return m.Effect
		}(),
		Incidence: func() CodeableConcept {
			if incidence != nil { return *incidence }
			return m.Incidence
		}(),
		Management: func() []CodeableConcept {
			if management != nil { return *management }
			return m.Management
		}(),
	}
}
// ClinicalUseDefinitionInteractant
// The specific medication, food, substance or laboratory test that interacts.
type ClinicalUseDefinitionInteractant struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// itemReference
	// The specific medication, food or laboratory test that interacts.
	ItemReference Reference `json:"itemReference,omitempty"`
	// itemCodeableConcept
	// The specific medication, food or laboratory test that interacts.
	ItemCodeableConcept CodeableConcept `json:"itemCodeableConcept,omitempty"`
}

// NewClinicalUseDefinitionInteractant creates a new ClinicalUseDefinitionInteractant instance
func NewClinicalUseDefinitionInteractant(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	itemReference Reference,
	itemCodeableConcept CodeableConcept,
) *ClinicalUseDefinitionInteractant {
	return &ClinicalUseDefinitionInteractant{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		ItemReference: itemReference,
		ItemCodeableConcept: itemCodeableConcept,
	}
}
// FromJSON populates ClinicalUseDefinitionInteractant from JSON data
func (m *ClinicalUseDefinitionInteractant) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionInteractant to JSON data
func (m *ClinicalUseDefinitionInteractant) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinitionInteractant
func (m *ClinicalUseDefinitionInteractant) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	itemReference *Reference,
	itemCodeableConcept *CodeableConcept,
) *ClinicalUseDefinitionInteractant {
	return &ClinicalUseDefinitionInteractant{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		ItemReference: func() Reference {
			if itemReference != nil { return *itemReference }
			return m.ItemReference
		}(),
		ItemCodeableConcept: func() CodeableConcept {
			if itemCodeableConcept != nil { return *itemCodeableConcept }
			return m.ItemCodeableConcept
		}(),
	}
}
// ClinicalUseDefinitionUndesirableEffect
// Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.
type ClinicalUseDefinitionUndesirableEffect struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// symptomConditionEffect
	// The situation in which the undesirable effect may manifest.
	SymptomConditionEffect CodeableReference `json:"symptomConditionEffect,omitempty"`
	// classification
	// High level classification of the effect.
	Classification CodeableConcept `json:"classification,omitempty"`
	// frequencyOfOccurrence
	// How often the effect is seen.
	FrequencyOfOccurrence CodeableConcept `json:"frequencyOfOccurrence,omitempty"`
}

// NewClinicalUseDefinitionUndesirableEffect creates a new ClinicalUseDefinitionUndesirableEffect instance
func NewClinicalUseDefinitionUndesirableEffect(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	symptomConditionEffect CodeableReference,
	classification CodeableConcept,
	frequencyOfOccurrence CodeableConcept,
) *ClinicalUseDefinitionUndesirableEffect {
	return &ClinicalUseDefinitionUndesirableEffect{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		SymptomConditionEffect: symptomConditionEffect,
		Classification: classification,
		FrequencyOfOccurrence: frequencyOfOccurrence,
	}
}
// FromJSON populates ClinicalUseDefinitionUndesirableEffect from JSON data
func (m *ClinicalUseDefinitionUndesirableEffect) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionUndesirableEffect to JSON data
func (m *ClinicalUseDefinitionUndesirableEffect) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinitionUndesirableEffect
func (m *ClinicalUseDefinitionUndesirableEffect) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	symptomConditionEffect *CodeableReference,
	classification *CodeableConcept,
	frequencyOfOccurrence *CodeableConcept,
) *ClinicalUseDefinitionUndesirableEffect {
	return &ClinicalUseDefinitionUndesirableEffect{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		SymptomConditionEffect: func() CodeableReference {
			if symptomConditionEffect != nil { return *symptomConditionEffect }
			return m.SymptomConditionEffect
		}(),
		Classification: func() CodeableConcept {
			if classification != nil { return *classification }
			return m.Classification
		}(),
		FrequencyOfOccurrence: func() CodeableConcept {
			if frequencyOfOccurrence != nil { return *frequencyOfOccurrence }
			return m.FrequencyOfOccurrence
		}(),
	}
}
// ClinicalUseDefinitionWarning
// A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
type ClinicalUseDefinitionWarning struct {
	BackboneElement
	// id
	// Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
	Id FhirString `json:"id,omitempty"`
	// extension
	// May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
	Extension_ []FhirExtension `json:"extension,omitempty"`
	// modifierExtension
	// May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
// 
// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
	ModifierExtension []FhirExtension `json:"modifierExtension,omitempty"`
	// description
	// A textual definition of this warning, with formatting.
	Description FhirMarkdown `json:"description,omitempty"`
	// code
	// A coded or unformatted textual definition of this warning.
	Code CodeableConcept `json:"code,omitempty"`
}

// NewClinicalUseDefinitionWarning creates a new ClinicalUseDefinitionWarning instance
func NewClinicalUseDefinitionWarning(
	id FhirString,
	extension_ []FhirExtension,
	modifierExtension []FhirExtension,
	description FhirMarkdown,
	code CodeableConcept,
) *ClinicalUseDefinitionWarning {
	return &ClinicalUseDefinitionWarning{
		Id: id,
		Extension_: extension_,
		ModifierExtension: modifierExtension,
		Description: description,
		Code: code,
	}
}
// FromJSON populates ClinicalUseDefinitionWarning from JSON data
func (m *ClinicalUseDefinitionWarning) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalUseDefinitionWarning to JSON data
func (m *ClinicalUseDefinitionWarning) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// CopyWith creates a modified copy of ClinicalUseDefinitionWarning
func (m *ClinicalUseDefinitionWarning) CopyWith(
	id *FhirString,
	extension_ *[]FhirExtension,
	modifierExtension *[]FhirExtension,
	description *FhirMarkdown,
	code *CodeableConcept,
) *ClinicalUseDefinitionWarning {
	return &ClinicalUseDefinitionWarning{
		Id: func() FhirString {
			if id != nil { return *id }
			return m.Id
		}(),
		Extension_: func() []FhirExtension {
			if extension_ != nil { return *extension_ }
			return m.Extension_
		}(),
		ModifierExtension: func() []FhirExtension {
			if modifierExtension != nil { return *modifierExtension }
			return m.ModifierExtension
		}(),
		Description: func() FhirMarkdown {
			if description != nil { return *description }
			return m.Description
		}(),
		Code: func() CodeableConcept {
			if code != nil { return *code }
			return m.Code
		}(),
	}
}
