// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// DeviceDefinition
// The characteristics, operational status and capabilities of a medical-related component of a medical device.
type DeviceDefinition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	UdiDeviceIdentifier []*DeviceDefinitionUdiDeviceIdentifier `json:"udideviceidentifier,omitempty"`
	ManufacturerString *FhirString `json:"manufacturerstring,omitempty"`
	ManufacturerReference *Reference `json:"manufacturerreference,omitempty"`
	DeviceName []*DeviceDefinitionDeviceName `json:"devicename,omitempty"`
	ModelNumber *FhirString `json:"modelnumber,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Specialization []*DeviceDefinitionSpecialization `json:"specialization,omitempty"`
	Version []*FhirString `json:"version,omitempty"`
	Safety []*CodeableConcept `json:"safety,omitempty"`
	ShelfLifeStorage []*ProductShelfLife `json:"shelflifestorage,omitempty"`
	PhysicalCharacteristics *ProdCharacteristic `json:"physicalcharacteristics,omitempty"`
	LanguageCode []*CodeableConcept `json:"languagecode,omitempty"`
	Capability []*DeviceDefinitionCapability `json:"capability,omitempty"`
	Property []*DeviceDefinitionProperty `json:"property,omitempty"`
	Owner *Reference `json:"owner,omitempty"`
	Contact []*ContactPoint `json:"contact,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	OnlineInformation *FhirUri `json:"onlineinformation,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	ParentDevice *Reference `json:"parentdevice,omitempty"`
	Material []*DeviceDefinitionMaterial `json:"material,omitempty"`
}

// NewDeviceDefinition creates a new DeviceDefinition instance
func NewDeviceDefinition() *DeviceDefinition {
	return &DeviceDefinition{}
}

// FromJSON populates DeviceDefinition from JSON data
func (m *DeviceDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDefinition to JSON data
func (m *DeviceDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDefinition
func (m *DeviceDefinition) Clone() *DeviceDefinition {
	if m == nil { return nil }
	return &DeviceDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		UdiDeviceIdentifier: cloneSlices(m.UdiDeviceIdentifier),
		ManufacturerString: m.ManufacturerString.Clone(),
		ManufacturerReference: m.ManufacturerReference.Clone(),
		DeviceName: cloneSlices(m.DeviceName),
		ModelNumber: m.ModelNumber.Clone(),
		Type: m.Type.Clone(),
		Specialization: cloneSlices(m.Specialization),
		Version: cloneSlices(m.Version),
		Safety: cloneSlices(m.Safety),
		ShelfLifeStorage: cloneSlices(m.ShelfLifeStorage),
		PhysicalCharacteristics: m.PhysicalCharacteristics.Clone(),
		LanguageCode: cloneSlices(m.LanguageCode),
		Capability: cloneSlices(m.Capability),
		Property: cloneSlices(m.Property),
		Owner: m.Owner.Clone(),
		Contact: cloneSlices(m.Contact),
		Url: m.Url.Clone(),
		OnlineInformation: m.OnlineInformation.Clone(),
		Note: cloneSlices(m.Note),
		Quantity: m.Quantity.Clone(),
		ParentDevice: m.ParentDevice.Clone(),
		Material: cloneSlices(m.Material),
	}
}

// Equals checks for equality with another DeviceDefinition instance
func (m *DeviceDefinition) Equals(other *DeviceDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.UdiDeviceIdentifier, other.UdiDeviceIdentifier) { return false }
	if !m.ManufacturerString.Equals(other.ManufacturerString) { return false }
	if !m.ManufacturerReference.Equals(other.ManufacturerReference) { return false }
	if !compareSlices(m.DeviceName, other.DeviceName) { return false }
	if !m.ModelNumber.Equals(other.ModelNumber) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Specialization, other.Specialization) { return false }
	if !compareSlices(m.Version, other.Version) { return false }
	if !compareSlices(m.Safety, other.Safety) { return false }
	if !compareSlices(m.ShelfLifeStorage, other.ShelfLifeStorage) { return false }
	if !m.PhysicalCharacteristics.Equals(other.PhysicalCharacteristics) { return false }
	if !compareSlices(m.LanguageCode, other.LanguageCode) { return false }
	if !compareSlices(m.Capability, other.Capability) { return false }
	if !compareSlices(m.Property, other.Property) { return false }
	if !m.Owner.Equals(other.Owner) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.OnlineInformation.Equals(other.OnlineInformation) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.ParentDevice.Equals(other.ParentDevice) { return false }
	if !compareSlices(m.Material, other.Material) { return false }
	return true
}

// DeviceDefinitionUdiDeviceIdentifier
// Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
type DeviceDefinitionUdiDeviceIdentifier struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DeviceIdentifier *FhirString `json:"deviceidentifier,omitempty"`
	Issuer *FhirUri `json:"issuer,omitempty"`
	Jurisdiction *FhirUri `json:"jurisdiction,omitempty"`
}

// NewDeviceDefinitionUdiDeviceIdentifier creates a new DeviceDefinitionUdiDeviceIdentifier instance
func NewDeviceDefinitionUdiDeviceIdentifier() *DeviceDefinitionUdiDeviceIdentifier {
	return &DeviceDefinitionUdiDeviceIdentifier{}
}

// FromJSON populates DeviceDefinitionUdiDeviceIdentifier from JSON data
func (m *DeviceDefinitionUdiDeviceIdentifier) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDefinitionUdiDeviceIdentifier to JSON data
func (m *DeviceDefinitionUdiDeviceIdentifier) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDefinitionUdiDeviceIdentifier
func (m *DeviceDefinitionUdiDeviceIdentifier) Clone() *DeviceDefinitionUdiDeviceIdentifier {
	if m == nil { return nil }
	return &DeviceDefinitionUdiDeviceIdentifier{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DeviceIdentifier: m.DeviceIdentifier.Clone(),
		Issuer: m.Issuer.Clone(),
		Jurisdiction: m.Jurisdiction.Clone(),
	}
}

// Equals checks for equality with another DeviceDefinitionUdiDeviceIdentifier instance
func (m *DeviceDefinitionUdiDeviceIdentifier) Equals(other *DeviceDefinitionUdiDeviceIdentifier) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.DeviceIdentifier.Equals(other.DeviceIdentifier) { return false }
	if !m.Issuer.Equals(other.Issuer) { return false }
	if !m.Jurisdiction.Equals(other.Jurisdiction) { return false }
	return true
}

// DeviceDefinitionDeviceName
// A name given to the device to identify it.
type DeviceDefinitionDeviceName struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Type *DeviceNameType `json:"type,omitempty"`
}

// NewDeviceDefinitionDeviceName creates a new DeviceDefinitionDeviceName instance
func NewDeviceDefinitionDeviceName() *DeviceDefinitionDeviceName {
	return &DeviceDefinitionDeviceName{}
}

// FromJSON populates DeviceDefinitionDeviceName from JSON data
func (m *DeviceDefinitionDeviceName) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDefinitionDeviceName to JSON data
func (m *DeviceDefinitionDeviceName) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDefinitionDeviceName
func (m *DeviceDefinitionDeviceName) Clone() *DeviceDefinitionDeviceName {
	if m == nil { return nil }
	return &DeviceDefinitionDeviceName{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Type: m.Type.Clone(),
	}
}

// Equals checks for equality with another DeviceDefinitionDeviceName instance
func (m *DeviceDefinitionDeviceName) Equals(other *DeviceDefinitionDeviceName) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// DeviceDefinitionSpecialization
// The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
type DeviceDefinitionSpecialization struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	SystemType *FhirString `json:"systemtype,omitempty"`
	Version *FhirString `json:"version,omitempty"`
}

// NewDeviceDefinitionSpecialization creates a new DeviceDefinitionSpecialization instance
func NewDeviceDefinitionSpecialization() *DeviceDefinitionSpecialization {
	return &DeviceDefinitionSpecialization{}
}

// FromJSON populates DeviceDefinitionSpecialization from JSON data
func (m *DeviceDefinitionSpecialization) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDefinitionSpecialization to JSON data
func (m *DeviceDefinitionSpecialization) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDefinitionSpecialization
func (m *DeviceDefinitionSpecialization) Clone() *DeviceDefinitionSpecialization {
	if m == nil { return nil }
	return &DeviceDefinitionSpecialization{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		SystemType: m.SystemType.Clone(),
		Version: m.Version.Clone(),
	}
}

// Equals checks for equality with another DeviceDefinitionSpecialization instance
func (m *DeviceDefinitionSpecialization) Equals(other *DeviceDefinitionSpecialization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.SystemType.Equals(other.SystemType) { return false }
	if !m.Version.Equals(other.Version) { return false }
	return true
}

// DeviceDefinitionCapability
// Device capabilities.
type DeviceDefinitionCapability struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Description []*CodeableConcept `json:"description,omitempty"`
}

// NewDeviceDefinitionCapability creates a new DeviceDefinitionCapability instance
func NewDeviceDefinitionCapability() *DeviceDefinitionCapability {
	return &DeviceDefinitionCapability{}
}

// FromJSON populates DeviceDefinitionCapability from JSON data
func (m *DeviceDefinitionCapability) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDefinitionCapability to JSON data
func (m *DeviceDefinitionCapability) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDefinitionCapability
func (m *DeviceDefinitionCapability) Clone() *DeviceDefinitionCapability {
	if m == nil { return nil }
	return &DeviceDefinitionCapability{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Description: cloneSlices(m.Description),
	}
}

// Equals checks for equality with another DeviceDefinitionCapability instance
func (m *DeviceDefinitionCapability) Equals(other *DeviceDefinitionCapability) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.Description, other.Description) { return false }
	return true
}

// DeviceDefinitionProperty
// The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
type DeviceDefinitionProperty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	ValueQuantity []*Quantity `json:"valuequantity,omitempty"`
	ValueCode []*CodeableConcept `json:"valuecode,omitempty"`
}

// NewDeviceDefinitionProperty creates a new DeviceDefinitionProperty instance
func NewDeviceDefinitionProperty() *DeviceDefinitionProperty {
	return &DeviceDefinitionProperty{}
}

// FromJSON populates DeviceDefinitionProperty from JSON data
func (m *DeviceDefinitionProperty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDefinitionProperty to JSON data
func (m *DeviceDefinitionProperty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDefinitionProperty
func (m *DeviceDefinitionProperty) Clone() *DeviceDefinitionProperty {
	if m == nil { return nil }
	return &DeviceDefinitionProperty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		ValueQuantity: cloneSlices(m.ValueQuantity),
		ValueCode: cloneSlices(m.ValueCode),
	}
}

// Equals checks for equality with another DeviceDefinitionProperty instance
func (m *DeviceDefinitionProperty) Equals(other *DeviceDefinitionProperty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !compareSlices(m.ValueQuantity, other.ValueQuantity) { return false }
	if !compareSlices(m.ValueCode, other.ValueCode) { return false }
	return true
}

// DeviceDefinitionMaterial
// A substance used to create the material(s) of which the device is made.
type DeviceDefinitionMaterial struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Substance *CodeableConcept `json:"substance,omitempty"`
	Alternate *FhirBoolean `json:"alternate,omitempty"`
	AllergenicIndicator *FhirBoolean `json:"allergenicindicator,omitempty"`
}

// NewDeviceDefinitionMaterial creates a new DeviceDefinitionMaterial instance
func NewDeviceDefinitionMaterial() *DeviceDefinitionMaterial {
	return &DeviceDefinitionMaterial{}
}

// FromJSON populates DeviceDefinitionMaterial from JSON data
func (m *DeviceDefinitionMaterial) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DeviceDefinitionMaterial to JSON data
func (m *DeviceDefinitionMaterial) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DeviceDefinitionMaterial
func (m *DeviceDefinitionMaterial) Clone() *DeviceDefinitionMaterial {
	if m == nil { return nil }
	return &DeviceDefinitionMaterial{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Substance: m.Substance.Clone(),
		Alternate: m.Alternate.Clone(),
		AllergenicIndicator: m.AllergenicIndicator.Clone(),
	}
}

// Equals checks for equality with another DeviceDefinitionMaterial instance
func (m *DeviceDefinitionMaterial) Equals(other *DeviceDefinitionMaterial) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Substance.Equals(other.Substance) { return false }
	if !m.Alternate.Equals(other.Alternate) { return false }
	if !m.AllergenicIndicator.Equals(other.AllergenicIndicator) { return false }
	return true
}

