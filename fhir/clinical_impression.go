// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// ClinicalImpression
// A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
type ClinicalImpression struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ClinicalImpressionStatus `json:"status,omitempty"`
	StatusReason *CodeableConcept `json:"statusreason,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	EffectiveDateTime *FhirDateTime `json:"effectivedatetime,omitempty"`
	EffectivePeriod *Period `json:"effectiveperiod,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Assessor *Reference `json:"assessor,omitempty"`
	Previous *Reference `json:"previous,omitempty"`
	Problem []*Reference `json:"problem,omitempty"`
	Investigation []*ClinicalImpressionInvestigation `json:"investigation,omitempty"`
	Protocol []*FhirUri `json:"protocol,omitempty"`
	Summary *FhirString `json:"summary,omitempty"`
	Finding []*ClinicalImpressionFinding `json:"finding,omitempty"`
	PrognosisCodeableConcept []*CodeableConcept `json:"prognosiscodeableconcept,omitempty"`
	PrognosisReference []*Reference `json:"prognosisreference,omitempty"`
	SupportingInfo []*Reference `json:"supportinginfo,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewClinicalImpression creates a new ClinicalImpression instance
func NewClinicalImpression() *ClinicalImpression {
	return &ClinicalImpression{}
}

// FromJSON populates ClinicalImpression from JSON data
func (m *ClinicalImpression) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalImpression to JSON data
func (m *ClinicalImpression) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalImpression
func (m *ClinicalImpression) Clone() *ClinicalImpression {
	if m == nil { return nil }
	return &ClinicalImpression{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		StatusReason: m.StatusReason.Clone(),
		Code: m.Code.Clone(),
		Description: m.Description.Clone(),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		EffectiveDateTime: m.EffectiveDateTime.Clone(),
		EffectivePeriod: m.EffectivePeriod.Clone(),
		Date: m.Date.Clone(),
		Assessor: m.Assessor.Clone(),
		Previous: m.Previous.Clone(),
		Problem: cloneSlices(m.Problem),
		Investigation: cloneSlices(m.Investigation),
		Protocol: cloneSlices(m.Protocol),
		Summary: m.Summary.Clone(),
		Finding: cloneSlices(m.Finding),
		PrognosisCodeableConcept: cloneSlices(m.PrognosisCodeableConcept),
		PrognosisReference: cloneSlices(m.PrognosisReference),
		SupportingInfo: cloneSlices(m.SupportingInfo),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks for equality with another ClinicalImpression instance
func (m *ClinicalImpression) Equals(other *ClinicalImpression) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusReason.Equals(other.StatusReason) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.EffectiveDateTime.Equals(other.EffectiveDateTime) { return false }
	if !m.EffectivePeriod.Equals(other.EffectivePeriod) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Assessor.Equals(other.Assessor) { return false }
	if !m.Previous.Equals(other.Previous) { return false }
	if !compareSlices(m.Problem, other.Problem) { return false }
	if !compareSlices(m.Investigation, other.Investigation) { return false }
	if !compareSlices(m.Protocol, other.Protocol) { return false }
	if !m.Summary.Equals(other.Summary) { return false }
	if !compareSlices(m.Finding, other.Finding) { return false }
	if !compareSlices(m.PrognosisCodeableConcept, other.PrognosisCodeableConcept) { return false }
	if !compareSlices(m.PrognosisReference, other.PrognosisReference) { return false }
	if !compareSlices(m.SupportingInfo, other.SupportingInfo) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// ClinicalImpressionInvestigation
// One or more sets of investigations (signs, symptoms, etc.). The actual grouping of investigations varies greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
type ClinicalImpressionInvestigation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Item []*Reference `json:"item,omitempty"`
}

// NewClinicalImpressionInvestigation creates a new ClinicalImpressionInvestigation instance
func NewClinicalImpressionInvestigation() *ClinicalImpressionInvestigation {
	return &ClinicalImpressionInvestigation{}
}

// FromJSON populates ClinicalImpressionInvestigation from JSON data
func (m *ClinicalImpressionInvestigation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalImpressionInvestigation to JSON data
func (m *ClinicalImpressionInvestigation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalImpressionInvestigation
func (m *ClinicalImpressionInvestigation) Clone() *ClinicalImpressionInvestigation {
	if m == nil { return nil }
	return &ClinicalImpressionInvestigation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Item: cloneSlices(m.Item),
	}
}

// Equals checks for equality with another ClinicalImpressionInvestigation instance
func (m *ClinicalImpressionInvestigation) Equals(other *ClinicalImpressionInvestigation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	return true
}

// ClinicalImpressionFinding
// Specific findings or diagnoses that were considered likely or relevant to ongoing treatment.
type ClinicalImpressionFinding struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ItemCodeableConcept *CodeableConcept `json:"itemcodeableconcept,omitempty"`
	ItemReference *Reference `json:"itemreference,omitempty"`
	Basis *FhirString `json:"basis,omitempty"`
}

// NewClinicalImpressionFinding creates a new ClinicalImpressionFinding instance
func NewClinicalImpressionFinding() *ClinicalImpressionFinding {
	return &ClinicalImpressionFinding{}
}

// FromJSON populates ClinicalImpressionFinding from JSON data
func (m *ClinicalImpressionFinding) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ClinicalImpressionFinding to JSON data
func (m *ClinicalImpressionFinding) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ClinicalImpressionFinding
func (m *ClinicalImpressionFinding) Clone() *ClinicalImpressionFinding {
	if m == nil { return nil }
	return &ClinicalImpressionFinding{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ItemCodeableConcept: m.ItemCodeableConcept.Clone(),
		ItemReference: m.ItemReference.Clone(),
		Basis: m.Basis.Clone(),
	}
}

// Equals checks for equality with another ClinicalImpressionFinding instance
func (m *ClinicalImpressionFinding) Equals(other *ClinicalImpressionFinding) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ItemCodeableConcept.Equals(other.ItemCodeableConcept) { return false }
	if !m.ItemReference.Equals(other.ItemReference) { return false }
	if !m.Basis.Equals(other.Basis) { return false }
	return true
}

