// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Encounter
// An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
type Encounter struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *EncounterStatus `json:"status,omitempty"`
	StatusHistory []*EncounterStatusHistory `json:"statushistory,omitempty"`
	Class_ *Coding `json:"class,omitempty"`
	ClassHistory []*EncounterClassHistory `json:"classhistory,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	ServiceType *CodeableConcept `json:"servicetype,omitempty"`
	Priority *CodeableConcept `json:"priority,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	EpisodeOfCare []*Reference `json:"episodeofcare,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	Participant []*EncounterParticipant `json:"participant,omitempty"`
	Appointment []*Reference `json:"appointment,omitempty"`
	Period *Period `json:"period,omitempty"`
	Length *FhirDuration `json:"length,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	Diagnosis []*EncounterDiagnosis `json:"diagnosis,omitempty"`
	Account []*Reference `json:"account,omitempty"`
	Hospitalization *EncounterHospitalization `json:"hospitalization,omitempty"`
	Location []*EncounterLocation `json:"location,omitempty"`
	ServiceProvider *Reference `json:"serviceprovider,omitempty"`
	PartOf *Reference `json:"partof,omitempty"`
}

// NewEncounter creates a new Encounter instance
func NewEncounter() *Encounter {
	return &Encounter{}
}

// FromJSON populates Encounter from JSON data
func (m *Encounter) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Encounter to JSON data
func (m *Encounter) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Encounter
func (m *Encounter) Clone() *Encounter {
	if m == nil { return nil }
	return &Encounter{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		StatusHistory: cloneSlices(m.StatusHistory),
		Class_: m.Class_.Clone(),
		ClassHistory: cloneSlices(m.ClassHistory),
		Type: cloneSlices(m.Type),
		ServiceType: m.ServiceType.Clone(),
		Priority: m.Priority.Clone(),
		Subject: m.Subject.Clone(),
		EpisodeOfCare: cloneSlices(m.EpisodeOfCare),
		BasedOn: cloneSlices(m.BasedOn),
		Participant: cloneSlices(m.Participant),
		Appointment: cloneSlices(m.Appointment),
		Period: m.Period.Clone(),
		Length: m.Length.Clone(),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		Diagnosis: cloneSlices(m.Diagnosis),
		Account: cloneSlices(m.Account),
		Hospitalization: m.Hospitalization.Clone(),
		Location: cloneSlices(m.Location),
		ServiceProvider: m.ServiceProvider.Clone(),
		PartOf: m.PartOf.Clone(),
	}
}

// Equals checks for equality with another Encounter instance
func (m *Encounter) Equals(other *Encounter) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !compareSlices(m.StatusHistory, other.StatusHistory) { return false }
	if !m.Class_.Equals(other.Class_) { return false }
	if !compareSlices(m.ClassHistory, other.ClassHistory) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.ServiceType.Equals(other.ServiceType) { return false }
	if !m.Priority.Equals(other.Priority) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !compareSlices(m.EpisodeOfCare, other.EpisodeOfCare) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !compareSlices(m.Participant, other.Participant) { return false }
	if !compareSlices(m.Appointment, other.Appointment) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.Length.Equals(other.Length) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !compareSlices(m.Diagnosis, other.Diagnosis) { return false }
	if !compareSlices(m.Account, other.Account) { return false }
	if !m.Hospitalization.Equals(other.Hospitalization) { return false }
	if !compareSlices(m.Location, other.Location) { return false }
	if !m.ServiceProvider.Equals(other.ServiceProvider) { return false }
	if !m.PartOf.Equals(other.PartOf) { return false }
	return true
}

// EncounterStatusHistory
// The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
type EncounterStatusHistory struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Status *EncounterStatus `json:"status,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewEncounterStatusHistory creates a new EncounterStatusHistory instance
func NewEncounterStatusHistory() *EncounterStatusHistory {
	return &EncounterStatusHistory{}
}

// FromJSON populates EncounterStatusHistory from JSON data
func (m *EncounterStatusHistory) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EncounterStatusHistory to JSON data
func (m *EncounterStatusHistory) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EncounterStatusHistory
func (m *EncounterStatusHistory) Clone() *EncounterStatusHistory {
	if m == nil { return nil }
	return &EncounterStatusHistory{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Status: m.Status.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks for equality with another EncounterStatusHistory instance
func (m *EncounterStatusHistory) Equals(other *EncounterStatusHistory) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// EncounterClassHistory
// The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
type EncounterClassHistory struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Class_ *Coding `json:"class,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewEncounterClassHistory creates a new EncounterClassHistory instance
func NewEncounterClassHistory() *EncounterClassHistory {
	return &EncounterClassHistory{}
}

// FromJSON populates EncounterClassHistory from JSON data
func (m *EncounterClassHistory) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EncounterClassHistory to JSON data
func (m *EncounterClassHistory) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EncounterClassHistory
func (m *EncounterClassHistory) Clone() *EncounterClassHistory {
	if m == nil { return nil }
	return &EncounterClassHistory{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Class_: m.Class_.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks for equality with another EncounterClassHistory instance
func (m *EncounterClassHistory) Equals(other *EncounterClassHistory) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Class_.Equals(other.Class_) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

// EncounterParticipant
// The list of people responsible for providing the service.
type EncounterParticipant struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	Period *Period `json:"period,omitempty"`
	Individual *Reference `json:"individual,omitempty"`
}

// NewEncounterParticipant creates a new EncounterParticipant instance
func NewEncounterParticipant() *EncounterParticipant {
	return &EncounterParticipant{}
}

// FromJSON populates EncounterParticipant from JSON data
func (m *EncounterParticipant) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EncounterParticipant to JSON data
func (m *EncounterParticipant) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EncounterParticipant
func (m *EncounterParticipant) Clone() *EncounterParticipant {
	if m == nil { return nil }
	return &EncounterParticipant{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: cloneSlices(m.Type),
		Period: m.Period.Clone(),
		Individual: m.Individual.Clone(),
	}
}

// Equals checks for equality with another EncounterParticipant instance
func (m *EncounterParticipant) Equals(other *EncounterParticipant) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.Individual.Equals(other.Individual) { return false }
	return true
}

// EncounterDiagnosis
// The list of diagnosis relevant to this encounter.
type EncounterDiagnosis struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Condition *Reference `json:"condition,omitempty"`
	Use *CodeableConcept `json:"use,omitempty"`
	Rank *FhirPositiveInt `json:"rank,omitempty"`
}

// NewEncounterDiagnosis creates a new EncounterDiagnosis instance
func NewEncounterDiagnosis() *EncounterDiagnosis {
	return &EncounterDiagnosis{}
}

// FromJSON populates EncounterDiagnosis from JSON data
func (m *EncounterDiagnosis) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EncounterDiagnosis to JSON data
func (m *EncounterDiagnosis) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EncounterDiagnosis
func (m *EncounterDiagnosis) Clone() *EncounterDiagnosis {
	if m == nil { return nil }
	return &EncounterDiagnosis{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Condition: m.Condition.Clone(),
		Use: m.Use.Clone(),
		Rank: m.Rank.Clone(),
	}
}

// Equals checks for equality with another EncounterDiagnosis instance
func (m *EncounterDiagnosis) Equals(other *EncounterDiagnosis) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Condition.Equals(other.Condition) { return false }
	if !m.Use.Equals(other.Use) { return false }
	if !m.Rank.Equals(other.Rank) { return false }
	return true
}

// EncounterHospitalization
// Details about the admission to a healthcare service.
type EncounterHospitalization struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	PreAdmissionIdentifier *Identifier `json:"preadmissionidentifier,omitempty"`
	Origin *Reference `json:"origin,omitempty"`
	AdmitSource *CodeableConcept `json:"admitsource,omitempty"`
	ReAdmission *CodeableConcept `json:"readmission,omitempty"`
	DietPreference []*CodeableConcept `json:"dietpreference,omitempty"`
	SpecialCourtesy []*CodeableConcept `json:"specialcourtesy,omitempty"`
	SpecialArrangement []*CodeableConcept `json:"specialarrangement,omitempty"`
	Destination *Reference `json:"destination,omitempty"`
	DischargeDisposition *CodeableConcept `json:"dischargedisposition,omitempty"`
}

// NewEncounterHospitalization creates a new EncounterHospitalization instance
func NewEncounterHospitalization() *EncounterHospitalization {
	return &EncounterHospitalization{}
}

// FromJSON populates EncounterHospitalization from JSON data
func (m *EncounterHospitalization) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EncounterHospitalization to JSON data
func (m *EncounterHospitalization) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EncounterHospitalization
func (m *EncounterHospitalization) Clone() *EncounterHospitalization {
	if m == nil { return nil }
	return &EncounterHospitalization{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		PreAdmissionIdentifier: m.PreAdmissionIdentifier.Clone(),
		Origin: m.Origin.Clone(),
		AdmitSource: m.AdmitSource.Clone(),
		ReAdmission: m.ReAdmission.Clone(),
		DietPreference: cloneSlices(m.DietPreference),
		SpecialCourtesy: cloneSlices(m.SpecialCourtesy),
		SpecialArrangement: cloneSlices(m.SpecialArrangement),
		Destination: m.Destination.Clone(),
		DischargeDisposition: m.DischargeDisposition.Clone(),
	}
}

// Equals checks for equality with another EncounterHospitalization instance
func (m *EncounterHospitalization) Equals(other *EncounterHospitalization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.PreAdmissionIdentifier.Equals(other.PreAdmissionIdentifier) { return false }
	if !m.Origin.Equals(other.Origin) { return false }
	if !m.AdmitSource.Equals(other.AdmitSource) { return false }
	if !m.ReAdmission.Equals(other.ReAdmission) { return false }
	if !compareSlices(m.DietPreference, other.DietPreference) { return false }
	if !compareSlices(m.SpecialCourtesy, other.SpecialCourtesy) { return false }
	if !compareSlices(m.SpecialArrangement, other.SpecialArrangement) { return false }
	if !m.Destination.Equals(other.Destination) { return false }
	if !m.DischargeDisposition.Equals(other.DischargeDisposition) { return false }
	return true
}

// EncounterLocation
// List of locations where  the patient has been during this encounter.
type EncounterLocation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Status *EncounterLocationStatus `json:"status,omitempty"`
	PhysicalType *CodeableConcept `json:"physicaltype,omitempty"`
	Period *Period `json:"period,omitempty"`
}

// NewEncounterLocation creates a new EncounterLocation instance
func NewEncounterLocation() *EncounterLocation {
	return &EncounterLocation{}
}

// FromJSON populates EncounterLocation from JSON data
func (m *EncounterLocation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EncounterLocation to JSON data
func (m *EncounterLocation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EncounterLocation
func (m *EncounterLocation) Clone() *EncounterLocation {
	if m == nil { return nil }
	return &EncounterLocation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Location: m.Location.Clone(),
		Status: m.Status.Clone(),
		PhysicalType: m.PhysicalType.Clone(),
		Period: m.Period.Clone(),
	}
}

// Equals checks for equality with another EncounterLocation instance
func (m *EncounterLocation) Equals(other *EncounterLocation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.PhysicalType.Equals(other.PhysicalType) { return false }
	if !m.Period.Equals(other.Period) { return false }
	return true
}

