// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Organization
// A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
type Organization struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Active *FhirBoolean `json:"active,omitempty"`
	Type []*CodeableConcept `json:"type,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Alias []*FhirString `json:"alias,omitempty"`
	Telecom []*ContactPoint `json:"telecom,omitempty"`
	Address []*Address `json:"address,omitempty"`
	PartOf *Reference `json:"partof,omitempty"`
	Contact []*OrganizationContact `json:"contact,omitempty"`
	Endpoint []*Reference `json:"endpoint,omitempty"`
}

// NewOrganization creates a new Organization instance
func NewOrganization() *Organization {
	return &Organization{}
}

// FromJSON populates Organization from JSON data
func (m *Organization) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Organization to JSON data
func (m *Organization) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Organization
func (m *Organization) Clone() *Organization {
	if m == nil { return nil }
	return &Organization{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Active: m.Active.Clone(),
		Type: cloneSlices(m.Type),
		Name: m.Name.Clone(),
		Alias: cloneSlices(m.Alias),
		Telecom: cloneSlices(m.Telecom),
		Address: cloneSlices(m.Address),
		PartOf: m.PartOf.Clone(),
		Contact: cloneSlices(m.Contact),
		Endpoint: cloneSlices(m.Endpoint),
	}
}

// Equals checks for equality with another Organization instance
func (m *Organization) Equals(other *Organization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Active.Equals(other.Active) { return false }
	if !compareSlices(m.Type, other.Type) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !compareSlices(m.Alias, other.Alias) { return false }
	if !compareSlices(m.Telecom, other.Telecom) { return false }
	if !compareSlices(m.Address, other.Address) { return false }
	if !m.PartOf.Equals(other.PartOf) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !compareSlices(m.Endpoint, other.Endpoint) { return false }
	return true
}

// OrganizationContact
// Contact for the organization for a certain purpose.
type OrganizationContact struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Purpose *CodeableConcept `json:"purpose,omitempty"`
	Name *HumanName `json:"name,omitempty"`
	Telecom []*ContactPoint `json:"telecom,omitempty"`
	Address *Address `json:"address,omitempty"`
}

// NewOrganizationContact creates a new OrganizationContact instance
func NewOrganizationContact() *OrganizationContact {
	return &OrganizationContact{}
}

// FromJSON populates OrganizationContact from JSON data
func (m *OrganizationContact) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts OrganizationContact to JSON data
func (m *OrganizationContact) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of OrganizationContact
func (m *OrganizationContact) Clone() *OrganizationContact {
	if m == nil { return nil }
	return &OrganizationContact{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Purpose: m.Purpose.Clone(),
		Name: m.Name.Clone(),
		Telecom: cloneSlices(m.Telecom),
		Address: m.Address.Clone(),
	}
}

// Equals checks for equality with another OrganizationContact instance
func (m *OrganizationContact) Equals(other *OrganizationContact) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !compareSlices(m.Telecom, other.Telecom) { return false }
	if !m.Address.Equals(other.Address) { return false }
	return true
}

