// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// AdverseEvent
// Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death.
type AdverseEvent struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Actuality *AdverseEventActuality `json:"actuality,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Event *CodeableConcept `json:"event,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Detected *FhirDateTime `json:"detected,omitempty"`
	RecordedDate *FhirDateTime `json:"recordeddate,omitempty"`
	ResultingCondition []*Reference `json:"resultingcondition,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Seriousness *CodeableConcept `json:"seriousness,omitempty"`
	Severity *CodeableConcept `json:"severity,omitempty"`
	Outcome *CodeableConcept `json:"outcome,omitempty"`
	Recorder *Reference `json:"recorder,omitempty"`
	Contributor []*Reference `json:"contributor,omitempty"`
	SuspectEntity []*AdverseEventSuspectEntity `json:"suspectentity,omitempty"`
	SubjectMedicalHistory []*Reference `json:"subjectmedicalhistory,omitempty"`
	ReferenceDocument []*Reference `json:"referencedocument,omitempty"`
	Study []*Reference `json:"study,omitempty"`
}

// NewAdverseEvent creates a new AdverseEvent instance
func NewAdverseEvent() *AdverseEvent {
	return &AdverseEvent{}
}

// FromJSON populates AdverseEvent from JSON data
func (m *AdverseEvent) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdverseEvent to JSON data
func (m *AdverseEvent) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdverseEvent
func (m *AdverseEvent) Clone() *AdverseEvent {
	if m == nil { return nil }
	return &AdverseEvent{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Actuality: m.Actuality.Clone(),
		Category: cloneSlices(m.Category),
		Event: m.Event.Clone(),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		Date: m.Date.Clone(),
		Detected: m.Detected.Clone(),
		RecordedDate: m.RecordedDate.Clone(),
		ResultingCondition: cloneSlices(m.ResultingCondition),
		Location: m.Location.Clone(),
		Seriousness: m.Seriousness.Clone(),
		Severity: m.Severity.Clone(),
		Outcome: m.Outcome.Clone(),
		Recorder: m.Recorder.Clone(),
		Contributor: cloneSlices(m.Contributor),
		SuspectEntity: cloneSlices(m.SuspectEntity),
		SubjectMedicalHistory: cloneSlices(m.SubjectMedicalHistory),
		ReferenceDocument: cloneSlices(m.ReferenceDocument),
		Study: cloneSlices(m.Study),
	}
}

// Equals checks for equality with another AdverseEvent instance
func (m *AdverseEvent) Equals(other *AdverseEvent) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Actuality.Equals(other.Actuality) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Event.Equals(other.Event) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Detected.Equals(other.Detected) { return false }
	if !m.RecordedDate.Equals(other.RecordedDate) { return false }
	if !compareSlices(m.ResultingCondition, other.ResultingCondition) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.Seriousness.Equals(other.Seriousness) { return false }
	if !m.Severity.Equals(other.Severity) { return false }
	if !m.Outcome.Equals(other.Outcome) { return false }
	if !m.Recorder.Equals(other.Recorder) { return false }
	if !compareSlices(m.Contributor, other.Contributor) { return false }
	if !compareSlices(m.SuspectEntity, other.SuspectEntity) { return false }
	if !compareSlices(m.SubjectMedicalHistory, other.SubjectMedicalHistory) { return false }
	if !compareSlices(m.ReferenceDocument, other.ReferenceDocument) { return false }
	if !compareSlices(m.Study, other.Study) { return false }
	return true
}

// AdverseEventSuspectEntity
// Describes the entity that is suspected to have caused the adverse event.
type AdverseEventSuspectEntity struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Instance *Reference `json:"instance,omitempty"`
	Causality []*AdverseEventCausality `json:"causality,omitempty"`
}

// NewAdverseEventSuspectEntity creates a new AdverseEventSuspectEntity instance
func NewAdverseEventSuspectEntity() *AdverseEventSuspectEntity {
	return &AdverseEventSuspectEntity{}
}

// FromJSON populates AdverseEventSuspectEntity from JSON data
func (m *AdverseEventSuspectEntity) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdverseEventSuspectEntity to JSON data
func (m *AdverseEventSuspectEntity) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdverseEventSuspectEntity
func (m *AdverseEventSuspectEntity) Clone() *AdverseEventSuspectEntity {
	if m == nil { return nil }
	return &AdverseEventSuspectEntity{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Instance: m.Instance.Clone(),
		Causality: cloneSlices(m.Causality),
	}
}

// Equals checks for equality with another AdverseEventSuspectEntity instance
func (m *AdverseEventSuspectEntity) Equals(other *AdverseEventSuspectEntity) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Instance.Equals(other.Instance) { return false }
	if !compareSlices(m.Causality, other.Causality) { return false }
	return true
}

// AdverseEventCausality
// Information on the possible cause of the event.
type AdverseEventCausality struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Assessment *CodeableConcept `json:"assessment,omitempty"`
	ProductRelatedness *FhirString `json:"productrelatedness,omitempty"`
	Author *Reference `json:"author,omitempty"`
	Method *CodeableConcept `json:"method,omitempty"`
}

// NewAdverseEventCausality creates a new AdverseEventCausality instance
func NewAdverseEventCausality() *AdverseEventCausality {
	return &AdverseEventCausality{}
}

// FromJSON populates AdverseEventCausality from JSON data
func (m *AdverseEventCausality) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts AdverseEventCausality to JSON data
func (m *AdverseEventCausality) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of AdverseEventCausality
func (m *AdverseEventCausality) Clone() *AdverseEventCausality {
	if m == nil { return nil }
	return &AdverseEventCausality{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Assessment: m.Assessment.Clone(),
		ProductRelatedness: m.ProductRelatedness.Clone(),
		Author: m.Author.Clone(),
		Method: m.Method.Clone(),
	}
}

// Equals checks for equality with another AdverseEventCausality instance
func (m *AdverseEventCausality) Equals(other *AdverseEventCausality) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Assessment.Equals(other.Assessment) { return false }
	if !m.ProductRelatedness.Equals(other.ProductRelatedness) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !m.Method.Equals(other.Method) { return false }
	return true
}

