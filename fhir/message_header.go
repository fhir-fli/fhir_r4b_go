// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// MessageHeader
// The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
type MessageHeader struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	EventCoding *Coding `json:"eventcoding,omitempty"`
	EventUri *FhirUri `json:"eventuri,omitempty"`
	Destination []*MessageHeaderDestination `json:"destination,omitempty"`
	Sender *Reference `json:"sender,omitempty"`
	Enterer *Reference `json:"enterer,omitempty"`
	Author *Reference `json:"author,omitempty"`
	Source *MessageHeaderSource `json:"source,omitempty"`
	Responsible *Reference `json:"responsible,omitempty"`
	Reason *CodeableConcept `json:"reason,omitempty"`
	Response *MessageHeaderResponse `json:"response,omitempty"`
	Focus []*Reference `json:"focus,omitempty"`
	Definition *FhirCanonical `json:"definition,omitempty"`
}

// NewMessageHeader creates a new MessageHeader instance
func NewMessageHeader() *MessageHeader {
	return &MessageHeader{}
}

// FromJSON populates MessageHeader from JSON data
func (m *MessageHeader) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MessageHeader to JSON data
func (m *MessageHeader) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MessageHeader
func (m *MessageHeader) Clone() *MessageHeader {
	if m == nil { return nil }
	return &MessageHeader{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		EventCoding: m.EventCoding.Clone(),
		EventUri: m.EventUri.Clone(),
		Destination: cloneSlices(m.Destination),
		Sender: m.Sender.Clone(),
		Enterer: m.Enterer.Clone(),
		Author: m.Author.Clone(),
		Source: m.Source.Clone(),
		Responsible: m.Responsible.Clone(),
		Reason: m.Reason.Clone(),
		Response: m.Response.Clone(),
		Focus: cloneSlices(m.Focus),
		Definition: m.Definition.Clone(),
	}
}

// Equals checks for equality with another MessageHeader instance
func (m *MessageHeader) Equals(other *MessageHeader) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.EventCoding.Equals(other.EventCoding) { return false }
	if !m.EventUri.Equals(other.EventUri) { return false }
	if !compareSlices(m.Destination, other.Destination) { return false }
	if !m.Sender.Equals(other.Sender) { return false }
	if !m.Enterer.Equals(other.Enterer) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !m.Responsible.Equals(other.Responsible) { return false }
	if !m.Reason.Equals(other.Reason) { return false }
	if !m.Response.Equals(other.Response) { return false }
	if !compareSlices(m.Focus, other.Focus) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	return true
}

// MessageHeaderDestination
// The destination application which the message is intended for.
type MessageHeaderDestination struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Target *Reference `json:"target,omitempty"`
	Endpoint *FhirUrl `json:"endpoint,omitempty"`
	Receiver *Reference `json:"receiver,omitempty"`
}

// NewMessageHeaderDestination creates a new MessageHeaderDestination instance
func NewMessageHeaderDestination() *MessageHeaderDestination {
	return &MessageHeaderDestination{}
}

// FromJSON populates MessageHeaderDestination from JSON data
func (m *MessageHeaderDestination) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MessageHeaderDestination to JSON data
func (m *MessageHeaderDestination) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MessageHeaderDestination
func (m *MessageHeaderDestination) Clone() *MessageHeaderDestination {
	if m == nil { return nil }
	return &MessageHeaderDestination{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Target: m.Target.Clone(),
		Endpoint: m.Endpoint.Clone(),
		Receiver: m.Receiver.Clone(),
	}
}

// Equals checks for equality with another MessageHeaderDestination instance
func (m *MessageHeaderDestination) Equals(other *MessageHeaderDestination) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Target.Equals(other.Target) { return false }
	if !m.Endpoint.Equals(other.Endpoint) { return false }
	if !m.Receiver.Equals(other.Receiver) { return false }
	return true
}

// MessageHeaderSource
// The source application from which this message originated.
type MessageHeaderSource struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Software *FhirString `json:"software,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Contact *ContactPoint `json:"contact,omitempty"`
	Endpoint *FhirUrl `json:"endpoint,omitempty"`
}

// NewMessageHeaderSource creates a new MessageHeaderSource instance
func NewMessageHeaderSource() *MessageHeaderSource {
	return &MessageHeaderSource{}
}

// FromJSON populates MessageHeaderSource from JSON data
func (m *MessageHeaderSource) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MessageHeaderSource to JSON data
func (m *MessageHeaderSource) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MessageHeaderSource
func (m *MessageHeaderSource) Clone() *MessageHeaderSource {
	if m == nil { return nil }
	return &MessageHeaderSource{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Software: m.Software.Clone(),
		Version: m.Version.Clone(),
		Contact: m.Contact.Clone(),
		Endpoint: m.Endpoint.Clone(),
	}
}

// Equals checks for equality with another MessageHeaderSource instance
func (m *MessageHeaderSource) Equals(other *MessageHeaderSource) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Software.Equals(other.Software) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Contact.Equals(other.Contact) { return false }
	if !m.Endpoint.Equals(other.Endpoint) { return false }
	return true
}

// MessageHeaderResponse
// Information about the message that this message is a response to.  Only present if this message is a response.
type MessageHeaderResponse struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *FhirId `json:"identifier,omitempty"`
	Code *ResponseType `json:"code,omitempty"`
	Details *Reference `json:"details,omitempty"`
}

// NewMessageHeaderResponse creates a new MessageHeaderResponse instance
func NewMessageHeaderResponse() *MessageHeaderResponse {
	return &MessageHeaderResponse{}
}

// FromJSON populates MessageHeaderResponse from JSON data
func (m *MessageHeaderResponse) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts MessageHeaderResponse to JSON data
func (m *MessageHeaderResponse) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of MessageHeaderResponse
func (m *MessageHeaderResponse) Clone() *MessageHeaderResponse {
	if m == nil { return nil }
	return &MessageHeaderResponse{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Code: m.Code.Clone(),
		Details: m.Details.Clone(),
	}
}

// Equals checks for equality with another MessageHeaderResponse instance
func (m *MessageHeaderResponse) Equals(other *MessageHeaderResponse) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Details.Equals(other.Details) { return false }
	return true
}

