// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Evidence
// The Evidence Resource provides a machine-interpretable expression of an evidence concept including the evidence variables (eg population, exposures/interventions, comparators, outcomes, measured variables, confounding variables), the statistics, and the certainty of this evidence.
type Evidence struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	CiteAsReference *Reference `json:"citeasreference,omitempty"`
	CiteAsMarkdown *FhirMarkdown `json:"citeasmarkdown,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	ApprovalDate *FhirDate `json:"approvaldate,omitempty"`
	LastReviewDate *FhirDate `json:"lastreviewdate,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Author []*ContactDetail `json:"author,omitempty"`
	Editor []*ContactDetail `json:"editor,omitempty"`
	Reviewer []*ContactDetail `json:"reviewer,omitempty"`
	Endorser []*ContactDetail `json:"endorser,omitempty"`
	RelatedArtifact []*RelatedArtifact `json:"relatedartifact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Assertion *FhirMarkdown `json:"assertion,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	VariableDefinition []*EvidenceVariableDefinition `json:"variabledefinition,omitempty"`
	SynthesisType *CodeableConcept `json:"synthesistype,omitempty"`
	StudyType *CodeableConcept `json:"studytype,omitempty"`
	Statistic []*EvidenceStatistic `json:"statistic,omitempty"`
	Certainty []*EvidenceCertainty `json:"certainty,omitempty"`
}

// NewEvidence creates a new Evidence instance
func NewEvidence() *Evidence {
	return &Evidence{}
}

// FromJSON populates Evidence from JSON data
func (m *Evidence) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Evidence to JSON data
func (m *Evidence) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Evidence
func (m *Evidence) Clone() *Evidence {
	if m == nil { return nil }
	return &Evidence{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Title: m.Title.Clone(),
		CiteAsReference: m.CiteAsReference.Clone(),
		CiteAsMarkdown: m.CiteAsMarkdown.Clone(),
		Status: m.Status.Clone(),
		Date: m.Date.Clone(),
		UseContext: cloneSlices(m.UseContext),
		ApprovalDate: m.ApprovalDate.Clone(),
		LastReviewDate: m.LastReviewDate.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Author: cloneSlices(m.Author),
		Editor: cloneSlices(m.Editor),
		Reviewer: cloneSlices(m.Reviewer),
		Endorser: cloneSlices(m.Endorser),
		RelatedArtifact: cloneSlices(m.RelatedArtifact),
		Description: m.Description.Clone(),
		Assertion: m.Assertion.Clone(),
		Note: cloneSlices(m.Note),
		VariableDefinition: cloneSlices(m.VariableDefinition),
		SynthesisType: m.SynthesisType.Clone(),
		StudyType: m.StudyType.Clone(),
		Statistic: cloneSlices(m.Statistic),
		Certainty: cloneSlices(m.Certainty),
	}
}

// Equals checks for equality with another Evidence instance
func (m *Evidence) Equals(other *Evidence) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.CiteAsReference.Equals(other.CiteAsReference) { return false }
	if !m.CiteAsMarkdown.Equals(other.CiteAsMarkdown) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !m.ApprovalDate.Equals(other.ApprovalDate) { return false }
	if !m.LastReviewDate.Equals(other.LastReviewDate) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !compareSlices(m.Author, other.Author) { return false }
	if !compareSlices(m.Editor, other.Editor) { return false }
	if !compareSlices(m.Reviewer, other.Reviewer) { return false }
	if !compareSlices(m.Endorser, other.Endorser) { return false }
	if !compareSlices(m.RelatedArtifact, other.RelatedArtifact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Assertion.Equals(other.Assertion) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.VariableDefinition, other.VariableDefinition) { return false }
	if !m.SynthesisType.Equals(other.SynthesisType) { return false }
	if !m.StudyType.Equals(other.StudyType) { return false }
	if !compareSlices(m.Statistic, other.Statistic) { return false }
	if !compareSlices(m.Certainty, other.Certainty) { return false }
	return true
}

// EvidenceVariableDefinition
// Evidence variable such as population, exposure, or outcome.
type EvidenceVariableDefinition struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	VariableRole *CodeableConcept `json:"variablerole,omitempty"`
	Observed *Reference `json:"observed,omitempty"`
	Intended *Reference `json:"intended,omitempty"`
	DirectnessMatch *CodeableConcept `json:"directnessmatch,omitempty"`
}

// NewEvidenceVariableDefinition creates a new EvidenceVariableDefinition instance
func NewEvidenceVariableDefinition() *EvidenceVariableDefinition {
	return &EvidenceVariableDefinition{}
}

// FromJSON populates EvidenceVariableDefinition from JSON data
func (m *EvidenceVariableDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceVariableDefinition to JSON data
func (m *EvidenceVariableDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceVariableDefinition
func (m *EvidenceVariableDefinition) Clone() *EvidenceVariableDefinition {
	if m == nil { return nil }
	return &EvidenceVariableDefinition{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		VariableRole: m.VariableRole.Clone(),
		Observed: m.Observed.Clone(),
		Intended: m.Intended.Clone(),
		DirectnessMatch: m.DirectnessMatch.Clone(),
	}
}

// Equals checks for equality with another EvidenceVariableDefinition instance
func (m *EvidenceVariableDefinition) Equals(other *EvidenceVariableDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.VariableRole.Equals(other.VariableRole) { return false }
	if !m.Observed.Equals(other.Observed) { return false }
	if !m.Intended.Equals(other.Intended) { return false }
	if !m.DirectnessMatch.Equals(other.DirectnessMatch) { return false }
	return true
}

// EvidenceStatistic
// Values and parameters for a single statistic.
type EvidenceStatistic struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	StatisticType *CodeableConcept `json:"statistictype,omitempty"`
	Category *CodeableConcept `json:"category,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	NumberOfEvents *FhirUnsignedInt `json:"numberofevents,omitempty"`
	NumberAffected *FhirUnsignedInt `json:"numberaffected,omitempty"`
	SampleSize *EvidenceSampleSize `json:"samplesize,omitempty"`
	AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
	ModelCharacteristic []*EvidenceModelCharacteristic `json:"modelcharacteristic,omitempty"`
}

// NewEvidenceStatistic creates a new EvidenceStatistic instance
func NewEvidenceStatistic() *EvidenceStatistic {
	return &EvidenceStatistic{}
}

// FromJSON populates EvidenceStatistic from JSON data
func (m *EvidenceStatistic) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceStatistic to JSON data
func (m *EvidenceStatistic) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceStatistic
func (m *EvidenceStatistic) Clone() *EvidenceStatistic {
	if m == nil { return nil }
	return &EvidenceStatistic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		StatisticType: m.StatisticType.Clone(),
		Category: m.Category.Clone(),
		Quantity: m.Quantity.Clone(),
		NumberOfEvents: m.NumberOfEvents.Clone(),
		NumberAffected: m.NumberAffected.Clone(),
		SampleSize: m.SampleSize.Clone(),
		AttributeEstimate: cloneSlices(m.AttributeEstimate),
		ModelCharacteristic: cloneSlices(m.ModelCharacteristic),
	}
}

// Equals checks for equality with another EvidenceStatistic instance
func (m *EvidenceStatistic) Equals(other *EvidenceStatistic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.StatisticType.Equals(other.StatisticType) { return false }
	if !m.Category.Equals(other.Category) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.NumberOfEvents.Equals(other.NumberOfEvents) { return false }
	if !m.NumberAffected.Equals(other.NumberAffected) { return false }
	if !m.SampleSize.Equals(other.SampleSize) { return false }
	if !compareSlices(m.AttributeEstimate, other.AttributeEstimate) { return false }
	if !compareSlices(m.ModelCharacteristic, other.ModelCharacteristic) { return false }
	return true
}

// EvidenceSampleSize
// Number of samples in the statistic.
type EvidenceSampleSize struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	NumberOfStudies *FhirUnsignedInt `json:"numberofstudies,omitempty"`
	NumberOfParticipants *FhirUnsignedInt `json:"numberofparticipants,omitempty"`
	KnownDataCount *FhirUnsignedInt `json:"knowndatacount,omitempty"`
}

// NewEvidenceSampleSize creates a new EvidenceSampleSize instance
func NewEvidenceSampleSize() *EvidenceSampleSize {
	return &EvidenceSampleSize{}
}

// FromJSON populates EvidenceSampleSize from JSON data
func (m *EvidenceSampleSize) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceSampleSize to JSON data
func (m *EvidenceSampleSize) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceSampleSize
func (m *EvidenceSampleSize) Clone() *EvidenceSampleSize {
	if m == nil { return nil }
	return &EvidenceSampleSize{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		NumberOfStudies: m.NumberOfStudies.Clone(),
		NumberOfParticipants: m.NumberOfParticipants.Clone(),
		KnownDataCount: m.KnownDataCount.Clone(),
	}
}

// Equals checks for equality with another EvidenceSampleSize instance
func (m *EvidenceSampleSize) Equals(other *EvidenceSampleSize) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.NumberOfStudies.Equals(other.NumberOfStudies) { return false }
	if !m.NumberOfParticipants.Equals(other.NumberOfParticipants) { return false }
	if !m.KnownDataCount.Equals(other.KnownDataCount) { return false }
	return true
}

// EvidenceAttributeEstimate
// A statistical attribute of the statistic such as a measure of heterogeneity.
type EvidenceAttributeEstimate struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Quantity *Quantity `json:"quantity,omitempty"`
	Level *FhirDecimal `json:"level,omitempty"`
	Range *Range `json:"range,omitempty"`
	AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
}

// NewEvidenceAttributeEstimate creates a new EvidenceAttributeEstimate instance
func NewEvidenceAttributeEstimate() *EvidenceAttributeEstimate {
	return &EvidenceAttributeEstimate{}
}

// FromJSON populates EvidenceAttributeEstimate from JSON data
func (m *EvidenceAttributeEstimate) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceAttributeEstimate to JSON data
func (m *EvidenceAttributeEstimate) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceAttributeEstimate
func (m *EvidenceAttributeEstimate) Clone() *EvidenceAttributeEstimate {
	if m == nil { return nil }
	return &EvidenceAttributeEstimate{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		Type: m.Type.Clone(),
		Quantity: m.Quantity.Clone(),
		Level: m.Level.Clone(),
		Range: m.Range.Clone(),
		AttributeEstimate: cloneSlices(m.AttributeEstimate),
	}
}

// Equals checks for equality with another EvidenceAttributeEstimate instance
func (m *EvidenceAttributeEstimate) Equals(other *EvidenceAttributeEstimate) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Quantity.Equals(other.Quantity) { return false }
	if !m.Level.Equals(other.Level) { return false }
	if !m.Range.Equals(other.Range) { return false }
	if !compareSlices(m.AttributeEstimate, other.AttributeEstimate) { return false }
	return true
}

// EvidenceModelCharacteristic
// A component of the method to generate the statistic.
type EvidenceModelCharacteristic struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Value *Quantity `json:"value,omitempty"`
	Variable []*EvidenceModelCharacteristicVariable `json:"variable,omitempty"`
	AttributeEstimate []*EvidenceAttributeEstimate `json:"attributeestimate,omitempty"`
}

// NewEvidenceModelCharacteristic creates a new EvidenceModelCharacteristic instance
func NewEvidenceModelCharacteristic() *EvidenceModelCharacteristic {
	return &EvidenceModelCharacteristic{}
}

// FromJSON populates EvidenceModelCharacteristic from JSON data
func (m *EvidenceModelCharacteristic) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceModelCharacteristic to JSON data
func (m *EvidenceModelCharacteristic) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceModelCharacteristic
func (m *EvidenceModelCharacteristic) Clone() *EvidenceModelCharacteristic {
	if m == nil { return nil }
	return &EvidenceModelCharacteristic{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Value: m.Value.Clone(),
		Variable: cloneSlices(m.Variable),
		AttributeEstimate: cloneSlices(m.AttributeEstimate),
	}
}

// Equals checks for equality with another EvidenceModelCharacteristic instance
func (m *EvidenceModelCharacteristic) Equals(other *EvidenceModelCharacteristic) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !compareSlices(m.Variable, other.Variable) { return false }
	if !compareSlices(m.AttributeEstimate, other.AttributeEstimate) { return false }
	return true
}

// EvidenceModelCharacteristicVariable
// A variable adjusted for in the adjusted analysis.
type EvidenceModelCharacteristicVariable struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	VariableDefinition *Reference `json:"variabledefinition,omitempty"`
	Handling *EvidenceVariableHandling `json:"handling,omitempty"`
	ValueCategory []*CodeableConcept `json:"valuecategory,omitempty"`
	ValueQuantity []*Quantity `json:"valuequantity,omitempty"`
	ValueRange []*Range `json:"valuerange,omitempty"`
}

// NewEvidenceModelCharacteristicVariable creates a new EvidenceModelCharacteristicVariable instance
func NewEvidenceModelCharacteristicVariable() *EvidenceModelCharacteristicVariable {
	return &EvidenceModelCharacteristicVariable{}
}

// FromJSON populates EvidenceModelCharacteristicVariable from JSON data
func (m *EvidenceModelCharacteristicVariable) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceModelCharacteristicVariable to JSON data
func (m *EvidenceModelCharacteristicVariable) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceModelCharacteristicVariable
func (m *EvidenceModelCharacteristicVariable) Clone() *EvidenceModelCharacteristicVariable {
	if m == nil { return nil }
	return &EvidenceModelCharacteristicVariable{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		VariableDefinition: m.VariableDefinition.Clone(),
		Handling: m.Handling.Clone(),
		ValueCategory: cloneSlices(m.ValueCategory),
		ValueQuantity: cloneSlices(m.ValueQuantity),
		ValueRange: cloneSlices(m.ValueRange),
	}
}

// Equals checks for equality with another EvidenceModelCharacteristicVariable instance
func (m *EvidenceModelCharacteristicVariable) Equals(other *EvidenceModelCharacteristicVariable) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.VariableDefinition.Equals(other.VariableDefinition) { return false }
	if !m.Handling.Equals(other.Handling) { return false }
	if !compareSlices(m.ValueCategory, other.ValueCategory) { return false }
	if !compareSlices(m.ValueQuantity, other.ValueQuantity) { return false }
	if !compareSlices(m.ValueRange, other.ValueRange) { return false }
	return true
}

// EvidenceCertainty
// Assessment of certainty, confidence in the estimates, or quality of the evidence.
type EvidenceCertainty struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Rating *CodeableConcept `json:"rating,omitempty"`
	Rater *FhirString `json:"rater,omitempty"`
	Subcomponent []*EvidenceCertainty `json:"subcomponent,omitempty"`
}

// NewEvidenceCertainty creates a new EvidenceCertainty instance
func NewEvidenceCertainty() *EvidenceCertainty {
	return &EvidenceCertainty{}
}

// FromJSON populates EvidenceCertainty from JSON data
func (m *EvidenceCertainty) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts EvidenceCertainty to JSON data
func (m *EvidenceCertainty) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of EvidenceCertainty
func (m *EvidenceCertainty) Clone() *EvidenceCertainty {
	if m == nil { return nil }
	return &EvidenceCertainty{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Note: cloneSlices(m.Note),
		Type: m.Type.Clone(),
		Rating: m.Rating.Clone(),
		Rater: m.Rater.Clone(),
		Subcomponent: cloneSlices(m.Subcomponent),
	}
}

// Equals checks for equality with another EvidenceCertainty instance
func (m *EvidenceCertainty) Equals(other *EvidenceCertainty) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Rating.Equals(other.Rating) { return false }
	if !m.Rater.Equals(other.Rater) { return false }
	if !compareSlices(m.Subcomponent, other.Subcomponent) { return false }
	return true
}

