// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// CapabilityStatement
// A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server for a particular version of FHIR that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
type CapabilityStatement struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	Kind *CapabilityStatementKind `json:"kind,omitempty"`
	Instantiates []*FhirCanonical `json:"instantiates,omitempty"`
	Imports []*FhirCanonical `json:"imports,omitempty"`
	Software *CapabilityStatementSoftware `json:"software,omitempty"`
	Implementation *CapabilityStatementImplementation `json:"implementation,omitempty"`
	FhirVersion *FHIRVersion `json:"fhirversion,omitempty"`
	Format []*FhirCode `json:"format,omitempty"`
	PatchFormat []*FhirCode `json:"patchformat,omitempty"`
	ImplementationGuide []*FhirCanonical `json:"implementationguide,omitempty"`
	Rest []*CapabilityStatementRest `json:"rest,omitempty"`
	Messaging []*CapabilityStatementMessaging `json:"messaging,omitempty"`
	Document []*CapabilityStatementDocument `json:"document,omitempty"`
}

// NewCapabilityStatement creates a new CapabilityStatement instance
func NewCapabilityStatement() *CapabilityStatement {
	return &CapabilityStatement{}
}

// FromJSON populates CapabilityStatement from JSON data
func (m *CapabilityStatement) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatement to JSON data
func (m *CapabilityStatement) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatement
func (m *CapabilityStatement) Clone() *CapabilityStatement {
	if m == nil { return nil }
	return &CapabilityStatement{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		Kind: m.Kind.Clone(),
		Instantiates: cloneSlices(m.Instantiates),
		Imports: cloneSlices(m.Imports),
		Software: m.Software.Clone(),
		Implementation: m.Implementation.Clone(),
		FhirVersion: m.FhirVersion.Clone(),
		Format: cloneSlices(m.Format),
		PatchFormat: cloneSlices(m.PatchFormat),
		ImplementationGuide: cloneSlices(m.ImplementationGuide),
		Rest: cloneSlices(m.Rest),
		Messaging: cloneSlices(m.Messaging),
		Document: cloneSlices(m.Document),
	}
}

// Equals checks for equality with another CapabilityStatement instance
func (m *CapabilityStatement) Equals(other *CapabilityStatement) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !m.Kind.Equals(other.Kind) { return false }
	if !compareSlices(m.Instantiates, other.Instantiates) { return false }
	if !compareSlices(m.Imports, other.Imports) { return false }
	if !m.Software.Equals(other.Software) { return false }
	if !m.Implementation.Equals(other.Implementation) { return false }
	if !m.FhirVersion.Equals(other.FhirVersion) { return false }
	if !compareSlices(m.Format, other.Format) { return false }
	if !compareSlices(m.PatchFormat, other.PatchFormat) { return false }
	if !compareSlices(m.ImplementationGuide, other.ImplementationGuide) { return false }
	if !compareSlices(m.Rest, other.Rest) { return false }
	if !compareSlices(m.Messaging, other.Messaging) { return false }
	if !compareSlices(m.Document, other.Document) { return false }
	return true
}

// CapabilityStatementSoftware
// Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
type CapabilityStatementSoftware struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	ReleaseDate *FhirDateTime `json:"releasedate,omitempty"`
}

// NewCapabilityStatementSoftware creates a new CapabilityStatementSoftware instance
func NewCapabilityStatementSoftware() *CapabilityStatementSoftware {
	return &CapabilityStatementSoftware{}
}

// FromJSON populates CapabilityStatementSoftware from JSON data
func (m *CapabilityStatementSoftware) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementSoftware to JSON data
func (m *CapabilityStatementSoftware) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementSoftware
func (m *CapabilityStatementSoftware) Clone() *CapabilityStatementSoftware {
	if m == nil { return nil }
	return &CapabilityStatementSoftware{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Version: m.Version.Clone(),
		ReleaseDate: m.ReleaseDate.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementSoftware instance
func (m *CapabilityStatementSoftware) Equals(other *CapabilityStatementSoftware) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.ReleaseDate.Equals(other.ReleaseDate) { return false }
	return true
}

// CapabilityStatementImplementation
// Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
type CapabilityStatementImplementation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Description *FhirString `json:"description,omitempty"`
	Url *FhirUrl `json:"url,omitempty"`
	Custodian *Reference `json:"custodian,omitempty"`
}

// NewCapabilityStatementImplementation creates a new CapabilityStatementImplementation instance
func NewCapabilityStatementImplementation() *CapabilityStatementImplementation {
	return &CapabilityStatementImplementation{}
}

// FromJSON populates CapabilityStatementImplementation from JSON data
func (m *CapabilityStatementImplementation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementImplementation to JSON data
func (m *CapabilityStatementImplementation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementImplementation
func (m *CapabilityStatementImplementation) Clone() *CapabilityStatementImplementation {
	if m == nil { return nil }
	return &CapabilityStatementImplementation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Description: m.Description.Clone(),
		Url: m.Url.Clone(),
		Custodian: m.Custodian.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementImplementation instance
func (m *CapabilityStatementImplementation) Equals(other *CapabilityStatementImplementation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Custodian.Equals(other.Custodian) { return false }
	return true
}

// CapabilityStatementRest
// A definition of the restful capabilities of the solution, if any.
type CapabilityStatementRest struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Mode *RestfulCapabilityMode `json:"mode,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
	Security *CapabilityStatementSecurity `json:"security,omitempty"`
	Resource []*CapabilityStatementResource `json:"resource,omitempty"`
	Interaction []*CapabilityStatementInteraction `json:"interaction,omitempty"`
	SearchParam []*CapabilityStatementSearchParam `json:"searchparam,omitempty"`
	Operation []*CapabilityStatementOperation `json:"operation,omitempty"`
	Compartment []*FhirCanonical `json:"compartment,omitempty"`
}

// NewCapabilityStatementRest creates a new CapabilityStatementRest instance
func NewCapabilityStatementRest() *CapabilityStatementRest {
	return &CapabilityStatementRest{}
}

// FromJSON populates CapabilityStatementRest from JSON data
func (m *CapabilityStatementRest) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementRest to JSON data
func (m *CapabilityStatementRest) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementRest
func (m *CapabilityStatementRest) Clone() *CapabilityStatementRest {
	if m == nil { return nil }
	return &CapabilityStatementRest{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Mode: m.Mode.Clone(),
		Documentation: m.Documentation.Clone(),
		Security: m.Security.Clone(),
		Resource: cloneSlices(m.Resource),
		Interaction: cloneSlices(m.Interaction),
		SearchParam: cloneSlices(m.SearchParam),
		Operation: cloneSlices(m.Operation),
		Compartment: cloneSlices(m.Compartment),
	}
}

// Equals checks for equality with another CapabilityStatementRest instance
func (m *CapabilityStatementRest) Equals(other *CapabilityStatementRest) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	if !m.Security.Equals(other.Security) { return false }
	if !compareSlices(m.Resource, other.Resource) { return false }
	if !compareSlices(m.Interaction, other.Interaction) { return false }
	if !compareSlices(m.SearchParam, other.SearchParam) { return false }
	if !compareSlices(m.Operation, other.Operation) { return false }
	if !compareSlices(m.Compartment, other.Compartment) { return false }
	return true
}

// CapabilityStatementSecurity
// Information about security implementation from an interface perspective - what a client needs to know.
type CapabilityStatementSecurity struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Cors *FhirBoolean `json:"cors,omitempty"`
	Service []*CodeableConcept `json:"service,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
}

// NewCapabilityStatementSecurity creates a new CapabilityStatementSecurity instance
func NewCapabilityStatementSecurity() *CapabilityStatementSecurity {
	return &CapabilityStatementSecurity{}
}

// FromJSON populates CapabilityStatementSecurity from JSON data
func (m *CapabilityStatementSecurity) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementSecurity to JSON data
func (m *CapabilityStatementSecurity) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementSecurity
func (m *CapabilityStatementSecurity) Clone() *CapabilityStatementSecurity {
	if m == nil { return nil }
	return &CapabilityStatementSecurity{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Cors: m.Cors.Clone(),
		Service: cloneSlices(m.Service),
		Description: m.Description.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementSecurity instance
func (m *CapabilityStatementSecurity) Equals(other *CapabilityStatementSecurity) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Cors.Equals(other.Cors) { return false }
	if !compareSlices(m.Service, other.Service) { return false }
	if !m.Description.Equals(other.Description) { return false }
	return true
}

// CapabilityStatementResource
// A specification of the restful capabilities of the solution for a specific resource type.
type CapabilityStatementResource struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *FhirCode `json:"type,omitempty"`
	Profile *FhirCanonical `json:"profile,omitempty"`
	SupportedProfile []*FhirCanonical `json:"supportedprofile,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
	Interaction []*CapabilityStatementInteraction `json:"interaction,omitempty"`
	Versioning *ResourceVersionPolicy `json:"versioning,omitempty"`
	ReadHistory *FhirBoolean `json:"readhistory,omitempty"`
	UpdateCreate *FhirBoolean `json:"updatecreate,omitempty"`
	ConditionalCreate *FhirBoolean `json:"conditionalcreate,omitempty"`
	ConditionalRead *ConditionalReadStatus `json:"conditionalread,omitempty"`
	ConditionalUpdate *FhirBoolean `json:"conditionalupdate,omitempty"`
	ConditionalDelete *ConditionalDeleteStatus `json:"conditionaldelete,omitempty"`
	ReferencePolicy []*ReferenceHandlingPolicy `json:"referencepolicy,omitempty"`
	SearchInclude []*FhirString `json:"searchinclude,omitempty"`
	SearchRevInclude []*FhirString `json:"searchrevinclude,omitempty"`
	SearchParam []*CapabilityStatementSearchParam `json:"searchparam,omitempty"`
	Operation []*CapabilityStatementOperation `json:"operation,omitempty"`
}

// NewCapabilityStatementResource creates a new CapabilityStatementResource instance
func NewCapabilityStatementResource() *CapabilityStatementResource {
	return &CapabilityStatementResource{}
}

// FromJSON populates CapabilityStatementResource from JSON data
func (m *CapabilityStatementResource) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementResource to JSON data
func (m *CapabilityStatementResource) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementResource
func (m *CapabilityStatementResource) Clone() *CapabilityStatementResource {
	if m == nil { return nil }
	return &CapabilityStatementResource{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Profile: m.Profile.Clone(),
		SupportedProfile: cloneSlices(m.SupportedProfile),
		Documentation: m.Documentation.Clone(),
		Interaction: cloneSlices(m.Interaction),
		Versioning: m.Versioning.Clone(),
		ReadHistory: m.ReadHistory.Clone(),
		UpdateCreate: m.UpdateCreate.Clone(),
		ConditionalCreate: m.ConditionalCreate.Clone(),
		ConditionalRead: m.ConditionalRead.Clone(),
		ConditionalUpdate: m.ConditionalUpdate.Clone(),
		ConditionalDelete: m.ConditionalDelete.Clone(),
		ReferencePolicy: cloneSlices(m.ReferencePolicy),
		SearchInclude: cloneSlices(m.SearchInclude),
		SearchRevInclude: cloneSlices(m.SearchRevInclude),
		SearchParam: cloneSlices(m.SearchParam),
		Operation: cloneSlices(m.Operation),
	}
}

// Equals checks for equality with another CapabilityStatementResource instance
func (m *CapabilityStatementResource) Equals(other *CapabilityStatementResource) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Profile.Equals(other.Profile) { return false }
	if !compareSlices(m.SupportedProfile, other.SupportedProfile) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	if !compareSlices(m.Interaction, other.Interaction) { return false }
	if !m.Versioning.Equals(other.Versioning) { return false }
	if !m.ReadHistory.Equals(other.ReadHistory) { return false }
	if !m.UpdateCreate.Equals(other.UpdateCreate) { return false }
	if !m.ConditionalCreate.Equals(other.ConditionalCreate) { return false }
	if !m.ConditionalRead.Equals(other.ConditionalRead) { return false }
	if !m.ConditionalUpdate.Equals(other.ConditionalUpdate) { return false }
	if !m.ConditionalDelete.Equals(other.ConditionalDelete) { return false }
	if !compareSlices(m.ReferencePolicy, other.ReferencePolicy) { return false }
	if !compareSlices(m.SearchInclude, other.SearchInclude) { return false }
	if !compareSlices(m.SearchRevInclude, other.SearchRevInclude) { return false }
	if !compareSlices(m.SearchParam, other.SearchParam) { return false }
	if !compareSlices(m.Operation, other.Operation) { return false }
	return true
}

// CapabilityStatementInteraction
// Identifies a restful operation supported by the solution.
type CapabilityStatementInteraction struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *TypeRestfulInteraction `json:"code,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
}

// NewCapabilityStatementInteraction creates a new CapabilityStatementInteraction instance
func NewCapabilityStatementInteraction() *CapabilityStatementInteraction {
	return &CapabilityStatementInteraction{}
}

// FromJSON populates CapabilityStatementInteraction from JSON data
func (m *CapabilityStatementInteraction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementInteraction to JSON data
func (m *CapabilityStatementInteraction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementInteraction
func (m *CapabilityStatementInteraction) Clone() *CapabilityStatementInteraction {
	if m == nil { return nil }
	return &CapabilityStatementInteraction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementInteraction instance
func (m *CapabilityStatementInteraction) Equals(other *CapabilityStatementInteraction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// CapabilityStatementSearchParam
// Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
type CapabilityStatementSearchParam struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Definition *FhirCanonical `json:"definition,omitempty"`
	Type *SearchParamType `json:"type,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
}

// NewCapabilityStatementSearchParam creates a new CapabilityStatementSearchParam instance
func NewCapabilityStatementSearchParam() *CapabilityStatementSearchParam {
	return &CapabilityStatementSearchParam{}
}

// FromJSON populates CapabilityStatementSearchParam from JSON data
func (m *CapabilityStatementSearchParam) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementSearchParam to JSON data
func (m *CapabilityStatementSearchParam) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementSearchParam
func (m *CapabilityStatementSearchParam) Clone() *CapabilityStatementSearchParam {
	if m == nil { return nil }
	return &CapabilityStatementSearchParam{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Definition: m.Definition.Clone(),
		Type: m.Type.Clone(),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementSearchParam instance
func (m *CapabilityStatementSearchParam) Equals(other *CapabilityStatementSearchParam) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// CapabilityStatementOperation
// Definition of an operation or a named query together with its parameters and their meaning and type. Consult the definition of the operation for details about how to invoke the operation, and the parameters.
type CapabilityStatementOperation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Definition *FhirCanonical `json:"definition,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
}

// NewCapabilityStatementOperation creates a new CapabilityStatementOperation instance
func NewCapabilityStatementOperation() *CapabilityStatementOperation {
	return &CapabilityStatementOperation{}
}

// FromJSON populates CapabilityStatementOperation from JSON data
func (m *CapabilityStatementOperation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementOperation to JSON data
func (m *CapabilityStatementOperation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementOperation
func (m *CapabilityStatementOperation) Clone() *CapabilityStatementOperation {
	if m == nil { return nil }
	return &CapabilityStatementOperation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Name: m.Name.Clone(),
		Definition: m.Definition.Clone(),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementOperation instance
func (m *CapabilityStatementOperation) Equals(other *CapabilityStatementOperation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// CapabilityStatementInteraction1
// A specification of restful operations supported by the system.
type CapabilityStatementInteraction1 struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code *SystemRestfulInteraction `json:"code,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
}

// NewCapabilityStatementInteraction1 creates a new CapabilityStatementInteraction1 instance
func NewCapabilityStatementInteraction1() *CapabilityStatementInteraction1 {
	return &CapabilityStatementInteraction1{}
}

// FromJSON populates CapabilityStatementInteraction1 from JSON data
func (m *CapabilityStatementInteraction1) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementInteraction1 to JSON data
func (m *CapabilityStatementInteraction1) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementInteraction1
func (m *CapabilityStatementInteraction1) Clone() *CapabilityStatementInteraction1 {
	if m == nil { return nil }
	return &CapabilityStatementInteraction1{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: m.Code.Clone(),
		Documentation: m.Documentation.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementInteraction1 instance
func (m *CapabilityStatementInteraction1) Equals(other *CapabilityStatementInteraction1) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	return true
}

// CapabilityStatementMessaging
// A description of the messaging capabilities of the solution.
type CapabilityStatementMessaging struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Endpoint []*CapabilityStatementEndpoint `json:"endpoint,omitempty"`
	ReliableCache *FhirUnsignedInt `json:"reliablecache,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
	SupportedMessage []*CapabilityStatementSupportedMessage `json:"supportedmessage,omitempty"`
}

// NewCapabilityStatementMessaging creates a new CapabilityStatementMessaging instance
func NewCapabilityStatementMessaging() *CapabilityStatementMessaging {
	return &CapabilityStatementMessaging{}
}

// FromJSON populates CapabilityStatementMessaging from JSON data
func (m *CapabilityStatementMessaging) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementMessaging to JSON data
func (m *CapabilityStatementMessaging) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementMessaging
func (m *CapabilityStatementMessaging) Clone() *CapabilityStatementMessaging {
	if m == nil { return nil }
	return &CapabilityStatementMessaging{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Endpoint: cloneSlices(m.Endpoint),
		ReliableCache: m.ReliableCache.Clone(),
		Documentation: m.Documentation.Clone(),
		SupportedMessage: cloneSlices(m.SupportedMessage),
	}
}

// Equals checks for equality with another CapabilityStatementMessaging instance
func (m *CapabilityStatementMessaging) Equals(other *CapabilityStatementMessaging) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Endpoint, other.Endpoint) { return false }
	if !m.ReliableCache.Equals(other.ReliableCache) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	if !compareSlices(m.SupportedMessage, other.SupportedMessage) { return false }
	return true
}

// CapabilityStatementEndpoint
// An endpoint (network accessible address) to which messages and/or replies are to be sent.
type CapabilityStatementEndpoint struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Protocol *Coding `json:"protocol,omitempty"`
	Address *FhirUrl `json:"address,omitempty"`
}

// NewCapabilityStatementEndpoint creates a new CapabilityStatementEndpoint instance
func NewCapabilityStatementEndpoint() *CapabilityStatementEndpoint {
	return &CapabilityStatementEndpoint{}
}

// FromJSON populates CapabilityStatementEndpoint from JSON data
func (m *CapabilityStatementEndpoint) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementEndpoint to JSON data
func (m *CapabilityStatementEndpoint) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementEndpoint
func (m *CapabilityStatementEndpoint) Clone() *CapabilityStatementEndpoint {
	if m == nil { return nil }
	return &CapabilityStatementEndpoint{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Protocol: m.Protocol.Clone(),
		Address: m.Address.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementEndpoint instance
func (m *CapabilityStatementEndpoint) Equals(other *CapabilityStatementEndpoint) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Protocol.Equals(other.Protocol) { return false }
	if !m.Address.Equals(other.Address) { return false }
	return true
}

// CapabilityStatementSupportedMessage
// References to message definitions for messages this system can send or receive.
type CapabilityStatementSupportedMessage struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Mode *EventCapabilityMode `json:"mode,omitempty"`
	Definition *FhirCanonical `json:"definition,omitempty"`
}

// NewCapabilityStatementSupportedMessage creates a new CapabilityStatementSupportedMessage instance
func NewCapabilityStatementSupportedMessage() *CapabilityStatementSupportedMessage {
	return &CapabilityStatementSupportedMessage{}
}

// FromJSON populates CapabilityStatementSupportedMessage from JSON data
func (m *CapabilityStatementSupportedMessage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementSupportedMessage to JSON data
func (m *CapabilityStatementSupportedMessage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementSupportedMessage
func (m *CapabilityStatementSupportedMessage) Clone() *CapabilityStatementSupportedMessage {
	if m == nil { return nil }
	return &CapabilityStatementSupportedMessage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Mode: m.Mode.Clone(),
		Definition: m.Definition.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementSupportedMessage instance
func (m *CapabilityStatementSupportedMessage) Equals(other *CapabilityStatementSupportedMessage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	return true
}

// CapabilityStatementDocument
// A document definition.
type CapabilityStatementDocument struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Mode *DocumentMode `json:"mode,omitempty"`
	Documentation *FhirMarkdown `json:"documentation,omitempty"`
	Profile *FhirCanonical `json:"profile,omitempty"`
}

// NewCapabilityStatementDocument creates a new CapabilityStatementDocument instance
func NewCapabilityStatementDocument() *CapabilityStatementDocument {
	return &CapabilityStatementDocument{}
}

// FromJSON populates CapabilityStatementDocument from JSON data
func (m *CapabilityStatementDocument) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts CapabilityStatementDocument to JSON data
func (m *CapabilityStatementDocument) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of CapabilityStatementDocument
func (m *CapabilityStatementDocument) Clone() *CapabilityStatementDocument {
	if m == nil { return nil }
	return &CapabilityStatementDocument{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Mode: m.Mode.Clone(),
		Documentation: m.Documentation.Clone(),
		Profile: m.Profile.Clone(),
	}
}

// Equals checks for equality with another CapabilityStatementDocument instance
func (m *CapabilityStatementDocument) Equals(other *CapabilityStatementDocument) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Mode.Equals(other.Mode) { return false }
	if !m.Documentation.Equals(other.Documentation) { return false }
	if !m.Profile.Equals(other.Profile) { return false }
	return true
}

