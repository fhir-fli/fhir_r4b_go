// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Condition
// A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
type Condition struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	ClinicalStatus *CodeableConcept `json:"clinicalstatus,omitempty"`
	VerificationStatus *CodeableConcept `json:"verificationstatus,omitempty"`
	Category []*CodeableConcept `json:"category,omitempty"`
	Severity *CodeableConcept `json:"severity,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	BodySite []*CodeableConcept `json:"bodysite,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	OnsetDateTime *FhirDateTime `json:"onsetdatetime,omitempty"`
	OnsetAge *Age `json:"onsetage,omitempty"`
	OnsetPeriod *Period `json:"onsetperiod,omitempty"`
	OnsetRange *Range `json:"onsetrange,omitempty"`
	OnsetString *FhirString `json:"onsetstring,omitempty"`
	AbatementDateTime *FhirDateTime `json:"abatementdatetime,omitempty"`
	AbatementAge *Age `json:"abatementage,omitempty"`
	AbatementPeriod *Period `json:"abatementperiod,omitempty"`
	AbatementRange *Range `json:"abatementrange,omitempty"`
	AbatementString *FhirString `json:"abatementstring,omitempty"`
	RecordedDate *FhirDateTime `json:"recordeddate,omitempty"`
	Recorder *Reference `json:"recorder,omitempty"`
	Asserter *Reference `json:"asserter,omitempty"`
	Stage []*ConditionStage `json:"stage,omitempty"`
	Evidence []*ConditionEvidence `json:"evidence,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
}

// NewCondition creates a new Condition instance
func NewCondition() *Condition {
	return &Condition{}
}

// FromJSON populates Condition from JSON data
func (m *Condition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Condition to JSON data
func (m *Condition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Condition
func (m *Condition) Clone() *Condition {
	if m == nil { return nil }
	return &Condition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		ClinicalStatus: m.ClinicalStatus.Clone(),
		VerificationStatus: m.VerificationStatus.Clone(),
		Category: cloneSlices(m.Category),
		Severity: m.Severity.Clone(),
		Code: m.Code.Clone(),
		BodySite: cloneSlices(m.BodySite),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		OnsetDateTime: m.OnsetDateTime.Clone(),
		OnsetAge: m.OnsetAge.Clone(),
		OnsetPeriod: m.OnsetPeriod.Clone(),
		OnsetRange: m.OnsetRange.Clone(),
		OnsetString: m.OnsetString.Clone(),
		AbatementDateTime: m.AbatementDateTime.Clone(),
		AbatementAge: m.AbatementAge.Clone(),
		AbatementPeriod: m.AbatementPeriod.Clone(),
		AbatementRange: m.AbatementRange.Clone(),
		AbatementString: m.AbatementString.Clone(),
		RecordedDate: m.RecordedDate.Clone(),
		Recorder: m.Recorder.Clone(),
		Asserter: m.Asserter.Clone(),
		Stage: cloneSlices(m.Stage),
		Evidence: cloneSlices(m.Evidence),
		Note: cloneSlices(m.Note),
	}
}

// Equals checks for equality with another Condition instance
func (m *Condition) Equals(other *Condition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.ClinicalStatus.Equals(other.ClinicalStatus) { return false }
	if !m.VerificationStatus.Equals(other.VerificationStatus) { return false }
	if !compareSlices(m.Category, other.Category) { return false }
	if !m.Severity.Equals(other.Severity) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !compareSlices(m.BodySite, other.BodySite) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.OnsetDateTime.Equals(other.OnsetDateTime) { return false }
	if !m.OnsetAge.Equals(other.OnsetAge) { return false }
	if !m.OnsetPeriod.Equals(other.OnsetPeriod) { return false }
	if !m.OnsetRange.Equals(other.OnsetRange) { return false }
	if !m.OnsetString.Equals(other.OnsetString) { return false }
	if !m.AbatementDateTime.Equals(other.AbatementDateTime) { return false }
	if !m.AbatementAge.Equals(other.AbatementAge) { return false }
	if !m.AbatementPeriod.Equals(other.AbatementPeriod) { return false }
	if !m.AbatementRange.Equals(other.AbatementRange) { return false }
	if !m.AbatementString.Equals(other.AbatementString) { return false }
	if !m.RecordedDate.Equals(other.RecordedDate) { return false }
	if !m.Recorder.Equals(other.Recorder) { return false }
	if !m.Asserter.Equals(other.Asserter) { return false }
	if !compareSlices(m.Stage, other.Stage) { return false }
	if !compareSlices(m.Evidence, other.Evidence) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	return true
}

// ConditionStage
// Clinical stage or grade of a condition. May include formal severity assessments.
type ConditionStage struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Summary *CodeableConcept `json:"summary,omitempty"`
	Assessment []*Reference `json:"assessment,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
}

// NewConditionStage creates a new ConditionStage instance
func NewConditionStage() *ConditionStage {
	return &ConditionStage{}
}

// FromJSON populates ConditionStage from JSON data
func (m *ConditionStage) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ConditionStage to JSON data
func (m *ConditionStage) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ConditionStage
func (m *ConditionStage) Clone() *ConditionStage {
	if m == nil { return nil }
	return &ConditionStage{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Summary: m.Summary.Clone(),
		Assessment: cloneSlices(m.Assessment),
		Type: m.Type.Clone(),
	}
}

// Equals checks for equality with another ConditionStage instance
func (m *ConditionStage) Equals(other *ConditionStage) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Summary.Equals(other.Summary) { return false }
	if !compareSlices(m.Assessment, other.Assessment) { return false }
	if !m.Type.Equals(other.Type) { return false }
	return true
}

// ConditionEvidence
// Supporting evidence / manifestations that are the basis of the Condition's verification status, such as evidence that confirmed or refuted the condition.
type ConditionEvidence struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code []*CodeableConcept `json:"code,omitempty"`
	Detail []*Reference `json:"detail,omitempty"`
}

// NewConditionEvidence creates a new ConditionEvidence instance
func NewConditionEvidence() *ConditionEvidence {
	return &ConditionEvidence{}
}

// FromJSON populates ConditionEvidence from JSON data
func (m *ConditionEvidence) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ConditionEvidence to JSON data
func (m *ConditionEvidence) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ConditionEvidence
func (m *ConditionEvidence) Clone() *ConditionEvidence {
	if m == nil { return nil }
	return &ConditionEvidence{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: cloneSlices(m.Code),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks for equality with another ConditionEvidence instance
func (m *ConditionEvidence) Equals(other *ConditionEvidence) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

