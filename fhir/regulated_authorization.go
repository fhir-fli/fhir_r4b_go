// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// RegulatedAuthorization
// Regulatory approval, clearance or licencing related to a regulated product, treatment, facility or activity that is cited in a guidance, regulation, rule or legislative act. An example is Market Authorization relating to a Medicinal Product.
type RegulatedAuthorization struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Subject []*Reference `json:"subject,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	Region []*CodeableConcept `json:"region,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	StatusDate *FhirDateTime `json:"statusdate,omitempty"`
	ValidityPeriod *Period `json:"validityperiod,omitempty"`
	Indication *CodeableReference `json:"indication,omitempty"`
	IntendedUse *CodeableConcept `json:"intendeduse,omitempty"`
	Basis []*CodeableConcept `json:"basis,omitempty"`
	Holder *Reference `json:"holder,omitempty"`
	Regulator *Reference `json:"regulator,omitempty"`
	Case_ *RegulatedAuthorizationCase `json:"case,omitempty"`
}

// NewRegulatedAuthorization creates a new RegulatedAuthorization instance
func NewRegulatedAuthorization() *RegulatedAuthorization {
	return &RegulatedAuthorization{}
}

// FromJSON populates RegulatedAuthorization from JSON data
func (m *RegulatedAuthorization) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts RegulatedAuthorization to JSON data
func (m *RegulatedAuthorization) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of RegulatedAuthorization
func (m *RegulatedAuthorization) Clone() *RegulatedAuthorization {
	if m == nil { return nil }
	return &RegulatedAuthorization{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Subject: cloneSlices(m.Subject),
		Type: m.Type.Clone(),
		Description: m.Description.Clone(),
		Region: cloneSlices(m.Region),
		Status: m.Status.Clone(),
		StatusDate: m.StatusDate.Clone(),
		ValidityPeriod: m.ValidityPeriod.Clone(),
		Indication: m.Indication.Clone(),
		IntendedUse: m.IntendedUse.Clone(),
		Basis: cloneSlices(m.Basis),
		Holder: m.Holder.Clone(),
		Regulator: m.Regulator.Clone(),
		Case_: m.Case_.Clone(),
	}
}

// Equals checks for equality with another RegulatedAuthorization instance
func (m *RegulatedAuthorization) Equals(other *RegulatedAuthorization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !compareSlices(m.Subject, other.Subject) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.Region, other.Region) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusDate.Equals(other.StatusDate) { return false }
	if !m.ValidityPeriod.Equals(other.ValidityPeriod) { return false }
	if !m.Indication.Equals(other.Indication) { return false }
	if !m.IntendedUse.Equals(other.IntendedUse) { return false }
	if !compareSlices(m.Basis, other.Basis) { return false }
	if !m.Holder.Equals(other.Holder) { return false }
	if !m.Regulator.Equals(other.Regulator) { return false }
	if !m.Case_.Equals(other.Case_) { return false }
	return true
}

// RegulatedAuthorizationCase
// The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
type RegulatedAuthorizationCase struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	Type *CodeableConcept `json:"type,omitempty"`
	Status *CodeableConcept `json:"status,omitempty"`
	DatePeriod *Period `json:"dateperiod,omitempty"`
	DateDateTime *FhirDateTime `json:"datedatetime,omitempty"`
	Application []*RegulatedAuthorizationCase `json:"application,omitempty"`
}

// NewRegulatedAuthorizationCase creates a new RegulatedAuthorizationCase instance
func NewRegulatedAuthorizationCase() *RegulatedAuthorizationCase {
	return &RegulatedAuthorizationCase{}
}

// FromJSON populates RegulatedAuthorizationCase from JSON data
func (m *RegulatedAuthorizationCase) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts RegulatedAuthorizationCase to JSON data
func (m *RegulatedAuthorizationCase) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of RegulatedAuthorizationCase
func (m *RegulatedAuthorizationCase) Clone() *RegulatedAuthorizationCase {
	if m == nil { return nil }
	return &RegulatedAuthorizationCase{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		Type: m.Type.Clone(),
		Status: m.Status.Clone(),
		DatePeriod: m.DatePeriod.Clone(),
		DateDateTime: m.DateDateTime.Clone(),
		Application: cloneSlices(m.Application),
	}
}

// Equals checks for equality with another RegulatedAuthorizationCase instance
func (m *RegulatedAuthorizationCase) Equals(other *RegulatedAuthorizationCase) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.DatePeriod.Equals(other.DatePeriod) { return false }
	if !m.DateDateTime.Equals(other.DateDateTime) { return false }
	if !compareSlices(m.Application, other.Application) { return false }
	return true
}

