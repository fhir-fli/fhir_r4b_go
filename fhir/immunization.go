// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Immunization
// Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party.
type Immunization struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ImmunizationStatusCodes `json:"status,omitempty"`
	StatusReason *CodeableConcept `json:"statusreason,omitempty"`
	VaccineCode *CodeableConcept `json:"vaccinecode,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	OccurrenceDateTime *FhirDateTime `json:"occurrencedatetime,omitempty"`
	OccurrenceString *FhirString `json:"occurrencestring,omitempty"`
	Recorded *FhirDateTime `json:"recorded,omitempty"`
	PrimarySource *FhirBoolean `json:"primarysource,omitempty"`
	ReportOrigin *CodeableConcept `json:"reportorigin,omitempty"`
	Location *Reference `json:"location,omitempty"`
	Manufacturer *Reference `json:"manufacturer,omitempty"`
	LotNumber *FhirString `json:"lotnumber,omitempty"`
	ExpirationDate *FhirDate `json:"expirationdate,omitempty"`
	Site *CodeableConcept `json:"site,omitempty"`
	Route *CodeableConcept `json:"route,omitempty"`
	DoseQuantity *Quantity `json:"dosequantity,omitempty"`
	Performer []*ImmunizationPerformer `json:"performer,omitempty"`
	Note []*Annotation `json:"note,omitempty"`
	ReasonCode []*CodeableConcept `json:"reasoncode,omitempty"`
	ReasonReference []*Reference `json:"reasonreference,omitempty"`
	IsSubpotent *FhirBoolean `json:"issubpotent,omitempty"`
	SubpotentReason []*CodeableConcept `json:"subpotentreason,omitempty"`
	Education []*ImmunizationEducation `json:"education,omitempty"`
	ProgramEligibility []*CodeableConcept `json:"programeligibility,omitempty"`
	FundingSource *CodeableConcept `json:"fundingsource,omitempty"`
	Reaction []*ImmunizationReaction `json:"reaction,omitempty"`
	ProtocolApplied []*ImmunizationProtocolApplied `json:"protocolapplied,omitempty"`
}

// NewImmunization creates a new Immunization instance
func NewImmunization() *Immunization {
	return &Immunization{}
}

// FromJSON populates Immunization from JSON data
func (m *Immunization) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Immunization to JSON data
func (m *Immunization) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Immunization
func (m *Immunization) Clone() *Immunization {
	if m == nil { return nil }
	return &Immunization{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		StatusReason: m.StatusReason.Clone(),
		VaccineCode: m.VaccineCode.Clone(),
		Patient: m.Patient.Clone(),
		Encounter: m.Encounter.Clone(),
		OccurrenceDateTime: m.OccurrenceDateTime.Clone(),
		OccurrenceString: m.OccurrenceString.Clone(),
		Recorded: m.Recorded.Clone(),
		PrimarySource: m.PrimarySource.Clone(),
		ReportOrigin: m.ReportOrigin.Clone(),
		Location: m.Location.Clone(),
		Manufacturer: m.Manufacturer.Clone(),
		LotNumber: m.LotNumber.Clone(),
		ExpirationDate: m.ExpirationDate.Clone(),
		Site: m.Site.Clone(),
		Route: m.Route.Clone(),
		DoseQuantity: m.DoseQuantity.Clone(),
		Performer: cloneSlices(m.Performer),
		Note: cloneSlices(m.Note),
		ReasonCode: cloneSlices(m.ReasonCode),
		ReasonReference: cloneSlices(m.ReasonReference),
		IsSubpotent: m.IsSubpotent.Clone(),
		SubpotentReason: cloneSlices(m.SubpotentReason),
		Education: cloneSlices(m.Education),
		ProgramEligibility: cloneSlices(m.ProgramEligibility),
		FundingSource: m.FundingSource.Clone(),
		Reaction: cloneSlices(m.Reaction),
		ProtocolApplied: cloneSlices(m.ProtocolApplied),
	}
}

// Equals checks for equality with another Immunization instance
func (m *Immunization) Equals(other *Immunization) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.StatusReason.Equals(other.StatusReason) { return false }
	if !m.VaccineCode.Equals(other.VaccineCode) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.OccurrenceDateTime.Equals(other.OccurrenceDateTime) { return false }
	if !m.OccurrenceString.Equals(other.OccurrenceString) { return false }
	if !m.Recorded.Equals(other.Recorded) { return false }
	if !m.PrimarySource.Equals(other.PrimarySource) { return false }
	if !m.ReportOrigin.Equals(other.ReportOrigin) { return false }
	if !m.Location.Equals(other.Location) { return false }
	if !m.Manufacturer.Equals(other.Manufacturer) { return false }
	if !m.LotNumber.Equals(other.LotNumber) { return false }
	if !m.ExpirationDate.Equals(other.ExpirationDate) { return false }
	if !m.Site.Equals(other.Site) { return false }
	if !m.Route.Equals(other.Route) { return false }
	if !m.DoseQuantity.Equals(other.DoseQuantity) { return false }
	if !compareSlices(m.Performer, other.Performer) { return false }
	if !compareSlices(m.Note, other.Note) { return false }
	if !compareSlices(m.ReasonCode, other.ReasonCode) { return false }
	if !compareSlices(m.ReasonReference, other.ReasonReference) { return false }
	if !m.IsSubpotent.Equals(other.IsSubpotent) { return false }
	if !compareSlices(m.SubpotentReason, other.SubpotentReason) { return false }
	if !compareSlices(m.Education, other.Education) { return false }
	if !compareSlices(m.ProgramEligibility, other.ProgramEligibility) { return false }
	if !m.FundingSource.Equals(other.FundingSource) { return false }
	if !compareSlices(m.Reaction, other.Reaction) { return false }
	if !compareSlices(m.ProtocolApplied, other.ProtocolApplied) { return false }
	return true
}

// ImmunizationPerformer
// Indicates who performed the immunization event.
type ImmunizationPerformer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Function_ *CodeableConcept `json:"function,omitempty"`
	Actor *Reference `json:"actor,omitempty"`
}

// NewImmunizationPerformer creates a new ImmunizationPerformer instance
func NewImmunizationPerformer() *ImmunizationPerformer {
	return &ImmunizationPerformer{}
}

// FromJSON populates ImmunizationPerformer from JSON data
func (m *ImmunizationPerformer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImmunizationPerformer to JSON data
func (m *ImmunizationPerformer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImmunizationPerformer
func (m *ImmunizationPerformer) Clone() *ImmunizationPerformer {
	if m == nil { return nil }
	return &ImmunizationPerformer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Function_: m.Function_.Clone(),
		Actor: m.Actor.Clone(),
	}
}

// Equals checks for equality with another ImmunizationPerformer instance
func (m *ImmunizationPerformer) Equals(other *ImmunizationPerformer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Function_.Equals(other.Function_) { return false }
	if !m.Actor.Equals(other.Actor) { return false }
	return true
}

// ImmunizationEducation
// Educational material presented to the patient (or guardian) at the time of vaccine administration.
type ImmunizationEducation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	DocumentType *FhirString `json:"documenttype,omitempty"`
	Reference *FhirUri `json:"reference,omitempty"`
	PublicationDate *FhirDateTime `json:"publicationdate,omitempty"`
	PresentationDate *FhirDateTime `json:"presentationdate,omitempty"`
}

// NewImmunizationEducation creates a new ImmunizationEducation instance
func NewImmunizationEducation() *ImmunizationEducation {
	return &ImmunizationEducation{}
}

// FromJSON populates ImmunizationEducation from JSON data
func (m *ImmunizationEducation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImmunizationEducation to JSON data
func (m *ImmunizationEducation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImmunizationEducation
func (m *ImmunizationEducation) Clone() *ImmunizationEducation {
	if m == nil { return nil }
	return &ImmunizationEducation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		DocumentType: m.DocumentType.Clone(),
		Reference: m.Reference.Clone(),
		PublicationDate: m.PublicationDate.Clone(),
		PresentationDate: m.PresentationDate.Clone(),
	}
}

// Equals checks for equality with another ImmunizationEducation instance
func (m *ImmunizationEducation) Equals(other *ImmunizationEducation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.DocumentType.Equals(other.DocumentType) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	if !m.PublicationDate.Equals(other.PublicationDate) { return false }
	if !m.PresentationDate.Equals(other.PresentationDate) { return false }
	return true
}

// ImmunizationReaction
// Categorical data indicating that an adverse event is associated in time to an immunization.
type ImmunizationReaction struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Detail *Reference `json:"detail,omitempty"`
	Reported *FhirBoolean `json:"reported,omitempty"`
}

// NewImmunizationReaction creates a new ImmunizationReaction instance
func NewImmunizationReaction() *ImmunizationReaction {
	return &ImmunizationReaction{}
}

// FromJSON populates ImmunizationReaction from JSON data
func (m *ImmunizationReaction) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImmunizationReaction to JSON data
func (m *ImmunizationReaction) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImmunizationReaction
func (m *ImmunizationReaction) Clone() *ImmunizationReaction {
	if m == nil { return nil }
	return &ImmunizationReaction{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Date: m.Date.Clone(),
		Detail: m.Detail.Clone(),
		Reported: m.Reported.Clone(),
	}
}

// Equals checks for equality with another ImmunizationReaction instance
func (m *ImmunizationReaction) Equals(other *ImmunizationReaction) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Detail.Equals(other.Detail) { return false }
	if !m.Reported.Equals(other.Reported) { return false }
	return true
}

// ImmunizationProtocolApplied
// The protocol (set of recommendations) being followed by the provider who administered the dose.
type ImmunizationProtocolApplied struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Series *FhirString `json:"series,omitempty"`
	Authority *Reference `json:"authority,omitempty"`
	TargetDisease []*CodeableConcept `json:"targetdisease,omitempty"`
	DoseNumberPositiveInt *FhirPositiveInt `json:"dosenumberpositiveint,omitempty"`
	DoseNumberString *FhirString `json:"dosenumberstring,omitempty"`
	SeriesDosesPositiveInt *FhirPositiveInt `json:"seriesdosespositiveint,omitempty"`
	SeriesDosesString *FhirString `json:"seriesdosesstring,omitempty"`
}

// NewImmunizationProtocolApplied creates a new ImmunizationProtocolApplied instance
func NewImmunizationProtocolApplied() *ImmunizationProtocolApplied {
	return &ImmunizationProtocolApplied{}
}

// FromJSON populates ImmunizationProtocolApplied from JSON data
func (m *ImmunizationProtocolApplied) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts ImmunizationProtocolApplied to JSON data
func (m *ImmunizationProtocolApplied) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of ImmunizationProtocolApplied
func (m *ImmunizationProtocolApplied) Clone() *ImmunizationProtocolApplied {
	if m == nil { return nil }
	return &ImmunizationProtocolApplied{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Series: m.Series.Clone(),
		Authority: m.Authority.Clone(),
		TargetDisease: cloneSlices(m.TargetDisease),
		DoseNumberPositiveInt: m.DoseNumberPositiveInt.Clone(),
		DoseNumberString: m.DoseNumberString.Clone(),
		SeriesDosesPositiveInt: m.SeriesDosesPositiveInt.Clone(),
		SeriesDosesString: m.SeriesDosesString.Clone(),
	}
}

// Equals checks for equality with another ImmunizationProtocolApplied instance
func (m *ImmunizationProtocolApplied) Equals(other *ImmunizationProtocolApplied) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Series.Equals(other.Series) { return false }
	if !m.Authority.Equals(other.Authority) { return false }
	if !compareSlices(m.TargetDisease, other.TargetDisease) { return false }
	if !m.DoseNumberPositiveInt.Equals(other.DoseNumberPositiveInt) { return false }
	if !m.DoseNumberString.Equals(other.DoseNumberString) { return false }
	if !m.SeriesDosesPositiveInt.Equals(other.SeriesDosesPositiveInt) { return false }
	if !m.SeriesDosesString.Equals(other.SeriesDosesString) { return false }
	return true
}

