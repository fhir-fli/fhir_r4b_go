// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// DetectedIssue
// Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
type DetectedIssue struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Status *ObservationStatus `json:"status,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
	Severity *DetectedIssueSeverity `json:"severity,omitempty"`
	Patient *Reference `json:"patient,omitempty"`
	IdentifiedDateTime *FhirDateTime `json:"identifieddatetime,omitempty"`
	IdentifiedPeriod *Period `json:"identifiedperiod,omitempty"`
	Author *Reference `json:"author,omitempty"`
	Implicated []*Reference `json:"implicated,omitempty"`
	Evidence []*DetectedIssueEvidence `json:"evidence,omitempty"`
	Detail *FhirString `json:"detail,omitempty"`
	Reference *FhirUri `json:"reference,omitempty"`
	Mitigation []*DetectedIssueMitigation `json:"mitigation,omitempty"`
}

// NewDetectedIssue creates a new DetectedIssue instance
func NewDetectedIssue() *DetectedIssue {
	return &DetectedIssue{}
}

// FromJSON populates DetectedIssue from JSON data
func (m *DetectedIssue) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DetectedIssue to JSON data
func (m *DetectedIssue) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DetectedIssue
func (m *DetectedIssue) Clone() *DetectedIssue {
	if m == nil { return nil }
	return &DetectedIssue{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: cloneSlices(m.Identifier),
		Status: m.Status.Clone(),
		Code: m.Code.Clone(),
		Severity: m.Severity.Clone(),
		Patient: m.Patient.Clone(),
		IdentifiedDateTime: m.IdentifiedDateTime.Clone(),
		IdentifiedPeriod: m.IdentifiedPeriod.Clone(),
		Author: m.Author.Clone(),
		Implicated: cloneSlices(m.Implicated),
		Evidence: cloneSlices(m.Evidence),
		Detail: m.Detail.Clone(),
		Reference: m.Reference.Clone(),
		Mitigation: cloneSlices(m.Mitigation),
	}
}

// Equals checks for equality with another DetectedIssue instance
func (m *DetectedIssue) Equals(other *DetectedIssue) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Code.Equals(other.Code) { return false }
	if !m.Severity.Equals(other.Severity) { return false }
	if !m.Patient.Equals(other.Patient) { return false }
	if !m.IdentifiedDateTime.Equals(other.IdentifiedDateTime) { return false }
	if !m.IdentifiedPeriod.Equals(other.IdentifiedPeriod) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !compareSlices(m.Implicated, other.Implicated) { return false }
	if !compareSlices(m.Evidence, other.Evidence) { return false }
	if !m.Detail.Equals(other.Detail) { return false }
	if !m.Reference.Equals(other.Reference) { return false }
	if !compareSlices(m.Mitigation, other.Mitigation) { return false }
	return true
}

// DetectedIssueEvidence
// Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
type DetectedIssueEvidence struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Code []*CodeableConcept `json:"code,omitempty"`
	Detail []*Reference `json:"detail,omitempty"`
}

// NewDetectedIssueEvidence creates a new DetectedIssueEvidence instance
func NewDetectedIssueEvidence() *DetectedIssueEvidence {
	return &DetectedIssueEvidence{}
}

// FromJSON populates DetectedIssueEvidence from JSON data
func (m *DetectedIssueEvidence) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DetectedIssueEvidence to JSON data
func (m *DetectedIssueEvidence) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DetectedIssueEvidence
func (m *DetectedIssueEvidence) Clone() *DetectedIssueEvidence {
	if m == nil { return nil }
	return &DetectedIssueEvidence{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Code: cloneSlices(m.Code),
		Detail: cloneSlices(m.Detail),
	}
}

// Equals checks for equality with another DetectedIssueEvidence instance
func (m *DetectedIssueEvidence) Equals(other *DetectedIssueEvidence) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Code, other.Code) { return false }
	if !compareSlices(m.Detail, other.Detail) { return false }
	return true
}

// DetectedIssueMitigation
// Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
type DetectedIssueMitigation struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Action *CodeableConcept `json:"action,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Author *Reference `json:"author,omitempty"`
}

// NewDetectedIssueMitigation creates a new DetectedIssueMitigation instance
func NewDetectedIssueMitigation() *DetectedIssueMitigation {
	return &DetectedIssueMitigation{}
}

// FromJSON populates DetectedIssueMitigation from JSON data
func (m *DetectedIssueMitigation) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts DetectedIssueMitigation to JSON data
func (m *DetectedIssueMitigation) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of DetectedIssueMitigation
func (m *DetectedIssueMitigation) Clone() *DetectedIssueMitigation {
	if m == nil { return nil }
	return &DetectedIssueMitigation{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Action: m.Action.Clone(),
		Date: m.Date.Clone(),
		Author: m.Author.Clone(),
	}
}

// Equals checks for equality with another DetectedIssueMitigation instance
func (m *DetectedIssueMitigation) Equals(other *DetectedIssueMitigation) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Action.Equals(other.Action) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Author.Equals(other.Author) { return false }
	return true
}

