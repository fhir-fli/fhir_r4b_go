// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// QuestionnaireResponse
// A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
type QuestionnaireResponse struct {
	DomainResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identifier *Identifier `json:"identifier,omitempty"`
	BasedOn []*Reference `json:"basedon,omitempty"`
	PartOf []*Reference `json:"partof,omitempty"`
	Questionnaire *FhirCanonical `json:"questionnaire,omitempty"`
	Status *QuestionnaireResponseStatus `json:"status,omitempty"`
	Subject *Reference `json:"subject,omitempty"`
	Encounter *Reference `json:"encounter,omitempty"`
	Authored *FhirDateTime `json:"authored,omitempty"`
	Author *Reference `json:"author,omitempty"`
	Source *Reference `json:"source,omitempty"`
	Item []*QuestionnaireResponseItem `json:"item,omitempty"`
}

// NewQuestionnaireResponse creates a new QuestionnaireResponse instance
func NewQuestionnaireResponse() *QuestionnaireResponse {
	return &QuestionnaireResponse{}
}

// FromJSON populates QuestionnaireResponse from JSON data
func (m *QuestionnaireResponse) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts QuestionnaireResponse to JSON data
func (m *QuestionnaireResponse) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of QuestionnaireResponse
func (m *QuestionnaireResponse) Clone() *QuestionnaireResponse {
	if m == nil { return nil }
	return &QuestionnaireResponse{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identifier: m.Identifier.Clone(),
		BasedOn: cloneSlices(m.BasedOn),
		PartOf: cloneSlices(m.PartOf),
		Questionnaire: m.Questionnaire.Clone(),
		Status: m.Status.Clone(),
		Subject: m.Subject.Clone(),
		Encounter: m.Encounter.Clone(),
		Authored: m.Authored.Clone(),
		Author: m.Author.Clone(),
		Source: m.Source.Clone(),
		Item: cloneSlices(m.Item),
	}
}

// Equals checks for equality with another QuestionnaireResponse instance
func (m *QuestionnaireResponse) Equals(other *QuestionnaireResponse) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identifier.Equals(other.Identifier) { return false }
	if !compareSlices(m.BasedOn, other.BasedOn) { return false }
	if !compareSlices(m.PartOf, other.PartOf) { return false }
	if !m.Questionnaire.Equals(other.Questionnaire) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Subject.Equals(other.Subject) { return false }
	if !m.Encounter.Equals(other.Encounter) { return false }
	if !m.Authored.Equals(other.Authored) { return false }
	if !m.Author.Equals(other.Author) { return false }
	if !m.Source.Equals(other.Source) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	return true
}

// QuestionnaireResponseItem
// A group or question item from the original questionnaire for which answers are provided.
type QuestionnaireResponseItem struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	LinkId *FhirString `json:"linkid,omitempty"`
	Definition *FhirUri `json:"definition,omitempty"`
	Text *FhirString `json:"text,omitempty"`
	Answer []*QuestionnaireResponseAnswer `json:"answer,omitempty"`
	Item []*QuestionnaireResponseItem `json:"item,omitempty"`
}

// NewQuestionnaireResponseItem creates a new QuestionnaireResponseItem instance
func NewQuestionnaireResponseItem() *QuestionnaireResponseItem {
	return &QuestionnaireResponseItem{}
}

// FromJSON populates QuestionnaireResponseItem from JSON data
func (m *QuestionnaireResponseItem) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts QuestionnaireResponseItem to JSON data
func (m *QuestionnaireResponseItem) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of QuestionnaireResponseItem
func (m *QuestionnaireResponseItem) Clone() *QuestionnaireResponseItem {
	if m == nil { return nil }
	return &QuestionnaireResponseItem{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		LinkId: m.LinkId.Clone(),
		Definition: m.Definition.Clone(),
		Text: m.Text.Clone(),
		Answer: cloneSlices(m.Answer),
		Item: cloneSlices(m.Item),
	}
}

// Equals checks for equality with another QuestionnaireResponseItem instance
func (m *QuestionnaireResponseItem) Equals(other *QuestionnaireResponseItem) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.LinkId.Equals(other.LinkId) { return false }
	if !m.Definition.Equals(other.Definition) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Answer, other.Answer) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	return true
}

// QuestionnaireResponseAnswer
// The respondent's answer(s) to the question.
type QuestionnaireResponseAnswer struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	ValueBoolean *FhirBoolean `json:"valueboolean,omitempty"`
	ValueDecimal *FhirDecimal `json:"valuedecimal,omitempty"`
	ValueInteger *FhirInteger `json:"valueinteger,omitempty"`
	ValueDate *FhirDate `json:"valuedate,omitempty"`
	ValueDateTime *FhirDateTime `json:"valuedatetime,omitempty"`
	ValueTime *FhirTime `json:"valuetime,omitempty"`
	ValueString *FhirString `json:"valuestring,omitempty"`
	ValueUri *FhirUri `json:"valueuri,omitempty"`
	ValueAttachment *Attachment `json:"valueattachment,omitempty"`
	ValueCoding *Coding `json:"valuecoding,omitempty"`
	ValueQuantity *Quantity `json:"valuequantity,omitempty"`
	ValueReference *Reference `json:"valuereference,omitempty"`
	Item []*QuestionnaireResponseItem `json:"item,omitempty"`
}

// NewQuestionnaireResponseAnswer creates a new QuestionnaireResponseAnswer instance
func NewQuestionnaireResponseAnswer() *QuestionnaireResponseAnswer {
	return &QuestionnaireResponseAnswer{}
}

// FromJSON populates QuestionnaireResponseAnswer from JSON data
func (m *QuestionnaireResponseAnswer) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts QuestionnaireResponseAnswer to JSON data
func (m *QuestionnaireResponseAnswer) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of QuestionnaireResponseAnswer
func (m *QuestionnaireResponseAnswer) Clone() *QuestionnaireResponseAnswer {
	if m == nil { return nil }
	return &QuestionnaireResponseAnswer{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		ValueBoolean: m.ValueBoolean.Clone(),
		ValueDecimal: m.ValueDecimal.Clone(),
		ValueInteger: m.ValueInteger.Clone(),
		ValueDate: m.ValueDate.Clone(),
		ValueDateTime: m.ValueDateTime.Clone(),
		ValueTime: m.ValueTime.Clone(),
		ValueString: m.ValueString.Clone(),
		ValueUri: m.ValueUri.Clone(),
		ValueAttachment: m.ValueAttachment.Clone(),
		ValueCoding: m.ValueCoding.Clone(),
		ValueQuantity: m.ValueQuantity.Clone(),
		ValueReference: m.ValueReference.Clone(),
		Item: cloneSlices(m.Item),
	}
}

// Equals checks for equality with another QuestionnaireResponseAnswer instance
func (m *QuestionnaireResponseAnswer) Equals(other *QuestionnaireResponseAnswer) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.ValueBoolean.Equals(other.ValueBoolean) { return false }
	if !m.ValueDecimal.Equals(other.ValueDecimal) { return false }
	if !m.ValueInteger.Equals(other.ValueInteger) { return false }
	if !m.ValueDate.Equals(other.ValueDate) { return false }
	if !m.ValueDateTime.Equals(other.ValueDateTime) { return false }
	if !m.ValueTime.Equals(other.ValueTime) { return false }
	if !m.ValueString.Equals(other.ValueString) { return false }
	if !m.ValueUri.Equals(other.ValueUri) { return false }
	if !m.ValueAttachment.Equals(other.ValueAttachment) { return false }
	if !m.ValueCoding.Equals(other.ValueCoding) { return false }
	if !m.ValueQuantity.Equals(other.ValueQuantity) { return false }
	if !m.ValueReference.Equals(other.ValueReference) { return false }
	if !compareSlices(m.Item, other.Item) { return false }
	return true
}

