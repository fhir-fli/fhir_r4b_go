// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Quantity
// A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
type Quantity struct {
	DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	Value *FhirDecimal `json:"value,omitempty"`
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	Unit *FhirString `json:"unit,omitempty"`
	System *FhirUri `json:"system,omitempty"`
	Code *FhirCode `json:"code,omitempty"`
}

// NewQuantity creates a new Quantity instance
func NewQuantity() *Quantity {
	return &Quantity{}
}

// FromJSON populates Quantity from JSON data
func (m *Quantity) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Quantity to JSON data
func (m *Quantity) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Quantity
func (m *Quantity) Clone() *Quantity {
	if m == nil { return nil }
	return &Quantity{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		Value: m.Value.Clone(),
		Comparator: m.Comparator.Clone(),
		Unit: m.Unit.Clone(),
		System: m.System.Clone(),
		Code: m.Code.Clone(),
	}
}

// Equals checks for equality with another Quantity instance
func (m *Quantity) Equals(other *Quantity) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.Value.Equals(other.Value) { return false }
	if !m.Comparator.Equals(other.Comparator) { return false }
	if !m.Unit.Equals(other.Unit) { return false }
	if !m.System.Equals(other.System) { return false }
	if !m.Code.Equals(other.Code) { return false }
	return true
}

