// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Attachment
// For referring to data content defined in other formats.
type Attachment struct {
	DataType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ContentType *FhirCode `json:"contenttype,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Data *FhirBase64Binary `json:"data,omitempty"`
	Url *FhirUrl `json:"url,omitempty"`
	Size *FhirUnsignedInt `json:"size,omitempty"`
	Hash *FhirBase64Binary `json:"hash,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Creation *FhirDateTime `json:"creation,omitempty"`
}

// NewAttachment creates a new Attachment instance
func NewAttachment() *Attachment {
	return &Attachment{}
}

// FromJSON populates Attachment from JSON data
func (m *Attachment) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Attachment to JSON data
func (m *Attachment) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Attachment
func (m *Attachment) Clone() *Attachment {
	if m == nil { return nil }
	return &Attachment{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ContentType: m.ContentType.Clone(),
		Language: m.Language.Clone(),
		Data: m.Data.Clone(),
		Url: m.Url.Clone(),
		Size: m.Size.Clone(),
		Hash: m.Hash.Clone(),
		Title: m.Title.Clone(),
		Creation: m.Creation.Clone(),
	}
}

// Equals checks for equality with another Attachment instance
func (m *Attachment) Equals(other *Attachment) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.ContentType.Equals(other.ContentType) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Data.Equals(other.Data) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !m.Size.Equals(other.Size) { return false }
	if !m.Hash.Equals(other.Hash) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Creation.Equals(other.Creation) { return false }
	return true
}

