// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// StructureDefinition
// A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
type StructureDefinition struct {
	CanonicalResource
	Id *FhirString `json:"id,omitempty"`
	Meta *FhirMeta `json:"meta,omitempty"`
	ImplicitRules *FhirUri `json:"implicitrules,omitempty"`
	Language *CommonLanguages `json:"language,omitempty"`
	Text *Narrative `json:"text,omitempty"`
	Contained []*Resource `json:"contained,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Url *FhirUri `json:"url,omitempty"`
	Identifier []*Identifier `json:"identifier,omitempty"`
	Version *FhirString `json:"version,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Title *FhirString `json:"title,omitempty"`
	Status *PublicationStatus `json:"status,omitempty"`
	Experimental *FhirBoolean `json:"experimental,omitempty"`
	Date *FhirDateTime `json:"date,omitempty"`
	Publisher *FhirString `json:"publisher,omitempty"`
	Contact []*ContactDetail `json:"contact,omitempty"`
	Description *FhirMarkdown `json:"description,omitempty"`
	UseContext []*UsageContext `json:"usecontext,omitempty"`
	Jurisdiction []*CodeableConcept `json:"jurisdiction,omitempty"`
	Purpose *FhirMarkdown `json:"purpose,omitempty"`
	Copyright *FhirMarkdown `json:"copyright,omitempty"`
	Keyword []*Coding `json:"keyword,omitempty"`
	FhirVersion *FHIRVersion `json:"fhirversion,omitempty"`
	Mapping []*StructureDefinitionMapping `json:"mapping,omitempty"`
	Kind *StructureDefinitionKind `json:"kind,omitempty"`
	Abstract_ *FhirBoolean `json:"abstract,omitempty"`
	Context []*StructureDefinitionContext `json:"context,omitempty"`
	ContextInvariant []*FhirString `json:"contextinvariant,omitempty"`
	Type *FhirUri `json:"type,omitempty"`
	BaseDefinition *FhirCanonical `json:"basedefinition,omitempty"`
	Derivation *TypeDerivationRule `json:"derivation,omitempty"`
	Snapshot *StructureDefinitionSnapshot `json:"snapshot,omitempty"`
	Differential *StructureDefinitionDifferential `json:"differential,omitempty"`
}

// NewStructureDefinition creates a new StructureDefinition instance
func NewStructureDefinition() *StructureDefinition {
	return &StructureDefinition{}
}

// FromJSON populates StructureDefinition from JSON data
func (m *StructureDefinition) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureDefinition to JSON data
func (m *StructureDefinition) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureDefinition
func (m *StructureDefinition) Clone() *StructureDefinition {
	if m == nil { return nil }
	return &StructureDefinition{
		Id: m.Id.Clone(),
		Meta: m.Meta.Clone(),
		ImplicitRules: m.ImplicitRules.Clone(),
		Language: m.Language.Clone(),
		Text: m.Text.Clone(),
		Contained: cloneSlices(m.Contained),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Url: m.Url.Clone(),
		Identifier: cloneSlices(m.Identifier),
		Version: m.Version.Clone(),
		Name: m.Name.Clone(),
		Title: m.Title.Clone(),
		Status: m.Status.Clone(),
		Experimental: m.Experimental.Clone(),
		Date: m.Date.Clone(),
		Publisher: m.Publisher.Clone(),
		Contact: cloneSlices(m.Contact),
		Description: m.Description.Clone(),
		UseContext: cloneSlices(m.UseContext),
		Jurisdiction: cloneSlices(m.Jurisdiction),
		Purpose: m.Purpose.Clone(),
		Copyright: m.Copyright.Clone(),
		Keyword: cloneSlices(m.Keyword),
		FhirVersion: m.FhirVersion.Clone(),
		Mapping: cloneSlices(m.Mapping),
		Kind: m.Kind.Clone(),
		Abstract_: m.Abstract_.Clone(),
		Context: cloneSlices(m.Context),
		ContextInvariant: cloneSlices(m.ContextInvariant),
		Type: m.Type.Clone(),
		BaseDefinition: m.BaseDefinition.Clone(),
		Derivation: m.Derivation.Clone(),
		Snapshot: m.Snapshot.Clone(),
		Differential: m.Differential.Clone(),
	}
}

// Equals checks for equality with another StructureDefinition instance
func (m *StructureDefinition) Equals(other *StructureDefinition) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !m.Meta.Equals(other.Meta) { return false }
	if !m.ImplicitRules.Equals(other.ImplicitRules) { return false }
	if !m.Language.Equals(other.Language) { return false }
	if !m.Text.Equals(other.Text) { return false }
	if !compareSlices(m.Contained, other.Contained) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Url.Equals(other.Url) { return false }
	if !compareSlices(m.Identifier, other.Identifier) { return false }
	if !m.Version.Equals(other.Version) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Title.Equals(other.Title) { return false }
	if !m.Status.Equals(other.Status) { return false }
	if !m.Experimental.Equals(other.Experimental) { return false }
	if !m.Date.Equals(other.Date) { return false }
	if !m.Publisher.Equals(other.Publisher) { return false }
	if !compareSlices(m.Contact, other.Contact) { return false }
	if !m.Description.Equals(other.Description) { return false }
	if !compareSlices(m.UseContext, other.UseContext) { return false }
	if !compareSlices(m.Jurisdiction, other.Jurisdiction) { return false }
	if !m.Purpose.Equals(other.Purpose) { return false }
	if !m.Copyright.Equals(other.Copyright) { return false }
	if !compareSlices(m.Keyword, other.Keyword) { return false }
	if !m.FhirVersion.Equals(other.FhirVersion) { return false }
	if !compareSlices(m.Mapping, other.Mapping) { return false }
	if !m.Kind.Equals(other.Kind) { return false }
	if !m.Abstract_.Equals(other.Abstract_) { return false }
	if !compareSlices(m.Context, other.Context) { return false }
	if !compareSlices(m.ContextInvariant, other.ContextInvariant) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.BaseDefinition.Equals(other.BaseDefinition) { return false }
	if !m.Derivation.Equals(other.Derivation) { return false }
	if !m.Snapshot.Equals(other.Snapshot) { return false }
	if !m.Differential.Equals(other.Differential) { return false }
	return true
}

// StructureDefinitionMapping
// An external specification that the content is mapped to.
type StructureDefinitionMapping struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Identity *FhirId `json:"identity,omitempty"`
	Uri *FhirUri `json:"uri,omitempty"`
	Name *FhirString `json:"name,omitempty"`
	Comment *FhirString `json:"comment,omitempty"`
}

// NewStructureDefinitionMapping creates a new StructureDefinitionMapping instance
func NewStructureDefinitionMapping() *StructureDefinitionMapping {
	return &StructureDefinitionMapping{}
}

// FromJSON populates StructureDefinitionMapping from JSON data
func (m *StructureDefinitionMapping) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureDefinitionMapping to JSON data
func (m *StructureDefinitionMapping) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureDefinitionMapping
func (m *StructureDefinitionMapping) Clone() *StructureDefinitionMapping {
	if m == nil { return nil }
	return &StructureDefinitionMapping{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Identity: m.Identity.Clone(),
		Uri: m.Uri.Clone(),
		Name: m.Name.Clone(),
		Comment: m.Comment.Clone(),
	}
}

// Equals checks for equality with another StructureDefinitionMapping instance
func (m *StructureDefinitionMapping) Equals(other *StructureDefinitionMapping) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Identity.Equals(other.Identity) { return false }
	if !m.Uri.Equals(other.Uri) { return false }
	if !m.Name.Equals(other.Name) { return false }
	if !m.Comment.Equals(other.Comment) { return false }
	return true
}

// StructureDefinitionContext
// Identifies the types of resource or data type elements to which the extension can be applied.
type StructureDefinitionContext struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Type *ExtensionContextType `json:"type,omitempty"`
	Expression *FhirString `json:"expression,omitempty"`
}

// NewStructureDefinitionContext creates a new StructureDefinitionContext instance
func NewStructureDefinitionContext() *StructureDefinitionContext {
	return &StructureDefinitionContext{}
}

// FromJSON populates StructureDefinitionContext from JSON data
func (m *StructureDefinitionContext) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureDefinitionContext to JSON data
func (m *StructureDefinitionContext) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureDefinitionContext
func (m *StructureDefinitionContext) Clone() *StructureDefinitionContext {
	if m == nil { return nil }
	return &StructureDefinitionContext{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Type: m.Type.Clone(),
		Expression: m.Expression.Clone(),
	}
}

// Equals checks for equality with another StructureDefinitionContext instance
func (m *StructureDefinitionContext) Equals(other *StructureDefinitionContext) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !m.Type.Equals(other.Type) { return false }
	if !m.Expression.Equals(other.Expression) { return false }
	return true
}

// StructureDefinitionSnapshot
// A snapshot view is expressed in a standalone form that can be used and interpreted without considering the base StructureDefinition.
type StructureDefinitionSnapshot struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Element []*ElementDefinition `json:"element,omitempty"`
}

// NewStructureDefinitionSnapshot creates a new StructureDefinitionSnapshot instance
func NewStructureDefinitionSnapshot() *StructureDefinitionSnapshot {
	return &StructureDefinitionSnapshot{}
}

// FromJSON populates StructureDefinitionSnapshot from JSON data
func (m *StructureDefinitionSnapshot) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureDefinitionSnapshot to JSON data
func (m *StructureDefinitionSnapshot) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureDefinitionSnapshot
func (m *StructureDefinitionSnapshot) Clone() *StructureDefinitionSnapshot {
	if m == nil { return nil }
	return &StructureDefinitionSnapshot{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Element: cloneSlices(m.Element),
	}
}

// Equals checks for equality with another StructureDefinitionSnapshot instance
func (m *StructureDefinitionSnapshot) Equals(other *StructureDefinitionSnapshot) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Element, other.Element) { return false }
	return true
}

// StructureDefinitionDifferential
// A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
type StructureDefinitionDifferential struct {
	BackboneElement
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Element []*ElementDefinition `json:"element,omitempty"`
}

// NewStructureDefinitionDifferential creates a new StructureDefinitionDifferential instance
func NewStructureDefinitionDifferential() *StructureDefinitionDifferential {
	return &StructureDefinitionDifferential{}
}

// FromJSON populates StructureDefinitionDifferential from JSON data
func (m *StructureDefinitionDifferential) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts StructureDefinitionDifferential to JSON data
func (m *StructureDefinitionDifferential) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of StructureDefinitionDifferential
func (m *StructureDefinitionDifferential) Clone() *StructureDefinitionDifferential {
	if m == nil { return nil }
	return &StructureDefinitionDifferential{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Element: cloneSlices(m.Element),
	}
}

// Equals checks for equality with another StructureDefinitionDifferential instance
func (m *StructureDefinitionDifferential) Equals(other *StructureDefinitionDifferential) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Element, other.Element) { return false }
	return true
}

