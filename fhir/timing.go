// Code generated by FHIR Generator. DO NOT EDIT.

package fhir_r4b_go

import (
	"encoding/json")

// Timing
// Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
type Timing struct {
	BackboneType
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	ModifierExtension []*FhirExtension `json:"modifierextension,omitempty"`
	Event []*FhirDateTime `json:"event,omitempty"`
	Repeat *TimingRepeat `json:"repeat,omitempty"`
	Code *CodeableConcept `json:"code,omitempty"`
}

// NewTiming creates a new Timing instance
func NewTiming() *Timing {
	return &Timing{}
}

// FromJSON populates Timing from JSON data
func (m *Timing) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts Timing to JSON data
func (m *Timing) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of Timing
func (m *Timing) Clone() *Timing {
	if m == nil { return nil }
	return &Timing{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		ModifierExtension: cloneSlices(m.ModifierExtension),
		Event: cloneSlices(m.Event),
		Repeat: m.Repeat.Clone(),
		Code: m.Code.Clone(),
	}
}

// Equals checks for equality with another Timing instance
func (m *Timing) Equals(other *Timing) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !compareSlices(m.ModifierExtension, other.ModifierExtension) { return false }
	if !compareSlices(m.Event, other.Event) { return false }
	if !m.Repeat.Equals(other.Repeat) { return false }
	if !m.Code.Equals(other.Code) { return false }
	return true
}

// TimingRepeat
// A set of rules that describe when the event is scheduled.
type TimingRepeat struct {
	Element
	Id *FhirString `json:"id,omitempty"`
	Extension_ []*FhirExtension `json:"extension,omitempty"`
	BoundsDuration *FhirDuration `json:"boundsduration,omitempty"`
	BoundsRange *Range `json:"boundsrange,omitempty"`
	BoundsPeriod *Period `json:"boundsperiod,omitempty"`
	Count *FhirPositiveInt `json:"count,omitempty"`
	CountMax *FhirPositiveInt `json:"countmax,omitempty"`
	Duration *FhirDecimal `json:"duration,omitempty"`
	DurationMax *FhirDecimal `json:"durationmax,omitempty"`
	DurationUnit *UnitsOfTime `json:"durationunit,omitempty"`
	Frequency *FhirPositiveInt `json:"frequency,omitempty"`
	FrequencyMax *FhirPositiveInt `json:"frequencymax,omitempty"`
	Period *FhirDecimal `json:"period,omitempty"`
	PeriodMax *FhirDecimal `json:"periodmax,omitempty"`
	PeriodUnit *UnitsOfTime `json:"periodunit,omitempty"`
	DayOfWeek []*DaysOfWeek `json:"dayofweek,omitempty"`
	TimeOfDay []*FhirTime `json:"timeofday,omitempty"`
	When []*EventTiming `json:"when,omitempty"`
	Offset *FhirUnsignedInt `json:"offset,omitempty"`
}

// NewTimingRepeat creates a new TimingRepeat instance
func NewTimingRepeat() *TimingRepeat {
	return &TimingRepeat{}
}

// FromJSON populates TimingRepeat from JSON data
func (m *TimingRepeat) FromJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// ToJSON converts TimingRepeat to JSON data
func (m *TimingRepeat) ToJSON() ([]byte, error) {
	return json.Marshal(m)
}

// Clone creates a deep copy of TimingRepeat
func (m *TimingRepeat) Clone() *TimingRepeat {
	if m == nil { return nil }
	return &TimingRepeat{
		Id: m.Id.Clone(),
		Extension_: cloneSlices(m.Extension_),
		BoundsDuration: m.BoundsDuration.Clone(),
		BoundsRange: m.BoundsRange.Clone(),
		BoundsPeriod: m.BoundsPeriod.Clone(),
		Count: m.Count.Clone(),
		CountMax: m.CountMax.Clone(),
		Duration: m.Duration.Clone(),
		DurationMax: m.DurationMax.Clone(),
		DurationUnit: m.DurationUnit.Clone(),
		Frequency: m.Frequency.Clone(),
		FrequencyMax: m.FrequencyMax.Clone(),
		Period: m.Period.Clone(),
		PeriodMax: m.PeriodMax.Clone(),
		PeriodUnit: m.PeriodUnit.Clone(),
		DayOfWeek: cloneSlices(m.DayOfWeek),
		TimeOfDay: cloneSlices(m.TimeOfDay),
		When: cloneSlices(m.When),
		Offset: m.Offset.Clone(),
	}
}

// Equals checks for equality with another TimingRepeat instance
func (m *TimingRepeat) Equals(other *TimingRepeat) bool {
	if m == nil && other == nil { return true }
	if m == nil || other == nil { return false }
	if !m.Id.Equals(other.Id) { return false }
	if !compareSlices(m.Extension_, other.Extension_) { return false }
	if !m.BoundsDuration.Equals(other.BoundsDuration) { return false }
	if !m.BoundsRange.Equals(other.BoundsRange) { return false }
	if !m.BoundsPeriod.Equals(other.BoundsPeriod) { return false }
	if !m.Count.Equals(other.Count) { return false }
	if !m.CountMax.Equals(other.CountMax) { return false }
	if !m.Duration.Equals(other.Duration) { return false }
	if !m.DurationMax.Equals(other.DurationMax) { return false }
	if !m.DurationUnit.Equals(other.DurationUnit) { return false }
	if !m.Frequency.Equals(other.Frequency) { return false }
	if !m.FrequencyMax.Equals(other.FrequencyMax) { return false }
	if !m.Period.Equals(other.Period) { return false }
	if !m.PeriodMax.Equals(other.PeriodMax) { return false }
	if !m.PeriodUnit.Equals(other.PeriodUnit) { return false }
	if !compareSlices(m.DayOfWeek, other.DayOfWeek) { return false }
	if !compareSlices(m.TimeOfDay, other.TimeOfDay) { return false }
	if !compareSlices(m.When, other.When) { return false }
	if !m.Offset.Equals(other.Offset) { return false }
	return true
}

